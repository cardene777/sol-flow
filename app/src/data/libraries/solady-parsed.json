{
  "id": "solady",
  "name": "Solady",
  "version": "latest",
  "generatedAt": "2026-01-26T06:30:27.583Z",
  "callGraph": {
    "version": "1.0.0",
    "generatedAt": "2026-01-26T06:30:27.583Z",
    "projectName": "Solady",
    "structure": {
      "name": "contracts",
      "type": "directory",
      "path": "contracts",
      "children": [
        {
          "name": "solady",
          "type": "directory",
          "path": "solady",
          "children": [
            {
              "name": "src",
              "type": "directory",
              "path": "solady/src",
              "children": [
                {
                  "name": "accounts",
                  "type": "directory",
                  "path": "solady/src/accounts",
                  "children": [
                    {
                      "name": "EIP7702Proxy.sol",
                      "type": "file",
                      "path": "solady/src/accounts/EIP7702Proxy.sol",
                      "contractName": "EIP7702Proxy"
                    },
                    {
                      "name": "ERC1271.sol",
                      "type": "file",
                      "path": "solady/src/accounts/ERC1271.sol",
                      "contractName": "ERC1271"
                    },
                    {
                      "name": "ERC4337.sol",
                      "type": "file",
                      "path": "solady/src/accounts/ERC4337.sol",
                      "contractName": "ERC4337"
                    },
                    {
                      "name": "ERC4337Factory.sol",
                      "type": "file",
                      "path": "solady/src/accounts/ERC4337Factory.sol",
                      "contractName": "ERC4337Factory"
                    },
                    {
                      "name": "ERC6551.sol",
                      "type": "file",
                      "path": "solady/src/accounts/ERC6551.sol",
                      "contractName": "ERC6551"
                    },
                    {
                      "name": "ERC6551Proxy.sol",
                      "type": "file",
                      "path": "solady/src/accounts/ERC6551Proxy.sol",
                      "contractName": "ERC6551Proxy"
                    },
                    {
                      "name": "ERC7821.sol",
                      "type": "file",
                      "path": "solady/src/accounts/ERC7821.sol",
                      "contractName": "ERC7821"
                    },
                    {
                      "name": "Receiver.sol",
                      "type": "file",
                      "path": "solady/src/accounts/Receiver.sol",
                      "contractName": "Receiver"
                    },
                    {
                      "name": "Timelock.sol",
                      "type": "file",
                      "path": "solady/src/accounts/Timelock.sol",
                      "contractName": "Timelock"
                    }
                  ]
                },
                {
                  "name": "auth",
                  "type": "directory",
                  "path": "solady/src/auth",
                  "children": [
                    {
                      "name": "EnumerableRoles.sol",
                      "type": "file",
                      "path": "solady/src/auth/EnumerableRoles.sol",
                      "contractName": "EnumerableRoles"
                    },
                    {
                      "name": "Ownable.sol",
                      "type": "file",
                      "path": "solady/src/auth/Ownable.sol",
                      "contractName": "Ownable"
                    },
                    {
                      "name": "OwnableRoles.sol",
                      "type": "file",
                      "path": "solady/src/auth/OwnableRoles.sol",
                      "contractName": "OwnableRoles"
                    },
                    {
                      "name": "TimedRoles.sol",
                      "type": "file",
                      "path": "solady/src/auth/TimedRoles.sol",
                      "contractName": "TimedRoles"
                    }
                  ]
                },
                {
                  "name": "tokens",
                  "type": "directory",
                  "path": "solady/src/tokens",
                  "children": [
                    {
                      "name": "ERC1155.sol",
                      "type": "file",
                      "path": "solady/src/tokens/ERC1155.sol",
                      "contractName": "ERC1155"
                    },
                    {
                      "name": "ERC20.sol",
                      "type": "file",
                      "path": "solady/src/tokens/ERC20.sol",
                      "contractName": "ERC20"
                    },
                    {
                      "name": "ERC20Votes.sol",
                      "type": "file",
                      "path": "solady/src/tokens/ERC20Votes.sol",
                      "contractName": "ERC20Votes"
                    },
                    {
                      "name": "ERC2981.sol",
                      "type": "file",
                      "path": "solady/src/tokens/ERC2981.sol",
                      "contractName": "ERC2981"
                    },
                    {
                      "name": "ERC4626.sol",
                      "type": "file",
                      "path": "solady/src/tokens/ERC4626.sol",
                      "contractName": "ERC4626"
                    },
                    {
                      "name": "ERC6909.sol",
                      "type": "file",
                      "path": "solady/src/tokens/ERC6909.sol",
                      "contractName": "ERC6909"
                    },
                    {
                      "name": "ERC721.sol",
                      "type": "file",
                      "path": "solady/src/tokens/ERC721.sol",
                      "contractName": "ERC721"
                    },
                    {
                      "name": "WETH.sol",
                      "type": "file",
                      "path": "solady/src/tokens/WETH.sol",
                      "contractName": "WETH"
                    },
                    {
                      "name": "ext",
                      "type": "directory",
                      "path": "solady/src/tokens/ext",
                      "children": [
                        {
                          "name": "zksync",
                          "type": "directory",
                          "path": "solady/src/tokens/ext/zksync",
                          "children": [
                            {
                              "name": "ERC1155.sol",
                              "type": "file",
                              "path": "solady/src/tokens/ext/zksync/ERC1155.sol",
                              "contractName": "ERC1155"
                            },
                            {
                              "name": "ERC721.sol",
                              "type": "file",
                              "path": "solady/src/tokens/ext/zksync/ERC721.sol",
                              "contractName": "ERC721"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "name": "utils",
                  "type": "directory",
                  "path": "solady/src/utils",
                  "children": [
                    {
                      "name": "CallContextChecker.sol",
                      "type": "file",
                      "path": "solady/src/utils/CallContextChecker.sol",
                      "contractName": "CallContextChecker"
                    },
                    {
                      "name": "DeploylessPredeployQueryer.sol",
                      "type": "file",
                      "path": "solady/src/utils/DeploylessPredeployQueryer.sol",
                      "contractName": "DeploylessPredeployQueryer"
                    },
                    {
                      "name": "EIP712.sol",
                      "type": "file",
                      "path": "solady/src/utils/EIP712.sol",
                      "contractName": "EIP712"
                    },
                    {
                      "name": "ERC1967Factory.sol",
                      "type": "file",
                      "path": "solady/src/utils/ERC1967Factory.sol",
                      "contractName": "ERC1967Factory"
                    },
                    {
                      "name": "Initializable.sol",
                      "type": "file",
                      "path": "solady/src/utils/Initializable.sol",
                      "contractName": "Initializable"
                    },
                    {
                      "name": "Lifebuoy.sol",
                      "type": "file",
                      "path": "solady/src/utils/Lifebuoy.sol",
                      "contractName": "Lifebuoy"
                    },
                    {
                      "name": "Multicallable.sol",
                      "type": "file",
                      "path": "solady/src/utils/Multicallable.sol",
                      "contractName": "Multicallable"
                    },
                    {
                      "name": "ReentrancyGuard.sol",
                      "type": "file",
                      "path": "solady/src/utils/ReentrancyGuard.sol",
                      "contractName": "ReentrancyGuard"
                    },
                    {
                      "name": "ReentrancyGuardTransient.sol",
                      "type": "file",
                      "path": "solady/src/utils/ReentrancyGuardTransient.sol",
                      "contractName": "ReentrancyGuardTransient"
                    },
                    {
                      "name": "UUPSUpgradeable.sol",
                      "type": "file",
                      "path": "solady/src/utils/UUPSUpgradeable.sol",
                      "contractName": "UUPSUpgradeable"
                    },
                    {
                      "name": "UpgradeableBeacon.sol",
                      "type": "file",
                      "path": "solady/src/utils/UpgradeableBeacon.sol",
                      "contractName": "UpgradeableBeacon"
                    },
                    {
                      "name": "ext",
                      "type": "directory",
                      "path": "solady/src/utils/ext",
                      "children": [
                        {
                          "name": "zksync",
                          "type": "directory",
                          "path": "solady/src/utils/ext/zksync",
                          "children": [
                            {
                              "name": "ERC1967BeaconProxy.sol",
                              "type": "file",
                              "path": "solady/src/utils/ext/zksync/ERC1967BeaconProxy.sol",
                              "contractName": "ERC1967BeaconProxy"
                            },
                            {
                              "name": "ERC1967Factory.sol",
                              "type": "file",
                              "path": "solady/src/utils/ext/zksync/ERC1967Factory.sol",
                              "contractName": "ERC1967Factory"
                            },
                            {
                              "name": "ERC1967Proxy.sol",
                              "type": "file",
                              "path": "solady/src/utils/ext/zksync/ERC1967Proxy.sol",
                              "contractName": "ERC1967Proxy"
                            },
                            {
                              "name": "SingleUseETHVault.sol",
                              "type": "file",
                              "path": "solady/src/utils/ext/zksync/SingleUseETHVault.sol",
                              "contractName": "SingleUseETHVault"
                            },
                            {
                              "name": "UpgradeableBeacon.sol",
                              "type": "file",
                              "path": "solady/src/utils/ext/zksync/UpgradeableBeacon.sol",
                              "contractName": "UpgradeableBeacon"
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "name": "legacy",
                      "type": "directory",
                      "path": "solady/src/utils/legacy",
                      "children": [
                        {
                          "name": "CWIA.sol",
                          "type": "file",
                          "path": "solady/src/utils/legacy/CWIA.sol",
                          "contractName": "CWIA"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    "contracts": [
      {
        "name": "EIP7702Proxy",
        "kind": "contract",
        "category": "proxy",
        "filePath": "solady/src/accounts/EIP7702Proxy.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [],
        "events": [],
        "errors": []
      },
      {
        "name": "ERC1271",
        "kind": "abstract",
        "category": "core",
        "filePath": "solady/src/accounts/ERC1271.sol",
        "inherits": [
          "EIP712"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "isValidSignature",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes4"
              }
            ],
            "calls": [
              {
                "target": "_erc1271IsValidSignature",
                "type": "internal"
              },
              {
                "target": "_erc1271UnwrapSignature",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function isValidSignature(bytes32 hash, bytes calldata signature)\n        public\n        view\n        virtual\n        returns (bytes4 result)\n    {\n        // For automatic detection that the smart account supports the nested EIP-712 workflow,\n        // See: https://eips.ethereum.org/EIPS/eip-7739.\n        // If `hash` is `0x7739...7739`, returns `bytes4(0x77390001)`.\n        // The returned number MAY be increased in future ERC7739 versions.\n        unchecked {\n            if (signature.length == uint256(0)) {\n                // Forces the compiler to optimize for smaller bytecode size.\n                if (uint256(hash) == ~signature.length / 0xffff * 0x7739) return 0x77390001;\n            }\n        }\n        bool success = _erc1271IsValidSignature(hash, _erc1271UnwrapSignature(signature));\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `success ? bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")) : 0xffffffff`.\n            // We use `0xffffffff` for invalid, in convention with the reference implementation.\n            result := shl(224, or(0x1626ba7e, sub(0, iszero(success))))\n        }\n    }",
            "startLine": 24,
            "signature": "isValidSignature(bytes32,bytes)",
            "selector": "0x3ad2757e",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_erc1271Signer",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _erc1271Signer() internal view virtual returns (address);",
            "startLine": 51,
            "visibility": "internal"
          },
          {
            "name": "_erc1271CallerIsSafe",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _erc1271CallerIsSafe() internal view virtual returns (bool) {\n        // The canonical `MulticallerWithSigner` at 0x000000000000D9ECebf3C23529de49815Dac1c4c\n        // is known to include the account in the hash to be signed.\n        return msg.sender == 0x000000000000D9ECebf3C23529de49815Dac1c4c;\n    }",
            "startLine": 57,
            "visibility": "internal"
          },
          {
            "name": "_erc1271IsValidSignatureNowCalldata",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "SignatureCheckerLib.isValidSignatureNowCalldata",
                "type": "library"
              },
              {
                "target": "_erc1271Signer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _erc1271IsValidSignatureNowCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return SignatureCheckerLib.isValidSignatureNowCalldata(_erc1271Signer(), hash, signature);\n    }",
            "startLine": 65,
            "visibility": "internal"
          },
          {
            "name": "_erc1271UnwrapSignature",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _erc1271UnwrapSignature(bytes calldata signature)\n        internal\n        view\n        virtual\n        returns (bytes calldata result)\n    {\n        result = signature;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Unwraps the ERC6492 wrapper if it exists.\n            // See: https://eips.ethereum.org/EIPS/eip-6492\n            if eq(\n                calldataload(add(result.offset, sub(result.length, 0x20))),\n                mul(0x6492, div(not(shr(address(), address())), 0xffff)) // `0x6492...6492`.\n            ) {\n                let o := add(result.offset, calldataload(add(result.offset, 0x40)))\n                result.length := calldataload(o)\n                result.offset := add(o, 0x20)\n            }\n        }\n    }",
            "startLine": 75,
            "visibility": "internal"
          },
          {
            "name": "_erc1271IsValidSignature",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_erc1271IsValidSignatureViaSafeCaller",
                "type": "internal"
              },
              {
                "target": "_erc1271IsValidSignatureViaNestedEIP712",
                "type": "internal"
              },
              {
                "target": "_erc1271IsValidSignatureViaRPC",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _erc1271IsValidSignature(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return _erc1271IsValidSignatureViaSafeCaller(hash, signature)\n            || _erc1271IsValidSignatureViaNestedEIP712(hash, signature)\n            || _erc1271IsValidSignatureViaRPC(hash, signature);\n    }",
            "startLine": 98,
            "visibility": "internal"
          },
          {
            "name": "_erc1271IsValidSignatureViaSafeCaller",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_erc1271CallerIsSafe",
                "type": "internal"
              },
              {
                "target": "_erc1271IsValidSignatureNowCalldata",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _erc1271IsValidSignatureViaSafeCaller(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        if (_erc1271CallerIsSafe()) result = _erc1271IsValidSignatureNowCalldata(hash, signature);\n    }",
            "startLine": 111,
            "visibility": "internal"
          },
          {
            "name": "_erc1271IsValidSignatureViaNestedEIP712",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "eip712Domain",
                "type": "internal"
              },
              {
                "target": "_hashTypedData",
                "type": "internal"
              },
              {
                "target": "_erc1271IsValidSignatureNowCalldata",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _erc1271IsValidSignatureViaNestedEIP712(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        uint256 t = uint256(uint160(address(this)));\n        // Forces the compiler to pop the variables after the scope, avoiding stack-too-deep.\n        if (t != uint256(0)) {\n            (\n                ,\n                string memory name,\n                string memory version,\n                uint256 chainId,\n                address verifyingContract,\n                bytes32 salt,\n            ) = eip712Domain();\n            /// @solidity memory-safe-assembly\n            assembly {\n                t := mload(0x40) // Grab the free memory pointer.\n                // Skip 2 words for the `typedDataSignTypehash` and `contents` struct hash.\n                mstore(add(t, 0x40), keccak256(add(name, 0x20), mload(name)))\n                mstore(add(t, 0x60), keccak256(add(version, 0x20), mload(version)))\n                mstore(add(t, 0x80), chainId)\n                mstore(add(t, 0xa0), shr(96, shl(96, verifyingContract)))\n                mstore(add(t, 0xc0), salt)\n                mstore(0x40, add(t, 0xe0)) // Allocate the memory.\n            }\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            // `c` is `contentsDescription.length`, which is stored in the last 2 bytes of the signature.\n            let c := shr(240, calldataload(add(signature.offset, sub(signature.length, 2))))\n            for {} 1 {} {\n                let l := add(0x42, c) // Total length of appended data (32 + 32 + c + 2).\n                let o := add(signature.offset, sub(signature.length, l)) // Offset of appended data.\n                mstore(0x00, 0x1901) // Store the \"\\x19\\x01\" prefix.\n                calldatacopy(0x20, o, 0x40) // Copy the `APP_DOMAIN_SEPARATOR` and `contents` struct hash.\n                // Use the `PersonalSign` workflow if the reconstructed hash doesn't match,\n                // or if the appended data is invalid, i.e.\n                // `appendedData.length > signature.length || contentsDescription.length == 0`.\n                if or(xor(keccak256(0x1e, 0x42), hash), or(lt(signature.length, l), iszero(c))) {\n                    t := 0 // Set `t` to 0, denoting that we need to `hash = _hashTypedData(hash)`.\n                    mstore(t, _PERSONAL_SIGN_TYPEHASH)\n                    mstore(0x20, hash) // Store the `prefixed`.\n                    hash := keccak256(t, 0x40) // Compute the `PersonalSign` struct hash.\n                    break\n                }\n                // Else, use the `TypedDataSign` workflow.\n                // `TypedDataSign({ContentsName} contents,string name,...){ContentsType}`.\n                mstore(m, \"TypedDataSign(\") // Store the start of `TypedDataSign`'s type encoding.\n                let p := add(m, 0x0e) // Advance 14 bytes to skip \"TypedDataSign(\".\n                calldatacopy(p, add(o, 0x40), c) // Copy `contentsName`, optimistically.\n                mstore(add(p, c), 40) // Store a '(' after the end.\n                if iszero(eq(byte(0, mload(sub(add(p, c), 1))), 41)) {\n                    let e := 0 // Length of `contentsName` in explicit mode.\n                    for { let q := sub(add(p, c), 1) } 1 {} {\n                        e := add(e, 1) // Scan backwards until we encounter a ')'.\n                        if iszero(gt(lt(e, c), eq(byte(0, mload(sub(q, e))), 41))) { break }\n                    }\n                    c := sub(c, e) // Truncate `contentsDescription` to `contentsType`.\n                    calldatacopy(p, add(add(o, 0x40), c), e) // Copy `contentsName`.\n                    mstore8(add(p, e), 40) // Store a '(' exactly right after the end.\n                }\n                // `d & 1 == 1` means that `contentsName` is invalid.\n                let d := shr(byte(0, mload(p)), 0x7fffffe000000000000010000000000) // Starts with `[a-z(]`.\n                // Advance `p` until we encounter '('.\n                for {} iszero(eq(byte(0, mload(p)), 40)) { p := add(p, 1) } {\n                    d := or(shr(byte(0, mload(p)), 0x120100000001), d) // Has a byte in \", )\\x00\".\n                }\n                mstore(p, \" contents,string name,string\") // Store the rest of the encoding.\n                mstore(add(p, 0x1c), \" version,uint256 chainId,address\")\n                mstore(add(p, 0x3c), \" verifyingContract,bytes32 salt)\")\n                p := add(p, 0x5c)\n                calldatacopy(p, add(o, 0x40), c) // Copy `contentsType`.\n                // Fill in the missing fields of the `TypedDataSign`.\n                calldatacopy(t, o, 0x40) // Copy the `contents` struct hash to `add(t, 0x20)`.\n                mstore(t, keccak256(m, sub(add(p, c), m))) // Store `typedDataSignTypehash`.\n                // The \"\\x19\\x01\" prefix is already at 0x00.\n                // `APP_DOMAIN_SEPARATOR` is already at 0x20.\n                mstore(0x40, keccak256(t, 0xe0)) // `hashStruct(typedDataSign)`.\n                // Compute the final hash, corrupted if `contentsName` is invalid.\n                hash := keccak256(0x1e, add(0x42, and(1, d)))\n                signature.length := sub(signature.length, l) // Truncate the signature.\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n        if (t == uint256(0)) hash = _hashTypedData(hash); // `PersonalSign` workflow.\n        result = _erc1271IsValidSignatureNowCalldata(hash, signature);\n    }",
            "startLine": 196,
            "visibility": "internal"
          },
          {
            "name": "_erc1271IsValidSignatureViaRPC",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_erc1271IsValidSignatureNowCalldata",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _erc1271IsValidSignatureViaRPC(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        // Non-zero gasprice is a heuristic to check if a call is on-chain,\n        // but we can't fully depend on it because it can be manipulated.\n        // See: https://x.com/NoahCitron/status/1580359718341484544\n        if (tx.gasprice == uint256(0)) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(gasprice(), gasprice())\n                // See: https://gist.github.com/Vectorized/3c9b63524d57492b265454f62d895f71\n                let b := 0x000000000000378eDCD5B5B0A24f5342d8C10485 // Basefee contract,\n                pop(staticcall(0xffff, b, codesize(), gasprice(), gasprice(), 0x20))\n                // If `gasprice < basefee`, the call cannot be on-chain, and we can skip the gas burn.\n                if iszero(mload(gasprice())) {\n                    let m := mload(0x40) // Cache the free memory pointer.\n                    mstore(gasprice(), 0x1626ba7e) // `isValidSignature(bytes32,bytes)`.\n                    mstore(0x20, b) // Recycle `b` to denote if we need to burn gas.\n                    mstore(0x40, 0x40)\n                    let gasToBurn := or(add(0xffff, gaslimit()), gaslimit())\n                    // Burns gas computationally efficiently. Also, requires that `gas > gasToBurn`.\n                    if or(eq(hash, b), lt(gas(), gasToBurn)) { invalid() }\n                    // Make a call to this with `b`, efficiently burning the gas provided.\n                    // No valid transaction can consume more than the gaslimit.\n                    // See: https://ethereum.github.io/yellowpaper/paper.pdf\n                    // Most RPCs perform calls with a gas budget greater than the gaslimit.\n                    pop(staticcall(gasToBurn, address(), 0x1c, 0x64, gasprice(), gasprice()))\n                    mstore(0x40, m) // Restore the free memory pointer.\n                }\n            }\n            result = _erc1271IsValidSignatureNowCalldata(hash, signature);\n        }\n    }",
            "startLine": 291,
            "visibility": "internal"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "ERC4337",
        "kind": "abstract",
        "category": "core",
        "filePath": "solady/src/accounts/ERC4337.sol",
        "inherits": [
          "Ownable",
          "UUPSUpgradeable",
          "Receiver",
          "ERC1271"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "initialize",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initializeOwner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function initialize(address newOwner) public payable virtual {\n        _initializeOwner(newOwner);\n    }",
            "startLine": 77,
            "signature": "initialize(address)",
            "selector": "0x737a8eb3",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "entryPoint",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function entryPoint() public view virtual returns (address) {\n        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\n    }",
            "startLine": 87,
            "signature": "entryPoint()",
            "selector": "0x1fe1c1bf",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "validateUserOp",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "userOp",
                "type": "PackedUserOperation"
              },
              {
                "name": "userOpHash",
                "type": "bytes32"
              },
              {
                "name": "missingAccountFunds",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "validationData",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_validateSignature",
                "type": "internal"
              },
              {
                "target": "_validateNonce",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    )\n        external\n        payable\n        virtual\n        onlyEntryPoint\n        payPrefund(missingAccountFunds)\n        returns (uint256 validationData)\n    {\n        validationData = _validateSignature(userOp, userOpHash);\n        _validateNonce(userOp.nonce);\n    }",
            "startLine": 103,
            "signature": "validateUserOp(PackedUserOperation,bytes32,uint256)",
            "selector": "0x0deaf420",
            "visibility": "external",
            "modifiers": [
              "onlyEntryPoint",
              "payPrefund"
            ]
          },
          {
            "name": "execute",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function execute(address target, uint256 value, bytes calldata data)\n        public\n        payable\n        virtual\n        onlyEntryPointOrOwner\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, data.offset, data.length)\n            if iszero(call(gas(), target, value, result, data.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }",
            "startLine": 181,
            "signature": "execute(address,uint256,bytes)",
            "selector": "0x02540d3c",
            "visibility": "public",
            "modifiers": [
              "onlyEntryPointOrOwner"
            ]
          },
          {
            "name": "executeBatch",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "calls",
                "type": "Call[]"
              }
            ],
            "returnValues": [
              {
                "name": "results",
                "type": "bytes[]"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function executeBatch(Call[] calldata calls)\n        public\n        payable\n        virtual\n        onlyEntryPointOrOwner\n        returns (bytes[] memory results)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            results := mload(0x40)\n            mstore(results, calls.length)\n            let r := add(0x20, results)\n            let m := add(r, shl(5, calls.length))\n            calldatacopy(r, calls.offset, shl(5, calls.length))\n            for { let end := m } iszero(eq(r, end)) { r := add(r, 0x20) } {\n                let e := add(calls.offset, mload(r))\n                let o := add(e, calldataload(add(e, 0x40)))\n                calldatacopy(m, add(o, 0x20), calldataload(o))\n                // forgefmt: disable-next-item\n                if iszero(call(gas(), calldataload(e), calldataload(add(e, 0x20)),\n                    m, calldataload(o), codesize(), 0x00)) {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n                mstore(r, m) // Append `m` into `results`.\n                mstore(m, returndatasize()) // Store the length,\n                let p := add(m, 0x20)\n                returndatacopy(p, 0x00, returndatasize()) // and copy the returndata.\n                m := add(p, returndatasize()) // Advance `m`.\n            }\n            mstore(0x40, m) // Allocate the memory.\n        }\n    }",
            "startLine": 205,
            "signature": "executeBatch(Call[])",
            "selector": "0x376b479a",
            "visibility": "public",
            "modifiers": [
              "onlyEntryPointOrOwner"
            ]
          },
          {
            "name": "delegateExecute",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "delegate",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function delegateExecute(address delegate, bytes calldata data)\n        public\n        payable\n        virtual\n        onlyEntryPointOrOwner\n        delegateExecuteGuard\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, data.offset, data.length)\n            // Forwards the `data` to `delegate` via delegatecall.\n            if iszero(delegatecall(gas(), delegate, result, data.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }",
            "startLine": 241,
            "signature": "delegateExecute(address,bytes)",
            "selector": "0x0d1bd7ce",
            "visibility": "public",
            "modifiers": [
              "onlyEntryPointOrOwner",
              "delegateExecuteGuard"
            ]
          },
          {
            "name": "storageLoad",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "storageSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function storageLoad(bytes32 storageSlot) public view virtual returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(storageSlot)\n        }\n    }",
            "startLine": 299,
            "signature": "storageLoad(bytes32)",
            "selector": "0x2673935a",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "storageStore",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "storageSlot",
                "type": "bytes32"
              },
              {
                "name": "storageValue",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function storageStore(bytes32 storageSlot, bytes32 storageValue)\n        public\n        payable\n        virtual\n        onlyEntryPointOrOwner\n        storageStoreGuard(storageSlot)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(storageSlot, storageValue)\n        }\n    }",
            "startLine": 307,
            "signature": "storageStore(bytes32,bytes32)",
            "selector": "0x3f38a97d",
            "visibility": "public",
            "modifiers": [
              "onlyEntryPointOrOwner",
              "storageStoreGuard"
            ]
          },
          {
            "name": "getDeposit",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "entryPoint",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function getDeposit() public view virtual returns (uint256 result) {\n        address ep = entryPoint();\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, address()) // Store the `account` argument.\n            mstore(0x00, 0x70a08231) // `balanceOf(address)`.\n            result :=\n                mul( // Returns 0 if the EntryPoint does not exist.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), ep, 0x1c, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }",
            "startLine": 337,
            "signature": "getDeposit()",
            "selector": "0x3156a297",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "addDeposit",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "entryPoint",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function addDeposit() public payable virtual {\n        address ep = entryPoint();\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The EntryPoint has balance accounting logic in the `receive()` function, as defined in ERC-4337.\n            // forgefmt: disable-next-item\n            if iszero(mul(extcodesize(ep), call(gas(), ep, callvalue(), codesize(), 0x00, codesize(), 0x00))) {\n                revert(codesize(), 0x00) // For gas estimation.\n            }\n        }\n    }",
            "startLine": 355,
            "signature": "addDeposit()",
            "selector": "0x38fc4782",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "withdrawDepositTo",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "entryPoint",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function withdrawDepositTo(address to, uint256 amount) public payable virtual onlyOwner {\n        address ep = entryPoint();\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x205c2878000000000000000000000000) // `withdrawTo(address,uint256)`.\n            if iszero(mul(extcodesize(ep), call(gas(), ep, 0, 0x10, 0x44, codesize(), 0x00))) {\n                returndatacopy(mload(0x40), 0x00, returndatasize())\n                revert(mload(0x40), returndatasize())\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }",
            "startLine": 368,
            "signature": "withdrawDepositTo(address,uint256)",
            "selector": "0x30866c7f",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          }
        ],
        "internalFunctions": [
          {
            "name": "_disableERC4337ImplementationInitializer",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_initializeOwner",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _disableERC4337ImplementationInitializer() internal virtual {\n        // Note that `Ownable._guardInitializeOwner` has been and must be overridden\n        // to return true, to block double-initialization. We'll initialize to `address(1)`,\n        // so that it's easier to verify that the implementation has been initialized.\n        _initializeOwner(address(1));\n    }",
            "startLine": 65,
            "visibility": "internal"
          },
          {
            "name": "_validateSignature",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "userOp",
                "type": "PackedUserOperation"
              },
              {
                "name": "userOpHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "validationData",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "SignatureCheckerLib.isValidSignatureNowCalldata",
                "type": "library"
              },
              {
                "target": "owner",
                "type": "internal"
              },
              {
                "target": "SignatureCheckerLib.toEthSignedMessageHash",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _validateSignature(PackedUserOperation calldata userOp, bytes32 userOpHash)\n        internal\n        virtual\n        returns (uint256 validationData)\n    {\n        bool success = SignatureCheckerLib.isValidSignatureNowCalldata(\n            owner(), SignatureCheckerLib.toEthSignedMessageHash(userOpHash), userOp.signature\n        );\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Returns 0 if the recovered address matches the owner.\n            // Else returns 1, which is equivalent to:\n            // `(success ? 0 : 1) | (uint256(validUntil) << 160) | (uint256(validAfter) << (160 + 48))`\n            // where `validUntil` is 0 (indefinite) and `validAfter` is 0.\n            validationData := iszero(success)\n        }\n    }",
            "startLine": 120,
            "visibility": "internal"
          },
          {
            "name": "_validateNonce",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "nonce",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _validateNonce(uint256 nonce) internal virtual {\n        nonce = nonce; // Silence unused variable warning.\n    }",
            "startLine": 148,
            "visibility": "internal"
          },
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual override(Ownable) {\n        if (msg.sender != owner()) if (msg.sender != address(this)) revert Unauthorized();\n    }",
            "startLine": 389,
            "visibility": "internal"
          },
          {
            "name": "_guardInitializeOwner",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _guardInitializeOwner() internal pure virtual override(Ownable) returns (bool) {\n        return true;\n    }",
            "startLine": 394,
            "visibility": "internal"
          },
          {
            "name": "_erc1271Signer",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _erc1271Signer() internal view virtual override(ERC1271) returns (address) {\n        return owner();\n    }",
            "startLine": 399,
            "visibility": "internal"
          },
          {
            "name": "_erc1271CallerIsSafe",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "entryPoint",
                "type": "internal"
              },
              {
                "target": "ERC1271._erc1271CallerIsSafe",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _erc1271CallerIsSafe() internal view virtual override(ERC1271) returns (bool) {\n        return msg.sender == entryPoint() || ERC1271._erc1271CallerIsSafe();\n    }",
            "startLine": 405,
            "visibility": "internal"
          },
          {
            "name": "_authorizeUpgrade",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _authorizeUpgrade(address) internal virtual override(UUPSUpgradeable) onlyOwner {}",
            "startLine": 410,
            "visibility": "internal"
          },
          {
            "name": "_useLibZipCdFallback",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _useLibZipCdFallback() internal view virtual returns (bool) {\n        return true;\n    }",
            "startLine": 413,
            "visibility": "internal"
          }
        ],
        "events": [],
        "errors": [],
        "proxyPattern": "uups",
        "proxyRole": "implementation",
        "proxyGroupId": "proxy-group-0"
      },
      {
        "name": "ERC4337Factory",
        "kind": "contract",
        "category": "core",
        "filePath": "solady/src/accounts/ERC4337Factory.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "createAccount",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "ownSalt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "LibClone.createDeterministicERC1967",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function createAccount(bytes32 ownSalt) public payable virtual returns (address) {\n        // Constructor data is optional, and is omitted for easier Etherscan verification.\n        (bool alreadyDeployed, address account) =\n            LibClone.createDeterministicERC1967(msg.value, implementation, ownSalt);\n\n        if (!alreadyDeployed) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(0x20, shr(96, ownSalt)) // Store the `owner` argument.\n                mstore(0x00, 0xc4d66de8) // `initialize(address)`.\n                if iszero(call(gas(), account, 0, 0x1c, 0x24, codesize(), 0x00)) {\n                    returndatacopy(mload(0x40), 0x00, returndatasize())\n                    revert(mload(0x40), returndatasize())\n                }\n            }\n        }\n        return account;\n    }",
            "startLine": 41,
            "signature": "createAccount(bytes32)",
            "selector": "0x7401f8ea",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getAddress",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ownSalt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "LibClone.predictDeterministicAddressERC1967",
                "type": "library"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function getAddress(bytes32 ownSalt) public view virtual returns (address) {\n        return LibClone.predictDeterministicAddressERC1967(implementation, ownSalt, address(this));\n    }",
            "startLine": 61,
            "signature": "getAddress(bytes32)",
            "selector": "0x0f0bff89",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "initCodeHash",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "LibClone.initCodeHashERC1967",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function initCodeHash() public view virtual returns (bytes32) {\n        return LibClone.initCodeHashERC1967(implementation);\n    }",
            "startLine": 67,
            "signature": "initCodeHash()",
            "selector": "0x142463f4",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": []
      },
      {
        "name": "ERC6551",
        "kind": "abstract",
        "category": "core",
        "filePath": "solady/src/accounts/ERC6551.sol",
        "inherits": [
          "UUPSUpgradeable",
          "Receiver",
          "ERC1271"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "token",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "chainId",
                "type": "uint256"
              },
              {
                "name": "tokenContract",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function token()\n        public\n        view\n        virtual\n        returns (uint256 chainId, address tokenContract, uint256 tokenId)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            extcodecopy(address(), 0x00, 0x4d, 0x60)\n            chainId := mload(0x00)\n            tokenContract := mload(0x20) // Upper 96 bits will be clean.\n            tokenId := mload(0x40)\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 86,
            "signature": "token()",
            "selector": "0x442fdb46",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address result) {\n        uint256 cachedChainId = _cachedChainId;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            extcodecopy(address(), 0x00, 0x4d, 0x60)\n            if eq(mload(0x00), cachedChainId) {\n                let tokenContract := mload(0x20)\n                // `tokenId` is already at 0x40.\n                mstore(0x20, 0x6352211e) // `ownerOf(uint256)`.\n                result :=\n                    mul( // Returns `address(0)` on failure or if contract does not exist.\n                        mload(0x20),\n                        and(\n                            gt(returndatasize(), 0x1f),\n                            staticcall(gas(), tokenContract, 0x3c, 0x24, 0x20, 0x20)\n                        )\n                    )\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 104,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "isValidSigner",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "context",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes4"
              }
            ],
            "calls": [
              {
                "target": "_isValidSigner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function isValidSigner(address signer, bytes calldata context)\n        public\n        view\n        virtual\n        returns (bytes4 result)\n    {\n        bool isValid = _isValidSigner(signer, bytes32(0), context);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `isValid ? bytes4(keccak256(\"isValidSigner(address,bytes)\")) : 0x00000000`.\n            // We use `0x00000000` for invalid, in convention with the reference implementation.\n            result := shl(224, mul(0x523e3260, iszero(iszero(isValid))))\n        }\n    }",
            "startLine": 144,
            "signature": "isValidSigner(address,bytes)",
            "selector": "0x61d70a3e",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "state",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function state() public view virtual returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_ERC6551_STATE_SLOT)\n        }\n    }",
            "startLine": 178,
            "signature": "state()",
            "selector": "0x711416ae",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "execute",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "operation",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "_updateState",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function execute(address target, uint256 value, bytes calldata data, uint8 operation)\n        public\n        payable\n        virtual\n        onlyValidSigner\n        returns (bytes memory result)\n    {\n        if (operation != 0) revert OperationNotSupported();\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, data.offset, data.length)\n            if iszero(call(gas(), target, value, result, data.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n        _updateState();\n    }",
            "startLine": 216,
            "signature": "execute(address,uint256,bytes,uint8)",
            "selector": "0x76a141ca",
            "visibility": "public",
            "modifiers": [
              "onlyValidSigner"
            ]
          },
          {
            "name": "executeBatch",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "calls",
                "type": "Call[]"
              },
              {
                "name": "operation",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "results",
                "type": "bytes[]"
              }
            ],
            "calls": [
              {
                "target": "_updateState",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function executeBatch(Call[] calldata calls, uint8 operation)\n        public\n        payable\n        virtual\n        onlyValidSigner\n        returns (bytes[] memory results)\n    {\n        if (operation != 0) revert OperationNotSupported();\n        /// @solidity memory-safe-assembly\n        assembly {\n            results := mload(0x40)\n            mstore(results, calls.length)\n            let r := add(0x20, results)\n            let m := add(r, shl(5, calls.length))\n            calldatacopy(r, calls.offset, shl(5, calls.length))\n            for { let end := m } iszero(eq(r, end)) { r := add(r, 0x20) } {\n                let e := add(calls.offset, mload(r))\n                let o := add(e, calldataload(add(e, 0x40)))\n                calldatacopy(m, add(o, 0x20), calldataload(o))\n                // forgefmt: disable-next-item\n                if iszero(call(gas(), calldataload(e), calldataload(add(e, 0x20)),\n                    m, calldataload(o), codesize(), 0x00)) {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n                mstore(r, m) // Append `m` into `results`.\n                mstore(m, returndatasize()) // Store the length,\n                let p := add(m, 0x20)\n                returndatacopy(p, 0x00, returndatasize()) // and copy the returndata.\n                m := add(p, returndatasize()) // Advance `m`.\n            }\n            mstore(0x40, m) // Allocate the memory.\n        }\n        _updateState();\n    }",
            "startLine": 246,
            "signature": "executeBatch(Call[],uint8)",
            "selector": "0x043b6574",
            "visibility": "public",
            "modifiers": [
              "onlyValidSigner"
            ]
          },
          {
            "name": "supportsInterface",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC6551: 0x6faff5f1, ERC6551Executable: 0x51945447.\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x6faff5f1)), eq(s, 0x51945447))\n        }\n    }",
            "startLine": 290,
            "signature": "supportsInterface(bytes4)",
            "selector": "0x4ba9e2f3",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_isValidSigner",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "extraData",
                "type": "bytes32"
              },
              {
                "name": "context",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _isValidSigner(address signer, bytes32 extraData, bytes calldata context)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        extraData = extraData; // Silence unused variable warning.\n        context = context; // Silence unused variable warning.\n        return signer == owner();\n    }",
            "startLine": 129,
            "visibility": "internal"
          },
          {
            "name": "_emptyContext",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "context",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _emptyContext() internal pure returns (bytes calldata context) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            context.length := 0\n        }\n    }",
            "startLine": 160,
            "visibility": "internal"
          },
          {
            "name": "_updateState",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _updateState() internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := _ERC6551_STATE_SLOT\n            let m := mload(0x40)\n            mstore(m, sload(s))\n            mstore(add(0x20, m), 0x40)\n            mstore(add(0x40, m), calldatasize())\n            calldatacopy(add(0x60, m), 0x00, add(0x20, calldatasize()))\n            sstore(s, keccak256(m, and(add(0x7f, calldatasize()), not(0x1f))))\n        }\n    }",
            "startLine": 187,
            "visibility": "internal"
          },
          {
            "name": "_hasOwnershipCycle",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _hasOwnershipCycle() internal view virtual returns (bool result) {\n        uint256 cachedChainId = _cachedChainId;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            extcodecopy(address(), 0x00, 0x4d, 0x60) // `(chainId, tokenContract, tokenId)`.\n            mstore(0x60, 0xfc0c546a) // `token()`.\n            for {} 1 {} {\n                let tokenContract := mload(0x20)\n                mstore(0x20, 0x6352211e) // `ownerOf(uint256)`.\n                let currentOwner :=\n                    mul( // `chainId == cachedChainId ? tokenContract.ownerOf(tokenId) : address(0)`.\n                        mload(0x20),\n                        and(\n                            and(gt(returndatasize(), 0x1f), eq(mload(0x00), cachedChainId)),\n                            staticcall(gas(), tokenContract, 0x3c, 0x24, 0x20, 0x20)\n                        )\n                    )\n                if iszero(eq(currentOwner, address())) {\n                    if iszero(\n                        and( // `(chainId, tokenContract, tokenId) = currentOwner.token()`.\n                            gt(returndatasize(), 0x5f),\n                            staticcall(gas(), currentOwner, 0x7c, 0x04, 0x00, 0x60)\n                        )\n                    ) { break }\n                    continue\n                }\n                result := 1\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }",
            "startLine": 304,
            "visibility": "internal"
          },
          {
            "name": "_authorizeUpgrade",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_updateState",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _authorizeUpgrade(address)\n        internal\n        virtual\n        override(UUPSUpgradeable)\n        onlyValidSigner\n        onlyViaERC6551Proxy\n    {\n        _updateState();\n    }",
            "startLine": 345,
            "visibility": "internal"
          },
          {
            "name": "_erc1271Signer",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _erc1271Signer() internal view virtual override(ERC1271) returns (address) {\n        return owner();\n    }",
            "startLine": 371,
            "visibility": "internal"
          },
          {
            "name": "_useLibZipCdFallback",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _useLibZipCdFallback() internal view virtual returns (bool) {\n        return true;\n    }",
            "startLine": 407,
            "visibility": "internal"
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "Unauthorized",
            "parameters": []
          },
          {
            "name": "OperationNotSupported",
            "parameters": []
          },
          {
            "name": "SelfOwnDetected",
            "parameters": []
          }
        ],
        "proxyPattern": "uups",
        "proxyRole": "implementation",
        "proxyGroupId": "proxy-group-0"
      },
      {
        "name": "ERC6551Proxy",
        "kind": "contract",
        "category": "proxy",
        "filePath": "solady/src/accounts/ERC6551Proxy.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [],
        "events": [],
        "errors": []
      },
      {
        "name": "ERC7821",
        "kind": "contract",
        "category": "core",
        "filePath": "solady/src/accounts/ERC7821.sol",
        "inherits": [
          "Receiver"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "execute",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              },
              {
                "name": "executionData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_executionModeId",
                "type": "internal"
              },
              {
                "target": "_executeBatchOfBatches",
                "type": "internal"
              },
              {
                "target": "_execute",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function execute(bytes32 mode, bytes calldata executionData) public payable virtual {\n        uint256 id = _executionModeId(mode);\n        if (id == 3) return _executeBatchOfBatches(mode, executionData);\n        Call[] calldata calls;\n        bytes calldata opData;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(id) {\n                mstore(0x00, 0x7f181275) // `UnsupportedExecutionMode()`.\n                revert(0x1c, 0x04)\n            }\n            // Use inline assembly to extract the calls and optional `opData` efficiently.\n            opData.length := 0\n            let o := add(executionData.offset, calldataload(executionData.offset))\n            calls.offset := add(o, 0x20)\n            calls.length := calldataload(o)\n            // If the offset of `executionData` allows for `opData`, and the mode supports it.\n            if gt(eq(id, 2), gt(0x40, calldataload(executionData.offset))) {\n                let q := add(executionData.offset, calldataload(add(0x20, executionData.offset)))\n                opData.offset := add(q, 0x20)\n                opData.length := calldataload(q)\n            }\n            // Bounds checking for `executionData` is skipped here for efficiency.\n            // This is safe if it is only used as an argument to `execute` externally.\n            // If `executionData` used as an argument to other functions externally,\n            // please perform the bounds checks via `LibERC7579.decodeBatchAndOpData`\n            /// or `abi.decode` in the other functions for safety.\n        }\n        _execute(mode, executionData, calls, opData);\n    }",
            "startLine": 73,
            "signature": "execute(bytes32,bytes)",
            "selector": "0x16830f13",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "supportsExecutionMode",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_executionModeId",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function supportsExecutionMode(bytes32 mode) public view virtual returns (bool result) {\n        return _executionModeId(mode) != 0;\n    }",
            "startLine": 105,
            "signature": "supportsExecutionMode(bytes32)",
            "selector": "0x284986b0",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_executionModeId",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _executionModeId(bytes32 mode) internal view virtual returns (uint256 id) {\n        // Only supports atomic batched executions.\n        // For the encoding scheme, see: https://eips.ethereum.org/EIPS/eip-7579\n        // Bytes Layout:\n        // - [0]      ( 1 byte )  `0x01` for batch call.\n        // - [1]      ( 1 byte )  `0x00` for revert on any failure.\n        // - [2..5]   ( 4 bytes)  Reserved by ERC7579 for future standardization.\n        // - [6..9]   ( 4 bytes)  `0x00000000` or `0x78210001` or `0x78210002`.\n        // - [10..31] (22 bytes)  Unused. Free for use.\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := and(shr(mul(22, 8), mode), 0xffff00000000ffffffff)\n            id := eq(m, 0x01000000000000000000) // 1.\n            id := or(shl(1, eq(m, 0x01000000000078210001)), id) // 2.\n            id := or(mul(3, eq(m, 0x01000000000078210002)), id) // 3.\n        }\n    }",
            "startLine": 114,
            "visibility": "internal"
          },
          {
            "name": "_executeBatchOfBatches",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              },
              {
                "name": "executionData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "execute",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _executeBatchOfBatches(bytes32 mode, bytes calldata executionData) internal virtual {\n        // Replace with `0x0100________78210001...` while preserving optional and reserved fields.\n        mode ^= bytes32(uint256(3 << (22 * 8))); // `2 XOR 3 = 1`.\n        (uint256 n, uint256 o, uint256 e) = (0, 0, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let j := calldataload(executionData.offset)\n            let t := add(executionData.offset, j)\n            n := calldataload(t) // `batches.length`.\n            o := add(0x20, t) // Offset of `batches[0]`.\n            e := add(executionData.offset, executionData.length) // End of `executionData`.\n            // Do the bounds check on `executionData` treating it as `abi.encode(bytes[])`.\n            // Not too expensive, so we will just do it right here right now.\n            if or(shr(64, j), or(lt(executionData.length, 0x20), gt(add(o, shl(5, n)), e))) {\n                mstore(0x00, 0x3995943b) // `BatchOfBatchesDecodingError()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        unchecked {\n            for (uint256 i; i != n; ++i) {\n                bytes calldata batch;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let j := calldataload(add(o, shl(5, i)))\n                    let t := add(o, j)\n                    batch.offset := add(t, 0x20)\n                    batch.length := calldataload(t)\n                    // Validate that `batches[i]` is not out-of-bounds.\n                    if or(shr(64, j), gt(add(batch.offset, batch.length), e)) {\n                        mstore(0x00, 0x3995943b) // `BatchOfBatchesDecodingError()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                execute(mode, batch);\n            }\n        }\n    }",
            "startLine": 133,
            "visibility": "internal"
          },
          {
            "name": "_execute",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              },
              {
                "name": "executionData",
                "type": "bytes"
              },
              {
                "name": "calls",
                "type": "Call[]"
              },
              {
                "name": "opData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_execute",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _execute(\n        bytes32 mode,\n        bytes calldata executionData,\n        Call[] calldata calls,\n        bytes calldata opData\n    ) internal virtual {\n        // Silence compiler warning on unused variables.\n        mode = mode;\n        executionData = executionData;\n        // Very basic auth to only allow this contract to be called by itself.\n        // Override this function to perform more complex auth with `opData`.\n        if (opData.length == uint256(0)) {\n            require(msg.sender == address(this));\n            // Remember to return `_execute(calls, extraData)` when you override this function.\n            return _execute(calls, bytes32(0));\n        }\n        revert(); // In your override, replace this with logic to operate on `opData`.\n    }",
            "startLine": 174,
            "visibility": "internal"
          },
          {
            "name": "_execute",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "calls",
                "type": "Call[]"
              },
              {
                "name": "extraData",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_get",
                "type": "internal"
              },
              {
                "target": "_execute",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _execute(Call[] calldata calls, bytes32 extraData) internal virtual {\n        unchecked {\n            uint256 i;\n            if (calls.length == uint256(0)) return;\n            do {\n                (address to, uint256 value, bytes calldata data) = _get(calls, i);\n                _execute(to, value, data, extraData);\n            } while (++i != calls.length);\n        }\n    }",
            "startLine": 196,
            "visibility": "internal"
          },
          {
            "name": "_execute",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "extraData",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _execute(address to, uint256 value, bytes calldata data, bytes32 extraData)\n        internal\n        virtual\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extraData := extraData // Silence unused variable compiler warning.\n            let m := mload(0x40) // Grab the free memory pointer.\n            calldatacopy(m, data.offset, data.length)\n            if iszero(call(gas(), to, value, m, data.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(m, 0x00, returndatasize())\n                revert(m, returndatasize())\n            }\n        }\n    }",
            "startLine": 210,
            "visibility": "internal"
          },
          {
            "name": "_get",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "calls",
                "type": "Call[]"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _get(Call[] calldata calls, uint256 i)\n        internal\n        view\n        virtual\n        returns (address to, uint256 value, bytes calldata data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let c := add(calls.offset, calldataload(add(calls.offset, shl(5, i))))\n            // Replaces `to` with `address(this)` if `address(0)` is provided.\n            let t := shr(96, shl(96, calldataload(c)))\n            to := or(mul(address(), iszero(t)), t)\n            value := calldataload(add(c, 0x20))\n            let o := add(c, calldataload(add(c, 0x40)))\n            data.offset := add(o, 0x20)\n            data.length := calldataload(o)\n        }\n    }",
            "startLine": 228,
            "visibility": "internal"
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "UnsupportedExecutionMode",
            "parameters": []
          },
          {
            "name": "BatchOfBatchesDecodingError",
            "parameters": []
          }
        ]
      },
      {
        "name": "Receiver",
        "kind": "abstract",
        "category": "core",
        "filePath": "solady/src/accounts/Receiver.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "_useReceiverFallbackBody",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _useReceiverFallbackBody() internal view virtual returns (bool) {\n        return true;\n    }",
            "startLine": 57,
            "visibility": "internal"
          },
          {
            "name": "_beforeReceiverFallbackBody",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _beforeReceiverFallbackBody() internal virtual {}",
            "startLine": 62,
            "visibility": "internal"
          },
          {
            "name": "_afterReceiverFallbackBody",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _afterReceiverFallbackBody() internal virtual {}",
            "startLine": 65,
            "visibility": "internal"
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "FnSelectorNotRecognized",
            "parameters": []
          }
        ]
      },
      {
        "name": "Timelock",
        "kind": "contract",
        "category": "core",
        "filePath": "solady/src/accounts/Timelock.sol",
        "inherits": [
          "ERC7821",
          "EnumerableRoles"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "initialize",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialMinDelay",
                "type": "uint256"
              },
              {
                "name": "initialAdmin",
                "type": "address"
              },
              {
                "name": "proposers",
                "type": "address[]"
              },
              {
                "name": "executors",
                "type": "address[]"
              },
              {
                "name": "cancellers",
                "type": "address[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initializeTimelockAuthorizationCheck",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_setRole",
                "type": "internal"
              },
              {
                "target": "_bulkSetRole",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function initialize(\n        uint256 initialMinDelay,\n        address initialAdmin,\n        address[] calldata proposers,\n        address[] calldata executors,\n        address[] calldata cancellers\n    ) public virtual {\n        _initializeTimelockAuthorizationCheck();\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(254, initialMinDelay) {\n                mstore(0x00, 0xd1efaf25) // `TimelockDelayOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            let s := _TIMELOCK_SLOT\n            if sload(s) {\n                mstore(0x00, 0xc44f149c) // `TimelockAlreadyInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(s, not(initialMinDelay))\n            mstore(0x00, initialMinDelay)\n            log1(0x00, 0x20, _MIN_DELAY_SET_EVENT_SIGNATURE)\n        }\n        if (initialAdmin != address(0)) {\n            _setRole(initialAdmin, ADMIN_ROLE, true);\n        }\n        _bulkSetRole(proposers, PROPOSER_ROLE, true);\n        _bulkSetRole(executors, EXECUTOR_ROLE, true);\n        _bulkSetRole(cancellers, CANCELLER_ROLE, true);\n    }",
            "startLine": 167,
            "signature": "initialize(uint256,address,address[],address[],address[])",
            "selector": "0x1fd13f1e",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "propose",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              },
              {
                "name": "executionData",
                "type": "bytes"
              },
              {
                "name": "delay",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "LibERC7579.decodeBatchAndOpData",
                "type": "library"
              },
              {
                "target": "minDelay",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function propose(bytes32 mode, bytes calldata executionData, uint256 delay)\n        public\n        virtual\n        onlyRole(PROPOSER_ROLE)\n        returns (bytes32 id)\n    {\n        LibERC7579.decodeBatchAndOpData(executionData); // Check if properly encoded.\n        uint256 t = minDelay();\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(254, delay) {\n                mstore(0x00, 0xd1efaf25) // `TimelockDelayOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            if lt(delay, t) {\n                mstore(0x00, 0x54336609) // `TimelockInsufficientDelay(uint256,uint256)`.\n                mstore(0x20, delay)\n                mstore(0x40, t)\n                revert(0x1c, 0x44)\n            }\n            let m := mload(0x40)\n            calldatacopy(add(m, 0x80), executionData.offset, executionData.length)\n            mstore(0x00, mode)\n            mstore(0x20, keccak256(add(m, 0x80), executionData.length))\n            id := keccak256(0x00, 0x40)\n            mstore(0x09, _TIMELOCK_SLOT)\n            mstore(0x00, id)\n            let s := keccak256(0x00, 0x29) // Operation slot.\n            if sload(s) {\n                mstore(0x00, 0xd639b0bf) // `TimelockInvalidOperation(bytes32,uint256)`.\n                mstore(0x20, id)\n                mstore(0x40, 1) // `1 << OperationState.Unset`\n                revert(0x1c, 0x44)\n            }\n            // Emits the {Proposed} event.\n            mstore(m, mode)\n            mstore(add(m, 0x20), 0x60)\n            let r := add(delay, timestamp()) // `readyTimestamp`.\n            sstore(s, shl(1, r)) // Update the operation in the storage.\n            mstore(add(m, 0x40), r)\n            mstore(add(m, 0x60), executionData.length)\n            // Some indexers require the bytes to be zero-right padded.\n            mstore(add(add(m, 0x80), executionData.length), 0) // Zeroize the slot after the end.\n            // forgefmt: disable-next-item\n            log2(m, add(0x80, and(not(0x1f), add(0x1f, executionData.length))),\n                _PROPOSED_EVENT_SIGNATURE, id)\n        }\n    }",
            "startLine": 228,
            "signature": "propose(bytes32,bytes,uint256)",
            "selector": "0x63f8943d",
            "visibility": "public",
            "modifiers": [
              "onlyRole"
            ]
          },
          {
            "name": "cancel",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x09, _TIMELOCK_SLOT)\n            mstore(0x00, id)\n            let s := keccak256(0x00, 0x29) // Operation slot.\n            let p := sload(s)\n            if or(and(1, p), iszero(p)) {\n                mstore(0x00, 0xd639b0bf) // `TimelockInvalidOperation(bytes32,uint256)`.\n                mstore(0x20, id)\n                mstore(0x40, 6) // `(1 << OperationState.Waiting) | (1 << OperationState.Ready)`\n                revert(0x1c, 0x44)\n            }\n            sstore(s, 0) // Clears the operation's storage slot.\n            // Emits the {Cancelled} event.\n            log2(0x00, 0x00, _CANCELLED_EVENT_SIGNATURE, id)\n        }\n    }",
            "startLine": 279,
            "signature": "cancel(bytes32)",
            "selector": "0x53867c4d",
            "visibility": "public",
            "modifiers": [
              "onlyRole"
            ]
          },
          {
            "name": "setMinDelay",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newMinDelay",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function setMinDelay(uint256 newMinDelay) public virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(caller(), address())) {\n                mstore(0x00, 0x55140ae8) // `TimelockUnauthorized()`.\n                revert(0x1c, 0x04)\n            }\n            if shr(254, newMinDelay) {\n                mstore(0x00, 0xd1efaf25) // `TimelockDelayOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(_TIMELOCK_SLOT, not(newMinDelay))\n            // Emits the {SetMinDelay} event.\n            mstore(0x00, newMinDelay)\n            log1(0x00, 0x20, _MIN_DELAY_SET_EVENT_SIGNATURE)\n        }\n    }",
            "startLine": 300,
            "signature": "setMinDelay(uint256)",
            "selector": "0x05a2bcbb",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "minDelay",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function minDelay() public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(sload(_TIMELOCK_SLOT))\n        }\n    }",
            "startLine": 323,
            "signature": "minDelay()",
            "selector": "0x35b8fb12",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "readyTimestamp",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function readyTimestamp(bytes32 id) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x09, _TIMELOCK_SLOT)\n            mstore(0x00, id)\n            result := shr(1, sload(keccak256(0x00, 0x29)))\n        }\n    }",
            "startLine": 331,
            "signature": "readyTimestamp(bytes32)",
            "selector": "0x1d034434",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "operationState",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "OperationState"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function operationState(bytes32 id) public view virtual returns (OperationState result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x09, _TIMELOCK_SLOT)\n            mstore(0x00, id)\n            result := sload(keccak256(0x00, 0x29))\n            // forgefmt: disable-next-item\n            result := mul(iszero(iszero(result)),\n                add(and(result, 1), sub(2, lt(timestamp(), shr(1, result)))))\n        }\n    }",
            "startLine": 341,
            "signature": "operationState(bytes32)",
            "selector": "0x70e8715d",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_initializeTimelockAuthorizationCheck",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializeTimelockAuthorizationCheck() internal virtual {\n        uint256 self = __timelockSelf;\n        uint256 deployer = __timelockDeployer;\n        uint256 deployerOrigin = __timelockDeployerOrigin;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(self, address()) {\n                if iszero(or(eq(caller(), deployer), eq(caller(), deployerOrigin))) {\n                    mstore(0x00, 0x55140ae8) // `TimelockUnauthorized()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 207,
            "visibility": "internal"
          },
          {
            "name": "_bulkSetRole",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "addresses",
                "type": "address[]"
              },
              {
                "name": "role",
                "type": "uint256"
              },
              {
                "name": "active",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setRole",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _bulkSetRole(address[] calldata addresses, uint256 role, bool active)\n        internal\n        virtual\n    {\n        for (uint256 i; i != addresses.length;) {\n            address a;\n            /// @solidity memory-safe-assembly\n            assembly {\n                a := calldataload(add(addresses.offset, shl(5, i)))\n                i := add(i, 1)\n            }\n            _setRole(a, role, active);\n        }\n    }",
            "startLine": 358,
            "visibility": "internal"
          },
          {
            "name": "_execute",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              },
              {
                "name": "executionData",
                "type": "bytes"
              },
              {
                "name": "calls",
                "type": "Call[]"
              },
              {
                "name": "opData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "hasRole",
                "type": "internal"
              },
              {
                "target": "_checkRole",
                "type": "internal"
              },
              {
                "target": "_execute",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _execute(\n        bytes32 mode,\n        bytes calldata executionData,\n        Call[] calldata calls,\n        bytes calldata opData\n    ) internal virtual override(ERC7821) {\n        if (!hasRole(OPEN_ROLE_HOLDER, EXECUTOR_ROLE)) _checkRole(EXECUTOR_ROLE);\n        bytes32 id;\n        uint256 s;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Copies the `executionData` for the event and to compute the `id`.\n            calldatacopy(mload(0x40), executionData.offset, executionData.length)\n            mstore(0x00, mode)\n            mstore(0x20, keccak256(mload(0x40), executionData.length))\n            id := keccak256(0x00, 0x40)\n            mstore(0x09, _TIMELOCK_SLOT)\n            mstore(0x00, id)\n            s := keccak256(0x00, 0x29)\n            let p := sload(s)\n            if or(or(and(1, p), iszero(p)), lt(timestamp(), shr(1, p))) {\n                mstore(0x00, 0xd639b0bf) // `TimelockInvalidOperation(bytes32,uint256)`.\n                mstore(0x20, id)\n                mstore(0x40, 4) // `1 << OperationState.Ready`\n                revert(0x1c, 0x44)\n            }\n            // Check if optional predecessor has been executed.\n            if iszero(lt(opData.length, 0x20)) {\n                let b := calldataload(opData.offset) // Predecessor's id.\n                mstore(0x00, b) // `_TIMELOCK_SLOT` is already at `0x09`.\n                if iszero(or(iszero(b), and(1, sload(keccak256(0x00, 0x29))))) {\n                    mstore(0x00, 0x90a9a618) // `TimelockUnexecutedPredecessor(bytes32)`.\n                    mstore(0x20, b)\n                    revert(0x1c, 0x24)\n                }\n            }\n        }\n        _execute(calls, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Recheck the operation after the calls, in case of reentrancy.\n            let p := sload(s)\n            if or(or(and(1, p), iszero(p)), lt(timestamp(), shr(1, p))) {\n                mstore(0x00, 0xd639b0bf) // `TimelockInvalidOperation(bytes32,uint256)`.\n                mstore(0x20, id)\n                mstore(0x40, 4) // `1 << OperationState.Ready`\n                revert(0x1c, 0x44)\n            }\n            let m := mload(0x40)\n            // Copies the `executionData` for the event.\n            calldatacopy(add(m, 0x60), executionData.offset, executionData.length)\n            // Emits the {Executed} event.\n            mstore(m, mode)\n            mstore(add(m, 0x20), 0x40)\n            mstore(add(m, 0x40), executionData.length)\n            // Some indexers require the bytes to be zero-right padded.\n            mstore(add(add(m, 0x60), executionData.length), 0) // Zeroize the slot after the end.\n            // forgefmt: disable-next-item\n            log2(m, add(0x60, and(not(0x1f), add(0x1f, executionData.length))),\n                _EXECUTED_EVENT_SIGNATURE, id)\n            sstore(s, or(1, p)) // Set the operation as executed in the storage.\n        }\n    }",
            "startLine": 381,
            "visibility": "internal"
          },
          {
            "name": "_authorizeSetRole",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_checkRole",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _authorizeSetRole(address, uint256, bool) internal virtual override(EnumerableRoles) {\n        if (msg.sender != address(this)) _checkRole(ADMIN_ROLE);\n    }",
            "startLine": 447,
            "visibility": "internal"
          }
        ],
        "events": [
          {
            "name": "Proposed",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "mode",
                "type": "bytes32",
                "indexed": false
              },
              {
                "name": "executionData",
                "type": "bytes",
                "indexed": false
              },
              {
                "name": "readyTimestamp",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "Executed",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "mode",
                "type": "bytes32",
                "indexed": false
              },
              {
                "name": "executionData",
                "type": "bytes",
                "indexed": false
              }
            ]
          },
          {
            "name": "Cancelled",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32",
                "indexed": true
              }
            ]
          },
          {
            "name": "MinDelaySet",
            "parameters": [
              {
                "name": "newMinDelay",
                "type": "uint256",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "TimelockInsufficientDelay",
            "parameters": [
              {
                "name": "delay",
                "type": "uint256"
              },
              {
                "name": "minDelay",
                "type": "uint256"
              }
            ]
          },
          {
            "name": "TimelockInvalidOperation",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              },
              {
                "name": "expectedStates",
                "type": "uint256"
              }
            ]
          },
          {
            "name": "TimelockUnexecutedPredecessor",
            "parameters": [
              {
                "name": "predecessor",
                "type": "bytes32"
              }
            ]
          },
          {
            "name": "TimelockUnauthorized",
            "parameters": []
          },
          {
            "name": "TimelockDelayOverflow",
            "parameters": []
          },
          {
            "name": "TimelockAlreadyInitialized",
            "parameters": []
          }
        ]
      },
      {
        "name": "EnumerableRoles",
        "kind": "abstract",
        "category": "access",
        "filePath": "solady/src/auth/EnumerableRoles.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "setRole",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "role",
                "type": "uint256"
              },
              {
                "name": "active",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_authorizeSetRole",
                "type": "internal"
              },
              {
                "target": "_setRole",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function setRole(address holder, uint256 role, bool active) public payable virtual {\n        _authorizeSetRole(holder, role, active);\n        _setRole(holder, role, active);\n    }",
            "startLine": 76,
            "signature": "setRole(address,uint256,bool)",
            "selector": "0x4b360ae4",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "hasRole",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "role",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function hasRole(address holder, uint256 role) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x18, holder)\n            mstore(0x04, _ENUMERABLE_ROLES_SLOT_SEED)\n            mstore(0x00, role)\n            result := iszero(iszero(sload(keccak256(0x00, 0x38))))\n        }\n    }",
            "startLine": 86,
            "signature": "hasRole(address,uint256)",
            "selector": "0x65b56940",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "roleHolders",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address[]"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function roleHolders(uint256 role) public view virtual returns (address[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(0x04, _ENUMERABLE_ROLES_SLOT_SEED)\n            mstore(0x00, role)\n            let rootSlot := keccak256(0x00, 0x24)\n            let rootPacked := sload(rootSlot)\n            let n := shr(160, shl(160, rootPacked))\n            let o := add(0x20, result)\n            mstore(o, shr(96, rootPacked))\n            for { let i := 1 } lt(i, n) { i := add(i, 1) } {\n                mstore(add(o, shl(5, i)), shr(96, sload(add(rootSlot, i))))\n            }\n            mstore(result, n)\n            mstore(0x40, add(o, shl(5, n)))\n        }\n    }",
            "startLine": 97,
            "signature": "roleHolders(uint256)",
            "selector": "0x1c8efae7",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "roleHolderCount",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function roleHolderCount(uint256 role) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ENUMERABLE_ROLES_SLOT_SEED)\n            mstore(0x00, role)\n            result := shr(160, shl(160, sload(keccak256(0x00, 0x24))))\n        }\n    }",
            "startLine": 117,
            "signature": "roleHolderCount(uint256)",
            "selector": "0x4dac0b15",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "roleHolderAt",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "uint256"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function roleHolderAt(uint256 role, uint256 i) public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ENUMERABLE_ROLES_SLOT_SEED)\n            mstore(0x00, role)\n            let rootSlot := keccak256(0x00, 0x24)\n            let rootPacked := sload(rootSlot)\n            if iszero(lt(i, shr(160, shl(160, rootPacked)))) {\n                mstore(0x00, 0x5694da8e) // `RoleHoldersIndexOutOfBounds()`.\n                revert(0x1c, 0x04)\n            }\n            result := shr(96, rootPacked)\n            if i { result := shr(96, sload(add(rootSlot, i))) }\n        }\n    }",
            "startLine": 127,
            "signature": "roleHolderAt(uint256,uint256)",
            "selector": "0x610d2556",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_setRole",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "role",
                "type": "uint256"
              },
              {
                "name": "active",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateRole",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _setRole(address holder, uint256 role, bool active) internal virtual {\n        _validateRole(role);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let holder_ := shl(96, holder)\n            if iszero(holder_) {\n                mstore(0x00, 0x82550143) // `RoleHolderIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x18, holder)\n            mstore(0x04, _ENUMERABLE_ROLES_SLOT_SEED)\n            mstore(0x00, role)\n            let rootSlot := keccak256(0x00, 0x24)\n            let n := shr(160, shl(160, sload(rootSlot)))\n            let positionSlot := keccak256(0x00, 0x38)\n            let position := sload(positionSlot)\n            for {} 1 {} {\n                if iszero(active) {\n                    if iszero(position) { break }\n                    let nSub := sub(n, 1)\n                    if iszero(eq(sub(position, 1), nSub)) {\n                        let lastHolder_ := shl(96, shr(96, sload(add(rootSlot, nSub))))\n                        sstore(add(rootSlot, sub(position, 1)), lastHolder_)\n                        sstore(add(rootSlot, nSub), 0)\n                        mstore(0x24, lastHolder_)\n                        sstore(keccak256(0x00, 0x38), position)\n                    }\n                    sstore(rootSlot, or(shl(96, shr(96, sload(rootSlot))), nSub))\n                    sstore(positionSlot, 0)\n                    break\n                }\n                if iszero(position) {\n                    sstore(add(rootSlot, n), holder_)\n                    sstore(positionSlot, add(n, 1))\n                    sstore(rootSlot, add(sload(rootSlot), 1))\n                }\n                break\n            }\n            // forgefmt: disable-next-item\n            log4(0x00, 0x00, _ROLE_SET_EVENT_SIGNATURE, shr(96, holder_), role, iszero(iszero(active)))\n        }\n    }",
            "startLine": 148,
            "visibility": "internal"
          },
          {
            "name": "_validateRole",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _validateRole(uint256 role) internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0xd24f19d5) // `MAX_ROLE()`.\n            if and(\n                and(gt(role, mload(0x00)), gt(returndatasize(), 0x1f)),\n                staticcall(gas(), address(), 0x1c, 0x04, 0x00, 0x20)\n            ) {\n                mstore(0x00, 0xd954416a) // `InvalidRole()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 193,
            "visibility": "internal"
          },
          {
            "name": "_authorizeSetRole",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "role",
                "type": "uint256"
              },
              {
                "name": "active",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_enumerableRolesSenderIsContractOwner",
                "type": "internal"
              },
              {
                "target": "_revertEnumerableRolesUnauthorized",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _authorizeSetRole(address holder, uint256 role, bool active) internal virtual {\n        if (!_enumerableRolesSenderIsContractOwner()) _revertEnumerableRolesUnauthorized();\n        // Silence compiler warning on unused variables.\n        (holder, role, active) = (holder, role, active);\n    }",
            "startLine": 208,
            "visibility": "internal"
          },
          {
            "name": "_hasAnyRoles",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "encodedRoles",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _hasAnyRoles(address holder, bytes memory encodedRoles)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x18, holder)\n            mstore(0x04, _ENUMERABLE_ROLES_SLOT_SEED)\n            let end := add(encodedRoles, shl(5, shr(5, mload(encodedRoles))))\n            for {} lt(result, lt(encodedRoles, end)) {} {\n                encodedRoles := add(0x20, encodedRoles)\n                mstore(0x00, mload(encodedRoles))\n                result := sload(keccak256(0x00, 0x38))\n            }\n            result := iszero(iszero(result))\n        }\n    }",
            "startLine": 216,
            "visibility": "internal"
          },
          {
            "name": "_checkRole",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "hasRole",
                "type": "internal"
              },
              {
                "target": "_revertEnumerableRolesUnauthorized",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkRole(uint256 role) internal view virtual {\n        if (!hasRole(msg.sender, role)) _revertEnumerableRolesUnauthorized();\n    }",
            "startLine": 237,
            "visibility": "internal"
          },
          {
            "name": "_checkRoles",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "encodedRoles",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_hasAnyRoles",
                "type": "internal"
              },
              {
                "target": "_revertEnumerableRolesUnauthorized",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkRoles(bytes memory encodedRoles) internal view virtual {\n        if (!_hasAnyRoles(msg.sender, encodedRoles)) _revertEnumerableRolesUnauthorized();\n    }",
            "startLine": 242,
            "visibility": "internal"
          },
          {
            "name": "_checkOwnerOrRole",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_enumerableRolesSenderIsContractOwner",
                "type": "internal"
              },
              {
                "target": "_checkRole",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwnerOrRole(uint256 role) internal view virtual {\n        if (!_enumerableRolesSenderIsContractOwner()) _checkRole(role);\n    }",
            "startLine": 247,
            "visibility": "internal"
          },
          {
            "name": "_checkOwnerOrRoles",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "encodedRoles",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_enumerableRolesSenderIsContractOwner",
                "type": "internal"
              },
              {
                "target": "_checkRoles",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwnerOrRoles(bytes memory encodedRoles) internal view virtual {\n        if (!_enumerableRolesSenderIsContractOwner()) _checkRoles(encodedRoles);\n    }",
            "startLine": 253,
            "visibility": "internal"
          },
          {
            "name": "_enumerableRolesSenderIsContractOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _enumerableRolesSenderIsContractOwner() private view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x8da5cb5b) // `owner()`.\n            result :=\n                and(\n                    and(eq(caller(), mload(0x00)), gt(returndatasize(), 0x1f)),\n                    staticcall(gas(), address(), 0x1c, 0x04, 0x00, 0x20)\n                )\n        }\n    }",
            "startLine": 295,
            "visibility": "private"
          },
          {
            "name": "_revertEnumerableRolesUnauthorized",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _revertEnumerableRolesUnauthorized() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x99152cca) // `EnumerableRolesUnauthorized()`.\n            revert(0x1c, 0x04)\n        }\n    }",
            "startLine": 308,
            "visibility": "private"
          }
        ],
        "events": [
          {
            "name": "RoleSet",
            "parameters": [
              {
                "name": "holder",
                "type": "address",
                "indexed": true
              },
              {
                "name": "role",
                "type": "uint256",
                "indexed": true
              },
              {
                "name": "active",
                "type": "bool",
                "indexed": true
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "RoleHoldersIndexOutOfBounds",
            "parameters": []
          },
          {
            "name": "RoleHolderIsZeroAddress",
            "parameters": []
          },
          {
            "name": "InvalidRole",
            "parameters": []
          },
          {
            "name": "EnumerableRolesUnauthorized",
            "parameters": []
          }
        ]
      },
      {
        "name": "Ownable",
        "kind": "abstract",
        "category": "access",
        "filePath": "solady/src/auth/Ownable.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "transferOwnership",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setOwner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }",
            "startLine": 174,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "renounceOwnership",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_setOwner",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }",
            "startLine": 186,
            "signature": "renounceOwnership()",
            "selector": "0x765becbf",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "requestOwnershipHandover",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_ownershipHandoverValidFor",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }",
            "startLine": 192,
            "signature": "requestOwnershipHandover()",
            "selector": "0x1238043c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "cancelOwnershipHandover",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }",
            "startLine": 208,
            "signature": "cancelOwnershipHandover()",
            "selector": "0x50b4a9f9",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "completeOwnershipHandover",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "pendingOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setOwner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }",
            "startLine": 222,
            "signature": "completeOwnershipHandover(address)",
            "selector": "0x629c6f1c",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_OWNER_SLOT)\n        }\n    }",
            "startLine": 245,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "ownershipHandoverExpiresAt",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "pendingOwner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }",
            "startLine": 253,
            "signature": "ownershipHandoverExpiresAt(address)",
            "selector": "0x1c8a15d8",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_guardInitializeOwner",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "guard",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _guardInitializeOwner() internal pure virtual returns (bool guard) {}",
            "startLine": 85,
            "visibility": "internal"
          },
          {
            "name": "_initializeOwner",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_guardInitializeOwner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializeOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                if sload(ownerSlot) {\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\n                    revert(0x1c, 0x04)\n                }\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(_OWNER_SLOT, newOwner)\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        }\n    }",
            "startLine": 94,
            "visibility": "internal"
          },
          {
            "name": "_setOwner",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_guardInitializeOwner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _setOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, newOwner)\n            }\n        }\n    }",
            "startLine": 124,
            "visibility": "internal"
          },
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 151,
            "visibility": "internal"
          },
          {
            "name": "_ownershipHandoverValidFor",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }",
            "startLine": 165,
            "visibility": "internal"
          }
        ],
        "events": [
          {
            "name": "OwnershipTransferred",
            "parameters": [
              {
                "name": "oldOwner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "newOwner",
                "type": "address",
                "indexed": true
              }
            ]
          },
          {
            "name": "OwnershipHandoverRequested",
            "parameters": [
              {
                "name": "pendingOwner",
                "type": "address",
                "indexed": true
              }
            ]
          },
          {
            "name": "OwnershipHandoverCanceled",
            "parameters": [
              {
                "name": "pendingOwner",
                "type": "address",
                "indexed": true
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "Unauthorized",
            "parameters": []
          },
          {
            "name": "NewOwnerIsZeroAddress",
            "parameters": []
          },
          {
            "name": "NoHandoverRequest",
            "parameters": []
          },
          {
            "name": "AlreadyInitialized",
            "parameters": []
          }
        ]
      },
      {
        "name": "OwnableRoles",
        "kind": "abstract",
        "category": "access",
        "filePath": "solady/src/auth/OwnableRoles.sol",
        "inherits": [
          "Ownable"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "grantRoles",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "user",
                "type": "address"
              },
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_grantRoles",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function grantRoles(address user, uint256 roles) public payable virtual onlyOwner {\n        _grantRoles(user, roles);\n    }",
            "startLine": 207,
            "signature": "grantRoles(address,uint256)",
            "selector": "0x47a2008f",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "revokeRoles",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "user",
                "type": "address"
              },
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_removeRoles",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function revokeRoles(address user, uint256 roles) public payable virtual onlyOwner {\n        _removeRoles(user, roles);\n    }",
            "startLine": 213,
            "signature": "revokeRoles(address,uint256)",
            "selector": "0x07320279",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "renounceRoles",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_removeRoles",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceRoles(uint256 roles) public payable virtual {\n        _removeRoles(msg.sender, roles);\n    }",
            "startLine": 219,
            "signature": "renounceRoles(uint256)",
            "selector": "0x5a30d86a",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "rolesOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "user",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function rolesOf(address user) public view virtual returns (uint256 roles) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the role slot.\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, user)\n            // Load the stored value.\n            roles := sload(keccak256(0x0c, 0x20))\n        }\n    }",
            "startLine": 228,
            "signature": "rolesOf(address)",
            "selector": "0x6b0b3fe9",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "hasAnyRole",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "user",
                "type": "address"
              },
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "rolesOf",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function hasAnyRole(address user, uint256 roles) public view virtual returns (bool) {\n        return rolesOf(user) & roles != 0;\n    }",
            "startLine": 240,
            "signature": "hasAnyRole(address,uint256)",
            "selector": "0x4b19b1e8",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "hasAllRoles",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "user",
                "type": "address"
              },
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "rolesOf",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function hasAllRoles(address user, uint256 roles) public view virtual returns (bool) {\n        return rolesOf(user) & roles == roles;\n    }",
            "startLine": 245,
            "signature": "hasAllRoles(address,uint256)",
            "selector": "0x09199a26",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_setRoles",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "user",
                "type": "address"
              },
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _setRoles(address user, uint256 roles) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, user)\n            // Store the new value.\n            sstore(keccak256(0x0c, 0x20), roles)\n            // Emit the {RolesUpdated} event.\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, mload(0x0c)), roles)\n        }\n    }",
            "startLine": 49,
            "visibility": "internal"
          },
          {
            "name": "_updateRoles",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "user",
                "type": "address"
              },
              {
                "name": "roles",
                "type": "uint256"
              },
              {
                "name": "on",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _updateRoles(address user, uint256 roles, bool on) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, user)\n            let roleSlot := keccak256(0x0c, 0x20)\n            // Load the current value.\n            let current := sload(roleSlot)\n            // Compute the updated roles if `on` is true.\n            let updated := or(current, roles)\n            // Compute the updated roles if `on` is false.\n            // Use `and` to compute the intersection of `current` and `roles`,\n            // `xor` it with `current` to flip the bits in the intersection.\n            if iszero(on) { updated := xor(current, and(current, roles)) }\n            // Then, store the new value.\n            sstore(roleSlot, updated)\n            // Emit the {RolesUpdated} event.\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, mload(0x0c)), updated)\n        }\n    }",
            "startLine": 64,
            "visibility": "internal"
          },
          {
            "name": "_grantRoles",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "user",
                "type": "address"
              },
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_updateRoles",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _grantRoles(address user, uint256 roles) internal virtual {\n        _updateRoles(user, roles, true);\n    }",
            "startLine": 87,
            "visibility": "internal"
          },
          {
            "name": "_removeRoles",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "user",
                "type": "address"
              },
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_updateRoles",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _removeRoles(address user, uint256 roles) internal virtual {\n        _updateRoles(user, roles, false);\n    }",
            "startLine": 93,
            "visibility": "internal"
          },
          {
            "name": "_checkRoles",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkRoles(uint256 roles) internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the role slot.\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, caller())\n            // Load the stored value, and if the `and` intersection\n            // of the value and `roles` is zero, revert.\n            if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 98,
            "visibility": "internal"
          },
          {
            "name": "_checkOwnerOrRoles",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwnerOrRoles(uint256 roles) internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner.\n            // Note: `_ROLE_SLOT_SEED` is equal to `_OWNER_SLOT_NOT`.\n            if iszero(eq(caller(), sload(not(_ROLE_SLOT_SEED)))) {\n                // Compute the role slot.\n                mstore(0x0c, _ROLE_SLOT_SEED)\n                mstore(0x00, caller())\n                // Load the stored value, and if the `and` intersection\n                // of the value and `roles` is zero, revert.\n                if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\n                    mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 116,
            "visibility": "internal"
          },
          {
            "name": "_checkRolesOrOwner",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkRolesOrOwner(uint256 roles) internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the role slot.\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, caller())\n            // Load the stored value, and if the `and` intersection\n            // of the value and `roles` is zero, revert.\n            if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\n                // If the caller is not the stored owner.\n                // Note: `_ROLE_SLOT_SEED` is equal to `_OWNER_SLOT_NOT`.\n                if iszero(eq(caller(), sload(not(_ROLE_SLOT_SEED)))) {\n                    mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 138,
            "visibility": "internal"
          },
          {
            "name": "_rolesFromOrdinals",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "ordinals",
                "type": "uint8[]"
              }
            ],
            "returnValues": [
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _rolesFromOrdinals(uint8[] memory ordinals) internal pure returns (uint256 roles) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let i := shl(5, mload(ordinals)) } i { i := sub(i, 0x20) } {\n                // We don't need to mask the values of `ordinals`, as Solidity\n                // cleans dirty upper bits when storing variables into memory.\n                roles := or(shl(mload(add(ordinals, i)), 1), roles)\n            }\n        }\n    }",
            "startLine": 161,
            "visibility": "internal"
          },
          {
            "name": "_ordinalsFromRoles",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "ordinals",
                "type": "uint8[]"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _ordinalsFromRoles(uint256 roles) internal pure returns (uint8[] memory ordinals) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the pointer to the free memory.\n            ordinals := mload(0x40)\n            let ptr := add(ordinals, 0x20)\n            let o := 0\n            // The absence of lookup tables, De Bruijn, etc., here is intentional for\n            // smaller bytecode, as this function is not meant to be called on-chain.\n            for { let t := roles } 1 {} {\n                mstore(ptr, o)\n                // `shr` 5 is equivalent to multiplying by 0x20.\n                // Push back into the ordinals array if the bit is set.\n                ptr := add(ptr, shl(5, and(t, 1)))\n                o := add(o, 1)\n                t := shr(o, roles)\n                if iszero(t) { break }\n            }\n            // Store the length of `ordinals`.\n            mstore(ordinals, shr(5, sub(ptr, add(ordinals, 0x20))))\n            // Allocate the memory.\n            mstore(0x40, ptr)\n        }\n    }",
            "startLine": 176,
            "visibility": "internal"
          }
        ],
        "events": [
          {
            "name": "RolesUpdated",
            "parameters": [
              {
                "name": "user",
                "type": "address",
                "indexed": true
              },
              {
                "name": "roles",
                "type": "uint256",
                "indexed": true
              }
            ]
          }
        ],
        "errors": []
      },
      {
        "name": "TimedRoles",
        "kind": "abstract",
        "category": "access",
        "filePath": "solady/src/auth/TimedRoles.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "setTimedRole",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "timedRole",
                "type": "uint256"
              },
              {
                "name": "start",
                "type": "uint40"
              },
              {
                "name": "expires",
                "type": "uint40"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_authorizeSetTimedRole",
                "type": "internal"
              },
              {
                "target": "_setTimedRole",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function setTimedRole(address holder, uint256 timedRole, uint40 start, uint40 expires)\n        public\n        payable\n        virtual\n    {\n        _authorizeSetTimedRole(holder, timedRole, start, expires);\n        _setTimedRole(holder, timedRole, start, expires);\n    }",
            "startLine": 84,
            "signature": "setTimedRole(address,uint256,uint40,uint40)",
            "selector": "0x55cb1805",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "timedRoleActive",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "timedRole",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "isActive",
                "type": "bool"
              },
              {
                "name": "start",
                "type": "uint40"
              },
              {
                "name": "expires",
                "type": "uint40"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function timedRoleActive(address holder, uint256 timedRole)\n        public\n        view\n        virtual\n        returns (bool isActive, uint40 start, uint40 expires)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x18, holder)\n            mstore(0x04, _TIMED_ROLES_SLOT_SEED)\n            mstore(0x00, timedRole)\n            let p := sload(keccak256(0x00, 0x38))\n            start := shr(216, p)\n            expires := and(0xffffffffff, p)\n            isActive := iszero(or(lt(timestamp(), start), gt(timestamp(), expires)))\n        }\n    }",
            "startLine": 98,
            "signature": "timedRoleActive(address,uint256)",
            "selector": "0x17159be3",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_setTimedRole",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "timedRole",
                "type": "uint256"
              },
              {
                "name": "start",
                "type": "uint40"
              },
              {
                "name": "expires",
                "type": "uint40"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateTimedRole",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _setTimedRole(address holder, uint256 timedRole, uint40 start, uint40 expires)\n        internal\n        virtual\n    {\n        _validateTimedRole(timedRole);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let holder_ := shl(96, holder)\n            if iszero(holder_) {\n                mstore(0x00, 0x093a136f) // `TimedRoleHolderIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // Clean the upper bits.\n            start := and(0xffffffffff, start)\n            expires := and(0xffffffffff, expires)\n            // Validate the range.\n            if lt(expires, start) {\n                mstore(0x00, 0x3304dd8c) // `InvalidTimedRoleRange()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the range.\n            mstore(0x18, holder)\n            mstore(0x04, _TIMED_ROLES_SLOT_SEED)\n            mstore(0x00, timedRole)\n            sstore(keccak256(0x00, 0x38), or(shl(216, start), expires))\n            // Emit the {TimedRoleSet} event.\n            mstore(0x00, start)\n            mstore(0x20, expires)\n            log3(0x00, 0x40, _TIMED_ROLE_SET_EVENT_SIGNATURE, shr(96, holder_), timedRole)\n        }\n    }",
            "startLine": 121,
            "visibility": "internal"
          },
          {
            "name": "_validateTimedRole",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "timedRole",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _validateTimedRole(uint256 timedRole) internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x32bc6439) // `MAX_TIMED_ROLE()`.\n            if and(\n                and(gt(timedRole, mload(0x00)), gt(returndatasize(), 0x1f)),\n                staticcall(gas(), address(), 0x1c, 0x04, 0x00, 0x20)\n            ) {\n                mstore(0x00, 0x802ee27f) // `InvalidTimedRole()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 155,
            "visibility": "internal"
          },
          {
            "name": "_authorizeSetTimedRole",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "timedRole",
                "type": "uint256"
              },
              {
                "name": "start",
                "type": "uint40"
              },
              {
                "name": "expires",
                "type": "uint40"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_timedRolesSenderIsContractOwner",
                "type": "internal"
              },
              {
                "target": "_revertTimedRolesUnauthorized",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _authorizeSetTimedRole(address holder, uint256 timedRole, uint40 start, uint40 expires)\n        internal\n        virtual\n    {\n        if (!_timedRolesSenderIsContractOwner()) _revertTimedRolesUnauthorized();\n        // Silence compiler warning on unused variables.\n        (holder, timedRole, start, expires) = (holder, timedRole, start, expires);\n    }",
            "startLine": 170,
            "visibility": "internal"
          },
          {
            "name": "_hasAnyTimedRoles",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "encodedTimeRoles",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _hasAnyTimedRoles(address holder, bytes memory encodedTimeRoles)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x18, holder)\n            mstore(0x04, _TIMED_ROLES_SLOT_SEED)\n            let end := add(encodedTimeRoles, shl(5, shr(5, mload(encodedTimeRoles))))\n            for {} lt(result, lt(encodedTimeRoles, end)) {} {\n                encodedTimeRoles := add(0x20, encodedTimeRoles)\n                mstore(0x00, mload(encodedTimeRoles))\n                let p := sload(keccak256(0x00, 0x38))\n                result :=\n                    iszero(or(lt(timestamp(), shr(216, p)), gt(timestamp(), and(0xffffffffff, p))))\n            }\n        }\n    }",
            "startLine": 181,
            "visibility": "internal"
          },
          {
            "name": "_checkTimedRole",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "timedRole",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "timedRoleActive",
                "type": "internal"
              },
              {
                "target": "_revertTimedRolesUnauthorized",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkTimedRole(uint256 timedRole) internal view virtual {\n        (bool isActive,,) = timedRoleActive(msg.sender, timedRole);\n        if (!isActive) _revertTimedRolesUnauthorized();\n    }",
            "startLine": 203,
            "visibility": "internal"
          },
          {
            "name": "_checkTimedRoles",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "encodedTimedRoles",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_hasAnyTimedRoles",
                "type": "internal"
              },
              {
                "target": "_revertTimedRolesUnauthorized",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkTimedRoles(bytes memory encodedTimedRoles) internal view virtual {\n        if (!_hasAnyTimedRoles(msg.sender, encodedTimedRoles)) _revertTimedRolesUnauthorized();\n    }",
            "startLine": 209,
            "visibility": "internal"
          },
          {
            "name": "_checkOwnerOrTimedRole",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "timedRole",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_timedRolesSenderIsContractOwner",
                "type": "internal"
              },
              {
                "target": "_checkTimedRole",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwnerOrTimedRole(uint256 timedRole) internal view virtual {\n        if (!_timedRolesSenderIsContractOwner()) _checkTimedRole(timedRole);\n    }",
            "startLine": 214,
            "visibility": "internal"
          },
          {
            "name": "_checkOwnerOrTimedRoles",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "encodedTimedRoles",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_timedRolesSenderIsContractOwner",
                "type": "internal"
              },
              {
                "target": "_checkTimedRoles",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwnerOrTimedRoles(bytes memory encodedTimedRoles) internal view virtual {\n        if (!_timedRolesSenderIsContractOwner()) _checkTimedRoles(encodedTimedRoles);\n    }",
            "startLine": 220,
            "visibility": "internal"
          },
          {
            "name": "_timedRolesSenderIsContractOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _timedRolesSenderIsContractOwner() private view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x8da5cb5b) // `owner()`.\n            result :=\n                and(\n                    and(eq(caller(), mload(0x00)), gt(returndatasize(), 0x1f)),\n                    staticcall(gas(), address(), 0x1c, 0x04, 0x00, 0x20)\n                )\n        }\n    }",
            "startLine": 262,
            "visibility": "private"
          },
          {
            "name": "_revertTimedRolesUnauthorized",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _revertTimedRolesUnauthorized() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0xb0c7b036) // `TimedRolesUnauthorized()`.\n            revert(0x1c, 0x04)\n        }\n    }",
            "startLine": 275,
            "visibility": "private"
          }
        ],
        "events": [
          {
            "name": "TimedRoleSet",
            "parameters": [
              {
                "name": "holder",
                "type": "address",
                "indexed": true
              },
              {
                "name": "timedRole",
                "type": "uint256",
                "indexed": true
              },
              {
                "name": "start",
                "type": "uint40",
                "indexed": false
              },
              {
                "name": "expires",
                "type": "uint40",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "TimedRoleHolderIsZeroAddress",
            "parameters": []
          },
          {
            "name": "InvalidTimedRole",
            "parameters": []
          },
          {
            "name": "TimedRolesUnauthorized",
            "parameters": []
          },
          {
            "name": "InvalidTimedRoleRange",
            "parameters": []
          }
        ]
      },
      {
        "name": "ERC1155",
        "kind": "abstract",
        "category": "token",
        "filePath": "solady/src/tokens/ERC1155.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "uri",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function uri(uint256 id) public view virtual returns (string memory);",
            "startLine": 126,
            "signature": "uri(uint256)",
            "selector": "0x1d5ffecc",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "balanceOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address owner, uint256 id) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, id)\n            result := sload(keccak256(0x00, 0x40))\n        }\n    }",
            "startLine": 133,
            "signature": "balanceOf(address,uint256)",
            "selector": "0x3d474403",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "isApprovedForAll",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, operator)\n            result := sload(keccak256(0x0c, 0x34))\n        }\n    }",
            "startLine": 144,
            "signature": "isApprovedForAll(address,address)",
            "selector": "0x3672353c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "setApprovalForAll",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "isApproved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function setApprovalForAll(address operator, bool isApproved) public virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`msg.sender`, `operator`).\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, caller())\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            // forgefmt: disable-next-line\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator)))\n        }\n    }",
            "startLine": 162,
            "signature": "setApprovalForAll(address,bool)",
            "selector": "0x7b14221c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "safeTransferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_single",
                "type": "internal"
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\n            mstore(0x20, fromSlotSeed)\n            // Clear the upper 96 bits.\n            from := shr(96, fromSlotSeed)\n            to := shr(96, toSlotSeed)\n            // Revert if `to` is the zero address.\n            if iszero(to) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // If the caller is not `from`, do the authorization check.\n            if iszero(eq(caller(), from)) {\n                mstore(0x00, caller())\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Subtract and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, toSlotSeed)\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), from, to)\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Do the {onERC1155Received} check if `to` is a smart contract.\n            if extcodesize(to) {\n                // Prepare the calldata.\n                let m := mload(0x40)\n                // `onERC1155Received(address,address,uint256,uint256,bytes)`.\n                mstore(m, 0xf23a6e61)\n                mstore(add(m, 0x20), caller())\n                mstore(add(m, 0x40), from)\n                mstore(add(m, 0x60), id)\n                mstore(add(m, 0x80), amount)\n                mstore(add(m, 0xa0), 0xa0)\n                mstore(add(m, 0xc0), data.length)\n                calldatacopy(add(m, 0xe0), data.offset, data.length)\n                // Revert if the call reverts.\n                if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, data.length), m, 0x20)) {\n                    if returndatasize() {\n                        // Bubble up the revert if the call reverts.\n                        returndatacopy(m, 0x00, returndatasize())\n                        revert(m, returndatasize())\n                    }\n                }\n                // Load the returndata and compare it with the function selector.\n                if iszero(eq(mload(m), shl(224, 0xf23a6e61))) {\n                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 190,
            "signature": "safeTransferFrom(address,address,uint256,uint256,bytes)",
            "selector": "0x2c321246",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "safeBatchTransferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransferCalldata",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(ids.length, amounts.length)) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\n            mstore(0x20, fromSlotSeed)\n            // Clear the upper 96 bits.\n            from := shr(96, fromSlotSeed)\n            to := shr(96, toSlotSeed)\n            // Revert if `to` is the zero address.\n            if iszero(to) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // If the caller is not `from`, do the authorization check.\n            if iszero(eq(caller(), from)) {\n                mstore(0x00, caller())\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                for { let i := shl(5, ids.length) } i {} {\n                    i := sub(i, 0x20)\n                    let amount := calldataload(add(amounts.offset, i))\n                    // Subtract and store the updated balance of `from`.\n                    {\n                        mstore(0x20, fromSlotSeed)\n                        mstore(0x00, calldataload(add(ids.offset, i)))\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\n                        let fromBalance := sload(fromBalanceSlot)\n                        if gt(amount, fromBalance) {\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\n                    }\n                    // Increase and store the updated balance of `to`.\n                    {\n                        mstore(0x20, toSlotSeed)\n                        let toBalanceSlot := keccak256(0x00, 0x40)\n                        let toBalanceBefore := sload(toBalanceSlot)\n                        let toBalanceAfter := add(toBalanceBefore, amount)\n                        if lt(toBalanceAfter, toBalanceBefore) {\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(toBalanceSlot, toBalanceAfter)\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := shl(5, ids.length)\n                mstore(add(m, 0x40), ids.length)\n                calldatacopy(add(m, 0x60), ids.offset, n)\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x60, n))\n                let o := add(add(m, n), 0x60)\n                mstore(o, ids.length)\n                calldatacopy(add(o, 0x20), amounts.offset, n)\n                // Do the emit.\n                log4(m, add(add(n, n), 0x80), _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), from, to)\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransferCalldata(from, to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Do the {onERC1155BatchReceived} check if `to` is a smart contract.\n            if extcodesize(to) {\n                mstore(0x00, to) // Cache `to` to prevent stack too deep.\n                let m := mload(0x40)\n                // Prepare the calldata.\n                // `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n                mstore(m, 0xbc197c81)\n                mstore(add(m, 0x20), caller())\n                mstore(add(m, 0x40), from)\n                // Copy the `ids`.\n                mstore(add(m, 0x60), 0xa0)\n                let n := shl(5, ids.length)\n                mstore(add(m, 0xc0), ids.length)\n                calldatacopy(add(m, 0xe0), ids.offset, n)\n                // Copy the `amounts`.\n                mstore(add(m, 0x80), add(0xc0, n))\n                let o := add(add(m, n), 0xe0)\n                mstore(o, ids.length)\n                calldatacopy(add(o, 0x20), amounts.offset, n)\n                // Copy the `data`.\n                mstore(add(m, 0xa0), add(add(0xe0, n), n))\n                o := add(add(o, n), 0x20)\n                mstore(o, data.length)\n                calldatacopy(add(o, 0x20), data.offset, data.length)\n                let nAll := add(0x104, add(data.length, add(n, n)))\n                // Revert if the call reverts.\n                if iszero(call(gas(), mload(0x00), 0, add(mload(0x40), 0x1c), nAll, m, 0x20)) {\n                    if returndatasize() {\n                        // Bubble up the revert if the call reverts.\n                        returndatacopy(m, 0x00, returndatasize())\n                        revert(m, returndatasize())\n                    }\n                }\n                // Load the returndata and compare it with the function selector.\n                if iszero(eq(mload(m), shl(224, 0xbc197c81))) {\n                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 295,
            "signature": "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)",
            "selector": "0x131cc66a",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "balanceOfBatch",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owners",
                "type": "address[]"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "balances",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(ids.length, owners.length)) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            balances := mload(0x40)\n            mstore(balances, ids.length)\n            let o := add(balances, 0x20)\n            let i := shl(5, ids.length)\n            mstore(0x40, add(i, o))\n            // Loop through all the `ids` and load the balances.\n            for {} i {} {\n                i := sub(i, 0x20)\n                let owner := calldataload(add(owners.offset, i))\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner)))\n                mstore(0x00, calldataload(add(ids.offset, i)))\n                mstore(add(o, i), sload(keccak256(0x00, 0x40)))\n            }\n        }\n    }",
            "startLine": 429,
            "signature": "balanceOfBatch(address[],uint256[])",
            "selector": "0x32988c25",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "supportsInterface",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC1155: 0xd9b67a26, ERC1155MetadataURI: 0x0e89341c.\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0xd9b67a26)), eq(s, 0x0e89341c))\n        }\n    }",
            "startLine": 460,
            "signature": "supportsInterface(bytes4)",
            "selector": "0x4ba9e2f3",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_mint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_single",
                "type": "internal"
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_hasCode",
                "type": "internal"
              },
              {
                "target": "_checkOnERC1155Received",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(address(0), to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n                mstore(0x14, to)\n                mstore(0x00, id)\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), 0, shr(96, to_))\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(address(0), to, _single(id), _single(amount), data);\n        }\n        if (_hasCode(to)) _checkOnERC1155Received(address(0), to, id, amount, data);\n    }",
            "startLine": 481,
            "visibility": "internal"
          },
          {
            "name": "_batchMint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_hasCode",
                "type": "internal"
              },
              {
                "target": "_checkOnERC1155BatchReceived",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(address(0), to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(mload(ids), mload(amounts))) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, to_))\n                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {\n                    let amount := mload(add(amounts, i))\n                    // Increase and store the updated balance of `to`.\n                    {\n                        mstore(0x00, mload(add(ids, i)))\n                        let toBalanceSlot := keccak256(0x00, 0x40)\n                        let toBalanceBefore := sload(toBalanceSlot)\n                        let toBalanceAfter := add(toBalanceBefore, amount)\n                        if lt(toBalanceAfter, toBalanceBefore) {\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(toBalanceSlot, toBalanceAfter)\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, mload(ids)))\n                let o := add(m, 0x40)\n                pop(staticcall(gas(), 4, ids, n, o, n))\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, returndatasize()))\n                o := add(o, returndatasize())\n                n := add(0x20, shl(5, mload(amounts)))\n                pop(staticcall(gas(), 4, amounts, n, o, n))\n                n := sub(add(o, returndatasize()), m)\n                // Do the emit.\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), 0, shr(96, to_))\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(address(0), to, ids, amounts, data);\n        }\n        if (_hasCode(to)) _checkOnERC1155BatchReceived(address(0), to, ids, amounts, data);\n    }",
            "startLine": 526,
            "visibility": "internal"
          },
          {
            "name": "_burn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_burn",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        _burn(address(0), from, id, amount);\n    }",
            "startLine": 595,
            "visibility": "internal"
          },
          {
            "name": "_burn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_single",
                "type": "internal"
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _burn(address by, address from, uint256 id, uint256 amount) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, address(0), _single(id), _single(amount), \"\");\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            if iszero(or(iszero(shl(96, by)), eq(shl(96, by), from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Decrease and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), shr(96, from_), 0)\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, address(0), _single(id), _single(amount), \"\");\n        }\n    }",
            "startLine": 607,
            "visibility": "internal"
          },
          {
            "name": "_batchBurn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_batchBurn",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _batchBurn(address from, uint256[] memory ids, uint256[] memory amounts)\n        internal\n        virtual\n    {\n        _batchBurn(address(0), from, ids, amounts);\n    }",
            "startLine": 645,
            "visibility": "internal"
          },
          {
            "name": "_batchBurn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _batchBurn(address by, address from, uint256[] memory ids, uint256[] memory amounts)\n        internal\n        virtual\n    {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, address(0), ids, amounts, \"\");\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(mload(ids), mload(amounts))) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let from_ := shl(96, from)\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            let by_ := shl(96, by)\n            if iszero(or(iszero(by_), eq(by_, from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {\n                    let amount := mload(add(amounts, i))\n                    // Decrease and store the updated balance of `from`.\n                    {\n                        mstore(0x00, mload(add(ids, i)))\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\n                        let fromBalance := sload(fromBalanceSlot)\n                        if gt(amount, fromBalance) {\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, mload(ids)))\n                let o := add(m, 0x40)\n                pop(staticcall(gas(), 4, ids, n, o, n))\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, returndatasize()))\n                o := add(o, returndatasize())\n                n := add(0x20, shl(5, mload(amounts)))\n                pop(staticcall(gas(), 4, amounts, n, o, n))\n                n := sub(add(o, returndatasize()), m)\n                // Do the emit.\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), shr(96, from_), 0)\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, address(0), ids, amounts, \"\");\n        }\n    }",
            "startLine": 661,
            "visibility": "internal"
          },
          {
            "name": "_setApprovalForAll",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "isApproved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`by`, `operator`).\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, by)\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            let m := shr(96, not(0))\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, and(m, by), and(m, operator))\n        }\n    }",
            "startLine": 734,
            "visibility": "internal"
          },
          {
            "name": "_safeTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address from, address to, uint256 id, uint256 amount, bytes memory data)\n        internal\n        virtual\n    {\n        _safeTransfer(address(0), from, to, id, amount, data);\n    }",
            "startLine": 756,
            "visibility": "internal"
          },
          {
            "name": "_safeTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_single",
                "type": "internal"
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_hasCode",
                "type": "internal"
              },
              {
                "target": "_checkOnERC1155Received",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(\n        address by,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            let by_ := shl(96, by)\n            if iszero(or(iszero(by_), eq(by_, from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Subtract and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, to_))\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            // forgefmt: disable-next-line\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), shr(96, from_), shr(96, to_))\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        if (_hasCode(to)) _checkOnERC1155Received(from, to, id, amount, data);\n    }",
            "startLine": 774,
            "visibility": "internal"
          },
          {
            "name": "_safeBatchTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeBatchTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeBatchTransfer(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _safeBatchTransfer(address(0), from, to, ids, amounts, data);\n    }",
            "startLine": 840,
            "visibility": "internal"
          },
          {
            "name": "_safeBatchTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_hasCode",
                "type": "internal"
              },
              {
                "target": "_checkOnERC1155BatchReceived",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeBatchTransfer(\n        address by,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(mload(ids), mload(amounts))) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let from_ := shl(96, from)\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, from_)\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, to_)\n            mstore(0x20, fromSlotSeed)\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            let by_ := shl(96, by)\n            if iszero(or(iszero(by_), eq(by_, from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {\n                    let amount := mload(add(amounts, i))\n                    // Subtract and store the updated balance of `from`.\n                    {\n                        mstore(0x20, fromSlotSeed)\n                        mstore(0x00, mload(add(ids, i)))\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\n                        let fromBalance := sload(fromBalanceSlot)\n                        if gt(amount, fromBalance) {\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\n                    }\n                    // Increase and store the updated balance of `to`.\n                    {\n                        mstore(0x20, toSlotSeed)\n                        let toBalanceSlot := keccak256(0x00, 0x40)\n                        let toBalanceBefore := sload(toBalanceSlot)\n                        let toBalanceAfter := add(toBalanceBefore, amount)\n                        if lt(toBalanceAfter, toBalanceBefore) {\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(toBalanceSlot, toBalanceAfter)\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, mload(ids)))\n                let o := add(m, 0x40)\n                pop(staticcall(gas(), 4, ids, n, o, n))\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, returndatasize()))\n                o := add(o, returndatasize())\n                n := add(0x20, shl(5, mload(amounts)))\n                pop(staticcall(gas(), 4, amounts, n, o, n))\n                n := sub(add(o, returndatasize()), m)\n                // Do the emit.\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), shr(96, from_), shr(96, to_))\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, ids, amounts, data);\n        }\n        if (_hasCode(to)) _checkOnERC1155BatchReceived(from, to, ids, amounts, data);\n    }",
            "startLine": 862,
            "visibility": "internal"
          },
          {
            "name": "_useBeforeTokenTransfer",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _useBeforeTokenTransfer() internal view virtual returns (bool) {\n        return false;\n    }",
            "startLine": 959,
            "visibility": "internal"
          },
          {
            "name": "_beforeTokenTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}",
            "startLine": 968,
            "visibility": "internal"
          },
          {
            "name": "_useAfterTokenTransfer",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _useAfterTokenTransfer() internal view virtual returns (bool) {\n        return false;\n    }",
            "startLine": 978,
            "visibility": "internal"
          },
          {
            "name": "_afterTokenTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}",
            "startLine": 987,
            "visibility": "internal"
          },
          {
            "name": "_afterTokenTransferCalldata",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _afterTokenTransferCalldata(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) private {\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, ids, amounts, data);\n        }\n    }",
            "startLine": 1001,
            "visibility": "private"
          },
          {
            "name": "_hasCode",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "a",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _hasCode(address a) private view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := extcodesize(a) // Can handle dirty upper bits.\n        }\n    }",
            "startLine": 1014,
            "visibility": "private"
          },
          {
            "name": "_checkOnERC1155Received",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _checkOnERC1155Received(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the calldata.\n            let m := mload(0x40)\n            // `onERC1155Received(address,address,uint256,uint256,bytes)`.\n            mstore(m, 0xf23a6e61)\n            mstore(add(m, 0x20), caller())\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            mstore(add(m, 0x60), id)\n            mstore(add(m, 0x80), amount)\n            mstore(add(m, 0xa0), 0xa0)\n            let n := mload(data)\n            mstore(add(m, 0xc0), n)\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xe0), n)) }\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, n), m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n            // Load the returndata and compare it with the function selector.\n            if iszero(eq(mload(m), shl(224, 0xf23a6e61))) {\n                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 1023,
            "visibility": "private"
          },
          {
            "name": "_checkOnERC1155BatchReceived",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _checkOnERC1155BatchReceived(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the calldata.\n            let m := mload(0x40)\n            // `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n            mstore(m, 0xbc197c81)\n            mstore(add(m, 0x20), caller())\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            // Copy the `ids`.\n            mstore(add(m, 0x60), 0xa0)\n            let n := add(0x20, shl(5, mload(ids)))\n            let o := add(m, 0xc0)\n            pop(staticcall(gas(), 4, ids, n, o, n))\n            // Copy the `amounts`.\n            let s := add(0xa0, returndatasize())\n            mstore(add(m, 0x80), s)\n            o := add(o, returndatasize())\n            n := add(0x20, shl(5, mload(amounts)))\n            pop(staticcall(gas(), 4, amounts, n, o, n))\n            // Copy the `data`.\n            mstore(add(m, 0xa0), add(s, returndatasize()))\n            o := add(o, returndatasize())\n            n := add(0x20, mload(data))\n            pop(staticcall(gas(), 4, data, n, o, n))\n            n := sub(add(o, returndatasize()), add(m, 0x1c))\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), n, m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n            // Load the returndata and compare it with the function selector.\n            if iszero(eq(mload(m), shl(224, 0xbc197c81))) {\n                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 1062,
            "visibility": "private"
          },
          {
            "name": "_single",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _single(uint256 x) private pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(0x40, add(result, 0x40))\n            mstore(result, 1)\n            mstore(add(result, 0x20), x)\n        }\n    }",
            "startLine": 1111,
            "visibility": "private"
          }
        ],
        "events": [
          {
            "name": "TransferSingle",
            "parameters": [
              {
                "name": "operator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "TransferBatch",
            "parameters": [
              {
                "name": "operator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "ids",
                "type": "uint256[]",
                "indexed": false
              },
              {
                "name": "amounts",
                "type": "uint256[]",
                "indexed": false
              }
            ]
          },
          {
            "name": "ApprovalForAll",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "operator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "isApproved",
                "type": "bool",
                "indexed": false
              }
            ]
          },
          {
            "name": "URI",
            "parameters": [
              {
                "name": "value",
                "type": "string",
                "indexed": false
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "ArrayLengthsMismatch",
            "parameters": []
          },
          {
            "name": "TransferToZeroAddress",
            "parameters": []
          },
          {
            "name": "AccountBalanceOverflow",
            "parameters": []
          },
          {
            "name": "InsufficientBalance",
            "parameters": []
          },
          {
            "name": "NotOwnerNorApproved",
            "parameters": []
          },
          {
            "name": "TransferToNonERC1155ReceiverImplementer",
            "parameters": []
          }
        ]
      },
      {
        "name": "ERC20",
        "kind": "abstract",
        "category": "token",
        "filePath": "solady/src/tokens/ERC20.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "name",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function name() public view virtual returns (string memory);",
            "startLine": 132,
            "signature": "name()",
            "selector": "0x3ec0f734",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "symbol",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function symbol() public view virtual returns (string memory);",
            "startLine": 135,
            "signature": "symbol()",
            "selector": "0x6a927499",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "decimals",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function decimals() public view virtual returns (uint8) {\n        return 18;\n    }",
            "startLine": 138,
            "signature": "decimals()",
            "selector": "0x76436c3d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "totalSupply",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function totalSupply() public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_TOTAL_SUPPLY_SLOT)\n        }\n    }",
            "startLine": 147,
            "signature": "totalSupply()",
            "selector": "0x6190166c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "balanceOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }",
            "startLine": 155,
            "signature": "balanceOf(address)",
            "selector": "0x7d2b9996",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "allowance",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_givePermit2InfiniteAllowance",
                "type": "internal"
              },
              {
                "target": "type",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        if (_givePermit2InfiniteAllowance()) {\n            if (spender == _PERMIT2) return type(uint256).max;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x34))\n        }\n    }",
            "startLine": 165,
            "signature": "allowance(address,address)",
            "selector": "0x596dd87d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_givePermit2InfiniteAllowance",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function approve(address spender, uint256 amount) public virtual returns (bool) {\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // If `spender == _PERMIT2 && amount != type(uint256).max`.\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\n        }\n        return true;\n    }",
            "startLine": 186,
            "signature": "approve(address,uint256)",
            "selector": "0x1d38323d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(msg.sender, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(msg.sender, to, amount);\n        return true;\n    }",
            "startLine": 217,
            "signature": "transfer(address,uint256)",
            "selector": "0x59d228e5",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "transferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_givePermit2InfiniteAllowance",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(from, to, amount);\n        // Code duplication is for zero-cost abstraction if possible.\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let from_ := shl(96, from)\n                if iszero(eq(caller(), _PERMIT2)) {\n                    // Compute the allowance slot and load its value.\n                    mstore(0x20, caller())\n                    mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\n                    let allowanceSlot := keccak256(0x0c, 0x34)\n                    let allowance_ := sload(allowanceSlot)\n                    // If the allowance is not the maximum uint256 value.\n                    if not(allowance_) {\n                        // Revert if the amount to be transferred exceeds the allowance.\n                        if gt(amount, allowance_) {\n                            mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        // Subtract and store the updated allowance.\n                        sstore(allowanceSlot, sub(allowance_, amount))\n                    }\n                }\n                // Compute the balance slot and load its value.\n                mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n                let fromBalanceSlot := keccak256(0x0c, 0x20)\n                let fromBalance := sload(fromBalanceSlot)\n                // Revert if insufficient balance.\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated balance.\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n                // Compute the balance slot of `to`.\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x20)\n                // Add and store the updated balance of `to`.\n                // Will not overflow because the sum of all user balances\n                // cannot exceed the maximum uint256 value.\n                sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n                // Emit the {Transfer} event.\n                mstore(0x20, amount)\n                log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let from_ := shl(96, from)\n                // Compute the allowance slot and load its value.\n                mstore(0x20, caller())\n                mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\n                let allowanceSlot := keccak256(0x0c, 0x34)\n                let allowance_ := sload(allowanceSlot)\n                // If the allowance is not the maximum uint256 value.\n                if not(allowance_) {\n                    // Revert if the amount to be transferred exceeds the allowance.\n                    if gt(amount, allowance_) {\n                        mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                        revert(0x1c, 0x04)\n                    }\n                    // Subtract and store the updated allowance.\n                    sstore(allowanceSlot, sub(allowance_, amount))\n                }\n                // Compute the balance slot and load its value.\n                mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n                let fromBalanceSlot := keccak256(0x0c, 0x20)\n                let fromBalance := sload(fromBalanceSlot)\n                // Revert if insufficient balance.\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated balance.\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n                // Compute the balance slot of `to`.\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x20)\n                // Add and store the updated balance of `to`.\n                // Will not overflow because the sum of all user balances\n                // cannot exceed the maximum uint256 value.\n                sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n                // Emit the {Transfer} event.\n                mstore(0x20, amount)\n                log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n            }\n        }\n        _afterTokenTransfer(from, to, amount);\n        return true;\n    }",
            "startLine": 257,
            "signature": "transferFrom(address,address,uint256)",
            "selector": "0x447f286d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "nonces",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function nonces(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the nonce slot and load its value.\n            mstore(0x0c, _NONCES_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }",
            "startLine": 375,
            "signature": "nonces(address)",
            "selector": "0x5eb764f9",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "permit",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "deadline",
                "type": "uint256"
              },
              {
                "name": "v",
                "type": "uint8"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_givePermit2InfiniteAllowance",
                "type": "internal"
              },
              {
                "target": "_constantNameHash",
                "type": "internal"
              },
              {
                "target": "name",
                "type": "internal"
              },
              {
                "target": "_versionHash",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // If `spender == _PERMIT2 && value != type(uint256).max`.\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(value)))) {\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        bytes32 versionHash = _versionHash();\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the block timestamp is greater than `deadline`.\n            if gt(timestamp(), deadline) {\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\n                revert(0x1c, 0x04)\n            }\n            let m := mload(0x40) // Grab the free memory pointer.\n            // Clean the upper 96 bits.\n            owner := shr(96, shl(96, owner))\n            spender := shr(96, shl(96, spender))\n            // Compute the nonce slot and load its value.\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\n            mstore(0x00, owner)\n            let nonceSlot := keccak256(0x0c, 0x20)\n            let nonceValue := sload(nonceSlot)\n            // Prepare the domain separator.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            mstore(0x2e, keccak256(m, 0xa0))\n            // Prepare the struct hash.\n            mstore(m, _PERMIT_TYPEHASH)\n            mstore(add(m, 0x20), owner)\n            mstore(add(m, 0x40), spender)\n            mstore(add(m, 0x60), value)\n            mstore(add(m, 0x80), nonceValue)\n            mstore(add(m, 0xa0), deadline)\n            mstore(0x4e, keccak256(m, 0xc0))\n            // Prepare the ecrecover calldata.\n            mstore(0x00, keccak256(0x2c, 0x42))\n            mstore(0x20, and(0xff, v))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            let t := staticcall(gas(), 1, 0x00, 0x80, 0x20, 0x20)\n            // If the ecrecover fails, the returndatasize will be 0x00,\n            // `owner` will be checked if it equals the hash at 0x00,\n            // which evaluates to false (i.e. 0), and we will revert.\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\n            // `owner` will be compared against the returned address at 0x20.\n            if iszero(eq(mload(returndatasize()), owner)) {\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\n                revert(0x1c, 0x04)\n            }\n            // Increment and store the updated nonce.\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\n            // Compute the allowance slot and store the value.\n            // The `owner` is already at slot 0x20.\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\n            sstore(keccak256(0x2c, 0x34), value)\n            // Emit the {Approval} event.\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }",
            "startLine": 389,
            "signature": "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)",
            "selector": "0x0bab04ae",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "DOMAIN_SEPARATOR",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_constantNameHash",
                "type": "internal"
              },
              {
                "target": "name",
                "type": "internal"
              },
              {
                "target": "_versionHash",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        bytes32 versionHash = _versionHash();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Grab the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            result := keccak256(m, 0xa0)\n        }\n    }",
            "startLine": 472,
            "signature": "DOMAIN_SEPARATOR()",
            "selector": "0x13388475",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_constantNameHash",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _constantNameHash() internal view virtual returns (bytes32 result) {}",
            "startLine": 355,
            "visibility": "internal"
          },
          {
            "name": "_versionHash",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _versionHash() internal view virtual returns (bytes32 result) {\n        result = _DEFAULT_VERSION_HASH;\n    }",
            "startLine": 358,
            "visibility": "internal"
          },
          {
            "name": "_incrementNonce",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _incrementNonce(address owner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _NONCES_SLOT_SEED)\n            mstore(0x00, owner)\n            let nonceSlot := keccak256(0x0c, 0x20)\n            sstore(nonceSlot, add(1, sload(nonceSlot)))\n        }\n    }",
            "startLine": 363,
            "visibility": "internal"
          },
          {
            "name": "_mint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _mint(address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\n            // Revert if the total supply overflows.\n            if lt(totalSupplyAfter, totalSupplyBefore) {\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(address(0), to, amount);\n    }",
            "startLine": 496,
            "visibility": "internal"
          },
          {
            "name": "_burn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _burn(address from, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, from)\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Subtract and store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\n            // Emit the {Transfer} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\n        }\n        _afterTokenTransfer(from, address(0), amount);\n    }",
            "startLine": 529,
            "visibility": "internal"
          },
          {
            "name": "_transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _transfer(address from, address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(from, to, amount);\n    }",
            "startLine": 559,
            "visibility": "internal"
          },
          {
            "name": "_spendAllowance",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_givePermit2InfiniteAllowance",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        if (_givePermit2InfiniteAllowance()) {\n            if (spender == _PERMIT2) return; // Do nothing, as allowance is infinite.\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and load its value.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowance_ := sload(allowanceSlot)\n            // If the allowance is not the maximum uint256 value.\n            if not(allowance_) {\n                // Revert if the amount to be transferred exceeds the allowance.\n                if gt(amount, allowance_) {\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated allowance.\n                sstore(allowanceSlot, sub(allowance_, amount))\n            }\n        }\n    }",
            "startLine": 594,
            "visibility": "internal"
          },
          {
            "name": "_approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_givePermit2InfiniteAllowance",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _approve(address owner, address spender, uint256 amount) internal virtual {\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // If `spender == _PERMIT2 && amount != type(uint256).max`.\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let owner_ := shl(96, owner)\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\n        }\n    }",
            "startLine": 622,
            "visibility": "internal"
          },
          {
            "name": "_beforeTokenTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}",
            "startLine": 652,
            "visibility": "internal"
          },
          {
            "name": "_afterTokenTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}",
            "startLine": 656,
            "visibility": "internal"
          },
          {
            "name": "_givePermit2InfiniteAllowance",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _givePermit2InfiniteAllowance() internal view virtual returns (bool) {\n        return true;\n    }",
            "startLine": 667,
            "visibility": "internal"
          }
        ],
        "events": [
          {
            "name": "Transfer",
            "parameters": [
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "Approval",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "spender",
                "type": "address",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "TotalSupplyOverflow",
            "parameters": []
          },
          {
            "name": "AllowanceOverflow",
            "parameters": []
          },
          {
            "name": "AllowanceUnderflow",
            "parameters": []
          },
          {
            "name": "InsufficientBalance",
            "parameters": []
          },
          {
            "name": "InsufficientAllowance",
            "parameters": []
          },
          {
            "name": "InvalidPermit",
            "parameters": []
          },
          {
            "name": "PermitExpired",
            "parameters": []
          },
          {
            "name": "Permit2AllowanceIsFixedAtInfinity",
            "parameters": []
          }
        ]
      },
      {
        "name": "ERC20Votes",
        "kind": "abstract",
        "category": "token",
        "filePath": "solady/src/tokens/ERC20Votes.sol",
        "inherits": [
          "ERC20"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "CLOCK_MODE",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function CLOCK_MODE() public view virtual returns (string memory) {\n        return \"mode=blocknumber&from=default\";\n    }",
            "startLine": 95,
            "signature": "CLOCK_MODE()",
            "selector": "0x003ccb55",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "clock",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "uint48"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function clock() public view virtual returns (uint48 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := number()\n            // Branch-less out-of-gas revert if `block.number >= 2 ** 48`.\n            returndatacopy(returndatasize(), returndatasize(), sub(0, shr(48, number())))\n        }\n    }",
            "startLine": 100,
            "signature": "clock()",
            "selector": "0x339f158f",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getVotes",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_checkpointLatest",
                "type": "internal"
              },
              {
                "target": "_delegateCheckpointsSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function getVotes(address account) public view virtual returns (uint256) {\n        return _checkpointLatest(_delegateCheckpointsSlot(account));\n    }",
            "startLine": 114,
            "signature": "getVotes(address)",
            "selector": "0x4f670f2a",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getPastVotes",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "timepoint",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "clock",
                "type": "internal"
              },
              {
                "target": "_revertERC5805FutureLookup",
                "type": "internal"
              },
              {
                "target": "_checkpointUpperLookupRecent",
                "type": "internal"
              },
              {
                "target": "_delegateCheckpointsSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function getPastVotes(address account, uint256 timepoint)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        if (timepoint >= clock()) _revertERC5805FutureLookup();\n        return _checkpointUpperLookupRecent(_delegateCheckpointsSlot(account), timepoint);\n    }",
            "startLine": 119,
            "signature": "getPastVotes(address,uint256)",
            "selector": "0x2952ef91",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "delegates",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "delegator",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function delegates(address delegator) public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ERC20_VOTES_MASTER_SLOT_SEED)\n            mstore(0x00, delegator)\n            result := sload(keccak256(0x0c, 0x18))\n        }\n    }",
            "startLine": 130,
            "signature": "delegates(address)",
            "selector": "0x52c1870f",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "delegate",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegatee",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_delegate",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function delegate(address delegatee) public virtual {\n        _delegate(msg.sender, delegatee);\n    }",
            "startLine": 140,
            "signature": "delegate(address)",
            "selector": "0x21a7c2f8",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "delegateBySig",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegatee",
                "type": "address"
              },
              {
                "name": "nonce",
                "type": "uint256"
              },
              {
                "name": "expiry",
                "type": "uint256"
              },
              {
                "name": "v",
                "type": "uint8"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_constantNameHash",
                "type": "internal"
              },
              {
                "target": "name",
                "type": "internal"
              },
              {
                "target": "_versionHash",
                "type": "internal"
              },
              {
                "target": "nonces",
                "type": "internal"
              },
              {
                "target": "_incrementNonce",
                "type": "internal"
              },
              {
                "target": "_delegate",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        address signer;\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        bytes32 versionHash = _versionHash();\n        /// @solidity memory-safe-assembly\n        assembly {\n            if gt(timestamp(), expiry) {\n                mstore(0x00, 0x3480e9e1) // `ERC5805DelegateSignatureExpired()`.\n                revert(0x1c, 0x04)\n            }\n            let m := mload(0x40)\n            // Prepare the struct hash.\n            mstore(0x00, _ERC5805_DELEGATION_TYPEHASH)\n            mstore(0x20, shr(96, shl(96, delegatee)))\n            mstore(0x40, nonce)\n            mstore(0x60, expiry)\n            mstore(0x40, keccak256(0x00, 0x80))\n            mstore(0x00, 0x1901) // Store \"\\x19\\x01\".\n            // Prepare the domain separator.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            mstore(0x20, keccak256(m, 0xa0))\n            // Prepare the ecrecover calldata.\n            mstore(0x00, keccak256(0x1e, 0x42))\n            mstore(0x20, and(0xff, v))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            signer := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            expiry := iszero(returndatasize()) // Reuse `expiry` to denote `ecrecover` failure.\n        }\n        if ((nonces(signer) ^ nonce) | expiry != 0) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(0x00, 0x1838d95c) // `ERC5805DelegateInvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _incrementNonce(signer);\n        _delegate(signer, delegatee);\n    }",
            "startLine": 145,
            "signature": "delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)",
            "selector": "0x3cffa200",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "checkpointCount",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_delegateCheckpointsSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function checkpointCount(address account) public view virtual returns (uint256 result) {\n        result = _delegateCheckpointsSlot(account);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(208, shl(160, sload(result)))\n        }\n    }",
            "startLine": 206,
            "signature": "checkpointCount(address)",
            "selector": "0x1b7a81aa",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "checkpointAt",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "checkpointClock",
                "type": "uint48"
              },
              {
                "name": "checkpointValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_delegateCheckpointsSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function checkpointAt(address account, uint256 i)\n        public\n        view\n        virtual\n        returns (uint48 checkpointClock, uint256 checkpointValue)\n    {\n        uint256 lengthSlot = _delegateCheckpointsSlot(account);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(i, shr(208, shl(160, sload(lengthSlot))))) {\n                mstore(0x00, 0x86df9d10) // `ERC5805CheckpointIndexOutOfBounds()`.\n                revert(0x1c, 0x04)\n            }\n            let checkpointPacked := sload(add(i, lengthSlot))\n            checkpointClock := and(0xffffffffffff, checkpointPacked)\n            checkpointValue := shr(96, checkpointPacked)\n            if eq(checkpointValue, address()) { checkpointValue := sload(not(add(i, lengthSlot))) }\n        }\n    }",
            "startLine": 215,
            "signature": "checkpointAt(address,uint256)",
            "selector": "0x561822f5",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getVotesTotalSupply",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_checkpointLatest",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function getVotesTotalSupply() public view virtual returns (uint256) {\n        return _checkpointLatest(_ERC20_VOTES_MASTER_SLOT_SEED << 96);\n    }",
            "startLine": 236,
            "signature": "getVotesTotalSupply()",
            "selector": "0x696400bf",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getPastVotesTotalSupply",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "timepoint",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "clock",
                "type": "internal"
              },
              {
                "target": "_revertERC5805FutureLookup",
                "type": "internal"
              },
              {
                "target": "_checkpointUpperLookupRecent",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function getPastVotesTotalSupply(uint256 timepoint) public view virtual returns (uint256) {\n        if (timepoint >= clock()) _revertERC5805FutureLookup();\n        return _checkpointUpperLookupRecent(_ERC20_VOTES_MASTER_SLOT_SEED << 96, timepoint);\n    }",
            "startLine": 241,
            "signature": "getPastVotesTotalSupply(uint256)",
            "selector": "0x73a6f87a",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_getVotingUnits",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "delegator",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "balanceOf",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _getVotingUnits(address delegator) internal view virtual returns (uint256) {\n        return balanceOf(delegator);\n    }",
            "startLine": 252,
            "visibility": "internal"
          },
          {
            "name": "_afterTokenTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferVotingUnits",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _afterTokenTransfer(address from, address to, uint256 amount)\n        internal\n        virtual\n        override\n    {\n        _transferVotingUnits(from, to, amount);\n    }",
            "startLine": 257,
            "visibility": "internal"
          },
          {
            "name": "_transferVotingUnits",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_checkpointPushDiff",
                "type": "internal"
              },
              {
                "target": "clock",
                "type": "internal"
              },
              {
                "target": "_moveDelegateVotes",
                "type": "internal"
              },
              {
                "target": "delegates",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _transferVotingUnits(address from, address to, uint256 amount) internal virtual {\n        if (from == address(0)) {\n            _checkpointPushDiff(_ERC20_VOTES_MASTER_SLOT_SEED << 96, clock(), amount, true);\n        }\n        if (to == address(0)) {\n            _checkpointPushDiff(_ERC20_VOTES_MASTER_SLOT_SEED << 96, clock(), amount, false);\n        }\n        _moveDelegateVotes(delegates(from), delegates(to), amount);\n    }",
            "startLine": 266,
            "visibility": "internal"
          },
          {
            "name": "_moveDelegateVotes",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_checkpointPushDiff",
                "type": "internal"
              },
              {
                "target": "_delegateCheckpointsSlot",
                "type": "internal"
              },
              {
                "target": "clock",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _moveDelegateVotes(address from, address to, uint256 amount) internal virtual {\n        if (amount == uint256(0)) return;\n        (uint256 fromCleaned, uint256 toCleaned) = (uint256(uint160(from)), uint256(uint160(to)));\n        if (fromCleaned == toCleaned) return;\n        if (fromCleaned != 0) {\n            (uint256 oldValue, uint256 newValue) =\n                _checkpointPushDiff(_delegateCheckpointsSlot(from), clock(), amount, false);\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Emit the {DelegateVotesChanged} event.\n                mstore(0x00, oldValue)\n                mstore(0x20, newValue)\n                log2(0x00, 0x40, _DELEGATE_VOTES_CHANGED_EVENT_SIGNATURE, fromCleaned)\n            }\n        }\n        if (toCleaned != 0) {\n            (uint256 oldValue, uint256 newValue) =\n                _checkpointPushDiff(_delegateCheckpointsSlot(to), clock(), amount, true);\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Emit the {DelegateVotesChanged} event.\n                mstore(0x00, oldValue)\n                mstore(0x20, newValue)\n                log2(0x00, 0x40, _DELEGATE_VOTES_CHANGED_EVENT_SIGNATURE, toCleaned)\n            }\n        }\n    }",
            "startLine": 278,
            "visibility": "internal"
          },
          {
            "name": "_delegate",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "delegatee",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_moveDelegateVotes",
                "type": "internal"
              },
              {
                "target": "_getVotingUnits",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _delegate(address account, address delegatee) internal virtual {\n        address from;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let to := shr(96, shl(96, delegatee))\n            mstore(0x04, _ERC20_VOTES_MASTER_SLOT_SEED)\n            mstore(0x00, account)\n            let delegateSlot := keccak256(0x0c, 0x18)\n            from := sload(delegateSlot)\n            sstore(delegateSlot, to)\n            // Emit the {DelegateChanged} event.\n            log4(0x00, 0x00, _DELEGATE_CHANGED_EVENT_SIGNATURE, shr(96, mload(0x0c)), from, to)\n        }\n        _moveDelegateVotes(from, delegatee, _getVotingUnits(account));\n    }",
            "startLine": 308,
            "visibility": "internal"
          },
          {
            "name": "_delegateCheckpointsSlot",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _delegateCheckpointsSlot(address account) private pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ERC20_VOTES_MASTER_SLOT_SEED)\n            mstore(0x00, account)\n            result := keccak256(0x0c, 0x17)\n        }\n    }",
            "startLine": 329,
            "visibility": "private"
          },
          {
            "name": "_checkpointPushDiff",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "lengthSlot",
                "type": "uint256"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "isAdd",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "oldValue",
                "type": "uint256"
              },
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _checkpointPushDiff(uint256 lengthSlot, uint256 key, uint256 amount, bool isAdd)\n        private\n        returns (uint256 oldValue, uint256 newValue)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let lengthSlotPacked := sload(lengthSlot)\n            for { let n := shr(208, shl(160, lengthSlotPacked)) } 1 {} {\n                if iszero(n) {\n                    if iszero(or(isAdd, iszero(amount))) {\n                        mstore(0x00, 0x5915f686) // `ERC5805CheckpointValueUnderflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    newValue := amount\n                    if iszero(or(eq(newValue, address()), shr(160, newValue))) {\n                        sstore(lengthSlot, or(or(key, shl(48, 1)), shl(96, newValue)))\n                        break\n                    }\n                    sstore(lengthSlot, or(or(key, shl(48, 1)), shl(96, address())))\n                    sstore(not(lengthSlot), newValue)\n                    break\n                }\n                let checkpointSlot := add(sub(n, 1), lengthSlot)\n                let lastPacked := sload(checkpointSlot)\n                oldValue := shr(96, lastPacked)\n                if eq(oldValue, address()) { oldValue := sload(not(checkpointSlot)) }\n                for {} 1 {} {\n                    if iszero(isAdd) {\n                        newValue := sub(oldValue, amount)\n                        if iszero(gt(newValue, oldValue)) { break }\n                        mstore(0x00, 0x5915f686) // `ERC5805CheckpointValueUnderflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    newValue := add(oldValue, amount)\n                    if iszero(lt(newValue, oldValue)) { break }\n                    mstore(0x00, 0x9dbbeb75) // `ERC5805CheckpointValueOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                let lastKey := and(0xffffffffffff, lastPacked)\n                if iszero(eq(lastKey, key)) {\n                    n := add(1, n)\n                    checkpointSlot := add(1, checkpointSlot)\n                    sstore(lengthSlot, add(shl(48, 1), lengthSlotPacked))\n                }\n                if or(gt(lastKey, key), shr(48, n)) { invalid() }\n                if iszero(or(eq(newValue, address()), shr(160, newValue))) {\n                    sstore(checkpointSlot, or(or(key, shl(48, n)), shl(96, newValue)))\n                    break\n                }\n                sstore(checkpointSlot, or(or(key, shl(48, n)), shl(96, address())))\n                sstore(not(checkpointSlot), newValue)\n                break\n            }\n        }\n    }",
            "startLine": 339,
            "visibility": "private"
          },
          {
            "name": "_checkpointLatest",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "lengthSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _checkpointLatest(uint256 lengthSlot) private view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(208, shl(160, sload(lengthSlot)))\n            if result {\n                lengthSlot := add(sub(result, 1), lengthSlot) // Reuse for `checkpointSlot`.\n                result := shr(96, sload(lengthSlot))\n                if eq(result, address()) { result := sload(not(lengthSlot)) }\n            }\n        }\n    }",
            "startLine": 396,
            "visibility": "private"
          },
          {
            "name": "_checkpointUpperLookupRecent",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "lengthSlot",
                "type": "uint256"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _checkpointUpperLookupRecent(uint256 lengthSlot, uint256 key)\n        private\n        view\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := 0 // Low.\n            let h := shr(208, shl(160, sload(lengthSlot))) // High.\n            // Start the binary search nearer to the right to optimize for recent checkpoints.\n            for {} iszero(lt(h, 6)) {} {\n                let m := shl(4, lt(0xffff, h))\n                m := shl(shr(1, or(m, shl(3, lt(0xff, shr(m, h))))), 16)\n                m := shr(1, add(m, div(h, m)))\n                m := shr(1, add(m, div(h, m)))\n                m := shr(1, add(m, div(h, m)))\n                m := shr(1, add(m, div(h, m)))\n                m := shr(1, add(m, div(h, m)))\n                m := sub(h, shr(1, add(m, div(h, m)))) // Approx `h - sqrt(h)`.\n                if iszero(lt(key, and(sload(add(m, lengthSlot)), 0xffffffffffff))) {\n                    l := add(1, m)\n                    break\n                }\n                h := m\n                break\n            }\n            // Binary search.\n            for {} lt(l, h) {} {\n                let m := shr(1, add(l, h)) // Won't overflow in practice.\n                if iszero(lt(key, and(sload(add(m, lengthSlot)), 0xffffffffffff))) {\n                    l := add(1, m)\n                    continue\n                }\n                h := m\n            }\n            let checkpointSlot := add(sub(h, 1), lengthSlot)\n            result := mul(iszero(iszero(h)), shr(96, sload(checkpointSlot)))\n            if eq(result, address()) { result := sload(not(checkpointSlot)) }\n        }\n    }",
            "startLine": 409,
            "visibility": "private"
          },
          {
            "name": "_revertERC5805FutureLookup",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _revertERC5805FutureLookup() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0xf9874464) // `ERC5805FutureLookup()`.\n            revert(0x1c, 0x04)\n        }\n    }",
            "startLine": 451,
            "visibility": "private"
          }
        ],
        "events": [
          {
            "name": "DelegateChanged",
            "parameters": [
              {
                "name": "delegator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              }
            ]
          },
          {
            "name": "DelegateVotesChanged",
            "parameters": [
              {
                "name": "delegate",
                "type": "address",
                "indexed": true
              },
              {
                "name": "oldValue",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "newValue",
                "type": "uint256",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "ERC5805FutureLookup",
            "parameters": []
          },
          {
            "name": "ERC5805DelegateSignatureExpired",
            "parameters": []
          },
          {
            "name": "ERC5805DelegateInvalidSignature",
            "parameters": []
          },
          {
            "name": "ERC5805CheckpointIndexOutOfBounds",
            "parameters": []
          },
          {
            "name": "ERC5805CheckpointValueOverflow",
            "parameters": []
          },
          {
            "name": "ERC5805CheckpointValueUnderflow",
            "parameters": []
          }
        ]
      },
      {
        "name": "ERC2981",
        "kind": "abstract",
        "category": "core",
        "filePath": "solady/src/tokens/ERC2981.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "supportsInterface",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC2981: 0x2a55205a.\n            result := or(eq(s, 0x01ffc9a7), eq(s, 0x2a55205a))\n        }\n    }",
            "startLine": 58,
            "signature": "supportsInterface(bytes4)",
            "selector": "0x4ba9e2f3",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "royaltyInfo",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "salePrice",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "royaltyAmount",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_feeDenominator",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        public\n        view\n        virtual\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        uint256 feeDenominator = _feeDenominator();\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, tokenId)\n            mstore(0x20, _ERC2981_MASTER_SLOT_SEED)\n            let packed := sload(keccak256(0x00, 0x40))\n            receiver := shr(96, packed)\n            if iszero(receiver) {\n                packed := sload(mload(0x20))\n                receiver := shr(96, packed)\n            }\n            let x := salePrice\n            let y := xor(packed, shl(96, receiver)) // `feeNumerator`.\n            // Overflow check, equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            // Out-of-gas revert. Should not be triggered in practice, but included for safety.\n            returndatacopy(returndatasize(), returndatasize(), mul(y, gt(x, div(not(0), y))))\n            royaltyAmount := div(mul(x, y), feeDenominator)\n        }\n    }",
            "startLine": 68,
            "signature": "royaltyInfo(uint256,uint256)",
            "selector": "0x2e69610f",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_feeDenominator",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint96"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }",
            "startLine": 51,
            "visibility": "internal"
          },
          {
            "name": "_setDefaultRoyalty",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "feeNumerator",
                "type": "uint96"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_feeDenominator",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        uint256 feeDenominator = _feeDenominator();\n        /// @solidity memory-safe-assembly\n        assembly {\n            feeNumerator := shr(160, shl(160, feeNumerator))\n            if gt(feeNumerator, feeDenominator) {\n                mstore(0x00, 0x350a88b3) // `RoyaltyOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            let packed := shl(96, receiver)\n            if iszero(packed) {\n                mstore(0x00, 0xb4457eaa) // `RoyaltyReceiverIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(_ERC2981_MASTER_SLOT_SEED, or(packed, feeNumerator))\n        }\n    }",
            "startLine": 99,
            "visibility": "internal"
          },
          {
            "name": "_deleteDefaultRoyalty",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _deleteDefaultRoyalty() internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(_ERC2981_MASTER_SLOT_SEED, 0)\n        }\n    }",
            "startLine": 118,
            "visibility": "internal"
          },
          {
            "name": "_setTokenRoyalty",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "feeNumerator",
                "type": "uint96"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_feeDenominator",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator)\n        internal\n        virtual\n    {\n        uint256 feeDenominator = _feeDenominator();\n        /// @solidity memory-safe-assembly\n        assembly {\n            feeNumerator := shr(160, shl(160, feeNumerator))\n            if gt(feeNumerator, feeDenominator) {\n                mstore(0x00, 0x350a88b3) // `RoyaltyOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            let packed := shl(96, receiver)\n            if iszero(packed) {\n                mstore(0x00, 0xb4457eaa) // `RoyaltyReceiverIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, tokenId)\n            mstore(0x20, _ERC2981_MASTER_SLOT_SEED)\n            sstore(keccak256(0x00, 0x40), or(packed, feeNumerator))\n        }\n    }",
            "startLine": 130,
            "visibility": "internal"
          },
          {
            "name": "_resetTokenRoyalty",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, tokenId)\n            mstore(0x20, _ERC2981_MASTER_SLOT_SEED)\n            sstore(keccak256(0x00, 0x40), 0)\n        }\n    }",
            "startLine": 154,
            "visibility": "internal"
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "RoyaltyOverflow",
            "parameters": []
          },
          {
            "name": "RoyaltyReceiverIsZeroAddress",
            "parameters": []
          }
        ]
      },
      {
        "name": "ERC4626",
        "kind": "abstract",
        "category": "core",
        "filePath": "solady/src/tokens/ERC4626.sol",
        "inherits": [
          "ERC20"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "asset",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function asset() public view virtual returns (address);",
            "startLine": 71,
            "signature": "asset()",
            "selector": "0x2a020c0f",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "decimals",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [
              {
                "target": "_useVirtualShares",
                "type": "internal"
              },
              {
                "target": "_underlyingDecimals",
                "type": "internal"
              },
              {
                "target": "_decimalsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function decimals() public view virtual override(ERC20) returns (uint8) {\n        if (!_useVirtualShares()) return _underlyingDecimals();\n        return _underlyingDecimals() + _decimalsOffset();\n    }",
            "startLine": 103,
            "signature": "decimals()",
            "selector": "0x76436c3d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "totalAssets",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "SafeTransferLib.balanceOf",
                "type": "library"
              },
              {
                "target": "asset",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function totalAssets() public view virtual returns (uint256 assets) {\n        assets = SafeTransferLib.balanceOf(asset(), address(this));\n    }",
            "startLine": 152,
            "signature": "totalAssets()",
            "selector": "0x14aaa0d8",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "convertToShares",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_useVirtualShares",
                "type": "internal"
              },
              {
                "target": "totalSupply",
                "type": "internal"
              },
              {
                "target": "_eitherIsZero",
                "type": "internal"
              },
              {
                "target": "_initialConvertToShares",
                "type": "internal"
              },
              {
                "target": "FixedPointMathLib.fullMulDiv",
                "type": "library"
              },
              {
                "target": "totalAssets",
                "type": "internal"
              },
              {
                "target": "_decimalsOffset",
                "type": "internal"
              },
              {
                "target": "_inc",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function convertToShares(uint256 assets) public view virtual returns (uint256 shares) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return _eitherIsZero(assets, supply)\n                ? _initialConvertToShares(assets)\n                : FixedPointMathLib.fullMulDiv(assets, supply, totalAssets());\n        }\n        uint256 o = _decimalsOffset();\n        if (o == uint256(0)) {\n            return FixedPointMathLib.fullMulDiv(assets, totalSupply() + 1, _inc(totalAssets()));\n        }\n        return FixedPointMathLib.fullMulDiv(assets, totalSupply() + 10 ** o, _inc(totalAssets()));\n    }",
            "startLine": 167,
            "signature": "convertToShares(uint256)",
            "selector": "0x2dae1caa",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "convertToAssets",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_useVirtualShares",
                "type": "internal"
              },
              {
                "target": "totalSupply",
                "type": "internal"
              },
              {
                "target": "_initialConvertToAssets",
                "type": "internal"
              },
              {
                "target": "FixedPointMathLib.fullMulDiv",
                "type": "library"
              },
              {
                "target": "totalAssets",
                "type": "internal"
              },
              {
                "target": "_decimalsOffset",
                "type": "internal"
              },
              {
                "target": "_inc",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function convertToAssets(uint256 shares) public view virtual returns (uint256 assets) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return supply == uint256(0)\n                ? _initialConvertToAssets(shares)\n                : FixedPointMathLib.fullMulDiv(shares, totalAssets(), supply);\n        }\n        uint256 o = _decimalsOffset();\n        if (o == uint256(0)) {\n            return FixedPointMathLib.fullMulDiv(shares, totalAssets() + 1, _inc(totalSupply()));\n        }\n        return FixedPointMathLib.fullMulDiv(shares, totalAssets() + 1, totalSupply() + 10 ** o);\n    }",
            "startLine": 192,
            "signature": "convertToAssets(uint256)",
            "selector": "0x50039d27",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "previewDeposit",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "convertToShares",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function previewDeposit(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = convertToShares(assets);\n    }",
            "startLine": 220,
            "signature": "previewDeposit(uint256)",
            "selector": "0x6cda7dc2",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "previewMint",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_useVirtualShares",
                "type": "internal"
              },
              {
                "target": "totalSupply",
                "type": "internal"
              },
              {
                "target": "_initialConvertToAssets",
                "type": "internal"
              },
              {
                "target": "FixedPointMathLib.fullMulDivUp",
                "type": "library"
              },
              {
                "target": "totalAssets",
                "type": "internal"
              },
              {
                "target": "_decimalsOffset",
                "type": "internal"
              },
              {
                "target": "_inc",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function previewMint(uint256 shares) public view virtual returns (uint256 assets) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return supply == uint256(0)\n                ? _initialConvertToAssets(shares)\n                : FixedPointMathLib.fullMulDivUp(shares, totalAssets(), supply);\n        }\n        uint256 o = _decimalsOffset();\n        if (o == uint256(0)) {\n            return FixedPointMathLib.fullMulDivUp(shares, totalAssets() + 1, _inc(totalSupply()));\n        }\n        return FixedPointMathLib.fullMulDivUp(shares, totalAssets() + 1, totalSupply() + 10 ** o);\n    }",
            "startLine": 238,
            "signature": "previewMint(uint256)",
            "selector": "0x490fc5ae",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "previewWithdraw",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_useVirtualShares",
                "type": "internal"
              },
              {
                "target": "totalSupply",
                "type": "internal"
              },
              {
                "target": "_eitherIsZero",
                "type": "internal"
              },
              {
                "target": "_initialConvertToShares",
                "type": "internal"
              },
              {
                "target": "FixedPointMathLib.fullMulDivUp",
                "type": "library"
              },
              {
                "target": "totalAssets",
                "type": "internal"
              },
              {
                "target": "_decimalsOffset",
                "type": "internal"
              },
              {
                "target": "_inc",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function previewWithdraw(uint256 assets) public view virtual returns (uint256 shares) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return _eitherIsZero(assets, supply)\n                ? _initialConvertToShares(assets)\n                : FixedPointMathLib.fullMulDivUp(assets, supply, totalAssets());\n        }\n        uint256 o = _decimalsOffset();\n        if (o == uint256(0)) {\n            return FixedPointMathLib.fullMulDivUp(assets, totalSupply() + 1, _inc(totalAssets()));\n        }\n        return FixedPointMathLib.fullMulDivUp(assets, totalSupply() + 10 ** o, _inc(totalAssets()));\n    }",
            "startLine": 266,
            "signature": "previewWithdraw(uint256)",
            "selector": "0x3c2b6ffa",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "previewRedeem",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "convertToAssets",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function previewRedeem(uint256 shares) public view virtual returns (uint256 assets) {\n        assets = convertToAssets(shares);\n    }",
            "startLine": 294,
            "signature": "previewRedeem(uint256)",
            "selector": "0x1890744c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "maxDeposit",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "maxAssets",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "type",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function maxDeposit(address to) public view virtual returns (uint256 maxAssets) {\n        to = to; // Silence unused variable warning.\n        maxAssets = type(uint256).max;\n    }",
            "startLine": 326,
            "signature": "maxDeposit(address)",
            "selector": "0x6f76a87d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "maxMint",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "maxShares",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "type",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function maxMint(address to) public view virtual returns (uint256 maxShares) {\n        to = to; // Silence unused variable warning.\n        maxShares = type(uint256).max;\n    }",
            "startLine": 337,
            "signature": "maxMint(address)",
            "selector": "0x6a1451b7",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "maxWithdraw",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "maxAssets",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "convertToAssets",
                "type": "internal"
              },
              {
                "target": "balanceOf",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function maxWithdraw(address owner) public view virtual returns (uint256 maxAssets) {\n        maxAssets = convertToAssets(balanceOf(owner));\n    }",
            "startLine": 347,
            "signature": "maxWithdraw(address)",
            "selector": "0x72ef75f1",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "maxRedeem",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "maxShares",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "balanceOf",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function maxRedeem(address owner) public view virtual returns (uint256 maxShares) {\n        maxShares = balanceOf(owner);\n    }",
            "startLine": 357,
            "signature": "maxRedeem(address)",
            "selector": "0x448b5143",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "deposit",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "to",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "maxDeposit",
                "type": "internal"
              },
              {
                "target": "_revert",
                "type": "internal"
              },
              {
                "target": "previewDeposit",
                "type": "internal"
              },
              {
                "target": "_deposit",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function deposit(uint256 assets, address to) public virtual returns (uint256 shares) {\n        if (assets > maxDeposit(to)) _revert(0xb3c61a83); // `DepositMoreThanMax()`.\n        shares = previewDeposit(assets);\n        _deposit(msg.sender, to, assets, shares);\n    }",
            "startLine": 376,
            "signature": "deposit(uint256,address)",
            "selector": "0x3e389b92",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "mint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "shares",
                "type": "uint256"
              },
              {
                "name": "to",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "maxMint",
                "type": "internal"
              },
              {
                "target": "_revert",
                "type": "internal"
              },
              {
                "target": "previewMint",
                "type": "internal"
              },
              {
                "target": "_deposit",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function mint(uint256 shares, address to) public virtual returns (uint256 assets) {\n        if (shares > maxMint(to)) _revert(0x6a695959); // `MintMoreThanMax()`.\n        assets = previewMint(shares);\n        _deposit(msg.sender, to, assets, shares);\n    }",
            "startLine": 393,
            "signature": "mint(uint256,address)",
            "selector": "0x73a6b1b2",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "withdraw",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "maxWithdraw",
                "type": "internal"
              },
              {
                "target": "_revert",
                "type": "internal"
              },
              {
                "target": "previewWithdraw",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function withdraw(uint256 assets, address to, address owner)\n        public\n        virtual\n        returns (uint256 shares)\n    {\n        if (assets > maxWithdraw(owner)) _revert(0x936941fc); // `WithdrawMoreThanMax()`.\n        shares = previewWithdraw(assets);\n        _withdraw(msg.sender, to, owner, assets, shares);\n    }",
            "startLine": 409,
            "signature": "withdraw(uint256,address,address)",
            "selector": "0x272649a2",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "redeem",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "shares",
                "type": "uint256"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "maxRedeem",
                "type": "internal"
              },
              {
                "target": "_revert",
                "type": "internal"
              },
              {
                "target": "previewRedeem",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function redeem(uint256 shares, address to, address owner)\n        public\n        virtual\n        returns (uint256 assets)\n    {\n        if (shares > maxRedeem(owner)) _revert(0x4656425a); // `RedeemMoreThanMax()`.\n        assets = previewRedeem(shares);\n        _withdraw(msg.sender, to, owner, assets, shares);\n    }",
            "startLine": 429,
            "signature": "redeem(uint256,address,address)",
            "selector": "0x15e6cff4",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_underlyingDecimals",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _underlyingDecimals() internal view virtual returns (uint8) {\n        return _DEFAULT_UNDERLYING_DECIMALS;\n    }",
            "startLine": 77,
            "visibility": "internal"
          },
          {
            "name": "_decimalsOffset",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _decimalsOffset() internal view virtual returns (uint8) {\n        return _DEFAULT_DECIMALS_OFFSET;\n    }",
            "startLine": 86,
            "visibility": "internal"
          },
          {
            "name": "_useVirtualShares",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _useVirtualShares() internal view virtual returns (bool) {\n        return true;\n    }",
            "startLine": 96,
            "visibility": "internal"
          },
          {
            "name": "_tryGetAssetDecimals",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "underlying",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "success",
                "type": "bool"
              },
              {
                "name": "result",
                "type": "uint8"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _tryGetAssetDecimals(address underlying)\n        internal\n        view\n        returns (bool success, uint8 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the function selector of `decimals()`.\n            mstore(0x00, 0x313ce567)\n            // Arguments are evaluated last to first.\n            success :=\n                and(\n                    // Returned value is less than 256, at left-padded to 32 bytes.\n                    and(lt(mload(0x00), 0x100), gt(returndatasize(), 0x1f)),\n                    // The staticcall succeeds.\n                    staticcall(gas(), underlying, 0x1c, 0x04, 0x00, 0x20)\n                )\n            result := mul(mload(0x00), success)\n        }\n    }",
            "startLine": 122,
            "visibility": "internal"
          },
          {
            "name": "_eitherIsZero",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256"
              },
              {
                "name": "b",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _eitherIsZero(uint256 a, uint256 b) private pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := or(iszero(a), iszero(b))\n        }\n    }",
            "startLine": 299,
            "visibility": "private"
          },
          {
            "name": "_inc",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _inc(uint256 x) private pure returns (uint256) {\n        unchecked {\n            return x + 1;\n        }\n    }",
            "startLine": 310,
            "visibility": "private"
          },
          {
            "name": "_revert",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _revert(uint256 s) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, s)\n            revert(0x1c, 0x04)\n        }\n    }",
            "startLine": 440,
            "visibility": "private"
          },
          {
            "name": "_deposit",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "SafeTransferLib.safeTransferFrom",
                "type": "library"
              },
              {
                "target": "asset",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_mint",
                "type": "internal"
              },
              {
                "target": "_afterDeposit",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _deposit(address by, address to, uint256 assets, uint256 shares) internal virtual {\n        SafeTransferLib.safeTransferFrom(asset(), by, address(this), assets);\n        _mint(to, shares);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Emit the {Deposit} event.\n            mstore(0x00, assets)\n            mstore(0x20, shares)\n            let m := shr(96, not(0))\n            log3(0x00, 0x40, _DEPOSIT_EVENT_SIGNATURE, and(m, by), and(m, to))\n        }\n        _afterDeposit(assets, shares);\n    }",
            "startLine": 455,
            "visibility": "internal"
          },
          {
            "name": "_withdraw",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_spendAllowance",
                "type": "internal"
              },
              {
                "target": "_beforeWithdraw",
                "type": "internal"
              },
              {
                "target": "_burn",
                "type": "internal"
              },
              {
                "target": "SafeTransferLib.safeTransfer",
                "type": "library"
              },
              {
                "target": "asset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _withdraw(address by, address to, address owner, uint256 assets, uint256 shares)\n        internal\n        virtual\n    {\n        if (by != owner) _spendAllowance(owner, by, shares);\n        _beforeWithdraw(assets, shares);\n        _burn(owner, shares);\n        SafeTransferLib.safeTransfer(asset(), to, assets);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Emit the {Withdraw} event.\n            mstore(0x00, assets)\n            mstore(0x20, shares)\n            let m := shr(96, not(0))\n            log4(0x00, 0x40, _WITHDRAW_EVENT_SIGNATURE, and(m, by), and(m, to), and(m, owner))\n        }\n    }",
            "startLine": 472,
            "visibility": "internal"
          },
          {
            "name": "_initialConvertToShares",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initialConvertToShares(uint256 assets)\n        internal\n        view\n        virtual\n        returns (uint256 shares)\n    {\n        shares = assets;\n    }",
            "startLine": 495,
            "visibility": "internal"
          },
          {
            "name": "_initialConvertToAssets",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initialConvertToAssets(uint256 shares)\n        internal\n        view\n        virtual\n        returns (uint256 assets)\n    {\n        assets = shares;\n    }",
            "startLine": 509,
            "visibility": "internal"
          },
          {
            "name": "_beforeWithdraw",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}",
            "startLine": 523,
            "visibility": "internal"
          },
          {
            "name": "_afterDeposit",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _afterDeposit(uint256 assets, uint256 shares) internal virtual {}",
            "startLine": 526,
            "visibility": "internal"
          }
        ],
        "events": [
          {
            "name": "Deposit",
            "parameters": [
              {
                "name": "by",
                "type": "address",
                "indexed": true
              },
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "assets",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "shares",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "Withdraw",
            "parameters": [
              {
                "name": "by",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "assets",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "shares",
                "type": "uint256",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "DepositMoreThanMax",
            "parameters": []
          },
          {
            "name": "MintMoreThanMax",
            "parameters": []
          },
          {
            "name": "WithdrawMoreThanMax",
            "parameters": []
          },
          {
            "name": "RedeemMoreThanMax",
            "parameters": []
          }
        ]
      },
      {
        "name": "ERC6909",
        "kind": "abstract",
        "category": "core",
        "filePath": "solady/src/tokens/ERC6909.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "name",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function name(uint256 id) public view virtual returns (string memory);",
            "startLine": 98,
            "signature": "name(uint256)",
            "selector": "0x462e9c8d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "symbol",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function symbol(uint256 id) public view virtual returns (string memory);",
            "startLine": 101,
            "signature": "symbol(uint256)",
            "selector": "0x568dc020",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "decimals",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function decimals(uint256 id) public view virtual returns (uint8) {\n        id = id; // Silence compiler warning.\n        return 18;\n    }",
            "startLine": 106,
            "signature": "decimals(uint256)",
            "selector": "0x03841db6",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "tokenURI",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function tokenURI(uint256 id) public view virtual returns (string memory);",
            "startLine": 112,
            "signature": "tokenURI(uint256)",
            "selector": "0x7bde9c9b",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "balanceOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address owner, uint256 id) public view virtual returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, id)\n            amount := sload(keccak256(0x00, 0x40))\n        }\n    }",
            "startLine": 119,
            "signature": "balanceOf(address,uint256)",
            "selector": "0x3d474403",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "allowance",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function allowance(address owner, address spender, uint256 id)\n        public\n        view\n        virtual\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, owner)\n            mstore(0x14, spender)\n            mstore(0x00, id)\n            amount := sload(keccak256(0x00, 0x54))\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n    }",
            "startLine": 130,
            "signature": "allowance(address,address,uint256)",
            "selector": "0x6ad46b10",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "isOperator",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "status",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function isOperator(address owner, address spender) public view virtual returns (bool status) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, spender)\n            status := sload(keccak256(0x0c, 0x34))\n        }\n    }",
            "startLine": 149,
            "signature": "isOperator(address,address)",
            "selector": "0x7a268767",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "transfer",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transfer(address to, uint256 id, uint256 amount)\n        public\n        payable\n        virtual\n        returns (bool)\n    {\n        _beforeTokenTransfer(msg.sender, to, id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            /// Compute the balance slot and load its value.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, caller())\n            mstore(0x00, id)\n            let fromBalanceSlot := keccak256(0x00, 0x40)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x14, to)\n            mstore(0x00, id)\n            let toBalanceSlot := keccak256(0x00, 0x40)\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n            // Revert if the balance overflows.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated balance of `to`.\n            sstore(toBalanceSlot, toBalanceAfter)\n            // Emit the {Transfer} event.\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, shl(96, to)), id)\n        }\n        _afterTokenTransfer(msg.sender, to, id, amount);\n        return true;\n    }",
            "startLine": 165,
            "signature": "transfer(address,uint256,uint256)",
            "selector": "0x65b5d378",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "transferFrom",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferFrom(address from, address to, uint256 id, uint256 amount)\n        public\n        payable\n        virtual\n        returns (bool)\n    {\n        _beforeTokenTransfer(from, to, id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the operator slot and load its value.\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, from)\n            mstore(0x14, caller())\n            // Check if the caller is an operator.\n            if iszero(sload(keccak256(0x20, 0x34))) {\n                // Compute the allowance slot and load its value.\n                mstore(0x00, id)\n                let allowanceSlot := keccak256(0x00, 0x54)\n                let allowance_ := sload(allowanceSlot)\n                // If the allowance is not the maximum uint256 value.\n                if add(allowance_, 1) {\n                    // Revert if the amount to be transferred exceeds the allowance.\n                    if gt(amount, allowance_) {\n                        mstore(0x00, 0xdeda9030) // `InsufficientPermission()`.\n                        revert(0x1c, 0x04)\n                    }\n                    // Subtract and store the updated allowance.\n                    sstore(allowanceSlot, sub(allowance_, amount))\n                }\n            }\n            // Compute the balance slot and load its value.\n            mstore(0x14, id)\n            let fromBalanceSlot := keccak256(0x14, 0x40)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x28, to)\n            mstore(0x14, id)\n            let toBalanceSlot := keccak256(0x14, 0x40)\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n            // Revert if the balance overflows.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated balance of `to`.\n            sstore(toBalanceSlot, toBalanceAfter)\n            // Emit the {Transfer} event.\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            // forgefmt: disable-next-line\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), shr(96, shl(96, to)), id)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n        _afterTokenTransfer(from, to, id, amount);\n        return true;\n    }",
            "startLine": 222,
            "signature": "transferFrom(address,address,uint256,uint256)",
            "selector": "0x7ca60bda",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "approve",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function approve(address spender, uint256 id, uint256 amount)\n        public\n        payable\n        virtual\n        returns (bool)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, caller())\n            mstore(0x14, spender)\n            mstore(0x00, id)\n            sstore(keccak256(0x00, 0x54), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log4(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x20)), id)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n        return true;\n    }",
            "startLine": 291,
            "signature": "approve(address,uint256,uint256)",
            "selector": "0x6be045aa",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "setOperator",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "approved",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function setOperator(address operator, bool approved) public payable virtual returns (bool) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert `approved` to `0` or `1`.\n            let approvedCleaned := iszero(iszero(approved))\n            // Compute the operator slot and store the approved.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, caller())\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), approvedCleaned)\n            // Emit the {OperatorSet} event.\n            mstore(0x20, approvedCleaned)\n            log3(0x20, 0x20, _OPERATOR_SET_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\n        }\n        return true;\n    }",
            "startLine": 317,
            "signature": "setOperator(address,bool)",
            "selector": "0x20e40045",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "supportsInterface",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC6909: 0x0f632fb3.\n            result := or(eq(s, 0x01ffc9a7), eq(s, 0x0f632fb3))\n        }\n    }",
            "startLine": 335,
            "signature": "supportsInterface(bytes4)",
            "selector": "0x4ba9e2f3",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_mint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _mint(address to, uint256 id, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, to)\n            mstore(0x00, id)\n            let toBalanceSlot := keccak256(0x00, 0x40)\n            // Add and store the updated balance\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n            // Revert if the balance overflows.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(toBalanceSlot, toBalanceAfter)\n            // Emit the {Transfer} event.\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, shl(96, to)), id)\n        }\n        _afterTokenTransfer(address(0), to, id, amount);\n    }",
            "startLine": 351,
            "visibility": "internal"
          },
          {
            "name": "_burn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, from)\n            mstore(0x00, id)\n            let fromBalanceSlot := keccak256(0x00, 0x40)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Emit the {Transfer} event.\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0, id)\n        }\n        _afterTokenTransfer(from, address(0), id, amount);\n    }",
            "startLine": 380,
            "visibility": "internal"
          },
          {
            "name": "_transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _transfer(address by, address from, address to, uint256 id, uint256 amount)\n        internal\n        virtual\n    {\n        _beforeTokenTransfer(from, to, id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let bitmaskAddress := 0xffffffffffffffffffffffffffffffffffffffff\n            // Compute the operator slot and load its value.\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, from)\n            // If `by` is not the zero address.\n            if and(bitmaskAddress, by) {\n                mstore(0x14, by)\n                // Check if the `by` is an operator.\n                if iszero(sload(keccak256(0x20, 0x34))) {\n                    // Compute the allowance slot and load its value.\n                    mstore(0x00, id)\n                    let allowanceSlot := keccak256(0x00, 0x54)\n                    let allowance_ := sload(allowanceSlot)\n                    // If the allowance is not the maximum uint256 value.\n                    if add(allowance_, 1) {\n                        // Revert if the amount to be transferred exceeds the allowance.\n                        if gt(amount, allowance_) {\n                            mstore(0x00, 0xdeda9030) // `InsufficientPermission()`.\n                            revert(0x1c, 0x04)\n                        }\n                        // Subtract and store the updated allowance.\n                        sstore(allowanceSlot, sub(allowance_, amount))\n                    }\n                }\n            }\n            // Compute the balance slot and load its value.\n            mstore(0x14, id)\n            let fromBalanceSlot := keccak256(0x14, 0x40)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x28, to)\n            mstore(0x14, id)\n            let toBalanceSlot := keccak256(0x14, 0x40)\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n            // Revert if the balance overflows.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated balance of `to`.\n            sstore(toBalanceSlot, toBalanceAfter)\n            // Emit the {Transfer} event.\n            mstore(0x00, and(bitmaskAddress, by))\n            mstore(0x20, amount)\n            // forgefmt: disable-next-line\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, and(bitmaskAddress, from), and(bitmaskAddress, to), id)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n        _afterTokenTransfer(from, to, id, amount);\n    }",
            "startLine": 419,
            "visibility": "internal"
          },
          {
            "name": "_approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _approve(address owner, address spender, uint256 id, uint256 amount)\n        internal\n        virtual\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, owner)\n            mstore(0x14, spender)\n            mstore(0x00, id)\n            sstore(keccak256(0x00, 0x54), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            // forgefmt: disable-next-line\n            log4(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x34)), shr(96, mload(0x20)), id)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n    }",
            "startLine": 489,
            "visibility": "internal"
          },
          {
            "name": "_setOperator",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "approved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _setOperator(address owner, address operator, bool approved) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert `approved` to `0` or `1`.\n            let approvedCleaned := iszero(iszero(approved))\n            // Compute the operator slot and store the approved.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), approvedCleaned)\n            // Emit the {OperatorSet} event.\n            mstore(0x20, approvedCleaned)\n            // forgefmt: disable-next-line\n            log3(0x20, 0x20, _OPERATOR_SET_EVENT_SIGNATURE, shr(96, shl(96, owner)), shr(96, mload(0x0c)))\n        }\n    }",
            "startLine": 513,
            "visibility": "internal"
          },
          {
            "name": "_beforeTokenTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _beforeTokenTransfer(address from, address to, uint256 id, uint256 amount)\n        internal\n        virtual\n    {}",
            "startLine": 536,
            "visibility": "internal"
          },
          {
            "name": "_afterTokenTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _afterTokenTransfer(address from, address to, uint256 id, uint256 amount)\n        internal\n        virtual\n    {}",
            "startLine": 543,
            "visibility": "internal"
          }
        ],
        "events": [
          {
            "name": "Transfer",
            "parameters": [
              {
                "name": "by",
                "type": "address",
                "indexed": false
              },
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "OperatorSet",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "operator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "approved",
                "type": "bool",
                "indexed": false
              }
            ]
          },
          {
            "name": "Approval",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "spender",
                "type": "address",
                "indexed": true
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "InsufficientBalance",
            "parameters": []
          },
          {
            "name": "InsufficientPermission",
            "parameters": []
          },
          {
            "name": "BalanceOverflow",
            "parameters": []
          }
        ]
      },
      {
        "name": "ERC721",
        "kind": "abstract",
        "category": "token",
        "filePath": "solady/src/tokens/ERC721.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "name",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function name() public view virtual returns (string memory);",
            "startLine": 131,
            "signature": "name()",
            "selector": "0x3ec0f734",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "symbol",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function symbol() public view virtual returns (string memory);",
            "startLine": 134,
            "signature": "symbol()",
            "selector": "0x6a927499",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "tokenURI",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function tokenURI(uint256 id) public view virtual returns (string memory);",
            "startLine": 137,
            "signature": "tokenURI(uint256)",
            "selector": "0x7bde9c9b",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "ownerOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_ownerOf",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function ownerOf(uint256 id) public view virtual returns (address result) {\n        result = _ownerOf(id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(result) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 147,
            "signature": "ownerOf(uint256)",
            "selector": "0x7799e9f2",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "balanceOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the `owner` is the zero address.\n            if iszero(owner) {\n                mstore(0x00, 0x8f4eb604) // `BalanceQueryForZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            result := and(sload(keccak256(0x0c, 0x1c)), _MAX_ACCOUNT_BALANCE)\n        }\n    }",
            "startLine": 162,
            "signature": "balanceOf(address)",
            "selector": "0x7d2b9996",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getApproved",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function getApproved(uint256 id) public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            if iszero(shl(96, sload(ownershipSlot))) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            result := sload(add(1, ownershipSlot))\n        }\n    }",
            "startLine": 180,
            "signature": "getApproved(uint256)",
            "selector": "0x4d05d6d5",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "approve",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function approve(address account, uint256 id) public payable virtual {\n        _approve(msg.sender, account, id);\n    }",
            "startLine": 202,
            "signature": "approve(address,uint256)",
            "selector": "0x1d38323d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "isApprovedForAll",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, operator)\n            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x30))\n        }\n    }",
            "startLine": 207,
            "signature": "isApprovedForAll(address,address)",
            "selector": "0x3672353c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "setApprovalForAll",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "isApproved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function setApprovalForAll(address operator, bool isApproved) public virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`msg.sender`, `operator`).\n            mstore(0x1c, operator)\n            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x30), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            // forgefmt: disable-next-item\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator)))\n        }\n    }",
            "startLine": 225,
            "signature": "setApprovalForAll(address,bool)",
            "selector": "0x7b14221c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "transferFrom",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferFrom(address from, address to, uint256 id) public payable virtual {\n        _beforeTokenTransfer(from, to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            from := and(bitmaskAddress, from)\n            to := and(bitmaskAddress, to)\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, caller()))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            let owner := and(bitmaskAddress, ownershipPacked)\n            // Revert if the token does not exist, or if `from` is not the owner.\n            if iszero(mul(owner, eq(owner, from))) {\n                // `TokenDoesNotExist()`, `TransferFromIncorrectOwner()`.\n                mstore(shl(2, iszero(owner)), 0xceea21b6a1148100)\n                revert(0x1c, 0x04)\n            }\n            // Load, check, and update the token approval.\n            {\n                mstore(0x00, from)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // Revert if the caller is not the owner, nor approved.\n                if iszero(or(eq(caller(), from), eq(caller(), approvedAddress))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Update with the new owner.\n            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))\n            // Decrement the balance of `from`.\n            {\n                let fromBalanceSlot := keccak256(0x0c, 0x1c)\n                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))\n            }\n            // Increment the balance of `to`.\n            {\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x1c)\n                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\n        }\n        _afterTokenTransfer(from, to, id);\n    }",
            "startLine": 252,
            "signature": "transferFrom(address,address,uint256)",
            "selector": "0x447f286d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "safeTransferFrom",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "transferFrom",
                "type": "internal"
              },
              {
                "target": "_hasCode",
                "type": "internal"
              },
              {
                "target": "_checkOnERC721Received",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\n        transferFrom(from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \"\");\n    }",
            "startLine": 313,
            "signature": "safeTransferFrom(address,address,uint256)",
            "selector": "0x0f33b3fa",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "safeTransferFrom",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "transferFrom",
                "type": "internal"
              },
              {
                "target": "_hasCode",
                "type": "internal"
              },
              {
                "target": "_checkOnERC721Received",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\n        public\n        payable\n        virtual\n    {\n        transferFrom(from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }",
            "startLine": 330,
            "signature": "safeTransferFrom(address,address,uint256,bytes)",
            "selector": "0x0b95ae67",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "supportsInterface",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\n        }\n    }",
            "startLine": 342,
            "signature": "supportsInterface(bytes4)",
            "selector": "0x4ba9e2f3",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_exists",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _exists(uint256 id) internal view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := iszero(iszero(shl(96, sload(add(id, add(id, keccak256(0x00, 0x20)))))))\n        }\n    }",
            "startLine": 356,
            "visibility": "internal"
          },
          {
            "name": "_ownerOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _ownerOf(uint256 id) internal view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := shr(96, shl(96, sload(add(id, add(id, keccak256(0x00, 0x20))))))\n        }\n    }",
            "startLine": 367,
            "visibility": "internal"
          },
          {
            "name": "_getAux",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint224"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _getAux(address owner) internal view virtual returns (uint224 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            result := shr(32, sload(keccak256(0x0c, 0x1c)))\n        }\n    }",
            "startLine": 386,
            "visibility": "internal"
          },
          {
            "name": "_setAux",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint224"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _setAux(address owner, uint224 value) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            let balanceSlot := keccak256(0x0c, 0x1c)\n            let packed := sload(balanceSlot)\n            sstore(balanceSlot, xor(packed, shl(32, xor(value, shr(32, packed)))))\n        }\n    }",
            "startLine": 398,
            "visibility": "internal"
          },
          {
            "name": "_getExtraData",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint96"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _getExtraData(uint256 id) internal view virtual returns (uint96 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := shr(160, sload(add(id, add(id, keccak256(0x00, 0x20)))))\n        }\n    }",
            "startLine": 412,
            "visibility": "internal"
          },
          {
            "name": "_setExtraData",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint96"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _setExtraData(uint256 id, uint96 value) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let packed := sload(ownershipSlot)\n            sstore(ownershipSlot, xor(packed, shl(160, xor(value, shr(160, packed)))))\n        }\n    }",
            "startLine": 424,
            "visibility": "internal"
          },
          {
            "name": "_mint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _mint(address to, uint256 id) internal virtual {\n        _beforeTokenTransfer(address(0), to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            to := shr(96, shl(96, to))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            // Revert if the token already exists.\n            if shl(96, ownershipPacked) {\n                mstore(0x00, 0xc991cbb1) // `TokenAlreadyExists()`.\n                revert(0x1c, 0x04)\n            }\n            // Update with the owner.\n            sstore(ownershipSlot, or(ownershipPacked, to))\n            // Increment the balance of the owner.\n            {\n                mstore(0x00, to)\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                let balanceSlotPacked := add(sload(balanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(balanceSlot, balanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)\n        }\n        _afterTokenTransfer(address(0), to, id);\n    }",
            "startLine": 447,
            "visibility": "internal"
          },
          {
            "name": "_mintAndSetExtraDataUnchecked",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint96"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _mintAndSetExtraDataUnchecked(address to, uint256 id, uint96 value) internal virtual {\n        _beforeTokenTransfer(address(0), to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            to := shr(96, shl(96, to))\n            // Update with the owner and extra data.\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            sstore(add(id, add(id, keccak256(0x00, 0x20))), or(shl(160, value), to))\n            // Increment the balance of the owner.\n            {\n                mstore(0x00, to)\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                let balanceSlotPacked := add(sload(balanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(balanceSlot, balanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)\n        }\n        _afterTokenTransfer(address(0), to, id);\n    }",
            "startLine": 492,
            "visibility": "internal"
          },
          {
            "name": "_safeMint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeMint",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeMint(address to, uint256 id) internal virtual {\n        _safeMint(to, id, \"\");\n    }",
            "startLine": 522,
            "visibility": "internal"
          },
          {
            "name": "_safeMint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_mint",
                "type": "internal"
              },
              {
                "target": "_hasCode",
                "type": "internal"
              },
              {
                "target": "_checkOnERC721Received",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\n        _mint(to, id);\n        if (_hasCode(to)) _checkOnERC721Received(address(0), to, id, data);\n    }",
            "startLine": 536,
            "visibility": "internal"
          },
          {
            "name": "_burn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_burn",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _burn(uint256 id) internal virtual {\n        _burn(address(0), id);\n    }",
            "startLine": 546,
            "visibility": "internal"
          },
          {
            "name": "_burn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "ownerOf",
                "type": "internal"
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _burn(address by, uint256 id) internal virtual {\n        address owner = ownerOf(id);\n        _beforeTokenTransfer(owner, address(0), id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            by := shr(96, shl(96, by))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            // Reload the owner in case it is changed in `_beforeTokenTransfer`.\n            owner := shr(96, shl(96, ownershipPacked))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // Load and check the token approval.\n            {\n                mstore(0x00, owner)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // If `by` is not the zero address, do the authorization check.\n                // Revert if the `by` is not the owner, nor approved.\n                if iszero(or(iszero(by), or(eq(by, owner), eq(by, approvedAddress)))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Clear the owner.\n            sstore(ownershipSlot, xor(ownershipPacked, owner))\n            // Decrement the balance of `owner`.\n            {\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                sstore(balanceSlot, sub(sload(balanceSlot), 1))\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, owner, 0, id)\n        }\n        _afterTokenTransfer(owner, address(0), id);\n    }",
            "startLine": 559,
            "visibility": "internal"
          },
          {
            "name": "_isApprovedOrOwner",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _isApprovedOrOwner(address account, uint256 id)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            // Clear the upper 96 bits.\n            account := shr(96, shl(96, account))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, account))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let owner := shr(96, shl(96, sload(ownershipSlot)))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // Check if `account` is the `owner`.\n            if iszero(eq(account, owner)) {\n                mstore(0x00, owner)\n                // Check if `account` is approved to manage the token.\n                if iszero(sload(keccak256(0x0c, 0x30))) {\n                    result := eq(account, sload(add(1, ownershipSlot)))\n                }\n            }\n        }\n    }",
            "startLine": 614,
            "visibility": "internal"
          },
          {
            "name": "_getApproved",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _getApproved(uint256 id) internal view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := sload(add(1, add(id, add(id, keccak256(0x00, 0x20)))))\n        }\n    }",
            "startLine": 648,
            "visibility": "internal"
          },
          {
            "name": "_approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_approve",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _approve(address account, uint256 id) internal virtual {\n        _approve(address(0), account, id);\n    }",
            "startLine": 658,
            "visibility": "internal"
          },
          {
            "name": "_approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _approve(address by, address account, uint256 id) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            account := and(bitmaskAddress, account)\n            by := and(bitmaskAddress, by)\n            // Load the owner of the token.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let owner := and(bitmaskAddress, sload(ownershipSlot))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // If `by` is not the zero address, do the authorization check.\n            // Revert if `by` is not the owner, nor approved.\n            if iszero(or(iszero(by), eq(by, owner))) {\n                mstore(0x00, owner)\n                if iszero(sload(keccak256(0x0c, 0x30))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Sets `account` as the approved account to manage `id`.\n            sstore(add(1, ownershipSlot), account)\n            // Emit the {Approval} event.\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, owner, account, id)\n        }\n    }",
            "startLine": 670,
            "visibility": "internal"
          },
          {
            "name": "_setApprovalForAll",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "isApproved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            by := shr(96, shl(96, by))\n            operator := shr(96, shl(96, operator))\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`by`, `operator`).\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))\n            mstore(0x00, by)\n            sstore(keccak256(0x0c, 0x30), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, by, operator)\n        }\n    }",
            "startLine": 707,
            "visibility": "internal"
          },
          {
            "name": "_transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _transfer(address from, address to, uint256 id) internal virtual {\n        _transfer(address(0), from, to, id);\n    }",
            "startLine": 730,
            "visibility": "internal"
          },
          {
            "name": "_transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _transfer(address by, address from, address to, uint256 id) internal virtual {\n        _beforeTokenTransfer(from, to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            from := and(bitmaskAddress, from)\n            to := and(bitmaskAddress, to)\n            by := and(bitmaskAddress, by)\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            let owner := and(bitmaskAddress, ownershipPacked)\n            // Revert if the token does not exist, or if `from` is not the owner.\n            if iszero(mul(owner, eq(owner, from))) {\n                // `TokenDoesNotExist()`, `TransferFromIncorrectOwner()`.\n                mstore(shl(2, iszero(owner)), 0xceea21b6a1148100)\n                revert(0x1c, 0x04)\n            }\n            // Load, check, and update the token approval.\n            {\n                mstore(0x00, from)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // If `by` is not the zero address, do the authorization check.\n                // Revert if the `by` is not the owner, nor approved.\n                if iszero(or(iszero(by), or(eq(by, from), eq(by, approvedAddress)))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Update with the new owner.\n            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))\n            // Decrement the balance of `from`.\n            {\n                let fromBalanceSlot := keccak256(0x0c, 0x1c)\n                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))\n            }\n            // Increment the balance of `to`.\n            {\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x1c)\n                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\n        }\n        _afterTokenTransfer(from, to, id);\n    }",
            "startLine": 745,
            "visibility": "internal"
          },
          {
            "name": "_safeTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address from, address to, uint256 id) internal virtual {\n        _safeTransfer(from, to, id, \"\");\n    }",
            "startLine": 808,
            "visibility": "internal"
          },
          {
            "name": "_safeTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_hasCode",
                "type": "internal"
              },
              {
                "target": "_checkOnERC721Received",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address from, address to, uint256 id, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(address(0), from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }",
            "startLine": 824,
            "visibility": "internal"
          },
          {
            "name": "_safeTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address by, address from, address to, uint256 id) internal virtual {\n        _safeTransfer(by, from, to, id, \"\");\n    }",
            "startLine": 833,
            "visibility": "internal"
          },
          {
            "name": "_safeTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transfer",
                "type": "internal"
              },
              {
                "target": "_hasCode",
                "type": "internal"
              },
              {
                "target": "_checkOnERC721Received",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address by, address from, address to, uint256 id, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(by, from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }",
            "startLine": 850,
            "visibility": "internal"
          },
          {
            "name": "_beforeTokenTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _beforeTokenTransfer(address from, address to, uint256 id) internal virtual {}",
            "startLine": 863,
            "visibility": "internal"
          },
          {
            "name": "_afterTokenTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _afterTokenTransfer(address from, address to, uint256 id) internal virtual {}",
            "startLine": 866,
            "visibility": "internal"
          },
          {
            "name": "_hasCode",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "a",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _hasCode(address a) private view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := extcodesize(a) // Can handle dirty upper bits.\n        }\n    }",
            "startLine": 873,
            "visibility": "private"
          },
          {
            "name": "_checkOnERC721Received",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\n        private\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the calldata.\n            let m := mload(0x40)\n            let onERC721ReceivedSelector := 0x150b7a02\n            mstore(m, onERC721ReceivedSelector)\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            mstore(add(m, 0x60), id)\n            mstore(add(m, 0x80), 0x80)\n            let n := mload(data)\n            mstore(add(m, 0xa0), n)\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n            // Load the returndata and compare it.\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 882,
            "visibility": "private"
          }
        ],
        "events": [
          {
            "name": "Transfer",
            "parameters": [
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              }
            ]
          },
          {
            "name": "Approval",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "account",
                "type": "address",
                "indexed": true
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              }
            ]
          },
          {
            "name": "ApprovalForAll",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "operator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "isApproved",
                "type": "bool",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "NotOwnerNorApproved",
            "parameters": []
          },
          {
            "name": "TokenDoesNotExist",
            "parameters": []
          },
          {
            "name": "TokenAlreadyExists",
            "parameters": []
          },
          {
            "name": "BalanceQueryForZeroAddress",
            "parameters": []
          },
          {
            "name": "TransferToZeroAddress",
            "parameters": []
          },
          {
            "name": "TransferFromIncorrectOwner",
            "parameters": []
          },
          {
            "name": "AccountBalanceOverflow",
            "parameters": []
          },
          {
            "name": "TransferToNonERC721ReceiverImplementer",
            "parameters": []
          }
        ]
      },
      {
        "name": "WETH",
        "kind": "contract",
        "category": "core",
        "filePath": "solady/src/tokens/WETH.sol",
        "inherits": [
          "ERC20"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "name",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function name() public view virtual override returns (string memory) {\n        return \"Wrapped Ether\";\n    }",
            "startLine": 23,
            "signature": "name()",
            "selector": "0x3ec0f734",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "symbol",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function symbol() public view virtual override returns (string memory) {\n        return \"WETH\";\n    }",
            "startLine": 28,
            "signature": "symbol()",
            "selector": "0x6a927499",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "deposit",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_mint",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function deposit() public payable virtual {\n        _mint(msg.sender, msg.value);\n    }",
            "startLine": 37,
            "signature": "deposit()",
            "selector": "0x30c413e1",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "withdraw",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_burn",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function withdraw(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gas(), caller(), amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 42,
            "signature": "withdraw(uint256)",
            "selector": "0x279e2aee",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": [
          {
            "name": "ETHTransferFailed",
            "parameters": []
          }
        ]
      },
      {
        "name": "ERC1155",
        "kind": "abstract",
        "category": "token",
        "filePath": "solady/src/tokens/ext/zksync/ERC1155.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "uri",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function uri(uint256 id) public view virtual returns (string memory);",
            "startLine": 124,
            "signature": "uri(uint256)",
            "selector": "0x1d5ffecc",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "balanceOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address owner, uint256 id) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, id)\n            result := sload(keccak256(0x00, 0x40))\n        }\n    }",
            "startLine": 131,
            "signature": "balanceOf(address,uint256)",
            "selector": "0x3d474403",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "isApprovedForAll",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, operator)\n            result := sload(keccak256(0x0c, 0x34))\n        }\n    }",
            "startLine": 142,
            "signature": "isApprovedForAll(address,address)",
            "selector": "0x3672353c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "setApprovalForAll",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "isApproved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function setApprovalForAll(address operator, bool isApproved) public virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`msg.sender`, `operator`).\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, caller())\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            // forgefmt: disable-next-line\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator)))\n        }\n    }",
            "startLine": 160,
            "signature": "setApprovalForAll(address,bool)",
            "selector": "0x7b14221c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "safeTransferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_single",
                "type": "internal"
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\n            mstore(0x20, fromSlotSeed)\n            // Clear the upper 96 bits.\n            from := shr(96, fromSlotSeed)\n            to := shr(96, toSlotSeed)\n            // Revert if `to` is the zero address.\n            if iszero(to) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // If the caller is not `from`, do the authorization check.\n            if iszero(eq(caller(), from)) {\n                mstore(0x00, caller())\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Subtract and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, toSlotSeed)\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), from, to)\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Do the {onERC1155Received} check if `to` is a smart contract.\n            if extcodesize(to) {\n                // Prepare the calldata.\n                let m := mload(0x40)\n                // `onERC1155Received(address,address,uint256,uint256,bytes)`.\n                mstore(m, 0xf23a6e61)\n                mstore(add(m, 0x20), caller())\n                mstore(add(m, 0x40), from)\n                mstore(add(m, 0x60), id)\n                mstore(add(m, 0x80), amount)\n                mstore(add(m, 0xa0), 0xa0)\n                mstore(add(m, 0xc0), data.length)\n                calldatacopy(add(m, 0xe0), data.offset, data.length)\n                // Revert if the call reverts.\n                if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, data.length), m, 0x20)) {\n                    if returndatasize() {\n                        // Bubble up the revert if the call reverts.\n                        returndatacopy(m, 0x00, returndatasize())\n                        revert(m, returndatasize())\n                    }\n                }\n                // Load the returndata and compare it with the function selector.\n                if iszero(eq(mload(m), shl(224, 0xf23a6e61))) {\n                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 188,
            "signature": "safeTransferFrom(address,address,uint256,uint256,bytes)",
            "selector": "0x2c321246",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "safeBatchTransferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransferCalldata",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(ids.length, amounts.length)) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\n            mstore(0x20, fromSlotSeed)\n            // Clear the upper 96 bits.\n            from := shr(96, fromSlotSeed)\n            to := shr(96, toSlotSeed)\n            // Revert if `to` is the zero address.\n            if iszero(to) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // If the caller is not `from`, do the authorization check.\n            if iszero(eq(caller(), from)) {\n                mstore(0x00, caller())\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                for { let i := shl(5, ids.length) } i {} {\n                    i := sub(i, 0x20)\n                    let amount := calldataload(add(amounts.offset, i))\n                    // Subtract and store the updated balance of `from`.\n                    {\n                        mstore(0x20, fromSlotSeed)\n                        mstore(0x00, calldataload(add(ids.offset, i)))\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\n                        let fromBalance := sload(fromBalanceSlot)\n                        if gt(amount, fromBalance) {\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\n                    }\n                    // Increase and store the updated balance of `to`.\n                    {\n                        mstore(0x20, toSlotSeed)\n                        let toBalanceSlot := keccak256(0x00, 0x40)\n                        let toBalanceBefore := sload(toBalanceSlot)\n                        let toBalanceAfter := add(toBalanceBefore, amount)\n                        if lt(toBalanceAfter, toBalanceBefore) {\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(toBalanceSlot, toBalanceAfter)\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := shl(5, ids.length)\n                mstore(add(m, 0x40), ids.length)\n                calldatacopy(add(m, 0x60), ids.offset, n)\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x60, n))\n                let o := add(add(m, n), 0x60)\n                mstore(o, ids.length)\n                calldatacopy(add(o, 0x20), amounts.offset, n)\n                // Do the emit.\n                log4(m, add(add(n, n), 0x80), _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), from, to)\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransferCalldata(from, to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Do the {onERC1155BatchReceived} check if `to` is a smart contract.\n            if extcodesize(to) {\n                mstore(0x00, to) // Cache `to` to prevent stack too deep.\n                let m := mload(0x40)\n                // Prepare the calldata.\n                // `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n                mstore(m, 0xbc197c81)\n                mstore(add(m, 0x20), caller())\n                mstore(add(m, 0x40), from)\n                // Copy the `ids`.\n                mstore(add(m, 0x60), 0xa0)\n                let n := shl(5, ids.length)\n                mstore(add(m, 0xc0), ids.length)\n                calldatacopy(add(m, 0xe0), ids.offset, n)\n                // Copy the `amounts`.\n                mstore(add(m, 0x80), add(0xc0, n))\n                let o := add(add(m, n), 0xe0)\n                mstore(o, ids.length)\n                calldatacopy(add(o, 0x20), amounts.offset, n)\n                // Copy the `data`.\n                mstore(add(m, 0xa0), add(add(0xe0, n), n))\n                o := add(add(o, n), 0x20)\n                mstore(o, data.length)\n                calldatacopy(add(o, 0x20), data.offset, data.length)\n                let nAll := add(0x104, add(data.length, add(n, n)))\n                // Revert if the call reverts.\n                if iszero(call(gas(), mload(0x00), 0, add(mload(0x40), 0x1c), nAll, m, 0x20)) {\n                    if returndatasize() {\n                        // Bubble up the revert if the call reverts.\n                        returndatacopy(m, 0x00, returndatasize())\n                        revert(m, returndatasize())\n                    }\n                }\n                // Load the returndata and compare it with the function selector.\n                if iszero(eq(mload(m), shl(224, 0xbc197c81))) {\n                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 293,
            "signature": "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)",
            "selector": "0x131cc66a",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "balanceOfBatch",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owners",
                "type": "address[]"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "balances",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(ids.length, owners.length)) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            balances := mload(0x40)\n            mstore(balances, ids.length)\n            let o := add(balances, 0x20)\n            let i := shl(5, ids.length)\n            mstore(0x40, add(i, o))\n            // Loop through all the `ids` and load the balances.\n            for {} i {} {\n                i := sub(i, 0x20)\n                let owner := calldataload(add(owners.offset, i))\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner)))\n                mstore(0x00, calldataload(add(ids.offset, i)))\n                mstore(add(o, i), sload(keccak256(0x00, 0x40)))\n            }\n        }\n    }",
            "startLine": 427,
            "signature": "balanceOfBatch(address[],uint256[])",
            "selector": "0x32988c25",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "supportsInterface",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC1155: 0xd9b67a26, ERC1155MetadataURI: 0x0e89341c.\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0xd9b67a26)), eq(s, 0x0e89341c))\n        }\n    }",
            "startLine": 458,
            "signature": "supportsInterface(bytes4)",
            "selector": "0x4ba9e2f3",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_mint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_single",
                "type": "internal"
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_hasCode",
                "type": "internal"
              },
              {
                "target": "_checkOnERC1155Received",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(address(0), to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n                mstore(0x14, to)\n                mstore(0x00, id)\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), 0, shr(96, to_))\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(address(0), to, _single(id), _single(amount), data);\n        }\n        if (_hasCode(to)) _checkOnERC1155Received(address(0), to, id, amount, data);\n    }",
            "startLine": 479,
            "visibility": "internal"
          },
          {
            "name": "_batchMint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_hasCode",
                "type": "internal"
              },
              {
                "target": "_checkOnERC1155BatchReceived",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(address(0), to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            function copy(dst_, src_, n_) {\n                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {\n                    mstore(add(dst_, i_), mload(add(src_, i_)))\n                }\n            }\n            if iszero(eq(mload(ids), mload(amounts))) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, to_))\n                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {\n                    let amount := mload(add(amounts, i))\n                    // Increase and store the updated balance of `to`.\n                    {\n                        mstore(0x00, mload(add(ids, i)))\n                        let toBalanceSlot := keccak256(0x00, 0x40)\n                        let toBalanceBefore := sload(toBalanceSlot)\n                        let toBalanceAfter := add(toBalanceBefore, amount)\n                        if lt(toBalanceAfter, toBalanceBefore) {\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(toBalanceSlot, toBalanceAfter)\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, mload(ids)))\n                let o := add(m, 0x40)\n                copy(o, ids, n)\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, n))\n                o := add(o, n)\n                n := add(0x20, shl(5, mload(amounts)))\n                copy(o, amounts, n)\n                n := sub(add(o, n), m)\n                // Do the emit.\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), 0, shr(96, to_))\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(address(0), to, ids, amounts, data);\n        }\n        if (_hasCode(to)) _checkOnERC1155BatchReceived(address(0), to, ids, amounts, data);\n    }",
            "startLine": 524,
            "visibility": "internal"
          },
          {
            "name": "_burn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_burn",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        _burn(address(0), from, id, amount);\n    }",
            "startLine": 598,
            "visibility": "internal"
          },
          {
            "name": "_burn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_single",
                "type": "internal"
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _burn(address by, address from, uint256 id, uint256 amount) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, address(0), _single(id), _single(amount), \"\");\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            if iszero(or(iszero(shl(96, by)), eq(shl(96, by), from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Decrease and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), shr(96, from_), 0)\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, address(0), _single(id), _single(amount), \"\");\n        }\n    }",
            "startLine": 610,
            "visibility": "internal"
          },
          {
            "name": "_batchBurn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_batchBurn",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _batchBurn(address from, uint256[] memory ids, uint256[] memory amounts)\n        internal\n        virtual\n    {\n        _batchBurn(address(0), from, ids, amounts);\n    }",
            "startLine": 648,
            "visibility": "internal"
          },
          {
            "name": "_batchBurn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _batchBurn(address by, address from, uint256[] memory ids, uint256[] memory amounts)\n        internal\n        virtual\n    {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, address(0), ids, amounts, \"\");\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            function copy(dst_, src_, n_) {\n                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {\n                    mstore(add(dst_, i_), mload(add(src_, i_)))\n                }\n            }\n            if iszero(eq(mload(ids), mload(amounts))) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let from_ := shl(96, from)\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            let by_ := shl(96, by)\n            if iszero(or(iszero(by_), eq(by_, from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {\n                    let amount := mload(add(amounts, i))\n                    // Decrease and store the updated balance of `from`.\n                    {\n                        mstore(0x00, mload(add(ids, i)))\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\n                        let fromBalance := sload(fromBalanceSlot)\n                        if gt(amount, fromBalance) {\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, mload(ids)))\n                let o := add(m, 0x40)\n                copy(o, ids, n)\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, n))\n                o := add(o, n)\n                n := add(0x20, shl(5, mload(amounts)))\n                copy(o, amounts, n)\n                n := sub(add(o, n), m)\n                // Do the emit.\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), shr(96, from_), 0)\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, address(0), ids, amounts, \"\");\n        }\n    }",
            "startLine": 664,
            "visibility": "internal"
          },
          {
            "name": "_setApprovalForAll",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "isApproved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`by`, `operator`).\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, by)\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            let m := shr(96, not(0))\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, and(m, by), and(m, operator))\n        }\n    }",
            "startLine": 742,
            "visibility": "internal"
          },
          {
            "name": "_safeTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address from, address to, uint256 id, uint256 amount, bytes memory data)\n        internal\n        virtual\n    {\n        _safeTransfer(address(0), from, to, id, amount, data);\n    }",
            "startLine": 764,
            "visibility": "internal"
          },
          {
            "name": "_safeTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_single",
                "type": "internal"
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_hasCode",
                "type": "internal"
              },
              {
                "target": "_checkOnERC1155Received",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(\n        address by,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            let by_ := shl(96, by)\n            if iszero(or(iszero(by_), eq(by_, from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Subtract and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, to_))\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            // forgefmt: disable-next-line\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), shr(96, from_), shr(96, to_))\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        if (_hasCode(to)) _checkOnERC1155Received(from, to, id, amount, data);\n    }",
            "startLine": 782,
            "visibility": "internal"
          },
          {
            "name": "_safeBatchTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeBatchTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeBatchTransfer(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _safeBatchTransfer(address(0), from, to, ids, amounts, data);\n    }",
            "startLine": 848,
            "visibility": "internal"
          },
          {
            "name": "_safeBatchTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_hasCode",
                "type": "internal"
              },
              {
                "target": "_checkOnERC1155BatchReceived",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeBatchTransfer(\n        address by,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            function copy(dst_, src_, n_) {\n                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {\n                    mstore(add(dst_, i_), mload(add(src_, i_)))\n                }\n            }\n            if iszero(eq(mload(ids), mload(amounts))) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let from_ := shl(96, from)\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, from_)\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, to_)\n            mstore(0x20, fromSlotSeed)\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            let by_ := shl(96, by)\n            if iszero(or(iszero(by_), eq(by_, from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {\n                    let amount := mload(add(amounts, i))\n                    // Subtract and store the updated balance of `from`.\n                    {\n                        mstore(0x20, fromSlotSeed)\n                        mstore(0x00, mload(add(ids, i)))\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\n                        let fromBalance := sload(fromBalanceSlot)\n                        if gt(amount, fromBalance) {\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\n                    }\n                    // Increase and store the updated balance of `to`.\n                    {\n                        mstore(0x20, toSlotSeed)\n                        let toBalanceSlot := keccak256(0x00, 0x40)\n                        let toBalanceBefore := sload(toBalanceSlot)\n                        let toBalanceAfter := add(toBalanceBefore, amount)\n                        if lt(toBalanceAfter, toBalanceBefore) {\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(toBalanceSlot, toBalanceAfter)\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, mload(ids)))\n                let o := add(m, 0x40)\n                copy(o, ids, n)\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, n))\n                o := add(o, n)\n                n := add(0x20, shl(5, mload(amounts)))\n                copy(o, amounts, n)\n                n := sub(add(o, n), m)\n                // Do the emit.\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), shr(96, from_), shr(96, to_))\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, ids, amounts, data);\n        }\n        if (_hasCode(to)) _checkOnERC1155BatchReceived(from, to, ids, amounts, data);\n    }",
            "startLine": 870,
            "visibility": "internal"
          },
          {
            "name": "_useBeforeTokenTransfer",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _useBeforeTokenTransfer() internal view virtual returns (bool) {\n        return false;\n    }",
            "startLine": 972,
            "visibility": "internal"
          },
          {
            "name": "_beforeTokenTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}",
            "startLine": 981,
            "visibility": "internal"
          },
          {
            "name": "_useAfterTokenTransfer",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _useAfterTokenTransfer() internal view virtual returns (bool) {\n        return false;\n    }",
            "startLine": 991,
            "visibility": "internal"
          },
          {
            "name": "_afterTokenTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}",
            "startLine": 1000,
            "visibility": "internal"
          },
          {
            "name": "_afterTokenTransferCalldata",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _afterTokenTransferCalldata(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) private {\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, ids, amounts, data);\n        }\n    }",
            "startLine": 1014,
            "visibility": "private"
          },
          {
            "name": "_hasCode",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "a",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _hasCode(address a) private view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := extcodesize(a) // Can handle dirty upper bits.\n        }\n    }",
            "startLine": 1027,
            "visibility": "private"
          },
          {
            "name": "_checkOnERC1155Received",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _checkOnERC1155Received(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function copy(dst_, src_, n_) {\n                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {\n                    mstore(add(dst_, i_), mload(add(src_, i_)))\n                }\n            }\n            // Prepare the calldata.\n            let m := mload(0x40)\n            // `onERC1155Received(address,address,uint256,uint256,bytes)`.\n            mstore(m, 0xf23a6e61)\n            mstore(add(m, 0x20), caller())\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            mstore(add(m, 0x60), id)\n            mstore(add(m, 0x80), amount)\n            mstore(add(m, 0xa0), 0xa0)\n            let n := mload(data)\n            mstore(add(m, 0xc0), n)\n            copy(add(m, 0xe0), add(data, 0x20), n)\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, n), m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n            // Load the returndata and compare it with the function selector.\n            if iszero(eq(mload(m), shl(224, 0xf23a6e61))) {\n                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 1036,
            "visibility": "private"
          },
          {
            "name": "_checkOnERC1155BatchReceived",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _checkOnERC1155BatchReceived(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function copy(dst_, src_, n_) {\n                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {\n                    mstore(add(dst_, i_), mload(add(src_, i_)))\n                }\n            }\n            // Prepare the calldata.\n            let m := mload(0x40)\n            // `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n            mstore(m, 0xbc197c81)\n            mstore(add(m, 0x20), caller())\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            // Copy the `ids`.\n            mstore(add(m, 0x60), 0xa0)\n            let n := add(0x20, shl(5, mload(ids)))\n            let o := add(m, 0xc0)\n            copy(o, ids, n)\n            // Copy the `amounts`.\n            let s := add(0xa0, n)\n            mstore(add(m, 0x80), s)\n            o := add(o, n)\n            n := add(0x20, shl(5, mload(amounts)))\n            copy(o, amounts, n)\n            // Copy the `data`.\n            mstore(add(m, 0xa0), add(s, n))\n            o := add(o, n)\n            n := add(0x20, mload(data))\n            copy(o, data, n)\n            n := sub(add(o, n), add(m, 0x1c))\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), n, m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n            // Load the returndata and compare it with the function selector.\n            if iszero(eq(mload(m), shl(224, 0xbc197c81))) {\n                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 1080,
            "visibility": "private"
          },
          {
            "name": "_single",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _single(uint256 x) private pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(0x40, add(result, 0x40))\n            mstore(result, 1)\n            mstore(add(result, 0x20), x)\n        }\n    }",
            "startLine": 1134,
            "visibility": "private"
          }
        ],
        "events": [
          {
            "name": "TransferSingle",
            "parameters": [
              {
                "name": "operator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "TransferBatch",
            "parameters": [
              {
                "name": "operator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "ids",
                "type": "uint256[]",
                "indexed": false
              },
              {
                "name": "amounts",
                "type": "uint256[]",
                "indexed": false
              }
            ]
          },
          {
            "name": "ApprovalForAll",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "operator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "isApproved",
                "type": "bool",
                "indexed": false
              }
            ]
          },
          {
            "name": "URI",
            "parameters": [
              {
                "name": "value",
                "type": "string",
                "indexed": false
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "ArrayLengthsMismatch",
            "parameters": []
          },
          {
            "name": "TransferToZeroAddress",
            "parameters": []
          },
          {
            "name": "AccountBalanceOverflow",
            "parameters": []
          },
          {
            "name": "InsufficientBalance",
            "parameters": []
          },
          {
            "name": "NotOwnerNorApproved",
            "parameters": []
          },
          {
            "name": "TransferToNonERC1155ReceiverImplementer",
            "parameters": []
          }
        ]
      },
      {
        "name": "ERC721",
        "kind": "abstract",
        "category": "token",
        "filePath": "solady/src/tokens/ext/zksync/ERC721.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "name",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function name() public view virtual returns (string memory);",
            "startLine": 129,
            "signature": "name()",
            "selector": "0x3ec0f734",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "symbol",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function symbol() public view virtual returns (string memory);",
            "startLine": 132,
            "signature": "symbol()",
            "selector": "0x6a927499",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "tokenURI",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function tokenURI(uint256 id) public view virtual returns (string memory);",
            "startLine": 135,
            "signature": "tokenURI(uint256)",
            "selector": "0x7bde9c9b",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "ownerOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_ownerOf",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function ownerOf(uint256 id) public view virtual returns (address result) {\n        result = _ownerOf(id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(result) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 145,
            "signature": "ownerOf(uint256)",
            "selector": "0x7799e9f2",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "balanceOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the `owner` is the zero address.\n            if iszero(owner) {\n                mstore(0x00, 0x8f4eb604) // `BalanceQueryForZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            result := and(sload(keccak256(0x0c, 0x1c)), _MAX_ACCOUNT_BALANCE)\n        }\n    }",
            "startLine": 160,
            "signature": "balanceOf(address)",
            "selector": "0x7d2b9996",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getApproved",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function getApproved(uint256 id) public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            if iszero(shl(96, sload(ownershipSlot))) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            result := sload(add(1, ownershipSlot))\n        }\n    }",
            "startLine": 178,
            "signature": "getApproved(uint256)",
            "selector": "0x4d05d6d5",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "approve",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function approve(address account, uint256 id) public payable virtual {\n        _approve(msg.sender, account, id);\n    }",
            "startLine": 200,
            "signature": "approve(address,uint256)",
            "selector": "0x1d38323d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "isApprovedForAll",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, operator)\n            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x30))\n        }\n    }",
            "startLine": 205,
            "signature": "isApprovedForAll(address,address)",
            "selector": "0x3672353c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "setApprovalForAll",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "isApproved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function setApprovalForAll(address operator, bool isApproved) public virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`msg.sender`, `operator`).\n            mstore(0x1c, operator)\n            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x30), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            // forgefmt: disable-next-item\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator)))\n        }\n    }",
            "startLine": 223,
            "signature": "setApprovalForAll(address,bool)",
            "selector": "0x7b14221c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "transferFrom",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferFrom(address from, address to, uint256 id) public payable virtual {\n        _beforeTokenTransfer(from, to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            from := and(bitmaskAddress, from)\n            to := and(bitmaskAddress, to)\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, caller()))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            let owner := and(bitmaskAddress, ownershipPacked)\n            // Revert if the token does not exist, or if `from` is not the owner.\n            if iszero(mul(owner, eq(owner, from))) {\n                // `TokenDoesNotExist()`, `TransferFromIncorrectOwner()`.\n                mstore(shl(2, iszero(owner)), 0xceea21b6a1148100)\n                revert(0x1c, 0x04)\n            }\n            // Load, check, and update the token approval.\n            {\n                mstore(0x00, from)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // Revert if the caller is not the owner, nor approved.\n                if iszero(or(eq(caller(), from), eq(caller(), approvedAddress))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Update with the new owner.\n            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))\n            // Decrement the balance of `from`.\n            {\n                let fromBalanceSlot := keccak256(0x0c, 0x1c)\n                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))\n            }\n            // Increment the balance of `to`.\n            {\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x1c)\n                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\n        }\n        _afterTokenTransfer(from, to, id);\n    }",
            "startLine": 250,
            "signature": "transferFrom(address,address,uint256)",
            "selector": "0x447f286d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "safeTransferFrom",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "transferFrom",
                "type": "internal"
              },
              {
                "target": "_hasCode",
                "type": "internal"
              },
              {
                "target": "_checkOnERC721Received",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\n        transferFrom(from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \"\");\n    }",
            "startLine": 311,
            "signature": "safeTransferFrom(address,address,uint256)",
            "selector": "0x0f33b3fa",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "safeTransferFrom",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "transferFrom",
                "type": "internal"
              },
              {
                "target": "_hasCode",
                "type": "internal"
              },
              {
                "target": "_checkOnERC721Received",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\n        public\n        payable\n        virtual\n    {\n        transferFrom(from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }",
            "startLine": 328,
            "signature": "safeTransferFrom(address,address,uint256,bytes)",
            "selector": "0x0b95ae67",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "supportsInterface",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\n        }\n    }",
            "startLine": 340,
            "signature": "supportsInterface(bytes4)",
            "selector": "0x4ba9e2f3",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_exists",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _exists(uint256 id) internal view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := iszero(iszero(shl(96, sload(add(id, add(id, keccak256(0x00, 0x20)))))))\n        }\n    }",
            "startLine": 354,
            "visibility": "internal"
          },
          {
            "name": "_ownerOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _ownerOf(uint256 id) internal view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := shr(96, shl(96, sload(add(id, add(id, keccak256(0x00, 0x20))))))\n        }\n    }",
            "startLine": 365,
            "visibility": "internal"
          },
          {
            "name": "_getAux",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint224"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _getAux(address owner) internal view virtual returns (uint224 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            result := shr(32, sload(keccak256(0x0c, 0x1c)))\n        }\n    }",
            "startLine": 384,
            "visibility": "internal"
          },
          {
            "name": "_setAux",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint224"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _setAux(address owner, uint224 value) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            let balanceSlot := keccak256(0x0c, 0x1c)\n            let packed := sload(balanceSlot)\n            sstore(balanceSlot, xor(packed, shl(32, xor(value, shr(32, packed)))))\n        }\n    }",
            "startLine": 396,
            "visibility": "internal"
          },
          {
            "name": "_getExtraData",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint96"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _getExtraData(uint256 id) internal view virtual returns (uint96 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := shr(160, sload(add(id, add(id, keccak256(0x00, 0x20)))))\n        }\n    }",
            "startLine": 410,
            "visibility": "internal"
          },
          {
            "name": "_setExtraData",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint96"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _setExtraData(uint256 id, uint96 value) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let packed := sload(ownershipSlot)\n            sstore(ownershipSlot, xor(packed, shl(160, xor(value, shr(160, packed)))))\n        }\n    }",
            "startLine": 422,
            "visibility": "internal"
          },
          {
            "name": "_mint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _mint(address to, uint256 id) internal virtual {\n        _beforeTokenTransfer(address(0), to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            to := shr(96, shl(96, to))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            // Revert if the token already exists.\n            if shl(96, ownershipPacked) {\n                mstore(0x00, 0xc991cbb1) // `TokenAlreadyExists()`.\n                revert(0x1c, 0x04)\n            }\n            // Update with the owner.\n            sstore(ownershipSlot, or(ownershipPacked, to))\n            // Increment the balance of the owner.\n            {\n                mstore(0x00, to)\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                let balanceSlotPacked := add(sload(balanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(balanceSlot, balanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)\n        }\n        _afterTokenTransfer(address(0), to, id);\n    }",
            "startLine": 445,
            "visibility": "internal"
          },
          {
            "name": "_mintAndSetExtraDataUnchecked",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint96"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _mintAndSetExtraDataUnchecked(address to, uint256 id, uint96 value) internal virtual {\n        _beforeTokenTransfer(address(0), to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            to := shr(96, shl(96, to))\n            // Update with the owner and extra data.\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            sstore(add(id, add(id, keccak256(0x00, 0x20))), or(shl(160, value), to))\n            // Increment the balance of the owner.\n            {\n                mstore(0x00, to)\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                let balanceSlotPacked := add(sload(balanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(balanceSlot, balanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)\n        }\n        _afterTokenTransfer(address(0), to, id);\n    }",
            "startLine": 490,
            "visibility": "internal"
          },
          {
            "name": "_safeMint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeMint",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeMint(address to, uint256 id) internal virtual {\n        _safeMint(to, id, \"\");\n    }",
            "startLine": 520,
            "visibility": "internal"
          },
          {
            "name": "_safeMint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_mint",
                "type": "internal"
              },
              {
                "target": "_hasCode",
                "type": "internal"
              },
              {
                "target": "_checkOnERC721Received",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\n        _mint(to, id);\n        if (_hasCode(to)) _checkOnERC721Received(address(0), to, id, data);\n    }",
            "startLine": 534,
            "visibility": "internal"
          },
          {
            "name": "_burn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_burn",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _burn(uint256 id) internal virtual {\n        _burn(address(0), id);\n    }",
            "startLine": 544,
            "visibility": "internal"
          },
          {
            "name": "_burn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "ownerOf",
                "type": "internal"
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _burn(address by, uint256 id) internal virtual {\n        address owner = ownerOf(id);\n        _beforeTokenTransfer(owner, address(0), id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            by := shr(96, shl(96, by))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            // Reload the owner in case it is changed in `_beforeTokenTransfer`.\n            owner := shr(96, shl(96, ownershipPacked))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // Load and check the token approval.\n            {\n                mstore(0x00, owner)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // If `by` is not the zero address, do the authorization check.\n                // Revert if the `by` is not the owner, nor approved.\n                if iszero(or(iszero(by), or(eq(by, owner), eq(by, approvedAddress)))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Clear the owner.\n            sstore(ownershipSlot, xor(ownershipPacked, owner))\n            // Decrement the balance of `owner`.\n            {\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                sstore(balanceSlot, sub(sload(balanceSlot), 1))\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, owner, 0, id)\n        }\n        _afterTokenTransfer(owner, address(0), id);\n    }",
            "startLine": 557,
            "visibility": "internal"
          },
          {
            "name": "_isApprovedOrOwner",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _isApprovedOrOwner(address account, uint256 id)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            // Clear the upper 96 bits.\n            account := shr(96, shl(96, account))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, account))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let owner := shr(96, shl(96, sload(ownershipSlot)))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // Check if `account` is the `owner`.\n            if iszero(eq(account, owner)) {\n                mstore(0x00, owner)\n                // Check if `account` is approved to manage the token.\n                if iszero(sload(keccak256(0x0c, 0x30))) {\n                    result := eq(account, sload(add(1, ownershipSlot)))\n                }\n            }\n        }\n    }",
            "startLine": 612,
            "visibility": "internal"
          },
          {
            "name": "_getApproved",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _getApproved(uint256 id) internal view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := sload(add(1, add(id, add(id, keccak256(0x00, 0x20)))))\n        }\n    }",
            "startLine": 646,
            "visibility": "internal"
          },
          {
            "name": "_approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_approve",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _approve(address account, uint256 id) internal virtual {\n        _approve(address(0), account, id);\n    }",
            "startLine": 656,
            "visibility": "internal"
          },
          {
            "name": "_approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _approve(address by, address account, uint256 id) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            account := and(bitmaskAddress, account)\n            by := and(bitmaskAddress, by)\n            // Load the owner of the token.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let owner := and(bitmaskAddress, sload(ownershipSlot))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // If `by` is not the zero address, do the authorization check.\n            // Revert if `by` is not the owner, nor approved.\n            if iszero(or(iszero(by), eq(by, owner))) {\n                mstore(0x00, owner)\n                if iszero(sload(keccak256(0x0c, 0x30))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Sets `account` as the approved account to manage `id`.\n            sstore(add(1, ownershipSlot), account)\n            // Emit the {Approval} event.\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, owner, account, id)\n        }\n    }",
            "startLine": 668,
            "visibility": "internal"
          },
          {
            "name": "_setApprovalForAll",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "isApproved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            by := shr(96, shl(96, by))\n            operator := shr(96, shl(96, operator))\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`by`, `operator`).\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))\n            mstore(0x00, by)\n            sstore(keccak256(0x0c, 0x30), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, by, operator)\n        }\n    }",
            "startLine": 705,
            "visibility": "internal"
          },
          {
            "name": "_transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _transfer(address from, address to, uint256 id) internal virtual {\n        _transfer(address(0), from, to, id);\n    }",
            "startLine": 728,
            "visibility": "internal"
          },
          {
            "name": "_transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal"
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _transfer(address by, address from, address to, uint256 id) internal virtual {\n        _beforeTokenTransfer(from, to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            from := and(bitmaskAddress, from)\n            to := and(bitmaskAddress, to)\n            by := and(bitmaskAddress, by)\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            let owner := and(bitmaskAddress, ownershipPacked)\n            // Revert if the token does not exist, or if `from` is not the owner.\n            if iszero(mul(owner, eq(owner, from))) {\n                // `TokenDoesNotExist()`, `TransferFromIncorrectOwner()`.\n                mstore(shl(2, iszero(owner)), 0xceea21b6a1148100)\n                revert(0x1c, 0x04)\n            }\n            // Load, check, and update the token approval.\n            {\n                mstore(0x00, from)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // If `by` is not the zero address, do the authorization check.\n                // Revert if the `by` is not the owner, nor approved.\n                if iszero(or(iszero(by), or(eq(by, from), eq(by, approvedAddress)))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Update with the new owner.\n            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))\n            // Decrement the balance of `from`.\n            {\n                let fromBalanceSlot := keccak256(0x0c, 0x1c)\n                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))\n            }\n            // Increment the balance of `to`.\n            {\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x1c)\n                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\n        }\n        _afterTokenTransfer(from, to, id);\n    }",
            "startLine": 743,
            "visibility": "internal"
          },
          {
            "name": "_safeTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address from, address to, uint256 id) internal virtual {\n        _safeTransfer(from, to, id, \"\");\n    }",
            "startLine": 806,
            "visibility": "internal"
          },
          {
            "name": "_safeTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transfer",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_hasCode",
                "type": "internal"
              },
              {
                "target": "_checkOnERC721Received",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address from, address to, uint256 id, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(address(0), from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }",
            "startLine": 822,
            "visibility": "internal"
          },
          {
            "name": "_safeTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address by, address from, address to, uint256 id) internal virtual {\n        _safeTransfer(by, from, to, id, \"\");\n    }",
            "startLine": 831,
            "visibility": "internal"
          },
          {
            "name": "_safeTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transfer",
                "type": "internal"
              },
              {
                "target": "_hasCode",
                "type": "internal"
              },
              {
                "target": "_checkOnERC721Received",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address by, address from, address to, uint256 id, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(by, from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }",
            "startLine": 848,
            "visibility": "internal"
          },
          {
            "name": "_beforeTokenTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _beforeTokenTransfer(address from, address to, uint256 id) internal virtual {}",
            "startLine": 861,
            "visibility": "internal"
          },
          {
            "name": "_afterTokenTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _afterTokenTransfer(address from, address to, uint256 id) internal virtual {}",
            "startLine": 864,
            "visibility": "internal"
          },
          {
            "name": "_hasCode",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "a",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _hasCode(address a) private view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := extcodesize(a) // Can handle dirty upper bits.\n        }\n    }",
            "startLine": 871,
            "visibility": "private"
          },
          {
            "name": "_checkOnERC721Received",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\n        private\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function copy(dst_, src_, n_) {\n                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {\n                    mstore(add(dst_, i_), mload(add(src_, i_)))\n                }\n            }\n            // Prepare the calldata.\n            let m := mload(0x40)\n            let onERC721ReceivedSelector := 0x150b7a02\n            mstore(m, onERC721ReceivedSelector)\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            mstore(add(m, 0x60), id)\n            mstore(add(m, 0x80), 0x80)\n            let n := mload(data)\n            mstore(add(m, 0xa0), n)\n            copy(add(m, 0xc0), add(data, 0x20), n)\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n            // Load the returndata and compare it.\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 880,
            "visibility": "private"
          }
        ],
        "events": [
          {
            "name": "Transfer",
            "parameters": [
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              }
            ]
          },
          {
            "name": "Approval",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "account",
                "type": "address",
                "indexed": true
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              }
            ]
          },
          {
            "name": "ApprovalForAll",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "operator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "isApproved",
                "type": "bool",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "NotOwnerNorApproved",
            "parameters": []
          },
          {
            "name": "TokenDoesNotExist",
            "parameters": []
          },
          {
            "name": "TokenAlreadyExists",
            "parameters": []
          },
          {
            "name": "BalanceQueryForZeroAddress",
            "parameters": []
          },
          {
            "name": "TransferToZeroAddress",
            "parameters": []
          },
          {
            "name": "TransferFromIncorrectOwner",
            "parameters": []
          },
          {
            "name": "AccountBalanceOverflow",
            "parameters": []
          },
          {
            "name": "TransferToNonERC721ReceiverImplementer",
            "parameters": []
          }
        ]
      },
      {
        "name": "CallContextChecker",
        "kind": "contract",
        "category": "core",
        "filePath": "solady/src/utils/CallContextChecker.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "_onEIP7702Authority",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _onEIP7702Authority() internal view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(address(), 0x00, 0x00, 0x20)\n            // Note: Checking that it starts with hex\"ef01\" is the most general and futureproof.\n            // 7702 bytecode is `abi.encodePacked(hex\"ef01\", uint8(version), address(delegation))`.\n            result := eq(0xef01, shr(240, mload(0x00)))\n        }\n    }",
            "startLine": 34,
            "visibility": "internal"
          },
          {
            "name": "_selfImplementation",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _selfImplementation() internal view virtual returns (address) {\n        return address(uint160(__self));\n    }",
            "startLine": 45,
            "visibility": "internal"
          },
          {
            "name": "_onImplementation",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _onImplementation() internal view virtual returns (bool) {\n        return __self == uint160(address(this));\n    }",
            "startLine": 50,
            "visibility": "internal"
          },
          {
            "name": "_checkOnlyEIP7702Authority",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_onEIP7702Authority",
                "type": "internal"
              },
              {
                "target": "_revertUnauthorizedCallContext",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOnlyEIP7702Authority() internal view virtual {\n        if (!_onEIP7702Authority()) _revertUnauthorizedCallContext();\n    }",
            "startLine": 55,
            "visibility": "internal"
          },
          {
            "name": "_checkOnlyProxy",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_onImplementation",
                "type": "internal"
              },
              {
                "target": "_revertUnauthorizedCallContext",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOnlyProxy() internal view virtual {\n        if (_onImplementation()) _revertUnauthorizedCallContext();\n    }",
            "startLine": 60,
            "visibility": "internal"
          },
          {
            "name": "_checkNotDelegated",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_onImplementation",
                "type": "internal"
              },
              {
                "target": "_revertUnauthorizedCallContext",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkNotDelegated() internal view virtual {\n        if (!_onImplementation()) _revertUnauthorizedCallContext();\n    }",
            "startLine": 66,
            "visibility": "internal"
          },
          {
            "name": "_revertUnauthorizedCallContext",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _revertUnauthorizedCallContext() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x9f03a026) // `UnauthorizedCallContext()`.\n            revert(0x1c, 0x04)\n        }\n    }",
            "startLine": 93,
            "visibility": "private"
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "UnauthorizedCallContext",
            "parameters": []
          }
        ]
      },
      {
        "name": "DeploylessPredeployQueryer",
        "kind": "contract",
        "category": "core",
        "filePath": "solady/src/utils/DeploylessPredeployQueryer.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [],
        "events": [],
        "errors": [
          {
            "name": "ReturnedAddressMismatch",
            "parameters": []
          }
        ]
      },
      {
        "name": "EIP712",
        "kind": "abstract",
        "category": "core",
        "filePath": "solady/src/utils/EIP712.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "eip712Domain",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "fields",
                "type": "bytes1"
              },
              {
                "name": "name",
                "type": "string"
              },
              {
                "name": "version",
                "type": "string"
              },
              {
                "name": "chainId",
                "type": "uint256"
              },
              {
                "name": "verifyingContract",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "extensions",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "_domainNameAndVersion",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        fields = hex\"0f\"; // `0b01111`.\n        (name, version) = _domainNameAndVersion();\n        chainId = block.chainid;\n        verifyingContract = address(this);\n        salt = salt; // `bytes32(0)`.\n        extensions = extensions; // `new uint256[](0)`.\n    }",
            "startLine": 241,
            "signature": "eip712Domain()",
            "selector": "0x49b169b1",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_domainNameAndVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "name",
                "type": "string"
              },
              {
                "name": "version",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _domainNameAndVersion()\n        internal\n        view\n        virtual\n        returns (string memory name, string memory version);",
            "startLine": 101,
            "visibility": "internal"
          },
          {
            "name": "_domainNameAndVersionMayChange",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}",
            "startLine": 110,
            "visibility": "internal"
          },
          {
            "name": "_domainSeparator",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "separator",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_domainNameAndVersionMayChange",
                "type": "internal"
              },
              {
                "target": "_buildDomainSeparator",
                "type": "internal"
              },
              {
                "target": "_cachedDomainSeparatorInvalidated",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _domainSeparator() internal view virtual returns (bytes32 separator) {\n        if (_domainNameAndVersionMayChange()) {\n            separator = _buildDomainSeparator();\n        } else {\n            separator = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\n        }\n    }",
            "startLine": 117,
            "visibility": "internal"
          },
          {
            "name": "_hashTypedData",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "structHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "digest",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_domainNameAndVersionMayChange",
                "type": "internal"
              },
              {
                "target": "_buildDomainSeparator",
                "type": "internal"
              },
              {
                "target": "_cachedDomainSeparatorInvalidated",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\n        // We will use `digest` to store the domain separator to save a bit of gas.\n        if (_domainNameAndVersionMayChange()) {\n            digest = _buildDomainSeparator();\n        } else {\n            digest = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) digest = _buildDomainSeparator();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the digest.\n            mstore(0x00, 0x1901000000000000) // Store \"\\x19\\x01\".\n            mstore(0x1a, digest) // Store the domain separator.\n            mstore(0x3a, structHash) // Store the struct hash.\n            digest := keccak256(0x18, 0x42)\n            // Restore the part of the free memory slot that was overwritten.\n            mstore(0x3a, 0)\n        }\n    }",
            "startLine": 139,
            "visibility": "internal"
          },
          {
            "name": "_hashTypedDataSansChainId",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "structHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "digest",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_domainNameAndVersion",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _hashTypedDataSansChainId(bytes32 structHash)\n        internal\n        view\n        virtual\n        returns (bytes32 digest)\n    {\n        (string memory name, string memory version) = _domainNameAndVersion();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(0x00, _DOMAIN_TYPEHASH_SANS_CHAIN_ID)\n            mstore(0x20, keccak256(add(name, 0x20), mload(name)))\n            mstore(0x40, keccak256(add(version, 0x20), mload(version)))\n            mstore(0x60, address())\n            // Compute the digest.\n            mstore(0x20, keccak256(0x00, 0x80)) // Store the domain separator.\n            mstore(0x00, 0x1901) // Store \"\\x19\\x01\".\n            mstore(0x40, structHash) // Store the struct hash.\n            digest := keccak256(0x1e, 0x42)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }",
            "startLine": 161,
            "visibility": "internal"
          },
          {
            "name": "_hashTypedDataSansChainIdAndVerifyingContract",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "structHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "digest",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_domainNameAndVersion",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _hashTypedDataSansChainIdAndVerifyingContract(bytes32 structHash)\n        internal\n        view\n        virtual\n        returns (bytes32 digest)\n    {\n        (string memory name, string memory version) = _domainNameAndVersion();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(0x00, _DOMAIN_TYPEHASH_SANS_CHAIN_ID_AND_VERIFYING_CONTRACT)\n            mstore(0x20, keccak256(add(name, 0x20), mload(name)))\n            mstore(0x40, keccak256(add(version, 0x20), mload(version)))\n            // Compute the digest.\n            mstore(0x20, keccak256(0x00, 0x60)) // Store the domain separator.\n            mstore(0x00, 0x1901) // Store \"\\x19\\x01\".\n            mstore(0x40, structHash) // Store the struct hash.\n            digest := keccak256(0x1e, 0x42)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }",
            "startLine": 187,
            "visibility": "internal"
          },
          {
            "name": "_hashTypedDataSansVerifyingContract",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "structHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "digest",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_domainNameAndVersion",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _hashTypedDataSansVerifyingContract(bytes32 structHash)\n        internal\n        view\n        virtual\n        returns (bytes32 digest)\n    {\n        (string memory name, string memory version) = _domainNameAndVersion();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(0x00, _DOMAIN_TYPEHASH_SANS_VERIFYING_CONTRACT)\n            mstore(0x20, keccak256(add(name, 0x20), mload(name)))\n            mstore(0x40, keccak256(add(version, 0x20), mload(version)))\n            mstore(0x60, chainid())\n            // Compute the digest.\n            mstore(0x20, keccak256(0x00, 0x80)) // Store the domain separator.\n            mstore(0x00, 0x1901) // Store \"\\x19\\x01\".\n            mstore(0x40, structHash) // Store the struct hash.\n            digest := keccak256(0x1e, 0x42)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }",
            "startLine": 212,
            "visibility": "internal"
          },
          {
            "name": "_buildDomainSeparator",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "separator",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_domainNameAndVersionMayChange",
                "type": "internal"
              },
              {
                "target": "_domainNameAndVersion",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _buildDomainSeparator() private view returns (bytes32 separator) {\n        // We will use `separator` to store the name hash to save a bit of gas.\n        bytes32 versionHash;\n        if (_domainNameAndVersionMayChange()) {\n            (string memory name, string memory version) = _domainNameAndVersion();\n            separator = keccak256(bytes(name));\n            versionHash = keccak256(bytes(version));\n        } else {\n            separator = _cachedNameHash;\n            versionHash = _cachedVersionHash;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), separator) // Name hash.\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            separator := keccak256(m, 0xa0)\n        }\n    }",
            "startLine": 268,
            "visibility": "private"
          },
          {
            "name": "_cachedDomainSeparatorInvalidated",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\n        uint256 cachedChainId = _cachedChainId;\n        uint256 cachedThis = _cachedThis;\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\n        }\n    }",
            "startLine": 292,
            "visibility": "private"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "ERC1967Factory",
        "kind": "contract",
        "category": "core",
        "filePath": "solady/src/utils/ERC1967Factory.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "adminOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proxy",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "admin",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function adminOf(address proxy) public view returns (address admin) {\n        assembly {\n            admin := sload(shl(96, proxy))\n        }\n    }",
            "startLine": 77,
            "signature": "adminOf(address)",
            "selector": "0x095f9c17",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "changeAdmin",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proxy",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function changeAdmin(address proxy, address admin) public {\n        assembly {\n            // Check if the caller is the admin of the proxy.\n            if iszero(eq(sload(shl(96, proxy)), caller())) {\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n            // Store the admin for the proxy.\n            sstore(shl(96, proxy), admin)\n            // Emit the {AdminChanged} event.\n            log3(0, 0, _ADMIN_CHANGED_EVENT_SIGNATURE, proxy, admin)\n        }\n    }",
            "startLine": 85,
            "signature": "changeAdmin(address,address)",
            "selector": "0x6d51c20a",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "upgrade",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "proxy",
                "type": "address"
              },
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "upgradeAndCall",
                "type": "internal"
              },
              {
                "target": "_emptyData",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function upgrade(address proxy, address implementation) public payable {\n        upgradeAndCall(proxy, implementation, _emptyData());\n    }",
            "startLine": 105,
            "signature": "upgrade(address,address)",
            "selector": "0x7fcc6107",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "upgradeAndCall",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "proxy",
                "type": "address"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function upgradeAndCall(address proxy, address implementation, bytes calldata data)\n        public\n        payable\n    {\n        assembly {\n            // Check if the caller is the admin of the proxy.\n            if iszero(eq(sload(shl(96, proxy)), caller())) {\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n            // Set up the calldata to upgrade the proxy.\n            let m := mload(0x40)\n            mstore(m, implementation)\n            mstore(add(m, 0x20), _IMPLEMENTATION_SLOT)\n            calldatacopy(add(m, 0x40), data.offset, data.length)\n            // Try upgrading the proxy and revert upon failure.\n            if iszero(call(gas(), proxy, callvalue(), m, add(0x40, data.length), 0x00, 0x00)) {\n                // Revert with the `UpgradeFailed` selector if there is no error returndata.\n                if iszero(returndatasize()) {\n                    mstore(0x00, _UPGRADE_FAILED_ERROR_SELECTOR)\n                    revert(0x1c, 0x04)\n                }\n                // Otherwise, bubble up the returned error.\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n            // Emit the {Upgraded} event.\n            log3(0, 0, _UPGRADED_EVENT_SIGNATURE, proxy, implementation)\n        }\n    }",
            "startLine": 112,
            "signature": "upgradeAndCall(address,address,bytes)",
            "selector": "0x0f13be83",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "deploy",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "proxy",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployAndCall",
                "type": "internal"
              },
              {
                "target": "_emptyData",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function deploy(address implementation, address admin) public payable returns (address proxy) {\n        proxy = deployAndCall(implementation, admin, _emptyData());\n    }",
            "startLine": 150,
            "signature": "deploy(address,address)",
            "selector": "0x27672872",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "deployAndCall",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "proxy",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_deploy",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function deployAndCall(address implementation, address admin, bytes calldata data)\n        public\n        payable\n        returns (address proxy)\n    {\n        proxy = _deploy(implementation, admin, bytes32(0), false, data);\n    }",
            "startLine": 158,
            "signature": "deployAndCall(address,address,bytes)",
            "selector": "0x1ed86308",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "deployDeterministic",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "proxy",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployDeterministicAndCall",
                "type": "internal"
              },
              {
                "target": "_emptyData",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function deployDeterministic(address implementation, address admin, bytes32 salt)\n        public\n        payable\n        returns (address proxy)\n    {\n        proxy = deployDeterministicAndCall(implementation, admin, salt, _emptyData());\n    }",
            "startLine": 169,
            "signature": "deployDeterministic(address,address,bytes32)",
            "selector": "0x72716114",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "deployDeterministicAndCall",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "proxy",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_deploy",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function deployDeterministicAndCall(\n        address implementation,\n        address admin,\n        bytes32 salt,\n        bytes calldata data\n    ) public payable returns (address proxy) {\n        assembly {\n            // If the salt does not start with the zero address or the caller.\n            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {\n                mstore(0x00, _SALT_DOES_NOT_START_WITH_CALLER_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n        proxy = _deploy(implementation, admin, salt, true, data);\n    }",
            "startLine": 181,
            "signature": "deployDeterministicAndCall(address,address,bytes32,bytes)",
            "selector": "0x2c1a9492",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "predictDeterministicAddress",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "initCodeHash",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddress(bytes32 salt) public view returns (address predicted) {\n        bytes32 hash = initCodeHash();\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            // Note: `predicted` has dirty upper 96 bits. We won't clean it here\n            // as it will be automatically cleaned when it is copied into the returndata.\n            // Please clean as needed if used in other inline assembly blocks.\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }",
            "startLine": 242,
            "signature": "predictDeterministicAddress(bytes32)",
            "selector": "0x4cafd214",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "initCodeHash",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_initCode",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initCodeHash() public view returns (bytes32 result) {\n        bytes32 m = _initCode();\n        assembly {\n            result := keccak256(add(m, 0x13), 0x88)\n        }\n    }",
            "startLine": 261,
            "signature": "initCodeHash()",
            "selector": "0x142463f4",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_deploy",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "useSalt",
                "type": "bool"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "proxy",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_initCode",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _deploy(\n        address implementation,\n        address admin,\n        bytes32 salt,\n        bool useSalt,\n        bytes calldata data\n    ) internal returns (address proxy) {\n        bytes32 m = _initCode();\n        assembly {\n            // Create the proxy.\n            switch useSalt\n            case 0 { proxy := create(0, add(m, 0x13), 0x88) }\n            default { proxy := create2(0, add(m, 0x13), 0x88, salt) }\n            // Revert if the creation fails.\n            if iszero(proxy) {\n                mstore(0x00, _DEPLOYMENT_FAILED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n\n            // Set up the calldata to set the implementation of the proxy.\n            mstore(m, implementation)\n            mstore(add(m, 0x20), _IMPLEMENTATION_SLOT)\n            calldatacopy(add(m, 0x40), data.offset, data.length)\n            // Try setting the implementation on the proxy and revert upon failure.\n            if iszero(call(gas(), proxy, callvalue(), m, add(0x40, data.length), 0x00, 0x00)) {\n                // Revert with the `DeploymentFailed` selector if there is no error returndata.\n                if iszero(returndatasize()) {\n                    mstore(0x00, _DEPLOYMENT_FAILED_ERROR_SELECTOR)\n                    revert(0x1c, 0x04)\n                }\n                // Otherwise, bubble up the returned error.\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n\n            // Store the admin for the proxy.\n            sstore(shl(96, proxy), admin)\n\n            // Emit the {Deployed} event.\n            log4(0, 0, _DEPLOYED_EVENT_SIGNATURE, proxy, implementation, admin)\n        }\n    }",
            "startLine": 198,
            "visibility": "internal"
          },
          {
            "name": "_initCode",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "m",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _initCode() internal view returns (bytes32 m) {\n        assembly {\n            /**\n             * -------------------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                                   |\n             * -------------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic        | Stack               | Memory                          |\n             * -------------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize   | r                   |                                 |\n             * 3d         | RETURNDATASIZE  | 0 r                 |                                 |\n             * 81         | DUP2            | r 0 r               |                                 |\n             * 60 offset  | PUSH1 offset    | o r 0 r             |                                 |\n             * 3d         | RETURNDATASIZE  | 0 o r 0 r           |                                 |\n             * 39         | CODECOPY        | 0 r                 | [0..runSize): runtime code      |\n             * f3         | RETURN          |                     | [0..runSize): runtime code      |\n             * -------------------------------------------------------------------------------------|\n             * RUNTIME (127 bytes)                                                                  |\n             * -------------------------------------------------------------------------------------|\n             * Opcode      | Mnemonic       | Stack               | Memory                          |\n             * -------------------------------------------------------------------------------------|\n             *                                                                                      |\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | 0                   |                                 |\n             * 3d          | RETURNDATASIZE | 0 0                 |                                 |\n             *                                                                                      |\n             * ::: check if caller is factory ::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 33          | CALLER         | c 0 0               |                                 |\n             * 73 factory  | PUSH20 factory | f c 0 0             |                                 |\n             * 14          | EQ             | isf 0 0             |                                 |\n             * 60 0x57     | PUSH1 0x57     | dest isf 0 0        |                                 |\n             * 57          | JUMPI          | 0 0                 |                                 |\n             *                                                                                      |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36          | CALLDATASIZE   | cds 0 0             |                                 |\n             * 3d          | RETURNDATASIZE | 0 cds 0 0           |                                 |\n             * 3d          | RETURNDATASIZE | 0 0 cds 0 0         |                                 |\n             * 37          | CALLDATACOPY   | 0 0                 | [0..calldatasize): calldata     |\n             *                                                                                      |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36          | CALLDATASIZE   | cds 0 0             | [0..calldatasize): calldata     |\n             * 3d          | RETURNDATASIZE | 0 cds 0 0           | [0..calldatasize): calldata     |\n             * 7f slot     | PUSH32 slot    | s 0 cds 0 0         | [0..calldatasize): calldata     |\n             * 54          | SLOAD          | i 0 cds 0 0         | [0..calldatasize): calldata     |\n             * 5a          | GAS            | g i 0 cds 0 0       | [0..calldatasize): calldata     |\n             * f4          | DELEGATECALL   | succ                | [0..calldatasize): calldata     |\n             *                                                                                      |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds succ            | [0..calldatasize): calldata     |\n             * 60 0x00     | PUSH1 0x00     | 0 rds succ          | [0..calldatasize): calldata     |\n             * 80          | DUP1           | 0 0 rds succ        | [0..calldatasize): calldata     |\n             * 3e          | RETURNDATACOPY | succ                | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x52     | PUSH1 0x52     | dest succ           | [0..returndatasize): returndata |\n             * 57          | JUMPI          |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds                 | [0..returndatasize): returndata |\n             * 60 0x00     | PUSH1 0x00     | 0 rds               | [0..returndatasize): returndata |\n             * fd          | REVERT         |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b          | JUMPDEST       |                     | [0..returndatasize): returndata |\n             * 3d          | RETURNDATASIZE | rds                 | [0..returndatasize): returndata |\n             * 60 0x00     | PUSH1 0x00     | 0 rds               | [0..returndatasize): returndata |\n             * f3          | RETURN         |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: set new implementation (caller is factory) ::::::::::::::::::::::::::::::::::::: |\n             * 5b          | JUMPDEST       | 0 0                 |                                 |\n             * 3d          | RETURNDATASIZE | 0 0 0               |                                 |\n             * 35          | CALLDATALOAD   | impl 0 0            |                                 |\n             * 60 0x20     | PUSH1 0x20     | w impl 0 0          |                                 |\n             * 35          | CALLDATALOAD   | slot impl 0 0       |                                 |\n             * 55          | SSTORE         | 0 0                 |                                 |\n             *                                                                                      |\n             * ::: no extra calldata, return :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x40     | PUSH1 0x40     | 2w 0 0              |                                 |\n             * 80          | DUP1           | 2w 2w 0 0           |                                 |\n             * 36          | CALLDATASIZE   | cds 2w 2w 0 0       |                                 |\n             * 11          | GT             | gt 2w 0 0           |                                 |\n             * 15          | ISZERO         | lte 2w 0 0          |                                 |\n             * 60 0x52     | PUSH1 0x52     | dest lte 2w 0 0     |                                 |\n             * 57          | JUMPI          | 2w 0 0              |                                 |\n             *                                                                                      |\n             * ::: copy extra calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36          | CALLDATASIZE   | cds 2w 0 0          |                                 |\n             * 03          | SUB            | t 0 0               |                                 |\n             * 80          | DUP1           | t t 0 0             |                                 |\n             * 60 0x40     | PUSH1 0x40     | 2w t t 0 0          |                                 |\n             * 3d          | RETURNDATASIZE | 0 2w t t 0 0        |                                 |\n             * 37          | CALLDATACOPY   | t 0 0               | [0..t): extra calldata          |\n             *                                                                                      |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | 0 t 0 0             | [0..t): extra calldata          |\n             * 3d          | RETURNDATASIZE | 0 0 t 0 0           | [0..t): extra calldata          |\n             * 35          | CALLDATALOAD   | i 0 t 0 0           | [0..t): extra calldata          |\n             * 5a          | GAS            | g i 0 t 0 0         | [0..t): extra calldata          |\n             * f4          | DELEGATECALL   | succ                | [0..t): extra calldata          |\n             *                                                                                      |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds succ            | [0..t): extra calldata          |\n             * 60 0x00     | PUSH1 0x00     | 0 rds succ          | [0..t): extra calldata          |\n             * 80          | DUP1           | 0 0 rds succ        | [0..t): extra calldata          |\n             * 3e          | RETURNDATACOPY | succ                | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x52     | PUSH1 0x52     | dest succ           | [0..returndatasize): returndata |\n             * 57          | JUMPI          |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds                 | [0..returndatasize): returndata |\n             * 60 0x00     | PUSH1 0x00     | 0 rds               | [0..returndatasize): returndata |\n             * fd          | REVERT         |                     | [0..returndatasize): returndata |\n             * -------------------------------------------------------------------------------------+\n             */\n            m := mload(0x40)\n            // forgefmt: disable-start\n            switch shr(112, address())\n            case 0 {\n                // If the factory's address has six or more leading zero bytes.\n                mstore(add(m, 0x75), 0x604c573d6000fd) // 7\n                mstore(add(m, 0x6e), 0x3d3560203555604080361115604c5736038060403d373d3d355af43d6000803e) // 32\n                mstore(add(m, 0x4e), 0x3735a920a3ca505d382bbc545af43d6000803e604c573d6000fd5b3d6000f35b) // 32\n                mstore(add(m, 0x2e), 0x14605157363d3d37363d7f360894a13ba1a3210667c828492db98dca3e2076cc) // 32\n                mstore(add(m, 0x0e), address()) // 14\n                mstore(m, 0x60793d8160093d39f33d3d336d) // 9 + 4\n            }\n            default {\n                mstore(add(m, 0x7b), 0x6052573d6000fd) // 7\n                mstore(add(m, 0x74), 0x3d356020355560408036111560525736038060403d373d3d355af43d6000803e) // 32\n                mstore(add(m, 0x54), 0x3735a920a3ca505d382bbc545af43d6000803e6052573d6000fd5b3d6000f35b) // 32\n                mstore(add(m, 0x34), 0x14605757363d3d37363d7f360894a13ba1a3210667c828492db98dca3e2076cc) // 32\n                mstore(add(m, 0x14), address()) // 20\n                mstore(m, 0x607f3d8160093d39f33d3d3373) // 9 + 4\n            }\n            // forgefmt: disable-end\n        }\n    }",
            "startLine": 269,
            "visibility": "internal"
          },
          {
            "name": "_emptyData",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _emptyData() internal pure returns (bytes calldata data) {\n        assembly {\n            data.length := 0\n        }\n    }",
            "startLine": 413,
            "visibility": "internal"
          }
        ],
        "events": [
          {
            "name": "AdminChanged",
            "parameters": [
              {
                "name": "proxy",
                "type": "address",
                "indexed": true
              },
              {
                "name": "admin",
                "type": "address",
                "indexed": true
              }
            ]
          },
          {
            "name": "Upgraded",
            "parameters": [
              {
                "name": "proxy",
                "type": "address",
                "indexed": true
              },
              {
                "name": "implementation",
                "type": "address",
                "indexed": true
              }
            ]
          },
          {
            "name": "Deployed",
            "parameters": [
              {
                "name": "proxy",
                "type": "address",
                "indexed": true
              },
              {
                "name": "implementation",
                "type": "address",
                "indexed": true
              },
              {
                "name": "admin",
                "type": "address",
                "indexed": true
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "Unauthorized",
            "parameters": []
          },
          {
            "name": "DeploymentFailed",
            "parameters": []
          },
          {
            "name": "UpgradeFailed",
            "parameters": []
          },
          {
            "name": "SaltDoesNotStartWithCaller",
            "parameters": []
          }
        ]
      },
      {
        "name": "Initializable",
        "kind": "abstract",
        "category": "core",
        "filePath": "solady/src/utils/Initializable.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "_initializableSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableSlot() internal pure virtual returns (bytes32) {\n        return _INITIALIZABLE_SLOT;\n    }",
            "startLine": 57,
            "visibility": "internal"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_initializableSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(and(1, sload(s))) {\n                mstore(0x00, 0xd7e6bcf8) // `NotInitializing()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 141,
            "visibility": "internal"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_initializableSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let i := sload(s)\n            if and(i, 1) {\n                mstore(0x00, 0xf92ee8a9) // `InvalidInitialization()`.\n                revert(0x1c, 0x04)\n            }\n            let uint64max := 0xffffffffffffffff\n            if iszero(eq(shr(1, i), uint64max)) {\n                // Set `initializing` to 0, `initializedVersion` to `2**64 - 1`.\n                sstore(s, shl(1, uint64max))\n                // Emit the {Initialized} event.\n                mstore(0x20, uint64max)\n                log1(0x20, 0x20, _INITIALIZED_EVENT_SIGNATURE)\n            }\n        }\n    }",
            "startLine": 159,
            "visibility": "internal"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "version",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_initializableSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _getInitializedVersion() internal view virtual returns (uint64 version) {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            version := shr(1, sload(s))\n        }\n    }",
            "startLine": 180,
            "visibility": "internal"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_initializableSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _isInitializing() internal view virtual returns (bool result) {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(1, sload(s))\n        }\n    }",
            "startLine": 189,
            "visibility": "internal"
          }
        ],
        "events": [
          {
            "name": "Initialized",
            "parameters": [
              {
                "name": "version",
                "type": "uint64",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "InvalidInitialization",
            "parameters": []
          },
          {
            "name": "NotInitializing",
            "parameters": []
          }
        ]
      },
      {
        "name": "Lifebuoy",
        "kind": "contract",
        "category": "core",
        "filePath": "solady/src/utils/Lifebuoy.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "rescueETH",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function rescueETH(address to, uint256 amount)\n        public\n        payable\n        virtual\n        onlyRescuer(_LIFEBUOY_RESCUE_ETH_LOCK)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0x7ec62e76) // `RescueTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 133,
            "signature": "rescueETH(address,uint256)",
            "selector": "0x3757df2a",
            "visibility": "public",
            "modifiers": [
              "onlyRescuer"
            ]
          },
          {
            "name": "rescueERC20",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function rescueERC20(address token, address to, uint256 amount)\n        public\n        payable\n        virtual\n        onlyRescuer(_LIFEBUOY_RESCUE_ERC20_LOCK)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            // `RescueTransferFailed()` and `transfer(address,uint256)`.\n            mstore(0x00, shl(96, 0x7ec62e76a9059cbb))\n            if iszero(call(gas(), token, callvalue(), 0x10, 0x44, codesize(), 0x00)) {\n                revert(0x0c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }",
            "startLine": 150,
            "signature": "rescueERC20(address,address,uint256)",
            "selector": "0x3fb93707",
            "visibility": "public",
            "modifiers": [
              "onlyRescuer"
            ]
          },
          {
            "name": "rescueERC721",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function rescueERC721(address token, address to, uint256 id)\n        public\n        payable\n        virtual\n        onlyRescuer(_LIFEBUOY_RESCUE_ERC721_LOCK)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, id) // Store the `id` argument.\n            mstore(0x40, shr(96, shl(96, to))) // Store the `to` argument.\n            mstore(0x20, address()) // Store the `from` argument.\n            // `RescueTransferFailed()` and `transferFrom(address,address,uint256)`.\n            mstore(0x00, 0x7ec62e7623b872dd)\n            if iszero(call(gas(), token, callvalue(), 0x1c, 0x64, codesize(), 0x00)) {\n                revert(0x18, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 171,
            "signature": "rescueERC721(address,address,uint256)",
            "selector": "0x0ab0bb8b",
            "visibility": "public",
            "modifiers": [
              "onlyRescuer"
            ]
          },
          {
            "name": "rescueERC1155",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function rescueERC1155(\n        address token,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public payable virtual onlyRescuer(_LIFEBUOY_RESCUE_ERC1155_LOCK) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            // `RescueTransferFailed()` and `safeTransferFrom(address,address,uint256,uint256,bytes)`.\n            mstore(m, 0x7ec62e76f242432a)\n            mstore(add(0x20, m), address()) // Store the `from` argument.\n            mstore(add(0x40, m), shr(96, shl(96, to))) // Store the `to` argument.\n            mstore(add(0x60, m), id) // Store the `id` argument.\n            mstore(add(0x80, m), amount) // Store the `amount` argument.\n            mstore(add(0xa0, m), 0xa0) // Store the offset to `data`.\n            mstore(add(0xc0, m), data.length)\n            calldatacopy(add(m, 0xe0), data.offset, data.length)\n            // forgefmt: disable-next-item\n            if iszero(\n                call(gas(), token, callvalue(), add(m, 0x1c), add(0xc4, data.length), codesize(), 0x00)\n            ) { revert(add(m, 0x18), 0x04) }\n        }\n    }",
            "startLine": 195,
            "signature": "rescueERC1155(address,address,uint256,uint256,bytes)",
            "selector": "0x3c4de2f9",
            "visibility": "public",
            "modifiers": [
              "onlyRescuer"
            ]
          },
          {
            "name": "rescueERC6909",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function rescueERC6909(address token, address to, uint256 id, uint256 amount)\n        public\n        payable\n        virtual\n        onlyRescuer(_LIFEBUOY_RESCUE_ERC6909_LOCK)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, id) // Store the `id` argument.\n            mstore(0x54, amount) // Store the `amount` argument.\n            // `RescueTransferFailed()` and `transfer(address,uint256,uint256)`.\n            mstore(0x00, shl(96, 0x7ec62e76095bcdb6))\n            if iszero(call(gas(), token, callvalue(), 0x10, 0x64, codesize(), 0x00)) {\n                revert(0x0c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 223,
            "signature": "rescueERC6909(address,address,uint256,uint256)",
            "selector": "0x41280c4c",
            "visibility": "public",
            "modifiers": [
              "onlyRescuer"
            ]
          },
          {
            "name": "rescueLocked",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "locks",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function rescueLocked() public view virtual returns (uint256 locks) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            locks := sload(_RESCUE_LOCKED_FLAGS_SLOT)\n        }\n    }",
            "startLine": 251,
            "signature": "rescueLocked()",
            "selector": "0x51f4443e",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "lockRescue",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "locksToSet",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_lockRescue",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function lockRescue(uint256 locksToSet)\n        public\n        payable\n        virtual\n        onlyRescuer(_LIFEBUOY_LOCK_RESCUE_LOCK)\n    {\n        _lockRescue(locksToSet);\n    }",
            "startLine": 259,
            "signature": "lockRescue(uint256)",
            "selector": "0x02da11da",
            "visibility": "public",
            "modifiers": [
              "onlyRescuer"
            ]
          }
        ],
        "internalFunctions": [
          {
            "name": "_lifebuoyDefaultDeployer",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _lifebuoyDefaultDeployer() internal view virtual returns (address) {\n        // I know about EIP7645, and I will stop it if it gets traction.\n        // Worse case, I will add an `ecrecover` method. But not today.\n        return tx.origin;\n    }",
            "startLine": 121,
            "visibility": "internal"
          },
          {
            "name": "_lockRescue",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "locksToSet",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _lockRescue(uint256 locksToSet) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := _RESCUE_LOCKED_FLAGS_SLOT\n            sstore(s, or(sload(s), locksToSet))\n        }\n    }",
            "startLine": 269,
            "visibility": "internal"
          },
          {
            "name": "_checkRescuer",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "modeLock",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "rescueLocked",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkRescuer(uint256 modeLock) internal view virtual {\n        uint256 locks = rescueLocked();\n        bytes32 h = _lifebuoyDeployerHash;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                // If the `modeLock` flag is true, set all bits in `locks` to true.\n                locks := or(sub(0, iszero(iszero(and(modeLock, locks)))), locks)\n                // Caller is the deployer\n                // AND the contract is not a proxy\n                // AND `locks & _LIFEBUOY_DEPLOYER_ACCESS_LOCK` is false.\n                mstore(0x20, caller())\n                mstore(and(locks, _LIFEBUOY_DEPLOYER_ACCESS_LOCK), address())\n                if eq(keccak256(0x00, 0x40), h) { break }\n                // If the caller is `owner()`\n                // AND `locks & _LIFEBUOY_OWNER_ACCESS_LOCK` is false.\n                mstore(0x08, 0x8da5cb5b0a0362e0) // `owner()` and `RescueUnauthorizedOrLocked()`.\n                if and( // The arguments of `and` are evaluated from right to left.\n                    lt(\n                        and(locks, _LIFEBUOY_OWNER_ACCESS_LOCK),\n                        and(gt(returndatasize(), 0x1f), eq(mload(0x00), caller()))\n                    ),\n                    staticcall(gas(), address(), 0x20, 0x04, 0x00, 0x20)\n                ) { break }\n                revert(0x24, 0x04)\n            }\n        }\n    }",
            "startLine": 282,
            "visibility": "internal"
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "RescueUnauthorizedOrLocked",
            "parameters": []
          },
          {
            "name": "RescueTransferFailed",
            "parameters": []
          }
        ]
      },
      {
        "name": "Multicallable",
        "kind": "abstract",
        "category": "core",
        "filePath": "solady/src/utils/Multicallable.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "multicall",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "data",
                "type": "bytes[]"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes[]"
              }
            ],
            "calls": [
              {
                "target": "_multicallDirectReturn",
                "type": "internal"
              },
              {
                "target": "_multicall",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function multicall(bytes[] calldata data) public payable virtual returns (bytes[] memory) {\n        // Revert if `msg.value` is non-zero by default to guard against double-spending.\n        // (See: https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong)\n        //\n        // If you really need to pass in a `msg.value`, then you will have to\n        // override this function and add in any relevant before and after checks.\n        if (msg.value != 0) revert();\n        // `_multicallDirectReturn` returns the results directly and terminates the call context.\n        _multicallDirectReturn(_multicall(data));\n    }",
            "startLine": 28,
            "signature": "multicall(bytes[])",
            "selector": "0x2972e453",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_multicall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "data",
                "type": "bytes[]"
              }
            ],
            "returnValues": [
              {
                "name": "results",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _multicall(bytes[] calldata data) internal virtual returns (bytes32 results) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            results := mload(0x40)\n            mstore(results, 0x20)\n            mstore(add(0x20, results), data.length)\n            let c := add(0x40, results)\n            let s := c\n            let end := shl(5, data.length)\n            calldatacopy(c, data.offset, end)\n            end := add(c, end)\n            let m := end\n            if data.length {\n                for {} 1 {} {\n                    let o := add(data.offset, mload(c))\n                    calldatacopy(m, add(o, 0x20), calldataload(o))\n                    // forgefmt: disable-next-item\n                    if iszero(delegatecall(gas(), address(), m, calldataload(o), codesize(), 0x00)) {\n                        // Bubble up the revert if the delegatecall reverts.\n                        returndatacopy(results, 0x00, returndatasize())\n                        revert(results, returndatasize())\n                    }\n                    mstore(c, sub(m, s))\n                    c := add(0x20, c)\n                    // Append the `returndatasize()`, and the return data.\n                    mstore(m, returndatasize())\n                    let b := add(m, 0x20)\n                    returndatacopy(b, 0x00, returndatasize())\n                    // Advance `m` by `returndatasize() + 0x20`,\n                    // rounded up to the next multiple of 32.\n                    m := and(add(add(b, returndatasize()), 0x1f), 0xffffffffffffffe0)\n                    mstore(add(b, returndatasize()), 0) // Zeroize the slot after the returndata.\n                    if iszero(lt(c, end)) { break }\n                }\n            }\n            mstore(0x40, m) // Allocate memory.\n            results := or(shl(64, sub(m, results)), results) // Pack the bytes length into `results`.\n        }\n    }",
            "startLine": 42,
            "visibility": "internal"
          },
          {
            "name": "_multicallResultsToBytesArray",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "results",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "decoded",
                "type": "bytes[]"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _multicallResultsToBytesArray(bytes32 results)\n        internal\n        pure\n        virtual\n        returns (bytes[] memory decoded)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            decoded := mload(0x40)\n            let c := and(0xffffffffffffffff, results) // Extract the offset.\n            mstore(decoded, mload(add(c, 0x20))) // Store the length.\n            let o := add(decoded, 0x20) // Start of elements in `decoded`.\n            let end := add(o, shl(5, mload(decoded)))\n            mstore(0x40, end) // Allocate memory.\n            let s := add(c, 0x40) // Start of elements in `results`.\n            let d := sub(s, o) // Difference between input and output pointers.\n            for {} iszero(eq(o, end)) { o := add(o, 0x20) } { mstore(o, add(mload(add(d, o)), s)) }\n        }\n    }",
            "startLine": 84,
            "visibility": "internal"
          },
          {
            "name": "_multicallDirectReturn",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "results",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _multicallDirectReturn(bytes32 results) internal pure virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            return(and(0xffffffffffffffff, results), shr(64, results))\n        }\n    }",
            "startLine": 106,
            "visibility": "internal"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "ReentrancyGuard",
        "kind": "abstract",
        "category": "core",
        "filePath": "solady/src/utils/ReentrancyGuard.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [],
        "events": [],
        "errors": [
          {
            "name": "Reentrancy",
            "parameters": []
          }
        ]
      },
      {
        "name": "ReentrancyGuardTransient",
        "kind": "abstract",
        "category": "core",
        "filePath": "solady/src/utils/ReentrancyGuardTransient.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "_useTransientReentrancyGuardOnlyOnMainnet",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _useTransientReentrancyGuardOnlyOnMainnet() internal view virtual returns (bool) {\n        return true;\n    }",
            "startLine": 120,
            "visibility": "internal"
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "Reentrancy",
            "parameters": []
          }
        ]
      },
      {
        "name": "UUPSUpgradeable",
        "kind": "abstract",
        "category": "proxy",
        "filePath": "solady/src/utils/UUPSUpgradeable.sol",
        "inherits": [
          "CallContextChecker"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "proxiableUUID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function proxiableUUID() public view virtual notDelegated returns (bytes32) {\n        // This function must always return `_ERC1967_IMPLEMENTATION_SLOT` to comply with ERC1967.\n        return _ERC1967_IMPLEMENTATION_SLOT;\n    }",
            "startLine": 60,
            "signature": "proxiableUUID()",
            "selector": "0x69a47b4c",
            "visibility": "public",
            "modifiers": [
              "notDelegated"
            ]
          },
          {
            "name": "upgradeToAndCall",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "newImplementation",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_authorizeUpgrade",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function upgradeToAndCall(address newImplementation, bytes calldata data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _authorizeUpgrade(newImplementation);\n        /// @solidity memory-safe-assembly\n        assembly {\n            newImplementation := shr(96, shl(96, newImplementation)) // Clears upper 96 bits.\n            mstore(0x00, returndatasize())\n            mstore(0x01, 0x52d1902d) // `proxiableUUID()`.\n            let s := _ERC1967_IMPLEMENTATION_SLOT\n            // Check if `newImplementation` implements `proxiableUUID` correctly.\n            if iszero(eq(mload(staticcall(gas(), newImplementation, 0x1d, 0x04, 0x01, 0x20)), s)) {\n                mstore(0x01, 0x55299b49) // `UpgradeFailed()`.\n                revert(0x1d, 0x04)\n            }\n            // Emit the {Upgraded} event.\n            log2(codesize(), 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)\n            sstore(s, newImplementation) // Updates the implementation.\n\n            // Perform a delegatecall to `newImplementation` if `data` is non-empty.\n            if data.length {\n                // Forwards the `data` to `newImplementation` via delegatecall.\n                let m := mload(0x40)\n                calldatacopy(m, data.offset, data.length)\n                if iszero(delegatecall(gas(), newImplementation, m, data.length, codesize(), 0x00))\n                {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n        }\n    }",
            "startLine": 69,
            "signature": "upgradeToAndCall(address,bytes)",
            "selector": "0x3c165d20",
            "visibility": "public",
            "modifiers": [
              "onlyProxy"
            ]
          }
        ],
        "internalFunctions": [
          {
            "name": "_authorizeUpgrade",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newImplementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _authorizeUpgrade(address newImplementation) internal virtual;",
            "startLine": 53,
            "visibility": "internal"
          }
        ],
        "events": [
          {
            "name": "Upgraded",
            "parameters": [
              {
                "name": "implementation",
                "type": "address",
                "indexed": true
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "UpgradeFailed",
            "parameters": []
          }
        ],
        "proxyPattern": "uups",
        "proxyRole": "implementation",
        "proxyGroupId": "proxy-group-0"
      },
      {
        "name": "UpgradeableBeacon",
        "kind": "contract",
        "category": "proxy",
        "filePath": "solady/src/utils/UpgradeableBeacon.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "implementation",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function implementation() public view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_UPGRADEABLE_BEACON_IMPLEMENTATION_SLOT)\n        }\n    }",
            "startLine": 132,
            "signature": "implementation()",
            "selector": "0x5a6673cd",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function owner() public view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_UPGRADEABLE_BEACON_OWNER_SLOT)\n        }\n    }",
            "startLine": 140,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "upgradeTo",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newImplementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setImplementation",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n    }",
            "startLine": 148,
            "signature": "upgradeTo(address)",
            "selector": "0x58a12b06",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setOwner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }",
            "startLine": 153,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "renounceOwnership",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_setOwner",
                "type": "internal"
              },
              {
                "target": "address",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }",
            "startLine": 165,
            "signature": "renounceOwnership()",
            "selector": "0x765becbf",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          }
        ],
        "internalFunctions": [
          {
            "name": "_constructUpgradeableBeacon",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              },
              {
                "name": "initialImplementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initializeUpgradeableBeacon",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _constructUpgradeableBeacon(address initialOwner, address initialImplementation)\n        internal\n        virtual\n    {\n        _initializeUpgradeableBeacon(initialOwner, initialImplementation);\n    }",
            "startLine": 80,
            "visibility": "internal"
          },
          {
            "name": "_initializeUpgradeableBeacon",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              },
              {
                "name": "initialImplementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setOwner",
                "type": "internal"
              },
              {
                "target": "_setImplementation",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializeUpgradeableBeacon(address initialOwner, address initialImplementation)\n        internal\n        virtual\n    {\n        // We don't need to check if `initialOwner` is the zero address here,\n        // as some use cases may not want the beacon to be owned.\n        _setOwner(initialOwner);\n        _setImplementation(initialImplementation);\n    }",
            "startLine": 93,
            "visibility": "internal"
          },
          {
            "name": "_setImplementation",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newImplementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _setImplementation(address newImplementation) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            newImplementation := shr(96, shl(96, newImplementation)) // Clean the upper 96 bits.\n            if iszero(extcodesize(newImplementation)) {\n                mstore(0x00, 0x6d3e283b) // `NewImplementationHasNoCode()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(_UPGRADEABLE_BEACON_IMPLEMENTATION_SLOT, newImplementation) // Store the implementation.\n            // Emit the {Upgraded} event.\n            log2(codesize(), 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)\n        }\n    }",
            "startLine": 104,
            "visibility": "internal"
          },
          {
            "name": "_setOwner",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _setOwner(address newOwner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            newOwner := shr(96, shl(96, newOwner)) // Clean the upper 96 bits.\n            let oldOwner := sload(_UPGRADEABLE_BEACON_OWNER_SLOT)\n            sstore(_UPGRADEABLE_BEACON_OWNER_SLOT, newOwner) // Store the owner.\n            // Emit the {OwnershipTransferred} event.\n            log3(codesize(), 0x00, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, oldOwner, newOwner)\n        }\n    }",
            "startLine": 119,
            "visibility": "internal"
          },
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_UPGRADEABLE_BEACON_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 170,
            "visibility": "internal"
          }
        ],
        "events": [
          {
            "name": "Upgraded",
            "parameters": [
              {
                "name": "implementation",
                "type": "address",
                "indexed": true
              }
            ]
          },
          {
            "name": "OwnershipTransferred",
            "parameters": [
              {
                "name": "oldOwner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "newOwner",
                "type": "address",
                "indexed": true
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "NewImplementationHasNoCode",
            "parameters": []
          },
          {
            "name": "Unauthorized",
            "parameters": []
          },
          {
            "name": "NewOwnerIsZeroAddress",
            "parameters": []
          }
        ],
        "proxyPattern": "uups",
        "proxyRole": "proxy",
        "proxyGroupId": "proxy-group-0"
      },
      {
        "name": "ERC1967BeaconProxy",
        "kind": "contract",
        "category": "proxy",
        "filePath": "solady/src/utils/ext/zksync/ERC1967BeaconProxy.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [],
        "events": [
          {
            "name": "BeaconUpgraded",
            "parameters": [
              {
                "name": "beacon",
                "type": "address",
                "indexed": true
              }
            ]
          }
        ],
        "errors": []
      },
      {
        "name": "ERC1967Factory",
        "kind": "contract",
        "category": "core",
        "filePath": "solady/src/utils/ext/zksync/ERC1967Factory.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "adminOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "admin",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function adminOf(address instance) public view returns (address admin) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            admin := mul(sload(instance), gt(instance, 0xff))\n        }\n    }",
            "startLine": 111,
            "signature": "adminOf(address)",
            "selector": "0x095f9c17",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "changeAdmin",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [
              "AdminChanged"
            ],
            "isVirtual": false,
            "sourceCode": "function changeAdmin(address instance, address admin) public {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(sload(instance), caller())) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(instance, admin)\n        }\n        emit AdminChanged(instance, admin);\n    }",
            "startLine": 121,
            "signature": "changeAdmin(address,address)",
            "selector": "0x6d51c20a",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "upgrade",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "upgradeAndCall",
                "type": "internal"
              },
              {
                "target": "_emptyData",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function upgrade(address instance, address implementation) public payable {\n        upgradeAndCall(instance, implementation, _emptyData());\n    }",
            "startLine": 140,
            "signature": "upgrade(address,address)",
            "selector": "0x7fcc6107",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "upgradeAndCall",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [
              "Upgraded"
            ],
            "isVirtual": false,
            "sourceCode": "function upgradeAndCall(address instance, address implementation, bytes calldata data)\n        public\n        payable\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(sload(instance), caller())) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n            let m := mload(0x40)\n            mstore(m, implementation)\n            calldatacopy(add(m, 0x20), data.offset, data.length)\n            if iszero(call(gas(), instance, callvalue(), m, add(0x20, data.length), 0x00, 0x00)) {\n                if iszero(returndatasize()) {\n                    mstore(0x00, 0x55299b49) // `UpgradeFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n        }\n        emit Upgraded(instance, implementation);\n    }",
            "startLine": 148,
            "signature": "upgradeAndCall(address,address,bytes)",
            "selector": "0x0f13be83",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "deployProxy",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployProxyAndCall",
                "type": "internal"
              },
              {
                "target": "_emptyData",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function deployProxy(address implementation, address admin) public payable returns (address) {\n        return deployProxyAndCall(implementation, admin, _emptyData());\n    }",
            "startLine": 179,
            "signature": "deployProxy(address,address)",
            "selector": "0x778b42ae",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "deployProxyAndCall",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_deploy",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function deployProxyAndCall(address implementation, address admin, bytes calldata data)\n        public\n        payable\n        returns (address)\n    {\n        return _deploy(0, uint160(implementation), uint160(admin), \"\", false, data);\n    }",
            "startLine": 186,
            "signature": "deployProxyAndCall(address,address,bytes)",
            "selector": "0x37daf418",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "deployProxyDeterministic",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployProxyDeterministicAndCall",
                "type": "internal"
              },
              {
                "target": "_emptyData",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function deployProxyDeterministic(address implementation, address admin, bytes32 salt)\n        public\n        payable\n        returns (address)\n    {\n        return deployProxyDeterministicAndCall(implementation, admin, salt, _emptyData());\n    }",
            "startLine": 197,
            "signature": "deployProxyDeterministic(address,address,bytes32)",
            "selector": "0x306b9834",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "deployProxyDeterministicAndCall",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_deploy",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function deployProxyDeterministicAndCall(\n        address implementation,\n        address admin,\n        bytes32 salt,\n        bytes calldata data\n    ) public payable returns (address) {\n        return _deploy(0, uint160(implementation), uint160(admin), salt, true, data);\n    }",
            "startLine": 209,
            "signature": "deployProxyDeterministicAndCall(address,address,bytes32,bytes)",
            "selector": "0x566af172",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "deployBeacon",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_deploy",
                "type": "internal"
              },
              {
                "target": "_emptyData",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function deployBeacon(address implementation, address admin) public returns (address) {\n        return _deploy(1, uint160(implementation), uint160(admin), \"\", false, _emptyData());\n    }",
            "startLine": 223,
            "signature": "deployBeacon(address,address)",
            "selector": "0x189854ea",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "deployBeaconDeterministic",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_deploy",
                "type": "internal"
              },
              {
                "target": "_emptyData",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function deployBeaconDeterministic(address implementation, address admin, bytes32 salt)\n        public\n        payable\n        returns (address)\n    {\n        return _deploy(1, uint160(implementation), uint160(admin), salt, true, _emptyData());\n    }",
            "startLine": 229,
            "signature": "deployBeaconDeterministic(address,address,bytes32)",
            "selector": "0x371e5310",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "deployBeaconProxy",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployBeaconProxyAndCall",
                "type": "internal"
              },
              {
                "target": "_emptyData",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function deployBeaconProxy(address beacon) public payable returns (address) {\n        return deployBeaconProxyAndCall(beacon, _emptyData());\n    }",
            "startLine": 243,
            "signature": "deployBeaconProxy(address)",
            "selector": "0x1113b6e6",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "deployBeaconProxyAndCall",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_deploy",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function deployBeaconProxyAndCall(address beacon, bytes calldata data)\n        public\n        payable\n        returns (address)\n    {\n        return _deploy(2, uint160(beacon), 0, \"\", false, data);\n    }",
            "startLine": 250,
            "signature": "deployBeaconProxyAndCall(address,bytes)",
            "selector": "0x1a9fbf8c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "deployBeaconProxyDeterministic",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployBeaconProxyDeterministicAndCall",
                "type": "internal"
              },
              {
                "target": "_emptyData",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function deployBeaconProxyDeterministic(address beacon, bytes32 salt)\n        public\n        payable\n        returns (address)\n    {\n        return deployBeaconProxyDeterministicAndCall(beacon, salt, _emptyData());\n    }",
            "startLine": 261,
            "signature": "deployBeaconProxyDeterministic(address,bytes32)",
            "selector": "0x6ef5a070",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "deployBeaconProxyDeterministicAndCall",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_deploy",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function deployBeaconProxyDeterministicAndCall(\n        address beacon,\n        bytes32 salt,\n        bytes calldata data\n    ) public payable returns (address) {\n        return _deploy(2, uint160(beacon), 0, salt, true, data);\n    }",
            "startLine": 273,
            "signature": "deployBeaconProxyDeterministicAndCall(address,bytes32,bytes)",
            "selector": "0x6e16a506",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "predictDeterministicAddress",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instanceHash",
                "type": "bytes32"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_predictDeterministicAddressZKsync",
                "type": "internal"
              },
              {
                "target": "_predictDeterministicAddressRegularEVM",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddress(bytes32 instanceHash, bytes32 salt)\n        public\n        view\n        returns (address)\n    {\n        if (_useZKsyncCreate2Prediction) {\n            return _predictDeterministicAddressZKsync(instanceHash, salt);\n        }\n        return _predictDeterministicAddressRegularEVM(instanceHash, salt);\n    }",
            "startLine": 287,
            "signature": "predictDeterministicAddress(bytes32,bytes32)",
            "selector": "0x6772784e",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "implementationOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_extcodehash",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function implementationOf(address instance) public view returns (address result) {\n        bytes32 h = _extcodehash(instance);\n        if (h == proxyHash || h == beaconProxyHash) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let s := staticcall(gas(), instance, 0x00, 0x01, 0x00, 0x20)\n                if iszero(and(gt(returndatasize(), 0x1f), s)) { revert(0x00, 0x00) }\n                result := mload(0x00)\n            }\n        } else if (h == beaconHash) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(0x00, 0x5c60da1b) // `implementation()`.\n                let s := staticcall(gas(), instance, 0x1c, 0x04, 0x00, 0x20)\n                if iszero(and(gt(returndatasize(), 0x1f), s)) { revert(0x00, 0x00) }\n                result := mload(0x00)\n            }\n        }\n    }",
            "startLine": 300,
            "signature": "implementationOf(address)",
            "selector": "0x3169e7d4",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_validateSalt",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSalt(bytes32 salt) internal view returns (bytes32) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the salt does not start with the zero address or the caller.\n            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {\n                mstore(0x00, 0x2f634836) // `SaltDoesNotStartWithCaller()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        return salt;\n    }",
            "startLine": 325,
            "visibility": "internal"
          },
          {
            "name": "_deploy",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "codeType",
                "type": "uint256"
              },
              {
                "name": "target",
                "type": "uint256"
              },
              {
                "name": "admin",
                "type": "uint256"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "useSalt",
                "type": "bool"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "address",
                "type": "internal"
              },
              {
                "target": "_validateSalt",
                "type": "internal"
              }
            ],
            "emits": [
              "ProxyDeployed",
              "BeaconDeployed",
              "BeaconProxyDeployed"
            ],
            "isVirtual": false,
            "sourceCode": "function _deploy(\n        uint256 codeType,\n        uint256 target,\n        uint256 admin,\n        bytes32 salt,\n        bool useSalt,\n        bytes calldata data\n    ) internal returns (address instance) {\n        if (codeType == 0) {\n            instance = address(\n                useSalt ? new ERC1967Proxy{salt: _validateSalt(salt)}() : new ERC1967Proxy()\n            );\n            /// @solidity memory-safe-assembly\n            assembly {\n                sstore(instance, admin)\n            }\n            emit ProxyDeployed(instance, address(uint160(target)), address(uint160(admin)));\n        } else if (codeType == 1) {\n            instance = address(\n                useSalt\n                    ? new UpgradeableBeacon{salt: _validateSalt(salt)}()\n                    : new UpgradeableBeacon()\n            );\n            /// @solidity memory-safe-assembly\n            assembly {\n                sstore(instance, admin)\n            }\n            emit BeaconDeployed(instance, address(uint160(target)), address(uint160(admin)));\n        } else {\n            instance = address(\n                useSalt\n                    ? new ERC1967BeaconProxy{salt: _validateSalt(salt)}()\n                    : new ERC1967BeaconProxy()\n            );\n            emit BeaconProxyDeployed(instance, address(uint160(target)));\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the creation fails.\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            // Make the initialization call.\n            let m := mload(0x40)\n            mstore(m, target)\n            calldatacopy(add(m, 0x20), data.offset, data.length)\n            if iszero(call(gas(), instance, callvalue(), m, add(0x20, data.length), 0x00, 0x00)) {\n                // Revert with the `DeploymentFailed` selector if there is no error returndata.\n                if iszero(returndatasize()) {\n                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                // Otherwise, bubble up the returned error.\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n        }\n    }",
            "startLine": 338,
            "visibility": "internal"
          },
          {
            "name": "_extcodehash",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _extcodehash(address instance) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := extcodehash(instance)\n        }\n    }",
            "startLine": 399,
            "visibility": "internal"
          },
          {
            "name": "_emptyData",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _emptyData() internal pure returns (bytes calldata data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data.length := 0\n        }\n    }",
            "startLine": 407,
            "visibility": "internal"
          },
          {
            "name": "_predictDeterministicAddressZKsync",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instanceHash",
                "type": "bytes32"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _predictDeterministicAddressZKsync(bytes32 instanceHash, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        bytes32 prefix = keccak256(\"zksyncCreate2\");\n        bytes32 emptyStringHash = keccak256(\"\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The following is `keccak256(abi.encode(...))`.\n            let m := mload(0x40)\n            mstore(m, prefix)\n            mstore(add(m, 0x20), address())\n            mstore(add(m, 0x40), salt)\n            mstore(add(m, 0x60), instanceHash)\n            mstore(add(m, 0x80), emptyStringHash)\n            predicted := keccak256(m, 0xa0)\n        }\n    }",
            "startLine": 415,
            "visibility": "internal"
          },
          {
            "name": "_predictDeterministicAddressRegularEVM",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instanceHash",
                "type": "bytes32"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _predictDeterministicAddressRegularEVM(bytes32 instanceHash, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        bytes32 initCodeHash = _initCodeHashes[instanceHash];\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(initCodeHash) {\n                mstore(0x00, 0xa3a58d1c) // `NoInitCodeHashFound()`.\n                revert(0x1c, 0x04)\n            }\n            // The following is `keccak256(abi.encodePacked(...))`.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, initCodeHash)\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 436,
            "visibility": "internal"
          }
        ],
        "events": [
          {
            "name": "AdminChanged",
            "parameters": [
              {
                "name": "instance",
                "type": "address",
                "indexed": true
              },
              {
                "name": "admin",
                "type": "address",
                "indexed": true
              }
            ]
          },
          {
            "name": "Upgraded",
            "parameters": [
              {
                "name": "instance",
                "type": "address",
                "indexed": true
              },
              {
                "name": "implementation",
                "type": "address",
                "indexed": true
              }
            ]
          },
          {
            "name": "ProxyDeployed",
            "parameters": [
              {
                "name": "proxy",
                "type": "address",
                "indexed": true
              },
              {
                "name": "implementation",
                "type": "address",
                "indexed": true
              },
              {
                "name": "admin",
                "type": "address",
                "indexed": true
              }
            ]
          },
          {
            "name": "BeaconDeployed",
            "parameters": [
              {
                "name": "beacon",
                "type": "address",
                "indexed": true
              },
              {
                "name": "implementation",
                "type": "address",
                "indexed": true
              },
              {
                "name": "admin",
                "type": "address",
                "indexed": true
              }
            ]
          },
          {
            "name": "BeaconProxyDeployed",
            "parameters": [
              {
                "name": "beaconProxy",
                "type": "address",
                "indexed": true
              },
              {
                "name": "beacon",
                "type": "address",
                "indexed": true
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "Unauthorized",
            "parameters": []
          },
          {
            "name": "DeploymentFailed",
            "parameters": []
          },
          {
            "name": "UpgradeFailed",
            "parameters": []
          },
          {
            "name": "SaltDoesNotStartWithCaller",
            "parameters": []
          },
          {
            "name": "NoInitCodeHashFound",
            "parameters": []
          }
        ]
      },
      {
        "name": "ERC1967Proxy",
        "kind": "contract",
        "category": "proxy",
        "filePath": "solady/src/utils/ext/zksync/ERC1967Proxy.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [],
        "events": [
          {
            "name": "Upgraded",
            "parameters": [
              {
                "name": "implementation",
                "type": "address",
                "indexed": true
              }
            ]
          }
        ],
        "errors": []
      },
      {
        "name": "SingleUseETHVault",
        "kind": "contract",
        "category": "core",
        "filePath": "solady/src/utils/ext/zksync/SingleUseETHVault.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [],
        "events": [],
        "errors": [
          {
            "name": "WithdrawAllFailed",
            "parameters": []
          },
          {
            "name": "Unauthorized",
            "parameters": []
          }
        ]
      },
      {
        "name": "UpgradeableBeacon",
        "kind": "contract",
        "category": "proxy",
        "filePath": "solady/src/utils/ext/zksync/UpgradeableBeacon.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "implementation",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function implementation() public view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(__implementation.slot)\n        }\n    }",
            "startLine": 42,
            "signature": "implementation()",
            "selector": "0x5a6673cd",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [
          {
            "name": "Upgraded",
            "parameters": [
              {
                "name": "implementation",
                "type": "address",
                "indexed": true
              }
            ]
          }
        ],
        "errors": [],
        "proxyPattern": "beacon",
        "proxyRole": "beacon"
      },
      {
        "name": "CWIA",
        "kind": "abstract",
        "category": "core",
        "filePath": "solady/src/utils/legacy/CWIA.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "_getArgBytes",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "arg",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgBytes() internal pure returns (bytes memory arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := mload(0x40)\n            let length := sub(calldatasize(), add(2, offset)) // 2 bytes are used for the length.\n            mstore(arg, length) // Store the length.\n            calldatacopy(add(arg, 0x20), offset, length)\n            let o := add(add(arg, 0x20), length)\n            mstore(o, 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }",
            "startLine": 10,
            "visibility": "internal"
          },
          {
            "name": "_getArgBytes",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              },
              {
                "name": "length",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgBytes(uint256 argOffset, uint256 length)\n        internal\n        pure\n        returns (bytes memory arg)\n    {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := mload(0x40)\n            mstore(arg, length) // Store the length.\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), length)\n            let o := add(add(arg, 0x20), length)\n            mstore(o, 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }",
            "startLine": 25,
            "visibility": "internal"
          },
          {
            "name": "_getArgAddress",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgAddress(uint256 argOffset) internal pure returns (address arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(96, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 43,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint256Array",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              },
              {
                "name": "length",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint256Array(uint256 argOffset, uint256 length)\n        internal\n        pure\n        returns (uint256[] memory arg)\n    {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := mload(0x40)\n            mstore(arg, length) // Store the length.\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))\n            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.\n        }\n    }",
            "startLine": 52,
            "visibility": "internal"
          },
          {
            "name": "_getArgBytes32Array",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              },
              {
                "name": "length",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "bytes32[]"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgBytes32Array(uint256 argOffset, uint256 length)\n        internal\n        pure\n        returns (bytes32[] memory arg)\n    {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := mload(0x40)\n            mstore(arg, length) // Store the length.\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))\n            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.\n        }\n    }",
            "startLine": 68,
            "visibility": "internal"
          },
          {
            "name": "_getArgBytes32",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgBytes32(uint256 argOffset) internal pure returns (bytes32 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := calldataload(add(offset, argOffset))\n        }\n    }",
            "startLine": 84,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint256",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint256(uint256 argOffset) internal pure returns (uint256 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := calldataload(add(offset, argOffset))\n        }\n    }",
            "startLine": 93,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint248",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint248"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint248(uint256 argOffset) internal pure returns (uint248 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(8, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 102,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint240",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint240"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint240(uint256 argOffset) internal pure returns (uint240 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(16, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 111,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint232",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint232"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint232(uint256 argOffset) internal pure returns (uint232 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(24, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 120,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint224",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint224"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint224(uint256 argOffset) internal pure returns (uint224 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(0x20, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 129,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint216",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint216"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint216(uint256 argOffset) internal pure returns (uint216 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(40, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 138,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint208",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint208"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint208(uint256 argOffset) internal pure returns (uint208 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(48, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 147,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint200",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint200"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint200(uint256 argOffset) internal pure returns (uint200 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(56, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 156,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint192",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint192"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint192(uint256 argOffset) internal pure returns (uint192 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(64, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 165,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint184",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint184"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint184(uint256 argOffset) internal pure returns (uint184 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(72, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 174,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint176",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint176"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint176(uint256 argOffset) internal pure returns (uint176 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(80, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 183,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint168",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint168"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint168(uint256 argOffset) internal pure returns (uint168 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(88, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 192,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint160",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint160"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint160(uint256 argOffset) internal pure returns (uint160 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(96, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 201,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint152",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint152"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint152(uint256 argOffset) internal pure returns (uint152 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(104, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 210,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint144",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint144"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint144(uint256 argOffset) internal pure returns (uint144 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(112, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 219,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint136",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint136"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint136(uint256 argOffset) internal pure returns (uint136 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(120, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 228,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint128",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint128"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint128(uint256 argOffset) internal pure returns (uint128 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(128, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 237,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint120",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint120"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint120(uint256 argOffset) internal pure returns (uint120 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(136, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 246,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint112",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint112"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint112(uint256 argOffset) internal pure returns (uint112 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(144, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 255,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint104",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint104"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint104(uint256 argOffset) internal pure returns (uint104 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(152, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 264,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint96",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint96"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint96(uint256 argOffset) internal pure returns (uint96 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(160, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 273,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint88",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint88"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint88(uint256 argOffset) internal pure returns (uint88 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(168, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 282,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint80",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint80"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint80(uint256 argOffset) internal pure returns (uint80 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(176, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 291,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint72",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint72"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint72(uint256 argOffset) internal pure returns (uint72 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(184, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 300,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint64",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint64(uint256 argOffset) internal pure returns (uint64 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(192, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 309,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint56",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint56"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint56(uint256 argOffset) internal pure returns (uint56 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(200, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 318,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint48",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint48"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint48(uint256 argOffset) internal pure returns (uint48 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(208, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 327,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint40",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint40"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint40(uint256 argOffset) internal pure returns (uint40 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(216, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 336,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint32",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint32"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint32(uint256 argOffset) internal pure returns (uint32 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(224, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 345,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint24",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint24"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint24(uint256 argOffset) internal pure returns (uint24 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(232, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 354,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint16",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint16"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint16(uint256 argOffset) internal pure returns (uint16 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(240, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 363,
            "visibility": "internal"
          },
          {
            "name": "_getArgUint8",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint8"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(248, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 372,
            "visibility": "internal"
          },
          {
            "name": "_getImmutableArgsOffset",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "offset",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            offset := sub(calldatasize(), shr(240, calldataload(sub(calldatasize(), 2))))\n        }\n    }",
            "startLine": 381,
            "visibility": "internal"
          }
        ],
        "events": [],
        "errors": []
      }
    ],
    "dependencies": [
      {
        "from": "ERC1271",
        "to": "EIP712",
        "type": "inherits"
      },
      {
        "from": "ERC4337",
        "to": "Ownable",
        "type": "inherits"
      },
      {
        "from": "ERC4337",
        "to": "UUPSUpgradeable",
        "type": "inherits"
      },
      {
        "from": "ERC4337",
        "to": "Receiver",
        "type": "inherits"
      },
      {
        "from": "ERC4337",
        "to": "ERC1271",
        "type": "inherits"
      },
      {
        "from": "ERC6551",
        "to": "UUPSUpgradeable",
        "type": "inherits"
      },
      {
        "from": "ERC6551",
        "to": "Receiver",
        "type": "inherits"
      },
      {
        "from": "ERC6551",
        "to": "ERC1271",
        "type": "inherits"
      },
      {
        "from": "ERC7821",
        "to": "Receiver",
        "type": "inherits"
      },
      {
        "from": "Timelock",
        "to": "ERC7821",
        "type": "inherits"
      },
      {
        "from": "Timelock",
        "to": "EnumerableRoles",
        "type": "inherits"
      },
      {
        "from": "OwnableRoles",
        "to": "Ownable",
        "type": "inherits"
      },
      {
        "from": "ERC20Votes",
        "to": "ERC20",
        "type": "inherits"
      },
      {
        "from": "ERC4626",
        "to": "ERC20",
        "type": "inherits"
      },
      {
        "from": "WETH",
        "to": "ERC20",
        "type": "inherits"
      },
      {
        "from": "UUPSUpgradeable",
        "to": "CallContextChecker",
        "type": "inherits"
      },
      {
        "from": "UpgradeableBeacon",
        "to": "ERC4337",
        "type": "delegatecall"
      },
      {
        "from": "UpgradeableBeacon",
        "to": "ERC6551",
        "type": "delegatecall"
      },
      {
        "from": "UpgradeableBeacon",
        "to": "UUPSUpgradeable",
        "type": "delegatecall"
      }
    ],
    "proxyGroups": [
      {
        "id": "proxy-group-0",
        "name": "UpgradeableBeacon",
        "patternType": "uups",
        "proxy": "UpgradeableBeacon",
        "implementations": [
          "ERC4337",
          "ERC6551",
          "UUPSUpgradeable"
        ]
      }
    ],
    "stats": {
      "totalContracts": 40,
      "totalLibraries": 0,
      "totalInterfaces": 0,
      "totalFunctions": 487
    }
  }
}