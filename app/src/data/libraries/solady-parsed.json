{
  "id": "solady",
  "name": "Solady",
  "version": "latest",
  "generatedAt": "2026-01-29T03:50:08.456Z",
  "callGraph": {
    "version": "1.0.0",
    "generatedAt": "2026-01-29T03:50:08.455Z",
    "projectName": "Solady",
    "structure": {
      "name": "contracts",
      "type": "directory",
      "path": "contracts",
      "children": [
        {
          "name": "Milady.sol",
          "type": "file",
          "path": "Milady.sol",
          "contractName": "Milady"
        },
        {
          "name": "accounts",
          "type": "directory",
          "path": "accounts",
          "children": [
            {
              "name": "EIP7702Proxy.sol",
              "type": "file",
              "path": "accounts/EIP7702Proxy.sol",
              "contractName": "EIP7702Proxy"
            },
            {
              "name": "ERC1271.sol",
              "type": "file",
              "path": "accounts/ERC1271.sol",
              "contractName": "ERC1271"
            },
            {
              "name": "ERC4337.sol",
              "type": "file",
              "path": "accounts/ERC4337.sol",
              "contractName": "ERC4337"
            },
            {
              "name": "ERC4337Factory.sol",
              "type": "file",
              "path": "accounts/ERC4337Factory.sol",
              "contractName": "ERC4337Factory"
            },
            {
              "name": "ERC6551.sol",
              "type": "file",
              "path": "accounts/ERC6551.sol",
              "contractName": "ERC6551"
            },
            {
              "name": "ERC6551Proxy.sol",
              "type": "file",
              "path": "accounts/ERC6551Proxy.sol",
              "contractName": "ERC6551Proxy"
            },
            {
              "name": "ERC7821.sol",
              "type": "file",
              "path": "accounts/ERC7821.sol",
              "contractName": "ERC7821"
            },
            {
              "name": "LibEIP7702.sol",
              "type": "file",
              "path": "accounts/LibEIP7702.sol",
              "contractName": "LibEIP7702"
            },
            {
              "name": "LibERC6551.sol",
              "type": "file",
              "path": "accounts/LibERC6551.sol",
              "contractName": "LibERC6551"
            },
            {
              "name": "LibERC7579.sol",
              "type": "file",
              "path": "accounts/LibERC7579.sol",
              "contractName": "LibERC7579"
            },
            {
              "name": "Receiver.sol",
              "type": "file",
              "path": "accounts/Receiver.sol",
              "contractName": "Receiver"
            },
            {
              "name": "Timelock.sol",
              "type": "file",
              "path": "accounts/Timelock.sol",
              "contractName": "Timelock"
            },
            {
              "name": "ext",
              "type": "directory",
              "path": "accounts/ext",
              "children": [
                {
                  "name": "ithaca",
                  "type": "directory",
                  "path": "accounts/ext/ithaca",
                  "children": [
                    {
                      "name": "ERC7821.sol",
                      "type": "file",
                      "path": "accounts/ext/ithaca/ERC7821.sol",
                      "contractName": "ERC7821"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "auth",
          "type": "directory",
          "path": "auth",
          "children": [
            {
              "name": "EnumerableRoles.sol",
              "type": "file",
              "path": "auth/EnumerableRoles.sol",
              "contractName": "EnumerableRoles"
            },
            {
              "name": "Ownable.sol",
              "type": "file",
              "path": "auth/Ownable.sol",
              "contractName": "Ownable"
            },
            {
              "name": "OwnableRoles.sol",
              "type": "file",
              "path": "auth/OwnableRoles.sol",
              "contractName": "OwnableRoles"
            },
            {
              "name": "TimedRoles.sol",
              "type": "file",
              "path": "auth/TimedRoles.sol",
              "contractName": "TimedRoles"
            }
          ]
        },
        {
          "name": "tokens",
          "type": "directory",
          "path": "tokens",
          "children": [
            {
              "name": "ERC1155.sol",
              "type": "file",
              "path": "tokens/ERC1155.sol",
              "contractName": "ERC1155"
            },
            {
              "name": "ERC20.sol",
              "type": "file",
              "path": "tokens/ERC20.sol",
              "contractName": "ERC20"
            },
            {
              "name": "ERC20Votes.sol",
              "type": "file",
              "path": "tokens/ERC20Votes.sol",
              "contractName": "ERC20Votes"
            },
            {
              "name": "ERC2981.sol",
              "type": "file",
              "path": "tokens/ERC2981.sol",
              "contractName": "ERC2981"
            },
            {
              "name": "ERC4626.sol",
              "type": "file",
              "path": "tokens/ERC4626.sol",
              "contractName": "ERC4626"
            },
            {
              "name": "ERC6909.sol",
              "type": "file",
              "path": "tokens/ERC6909.sol",
              "contractName": "ERC6909"
            },
            {
              "name": "ERC721.sol",
              "type": "file",
              "path": "tokens/ERC721.sol",
              "contractName": "ERC721"
            },
            {
              "name": "WETH.sol",
              "type": "file",
              "path": "tokens/WETH.sol",
              "contractName": "WETH"
            },
            {
              "name": "ext",
              "type": "directory",
              "path": "tokens/ext",
              "children": [
                {
                  "name": "zksync",
                  "type": "directory",
                  "path": "tokens/ext/zksync",
                  "children": [
                    {
                      "name": "ERC1155.sol",
                      "type": "file",
                      "path": "tokens/ext/zksync/ERC1155.sol",
                      "contractName": "ERC1155"
                    },
                    {
                      "name": "ERC721.sol",
                      "type": "file",
                      "path": "tokens/ext/zksync/ERC721.sol",
                      "contractName": "ERC721"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "utils",
          "type": "directory",
          "path": "utils",
          "children": [
            {
              "name": "Base58.sol",
              "type": "file",
              "path": "utils/Base58.sol",
              "contractName": "Base58"
            },
            {
              "name": "Base64.sol",
              "type": "file",
              "path": "utils/Base64.sol",
              "contractName": "Base64"
            },
            {
              "name": "BlockHashLib.sol",
              "type": "file",
              "path": "utils/BlockHashLib.sol",
              "contractName": "BlockHashLib"
            },
            {
              "name": "CREATE3.sol",
              "type": "file",
              "path": "utils/CREATE3.sol",
              "contractName": "CREATE3"
            },
            {
              "name": "CallContextChecker.sol",
              "type": "file",
              "path": "utils/CallContextChecker.sol",
              "contractName": "CallContextChecker"
            },
            {
              "name": "DateTimeLib.sol",
              "type": "file",
              "path": "utils/DateTimeLib.sol",
              "contractName": "DateTimeLib"
            },
            {
              "name": "DeploylessPredeployQueryer.sol",
              "type": "file",
              "path": "utils/DeploylessPredeployQueryer.sol",
              "contractName": "DeploylessPredeployQueryer"
            },
            {
              "name": "DynamicArrayLib.sol",
              "type": "file",
              "path": "utils/DynamicArrayLib.sol",
              "contractName": "DynamicArrayLib"
            },
            {
              "name": "DynamicBufferLib.sol",
              "type": "file",
              "path": "utils/DynamicBufferLib.sol",
              "contractName": "DynamicBufferLib"
            },
            {
              "name": "ECDSA.sol",
              "type": "file",
              "path": "utils/ECDSA.sol",
              "contractName": "ECDSA"
            },
            {
              "name": "EIP712.sol",
              "type": "file",
              "path": "utils/EIP712.sol",
              "contractName": "EIP712"
            },
            {
              "name": "ERC1967Factory.sol",
              "type": "file",
              "path": "utils/ERC1967Factory.sol",
              "contractName": "ERC1967Factory"
            },
            {
              "name": "ERC1967FactoryConstants.sol",
              "type": "file",
              "path": "utils/ERC1967FactoryConstants.sol",
              "contractName": "ERC1967FactoryConstants"
            },
            {
              "name": "EfficientHashLib.sol",
              "type": "file",
              "path": "utils/EfficientHashLib.sol",
              "contractName": "EfficientHashLib"
            },
            {
              "name": "EnumerableMapLib.sol",
              "type": "file",
              "path": "utils/EnumerableMapLib.sol",
              "contractName": "EnumerableMapLib"
            },
            {
              "name": "EnumerableSetLib.sol",
              "type": "file",
              "path": "utils/EnumerableSetLib.sol",
              "contractName": "EnumerableSetLib"
            },
            {
              "name": "FixedPointMathLib.sol",
              "type": "file",
              "path": "utils/FixedPointMathLib.sol",
              "contractName": "FixedPointMathLib"
            },
            {
              "name": "GasBurnerLib.sol",
              "type": "file",
              "path": "utils/GasBurnerLib.sol",
              "contractName": "GasBurnerLib"
            },
            {
              "name": "Initializable.sol",
              "type": "file",
              "path": "utils/Initializable.sol",
              "contractName": "Initializable"
            },
            {
              "name": "JSONParserLib.sol",
              "type": "file",
              "path": "utils/JSONParserLib.sol",
              "contractName": "JSONParserLib"
            },
            {
              "name": "LibBit.sol",
              "type": "file",
              "path": "utils/LibBit.sol",
              "contractName": "LibBit"
            },
            {
              "name": "LibBitmap.sol",
              "type": "file",
              "path": "utils/LibBitmap.sol",
              "contractName": "LibBitmap"
            },
            {
              "name": "LibBytes.sol",
              "type": "file",
              "path": "utils/LibBytes.sol",
              "contractName": "LibBytes"
            },
            {
              "name": "LibCall.sol",
              "type": "file",
              "path": "utils/LibCall.sol",
              "contractName": "LibCall"
            },
            {
              "name": "LibClone.sol",
              "type": "file",
              "path": "utils/LibClone.sol",
              "contractName": "LibClone"
            },
            {
              "name": "LibMap.sol",
              "type": "file",
              "path": "utils/LibMap.sol",
              "contractName": "LibMap"
            },
            {
              "name": "LibPRNG.sol",
              "type": "file",
              "path": "utils/LibPRNG.sol",
              "contractName": "LibPRNG"
            },
            {
              "name": "LibRLP.sol",
              "type": "file",
              "path": "utils/LibRLP.sol",
              "contractName": "LibRLP"
            },
            {
              "name": "LibSort.sol",
              "type": "file",
              "path": "utils/LibSort.sol",
              "contractName": "LibSort"
            },
            {
              "name": "LibStorage.sol",
              "type": "file",
              "path": "utils/LibStorage.sol",
              "contractName": "LibStorage"
            },
            {
              "name": "LibString.sol",
              "type": "file",
              "path": "utils/LibString.sol",
              "contractName": "LibString"
            },
            {
              "name": "LibTransient.sol",
              "type": "file",
              "path": "utils/LibTransient.sol",
              "contractName": "LibTransient"
            },
            {
              "name": "LibZip.sol",
              "type": "file",
              "path": "utils/LibZip.sol",
              "contractName": "LibZip"
            },
            {
              "name": "Lifebuoy.sol",
              "type": "file",
              "path": "utils/Lifebuoy.sol",
              "contractName": "Lifebuoy"
            },
            {
              "name": "MerkleProofLib.sol",
              "type": "file",
              "path": "utils/MerkleProofLib.sol",
              "contractName": "MerkleProofLib"
            },
            {
              "name": "MerkleTreeLib.sol",
              "type": "file",
              "path": "utils/MerkleTreeLib.sol",
              "contractName": "MerkleTreeLib"
            },
            {
              "name": "MetadataReaderLib.sol",
              "type": "file",
              "path": "utils/MetadataReaderLib.sol",
              "contractName": "MetadataReaderLib"
            },
            {
              "name": "MinHeapLib.sol",
              "type": "file",
              "path": "utils/MinHeapLib.sol",
              "contractName": "MinHeapLib"
            },
            {
              "name": "Multicallable.sol",
              "type": "file",
              "path": "utils/Multicallable.sol",
              "contractName": "Multicallable"
            },
            {
              "name": "P256.sol",
              "type": "file",
              "path": "utils/P256.sol",
              "contractName": "P256"
            },
            {
              "name": "RedBlackTreeLib.sol",
              "type": "file",
              "path": "utils/RedBlackTreeLib.sol",
              "contractName": "RedBlackTreeLib"
            },
            {
              "name": "ReentrancyGuard.sol",
              "type": "file",
              "path": "utils/ReentrancyGuard.sol",
              "contractName": "ReentrancyGuard"
            },
            {
              "name": "ReentrancyGuardTransient.sol",
              "type": "file",
              "path": "utils/ReentrancyGuardTransient.sol",
              "contractName": "ReentrancyGuardTransient"
            },
            {
              "name": "SSTORE2.sol",
              "type": "file",
              "path": "utils/SSTORE2.sol",
              "contractName": "SSTORE2"
            },
            {
              "name": "SafeCastLib.sol",
              "type": "file",
              "path": "utils/SafeCastLib.sol",
              "contractName": "SafeCastLib"
            },
            {
              "name": "SafeTransferLib.sol",
              "type": "file",
              "path": "utils/SafeTransferLib.sol",
              "contractName": "SafeTransferLib"
            },
            {
              "name": "SemVerLib.sol",
              "type": "file",
              "path": "utils/SemVerLib.sol",
              "contractName": "SemVerLib"
            },
            {
              "name": "SignatureCheckerLib.sol",
              "type": "file",
              "path": "utils/SignatureCheckerLib.sol",
              "contractName": "SignatureCheckerLib"
            },
            {
              "name": "UUPSUpgradeable.sol",
              "type": "file",
              "path": "utils/UUPSUpgradeable.sol",
              "contractName": "UUPSUpgradeable"
            },
            {
              "name": "UpgradeableBeacon.sol",
              "type": "file",
              "path": "utils/UpgradeableBeacon.sol",
              "contractName": "UpgradeableBeacon"
            },
            {
              "name": "WebAuthn.sol",
              "type": "file",
              "path": "utils/WebAuthn.sol",
              "contractName": "WebAuthn"
            },
            {
              "name": "ext",
              "type": "directory",
              "path": "utils/ext",
              "children": [
                {
                  "name": "delegatexyz",
                  "type": "directory",
                  "path": "utils/ext/delegatexyz",
                  "children": [
                    {
                      "name": "DelegateCheckerLib.sol",
                      "type": "file",
                      "path": "utils/ext/delegatexyz/DelegateCheckerLib.sol",
                      "contractName": "DelegateCheckerLib"
                    }
                  ]
                },
                {
                  "name": "ithaca",
                  "type": "directory",
                  "path": "utils/ext/ithaca",
                  "children": [
                    {
                      "name": "BLS.sol",
                      "type": "file",
                      "path": "utils/ext/ithaca/BLS.sol",
                      "contractName": "BLS"
                    }
                  ]
                },
                {
                  "name": "zksync",
                  "type": "directory",
                  "path": "utils/ext/zksync",
                  "children": [
                    {
                      "name": "ERC1967BeaconProxy.sol",
                      "type": "file",
                      "path": "utils/ext/zksync/ERC1967BeaconProxy.sol",
                      "contractName": "ERC1967BeaconProxy"
                    },
                    {
                      "name": "ERC1967Factory.sol",
                      "type": "file",
                      "path": "utils/ext/zksync/ERC1967Factory.sol",
                      "contractName": "ERC1967Factory"
                    },
                    {
                      "name": "ERC1967FactoryConstants.sol",
                      "type": "file",
                      "path": "utils/ext/zksync/ERC1967FactoryConstants.sol",
                      "contractName": "ERC1967FactoryConstants"
                    },
                    {
                      "name": "ERC1967Proxy.sol",
                      "type": "file",
                      "path": "utils/ext/zksync/ERC1967Proxy.sol",
                      "contractName": "ERC1967Proxy"
                    },
                    {
                      "name": "SafeTransferLib.sol",
                      "type": "file",
                      "path": "utils/ext/zksync/SafeTransferLib.sol",
                      "contractName": "SafeTransferLib"
                    },
                    {
                      "name": "SignatureCheckerLib.sol",
                      "type": "file",
                      "path": "utils/ext/zksync/SignatureCheckerLib.sol",
                      "contractName": "SignatureCheckerLib"
                    },
                    {
                      "name": "SingleUseETHVault.sol",
                      "type": "file",
                      "path": "utils/ext/zksync/SingleUseETHVault.sol",
                      "contractName": "SingleUseETHVault"
                    },
                    {
                      "name": "UpgradeableBeacon.sol",
                      "type": "file",
                      "path": "utils/ext/zksync/UpgradeableBeacon.sol",
                      "contractName": "UpgradeableBeacon"
                    },
                    {
                      "name": "delegatexyz",
                      "type": "directory",
                      "path": "utils/ext/zksync/delegatexyz",
                      "children": [
                        {
                          "name": "DelegateCheckerLib.sol",
                          "type": "file",
                          "path": "utils/ext/zksync/delegatexyz/DelegateCheckerLib.sol",
                          "contractName": "DelegateCheckerLib"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "name": "g",
              "type": "directory",
              "path": "utils/g",
              "children": [
                {
                  "name": "BlockHashLib.sol",
                  "type": "file",
                  "path": "utils/g/BlockHashLib.sol",
                  "contractName": "BlockHashLib"
                },
                {
                  "name": "DynamicArrayLib.sol",
                  "type": "file",
                  "path": "utils/g/DynamicArrayLib.sol",
                  "contractName": "DynamicArrayLib"
                },
                {
                  "name": "DynamicBufferLib.sol",
                  "type": "file",
                  "path": "utils/g/DynamicBufferLib.sol",
                  "contractName": "DynamicBufferLib"
                },
                {
                  "name": "EnumerableMapLib.sol",
                  "type": "file",
                  "path": "utils/g/EnumerableMapLib.sol",
                  "contractName": "EnumerableMapLib"
                },
                {
                  "name": "EnumerableSetLib.sol",
                  "type": "file",
                  "path": "utils/g/EnumerableSetLib.sol",
                  "contractName": "EnumerableSetLib"
                },
                {
                  "name": "JSONParserLib.sol",
                  "type": "file",
                  "path": "utils/g/JSONParserLib.sol",
                  "contractName": "JSONParserLib"
                },
                {
                  "name": "LibBitmap.sol",
                  "type": "file",
                  "path": "utils/g/LibBitmap.sol",
                  "contractName": "LibBitmap"
                },
                {
                  "name": "LibBytes.sol",
                  "type": "file",
                  "path": "utils/g/LibBytes.sol",
                  "contractName": "LibBytes"
                },
                {
                  "name": "LibMap.sol",
                  "type": "file",
                  "path": "utils/g/LibMap.sol",
                  "contractName": "LibMap"
                },
                {
                  "name": "LibPRNG.sol",
                  "type": "file",
                  "path": "utils/g/LibPRNG.sol",
                  "contractName": "LibPRNG"
                },
                {
                  "name": "LibRLP.sol",
                  "type": "file",
                  "path": "utils/g/LibRLP.sol",
                  "contractName": "LibRLP"
                },
                {
                  "name": "LibStorage.sol",
                  "type": "file",
                  "path": "utils/g/LibStorage.sol",
                  "contractName": "LibStorage"
                },
                {
                  "name": "LibString.sol",
                  "type": "file",
                  "path": "utils/g/LibString.sol",
                  "contractName": "LibString"
                },
                {
                  "name": "LibTransient.sol",
                  "type": "file",
                  "path": "utils/g/LibTransient.sol",
                  "contractName": "LibTransient"
                },
                {
                  "name": "MinHeapLib.sol",
                  "type": "file",
                  "path": "utils/g/MinHeapLib.sol",
                  "contractName": "MinHeapLib"
                },
                {
                  "name": "RedBlackTreeLib.sol",
                  "type": "file",
                  "path": "utils/g/RedBlackTreeLib.sol",
                  "contractName": "RedBlackTreeLib"
                },
                {
                  "name": "WebAuthn.sol",
                  "type": "file",
                  "path": "utils/g/WebAuthn.sol",
                  "contractName": "WebAuthn"
                }
              ]
            },
            {
              "name": "legacy",
              "type": "directory",
              "path": "utils/legacy",
              "children": [
                {
                  "name": "CWIA.sol",
                  "type": "file",
                  "path": "utils/legacy/CWIA.sol",
                  "contractName": "CWIA"
                },
                {
                  "name": "LibCWIA.sol",
                  "type": "file",
                  "path": "utils/legacy/LibCWIA.sol",
                  "contractName": "LibCWIA"
                }
              ]
            }
          ]
        }
      ]
    },
    "contracts": [
      {
        "name": "Milady",
        "filePath": "Milady.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "WEBSITE",
            "type": "string",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 77
          },
          {
            "name": "CONTRACT",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 79
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./accounts/ERC1271.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./accounts/ERC4337.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./accounts/ERC4337Factory.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./accounts/ERC6551.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./accounts/ERC6551Proxy.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./accounts/ERC7821.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./accounts/LibERC6551.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./accounts/LibERC7579.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./accounts/Receiver.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./accounts/Timelock.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./auth/EnumerableRoles.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./auth/Ownable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./auth/OwnableRoles.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./auth/TimedRoles.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./tokens/ERC1155.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./tokens/ERC20.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./tokens/ERC20Votes.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./tokens/ERC2981.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./tokens/ERC4626.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./tokens/ERC6909.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./tokens/ERC721.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./tokens/WETH.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/Base58.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/Base64.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/BlockHashLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/CREATE3.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/CallContextChecker.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/DateTimeLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/DeploylessPredeployQueryer.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/DynamicArrayLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/DynamicBufferLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/ECDSA.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/EIP712.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/ERC1967Factory.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/ERC1967FactoryConstants.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/EfficientHashLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/EnumerableMapLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/EnumerableSetLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/FixedPointMathLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/GasBurnerLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/JSONParserLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/LibBit.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/LibBitmap.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/LibCall.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/LibClone.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/LibMap.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/LibPRNG.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/LibRLP.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/LibSort.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/LibStorage.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/LibString.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/LibZip.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/Lifebuoy.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/MerkleProofLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/MerkleTreeLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/MetadataReaderLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/MinHeapLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/Multicallable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/P256.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/RedBlackTreeLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/ReentrancyGuard.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/SSTORE2.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/SafeCastLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/SafeTransferLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/SemVerLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/SignatureCheckerLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/UUPSUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/UpgradeableBeacon.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/WebAuthn.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./utils/ext/delegatexyz/DelegateCheckerLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "EIP7702Proxy",
        "filePath": "accounts/EIP7702Proxy.sol",
        "kind": "contract",
        "inherits": [],
        "implements": [],
        "category": "other",
        "externalFunctions": [
          {
            "name": "fallback",
            "signature": "fallback()",
            "selector": "",
            "visibility": "external",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "fallback() external payable virtual {\n        uint256 s = __self;\n        uint256 defaultImplementation = _defaultImplementation;\n        bytes32 implementationSlot = _ERC1967_IMPLEMENTATION_SLOT;\n        uint256 addrMask = (~msg.data.length) >> 96;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, 1)\n            // Workflow for calling on the proxy itself.\n            // We cannot put these functions in the public ABI as this proxy must\n            // fully forward all the calldata from EOAs pointing to this proxy.\n            if iszero(xor(address(), s)) {\n                if iszero(gt(calldatasize(), 1)) {\n                    mstore(0x00, and(addrMask, sload(implementationSlot)))\n                    return(0x00, 0x20)\n                }\n                let fnSel := shr(224, calldataload(0x00))\n                // `implementation()`.\n                if eq(0x5c60da1b, fnSel) {\n                    mstore(0x00, and(addrMask, sload(implementationSlot)))\n                    return(0x00, 0x20)\n                }\n                let adminSlot := _ERC1967_ADMIN_SLOT\n                // `admin()`.\n                if eq(0xf851a440, fnSel) {\n                    mstore(0x00, sload(adminSlot))\n                    return(0x00, 0x20)\n                }\n                // Admin workflow.\n                if eq(caller(), sload(adminSlot)) {\n                    let addrSlot :=\n                        or(\n                            mul(eq(0x8f283970, fnSel), adminSlot), // `changeAdmin(address)`.\n                            mul(eq(0x0900f010, fnSel), implementationSlot) // `upgrade(address)`.\n                        )\n                    if addrSlot {\n                        sstore(addrSlot, and(addrMask, calldataload(0x04)))\n                        return(0x40, 0x20) // Return `true`.\n                    }\n                    // For minimalism, we shall skip events and calldata bounds checks.\n                    // We don't need to forward any data to the new implementation.\n                    // This \"proxy\" is actually close to an upgradeable beacon.\n                }\n                revert(0x00, 0x00)\n            }\n            // Workflow for the EIP7702 authority (i.e. the EOA).\n            let implementation := and(addrMask, sload(implementationSlot)) // On EOA's storage.\n            // Special workflow for retrieving the implementation directly.\n            if eq(1, calldatasize()) {\n                // If the preferred implementation is `address(0)`.\n                if iszero(implementation) {\n                    implementation := defaultImplementation\n                    // If `defaultImplementation` is `address(0)`\n                    if iszero(implementation) {\n                        // Fetch the implementation from the proxy.\n                        if staticcall(gas(), s, 0x00, 0x00, 0x00, 0x20) {\n                            return(0x00, returndatasize())\n                        }\n                        revert(0x00, 0x00)\n                    }\n                }\n                mstore(0x00, implementation)\n                return(0x00, 0x20)\n            }\n            calldatacopy(0x00, 0x00, calldatasize()) // Copy the calldata for the delegatecall.\n            // If the preferred implementation is `address(0)`.\n            if iszero(implementation) {\n                implementation := defaultImplementation\n                // If `defaultImplementation` is `address(0)`, perform the initialization workflow.\n                if iszero(implementation) {\n                    if iszero(\n                        and( // The arguments of `and` are evaluated from right to left.\n                            delegatecall(\n                                gas(), mload(calldatasize()), 0x00, calldatasize(), 0x00, 0x00\n                            ),\n                            // Fetch the implementation from the proxy.\n                            staticcall(gas(), s, 0x00, 0x00, calldatasize(), 0x20)\n                        )\n                    ) {\n                        returndatacopy(0x00, 0x00, returndatasize())\n                        revert(0x00, returndatasize())\n                    }\n                    // Because we cannot reliably and efficiently tell if the call is made\n                    // via staticcall or call, we shall ask the delegation to make a proxy delegation\n                    // initialization request to signal that we should initialize the storage slot with\n                    // the actual implementation. This also gives flexibility on whether to let the\n                    // proxy auto-upgrade, or let the authority manually upgrade (via 7702 or passkey).\n                    // A non-zero value in the transient storage denotes a initialization request.\n                    let initializationRequestSlot :=\n                        _EIP7702_PROXY_DELEGATION_INITIALIZATION_REQUEST_SLOT\n                    if tload(initializationRequestSlot) {\n                        // The `implementation` is still at `calldatasize()` in memory.\n                        // Preserve the upper 96 bits when updating in case they are used for some stuff.\n                        sstore(\n                            implementationSlot,\n                            or(and(not(addrMask), sload(implementationSlot)), mload(calldatasize()))\n                        )\n                        tstore(initializationRequestSlot, 0) // Clear.\n                    }\n                    returndatacopy(0x00, 0x00, returndatasize())\n                    return(0x00, returndatasize())\n                }\n            }\n            // Otherwise, just delegatecall and bubble up the results without initialization.\n            if iszero(delegatecall(gas(), implementation, 0x00, calldatasize(), 0x00, 0x00)) {\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n            returndatacopy(0x00, 0x00, returndatasize())\n            return(0x00, returndatasize())\n        }\n    }",
            "startLine": 70
          }
        ],
        "internalFunctions": [
          {
            "name": "constructor",
            "visibility": "default",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "initialImplementation",
                "type": "address"
              },
              {
                "name": "initialAdmin",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "constructor(address initialImplementation, address initialAdmin) payable {\n        uint256 defaultImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We will store the implementation in the storage regardless,\n            // to aid proxy detection on block explorers.\n            sstore(_ERC1967_IMPLEMENTATION_SLOT, initialImplementation)\n            sstore(_ERC1967_ADMIN_SLOT, initialAdmin)\n            defaultImplementation :=\n                mul(lt(initialAdmin, iszero(iszero(initialImplementation))), initialImplementation)\n        }\n        _defaultImplementation = defaultImplementation;\n    }",
            "startLine": 52
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "__self",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": false,
            "isImmutable": true,
            "startLine": 21
          },
          {
            "name": "_defaultImplementation",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": false,
            "isImmutable": true,
            "startLine": 25
          },
          {
            "name": "_ERC1967_IMPLEMENTATION_SLOT",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 33
          },
          {
            "name": "_ERC1967_ADMIN_SLOT",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 38
          },
          {
            "name": "_EIP7702_PROXY_DELEGATION_INITIALIZATION_REQUEST_SLOT",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 45
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "ERC1271",
        "filePath": "accounts/ERC1271.sol",
        "kind": "abstract",
        "inherits": [
          "EIP712"
        ],
        "implements": [],
        "category": "other",
        "externalFunctions": [
          {
            "name": "isValidSignature",
            "signature": "isValidSignature(bytes32,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes4"
              }
            ],
            "calls": [
              {
                "target": "_erc1271IsValidSignature",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_erc1271UnwrapSignature",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function isValidSignature(bytes32 hash, bytes calldata signature)\n        public\n        view\n        virtual\n        returns (bytes4 result)\n    {\n        // For automatic detection that the smart account supports the nested EIP-712 workflow,\n        // See: https://eips.ethereum.org/EIPS/eip-7739.\n        // If `hash` is `0x7739...7739`, returns `bytes4(0x77390001)`.\n        // The returned number MAY be increased in future ERC7739 versions.\n        unchecked {\n            if (signature.length == uint256(0)) {\n                // Forces the compiler to optimize for smaller bytecode size.\n                if (uint256(hash) == ~signature.length / 0xffff * 0x7739) return 0x77390001;\n            }\n        }\n        bool success = _erc1271IsValidSignature(hash, _erc1271UnwrapSignature(signature));\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `success ? bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")) : 0xffffffff`.\n            // We use `0xffffffff` for invalid, in convention with the reference implementation.\n            result := shl(224, or(0x1626ba7e, sub(0, iszero(success))))\n        }\n    }",
            "startLine": 24
          }
        ],
        "internalFunctions": [
          {
            "name": "_erc1271Signer",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _erc1271Signer() internal view virtual returns (address);",
            "startLine": 51
          },
          {
            "name": "_erc1271CallerIsSafe",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _erc1271CallerIsSafe() internal view virtual returns (bool) {\n        // The canonical `MulticallerWithSigner` at 0x000000000000D9ECebf3C23529de49815Dac1c4c\n        // is known to include the account in the hash to be signed.\n        return msg.sender == 0x000000000000D9ECebf3C23529de49815Dac1c4c;\n    }",
            "startLine": 57
          },
          {
            "name": "_erc1271IsValidSignatureNowCalldata",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "SignatureCheckerLib.isValidSignatureNowCalldata",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "_erc1271Signer",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _erc1271IsValidSignatureNowCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return SignatureCheckerLib.isValidSignatureNowCalldata(_erc1271Signer(), hash, signature);\n    }",
            "startLine": 65
          },
          {
            "name": "_erc1271UnwrapSignature",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _erc1271UnwrapSignature(bytes calldata signature)\n        internal\n        view\n        virtual\n        returns (bytes calldata result)\n    {\n        result = signature;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Unwraps the ERC6492 wrapper if it exists.\n            // See: https://eips.ethereum.org/EIPS/eip-6492\n            if eq(\n                calldataload(add(result.offset, sub(result.length, 0x20))),\n                mul(0x6492, div(not(shr(address(), address())), 0xffff)) // `0x6492...6492`.\n            ) {\n                let o := add(result.offset, calldataload(add(result.offset, 0x40)))\n                result.length := calldataload(o)\n                result.offset := add(o, 0x20)\n            }\n        }\n    }",
            "startLine": 75
          },
          {
            "name": "_erc1271IsValidSignature",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_erc1271IsValidSignatureViaSafeCaller",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_erc1271IsValidSignatureViaNestedEIP712",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_erc1271IsValidSignatureViaRPC",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _erc1271IsValidSignature(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return _erc1271IsValidSignatureViaSafeCaller(hash, signature)\n            || _erc1271IsValidSignatureViaNestedEIP712(hash, signature)\n            || _erc1271IsValidSignatureViaRPC(hash, signature);\n    }",
            "startLine": 98
          },
          {
            "name": "_erc1271IsValidSignatureViaSafeCaller",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_erc1271CallerIsSafe",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_erc1271IsValidSignatureNowCalldata",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _erc1271IsValidSignatureViaSafeCaller(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        if (_erc1271CallerIsSafe()) {\n            result = _erc1271IsValidSignatureNowCalldata(hash, signature);\n        }\n    }",
            "startLine": 111
          },
          {
            "name": "_erc1271IsValidSignatureViaNestedEIP712",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "eip712Domain",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_hashTypedData",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_erc1271IsValidSignatureNowCalldata",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _erc1271IsValidSignatureViaNestedEIP712(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        uint256 t = uint256(uint160(address(this)));\n        // Forces the compiler to pop the variables after the scope, avoiding stack-too-deep.\n        if (t != uint256(0)) {\n            (\n                ,\n                string memory name,\n                string memory version,\n                uint256 chainId,\n                address verifyingContract,\n                bytes32 salt,\n            ) = eip712Domain();\n            /// @solidity memory-safe-assembly\n            assembly {\n                t := mload(0x40) // Grab the free memory pointer.\n                // Skip 2 words for the `typedDataSignTypehash` and `contents` struct hash.\n                mstore(add(t, 0x40), keccak256(add(name, 0x20), mload(name)))\n                mstore(add(t, 0x60), keccak256(add(version, 0x20), mload(version)))\n                mstore(add(t, 0x80), chainId)\n                mstore(add(t, 0xa0), shr(96, shl(96, verifyingContract)))\n                mstore(add(t, 0xc0), salt)\n                mstore(0x40, add(t, 0xe0)) // Allocate the memory.\n            }\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            // `c` is `contentsDescription.length`, which is stored in the last 2 bytes of the signature.\n            let c := shr(240, calldataload(add(signature.offset, sub(signature.length, 2))))\n            for {} 1 {} {\n                let l := add(0x42, c) // Total length of appended data (32 + 32 + c + 2).\n                let o := add(signature.offset, sub(signature.length, l)) // Offset of appended data.\n                mstore(0x00, 0x1901) // Store the \"\\x19\\x01\" prefix.\n                calldatacopy(0x20, o, 0x40) // Copy the `APP_DOMAIN_SEPARATOR` and `contents` struct hash.\n                // Use the `PersonalSign` workflow if the reconstructed hash doesn't match,\n                // or if the appended data is invalid, i.e.\n                // `appendedData.length > signature.length || contentsDescription.length == 0`.\n                if or(xor(keccak256(0x1e, 0x42), hash), or(lt(signature.length, l), iszero(c))) {\n                    t := 0 // Set `t` to 0, denoting that we need to `hash = _hashTypedData(hash)`.\n                    mstore(t, _PERSONAL_SIGN_TYPEHASH)\n                    mstore(0x20, hash) // Store the `prefixed`.\n                    hash := keccak256(t, 0x40) // Compute the `PersonalSign` struct hash.\n                    break\n                }\n                // Else, use the `TypedDataSign` workflow.\n                // `TypedDataSign({ContentsName} contents,string name,...){ContentsType}`.\n                mstore(m, \"TypedDataSign(\") // Store the start of `TypedDataSign`'s type encoding.\n                let p := add(m, 0x0e) // Advance 14 bytes to skip \"TypedDataSign(\".\n                calldatacopy(p, add(o, 0x40), c) // Copy `contentsName`, optimistically.\n                mstore(add(p, c), 40) // Store a '(' after the end.\n                if iszero(eq(byte(0, mload(sub(add(p, c), 1))), 41)) {\n                    let e := 0 // Length of `contentsName` in explicit mode.\n                    for { let q := sub(add(p, c), 1) } 1 {} {\n                        e := add(e, 1) // Scan backwards until we encounter a ')'.\n                        if iszero(gt(lt(e, c), eq(byte(0, mload(sub(q, e))), 41))) {\n                            break\n                        }\n                    }\n                    c := sub(c, e) // Truncate `contentsDescription` to `contentsType`.\n                    calldatacopy(p, add(add(o, 0x40), c), e) // Copy `contentsName`.\n                    mstore8(add(p, e), 40) // Store a '(' exactly right after the end.\n                }\n                // `d & 1 == 1` means that `contentsName` is invalid.\n                let d := shr(byte(0, mload(p)), 0x7fffffe000000000000010000000000) // Starts with `[a-z(]`.\n                // Advance `p` until we encounter '('.\n                for {} iszero(eq(byte(0, mload(p)), 40)) { p := add(p, 1) } {\n                    d := or(shr(byte(0, mload(p)), 0x120100000001), d) // Has a byte in \", )\\x00\".\n                }\n                mstore(p, \" contents,string name,string\") // Store the rest of the encoding.\n                mstore(add(p, 0x1c), \" version,uint256 chainId,address\")\n                mstore(add(p, 0x3c), \" verifyingContract,bytes32 salt)\")\n                p := add(p, 0x5c)\n                calldatacopy(p, add(o, 0x40), c) // Copy `contentsType`.\n                // Fill in the missing fields of the `TypedDataSign`.\n                calldatacopy(t, o, 0x40) // Copy the `contents` struct hash to `add(t, 0x20)`.\n                mstore(t, keccak256(m, sub(add(p, c), m))) // Store `typedDataSignTypehash`.\n                // The \"\\x19\\x01\" prefix is already at 0x00.\n                // `APP_DOMAIN_SEPARATOR` is already at 0x20.\n                mstore(0x40, keccak256(t, 0xe0)) // `hashStruct(typedDataSign)`.\n                // Compute the final hash, corrupted if `contentsName` is invalid.\n                hash := keccak256(0x1e, add(0x42, and(1, d)))\n                signature.length := sub(signature.length, l) // Truncate the signature.\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n        if (t == uint256(0)) hash = _hashTypedData(hash); // `PersonalSign` workflow.\n        result = _erc1271IsValidSignatureNowCalldata(hash, signature);\n    }",
            "startLine": 198
          },
          {
            "name": "_erc1271IsValidSignatureViaRPC",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_erc1271IsValidSignatureNowCalldata",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _erc1271IsValidSignatureViaRPC(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        // Non-zero gasprice is a heuristic to check if a call is on-chain,\n        // but we can't fully depend on it because it can be manipulated.\n        // See: https://x.com/NoahCitron/status/1580359718341484544\n        if (tx.gasprice == uint256(0)) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(gasprice(), gasprice())\n                // See: https://gist.github.com/Vectorized/3c9b63524d57492b265454f62d895f71\n                let b := 0x000000000000378eDCD5B5B0A24f5342d8C10485 // Basefee contract,\n                pop(staticcall(0xffff, b, codesize(), gasprice(), gasprice(), 0x20))\n                // If `gasprice < basefee`, the call cannot be on-chain, and we can skip the gas burn.\n                if iszero(mload(gasprice())) {\n                    let m := mload(0x40) // Cache the free memory pointer.\n                    mstore(gasprice(), 0x1626ba7e) // `isValidSignature(bytes32,bytes)`.\n                    mstore(0x20, b) // Recycle `b` to denote if we need to burn gas.\n                    mstore(0x40, 0x40)\n                    let gasToBurn := or(add(0xffff, gaslimit()), gaslimit())\n                    // Burns gas computationally efficiently. Also, requires that `gas > gasToBurn`.\n                    if or(eq(hash, b), lt(gas(), gasToBurn)) { invalid() }\n                    // Make a call to this with `b`, efficiently burning the gas provided.\n                    // No valid transaction can consume more than the gaslimit.\n                    // See: https://ethereum.github.io/yellowpaper/paper.pdf\n                    // Most RPCs perform calls with a gas budget greater than the gaslimit.\n                    pop(staticcall(gasToBurn, address(), 0x1c, 0x64, gasprice(), gasprice()))\n                    mstore(0x40, m) // Restore the free memory pointer.\n                }\n            }\n            result = _erc1271IsValidSignatureNowCalldata(hash, signature);\n        }\n    }",
            "startLine": 295
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "_PERSONAL_SIGN_TYPEHASH",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 15
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../utils/EIP712.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../utils/SignatureCheckerLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "ERC4337",
        "filePath": "accounts/ERC4337.sol",
        "kind": "abstract",
        "inherits": [
          "Ownable",
          "UUPSUpgradeable",
          "Receiver",
          "ERC1271"
        ],
        "implements": [],
        "category": "other",
        "externalFunctions": [
          {
            "name": "initialize",
            "signature": "initialize(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initializeOwner",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function initialize(address newOwner) public payable virtual {\n        _initializeOwner(newOwner);\n    }",
            "startLine": 77
          },
          {
            "name": "entryPoint",
            "signature": "entryPoint()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function entryPoint() public view virtual returns (address) {\n        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\n    }",
            "startLine": 87
          },
          {
            "name": "validateUserOp",
            "signature": "validateUserOp(PackedUserOperation,bytes32,uint256)",
            "selector": "",
            "visibility": "external",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "userOp",
                "type": "PackedUserOperation"
              },
              {
                "name": "userOpHash",
                "type": "bytes32"
              },
              {
                "name": "missingAccountFunds",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "validationData",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_validateSignature",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_validateNonce",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    )\n        external\n        payable\n        virtual\n        onlyEntryPoint\n        payPrefund(missingAccountFunds)\n        returns (uint256 validationData)\n    {\n        validationData = _validateSignature(userOp, userOpHash);\n        _validateNonce(userOp.nonce);\n    }",
            "startLine": 103
          },
          {
            "name": "execute",
            "signature": "execute(address,uint256,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function execute(address target, uint256 value, bytes calldata data)\n        public\n        payable\n        virtual\n        onlyEntryPointOrOwner\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, data.offset, data.length)\n            if iszero(call(gas(), target, value, result, data.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }",
            "startLine": 181
          },
          {
            "name": "executeBatch",
            "signature": "executeBatch(Call[])",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "calls",
                "type": "Call[]"
              }
            ],
            "returnValues": [
              {
                "name": "results",
                "type": "bytes[]"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function executeBatch(Call[] calldata calls)\n        public\n        payable\n        virtual\n        onlyEntryPointOrOwner\n        returns (bytes[] memory results)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            results := mload(0x40)\n            mstore(results, calls.length)\n            let r := add(0x20, results)\n            let m := add(r, shl(5, calls.length))\n            calldatacopy(r, calls.offset, shl(5, calls.length))\n            for { let end := m } iszero(eq(r, end)) { r := add(r, 0x20) } {\n                let e := add(calls.offset, mload(r))\n                let o := add(e, calldataload(add(e, 0x40)))\n                calldatacopy(m, add(o, 0x20), calldataload(o))\n                // forgefmt: disable-next-item\n                if iszero(call(gas(), calldataload(e), calldataload(add(e, 0x20)),\n                    m, calldataload(o), codesize(), 0x00)) {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n                mstore(r, m) // Append `m` into `results`.\n                mstore(m, returndatasize()) // Store the length,\n                let p := add(m, 0x20)\n                returndatacopy(p, 0x00, returndatasize()) // and copy the returndata.\n                m := add(p, returndatasize()) // Advance `m`.\n            }\n            mstore(0x40, m) // Allocate the memory.\n        }\n    }",
            "startLine": 205
          },
          {
            "name": "delegateExecute",
            "signature": "delegateExecute(address,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "delegate",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function delegateExecute(address delegate, bytes calldata data)\n        public\n        payable\n        virtual\n        onlyEntryPointOrOwner\n        delegateExecuteGuard\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, data.offset, data.length)\n            // Forwards the `data` to `delegate` via delegatecall.\n            if iszero(delegatecall(gas(), delegate, result, data.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }",
            "startLine": 241
          },
          {
            "name": "storageLoad",
            "signature": "storageLoad(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "storageSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function storageLoad(bytes32 storageSlot) public view virtual returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(storageSlot)\n        }\n    }",
            "startLine": 299
          },
          {
            "name": "storageStore",
            "signature": "storageStore(bytes32,bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "storageSlot",
                "type": "bytes32"
              },
              {
                "name": "storageValue",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function storageStore(bytes32 storageSlot, bytes32 storageValue)\n        public\n        payable\n        virtual\n        onlyEntryPointOrOwner\n        storageStoreGuard(storageSlot)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(storageSlot, storageValue)\n        }\n    }",
            "startLine": 307
          },
          {
            "name": "getDeposit",
            "signature": "getDeposit()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "entryPoint",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getDeposit() public view virtual returns (uint256 result) {\n        address ep = entryPoint();\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, address()) // Store the `account` argument.\n            mstore(0x00, 0x70a08231) // `balanceOf(address)`.\n            result := mul( // Returns 0 if the EntryPoint does not exist.\n                mload(0x20),\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), ep, 0x1c, 0x24, 0x20, 0x20)\n                )\n            )\n        }\n    }",
            "startLine": 337
          },
          {
            "name": "addDeposit",
            "signature": "addDeposit()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "entryPoint",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function addDeposit() public payable virtual {\n        address ep = entryPoint();\n        /// @solidity memory-safe-assembly\n        assembly {\n\n            // The EntryPoint has balance accounting logic in the `receive()` function, as defined in ERC-4337.\n            // forgefmt: disable-next-item\n            if iszero(mul(extcodesize(ep), call(gas(), ep, callvalue(), codesize(), 0x00, codesize(), 0x00))) {\n                revert(codesize(), 0x00) // For gas estimation.\n            }\n        }\n    }",
            "startLine": 354
          },
          {
            "name": "withdrawDepositTo",
            "signature": "withdrawDepositTo(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "entryPoint",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function withdrawDepositTo(address to, uint256 amount) public payable virtual onlyOwner {\n        address ep = entryPoint();\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x205c2878000000000000000000000000) // `withdrawTo(address,uint256)`.\n            if iszero(mul(extcodesize(ep), call(gas(), ep, 0, 0x10, 0x44, codesize(), 0x00))) {\n                returndatacopy(mload(0x40), 0x00, returndatasize())\n                revert(mload(0x40), returndatasize())\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }",
            "startLine": 368
          },
          {
            "name": "fallback",
            "signature": "fallback()",
            "selector": "",
            "visibility": "external",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_useLibZipCdFallback",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "LibZip.cdFallback",
                "type": "library",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "fallback() external payable virtual override(Receiver) receiverFallback {\n        if (_useLibZipCdFallback()) {\n            // Reverts with out-of-gas by recursing infinitely if the first 4 bytes\n            // of the decompressed `msg.data` doesn't match any function selector.\n            LibZip.cdFallback();\n        } else {\n            revert FnSelectorNotRecognized();\n        }\n    }",
            "startLine": 419
          }
        ],
        "internalFunctions": [
          {
            "name": "constructor",
            "visibility": "default",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_disableERC4337ImplementationInitializer",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "constructor() payable {\n        _disableERC4337ImplementationInitializer();\n    }",
            "startLine": 58
          },
          {
            "name": "_disableERC4337ImplementationInitializer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_initializeOwner",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _disableERC4337ImplementationInitializer() internal virtual {\n        // Note that `Ownable._guardInitializeOwner` has been and must be overridden\n        // to return true, to block double-initialization. We'll initialize to `address(1)`,\n        // so that it's easier to verify that the implementation has been initialized.\n        _initializeOwner(address(1));\n    }",
            "startLine": 65
          },
          {
            "name": "_validateSignature",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "userOp",
                "type": "PackedUserOperation"
              },
              {
                "name": "userOpHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "validationData",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "SignatureCheckerLib.isValidSignatureNowCalldata",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "owner",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "SignatureCheckerLib.toEthSignedMessageHash",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _validateSignature(PackedUserOperation calldata userOp, bytes32 userOpHash)\n        internal\n        virtual\n        returns (uint256 validationData)\n    {\n        bool success = SignatureCheckerLib.isValidSignatureNowCalldata(\n            owner(), SignatureCheckerLib.toEthSignedMessageHash(userOpHash), userOp.signature\n        );\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Returns 0 if the recovered address matches the owner.\n            // Else returns 1, which is equivalent to:\n            // `(success ? 0 : 1) | (uint256(validUntil) << 160) | (uint256(validAfter) << (160 + 48))`\n            // where `validUntil` is 0 (indefinite) and `validAfter` is 0.\n            validationData := iszero(success)\n        }\n    }",
            "startLine": 120
          },
          {
            "name": "_validateNonce",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "nonce",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _validateNonce(uint256 nonce) internal virtual {\n        nonce = nonce; // Silence unused variable warning.\n    }",
            "startLine": 148
          },
          {
            "name": "_checkOwner",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual override(Ownable) {\n        if (msg.sender != owner()) if (msg.sender != address(this)) revert Unauthorized();\n    }",
            "startLine": 389
          },
          {
            "name": "_guardInitializeOwner",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _guardInitializeOwner() internal pure virtual override(Ownable) returns (bool) {\n        return true;\n    }",
            "startLine": 394
          },
          {
            "name": "_erc1271Signer",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "owner",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _erc1271Signer() internal view virtual override(ERC1271) returns (address) {\n        return owner();\n    }",
            "startLine": 399
          },
          {
            "name": "_erc1271CallerIsSafe",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "entryPoint",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "ERC1271._erc1271CallerIsSafe",
                "type": "library",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _erc1271CallerIsSafe() internal view virtual override(ERC1271) returns (bool) {\n        return msg.sender == entryPoint() || ERC1271._erc1271CallerIsSafe();\n    }",
            "startLine": 405
          },
          {
            "name": "_authorizeUpgrade",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _authorizeUpgrade(address) internal virtual override(UUPSUpgradeable) onlyOwner {}",
            "startLine": 410
          },
          {
            "name": "_useLibZipCdFallback",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _useLibZipCdFallback() internal view virtual returns (bool) {\n        return true;\n    }",
            "startLine": 413
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "PackedUserOperation",
            "members": [
              {
                "name": "sender",
                "type": "address"
              },
              {
                "name": "nonce",
                "type": "uint256"
              },
              {
                "name": "initCode",
                "type": "bytes"
              },
              {
                "name": "callData",
                "type": "bytes"
              },
              {
                "name": "accountGasLimits",
                "type": "bytes32"
              },
              {
                "name": "preVerificationGas",
                "type": "uint256"
              },
              {
                "name": "gasFees",
                "type": "bytes32"
              },
              {
                "name": "paymasterAndData",
                "type": "bytes"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "startLine": 34
          },
          {
            "name": "Call",
            "members": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "startLine": 47
          }
        ],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./Receiver.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../utils/LibZip.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../auth/Ownable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../utils/UUPSUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../accounts/ERC1271.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "ERC4337Factory",
        "filePath": "accounts/ERC4337Factory.sol",
        "kind": "contract",
        "inherits": [],
        "implements": [],
        "category": "other",
        "externalFunctions": [
          {
            "name": "createAccount",
            "signature": "createAccount(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "ownSalt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "LibClone.createDeterministicERC1967",
                "type": "library",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function createAccount(bytes32 ownSalt) public payable virtual returns (address) {\n        // Constructor data is optional, and is omitted for easier Etherscan verification.\n        (bool alreadyDeployed, address account) =\n            LibClone.createDeterministicERC1967(msg.value, implementation, ownSalt);\n\n        if (!alreadyDeployed) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(0x20, shr(96, ownSalt)) // Store the `owner` argument.\n                mstore(0x00, 0xc4d66de8) // `initialize(address)`.\n                if iszero(call(gas(), account, 0, 0x1c, 0x24, codesize(), 0x00)) {\n                    returndatacopy(mload(0x40), 0x00, returndatasize())\n                    revert(mload(0x40), returndatasize())\n                }\n            }\n        }\n        return account;\n    }",
            "startLine": 41
          },
          {
            "name": "getAddress",
            "signature": "getAddress(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ownSalt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "LibClone.predictDeterministicAddressERC1967",
                "type": "library",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getAddress(bytes32 ownSalt) public view virtual returns (address) {\n        return LibClone.predictDeterministicAddressERC1967(implementation, ownSalt, address(this));\n    }",
            "startLine": 61
          },
          {
            "name": "initCodeHash",
            "signature": "initCodeHash()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "LibClone.initCodeHashERC1967",
                "type": "library",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function initCodeHash() public view virtual returns (bytes32) {\n        return LibClone.initCodeHashERC1967(implementation);\n    }",
            "startLine": 67
          }
        ],
        "internalFunctions": [
          {
            "name": "constructor",
            "visibility": "default",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "erc4337",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "constructor(address erc4337) payable {\n        implementation = erc4337;\n    }",
            "startLine": 29
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "implementation",
            "type": "address",
            "visibility": "public",
            "isConstant": false,
            "isImmutable": true,
            "startLine": 23
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../utils/LibClone.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "ERC6551",
        "filePath": "accounts/ERC6551.sol",
        "kind": "abstract",
        "inherits": [
          "UUPSUpgradeable",
          "Receiver",
          "ERC1271"
        ],
        "implements": [],
        "category": "other",
        "externalFunctions": [
          {
            "name": "token",
            "signature": "token()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "chainId",
                "type": "uint256"
              },
              {
                "name": "tokenContract",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function token()\n        public\n        view\n        virtual\n        returns (uint256 chainId, address tokenContract, uint256 tokenId)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            extcodecopy(address(), 0x00, 0x4d, 0x60)\n            chainId := mload(0x00)\n            tokenContract := mload(0x20) // Upper 96 bits will be clean.\n            tokenId := mload(0x40)\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 86
          },
          {
            "name": "owner",
            "signature": "owner()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address result) {\n        uint256 cachedChainId = _cachedChainId;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            extcodecopy(address(), 0x00, 0x4d, 0x60)\n            if eq(mload(0x00), cachedChainId) {\n                let tokenContract := mload(0x20)\n                // `tokenId` is already at 0x40.\n                mstore(0x20, 0x6352211e) // `ownerOf(uint256)`.\n                result := mul( // Returns `address(0)` on failure or if contract does not exist.\n                    mload(0x20),\n                    and(\n                        gt(returndatasize(), 0x1f),\n                        staticcall(gas(), tokenContract, 0x3c, 0x24, 0x20, 0x20)\n                    )\n                )\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 104
          },
          {
            "name": "isValidSigner",
            "signature": "isValidSigner(address,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "context",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes4"
              }
            ],
            "calls": [
              {
                "target": "_isValidSigner",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function isValidSigner(address signer, bytes calldata context)\n        public\n        view\n        virtual\n        returns (bytes4 result)\n    {\n        bool isValid = _isValidSigner(signer, bytes32(0), context);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `isValid ? bytes4(keccak256(\"isValidSigner(address,bytes)\")) : 0x00000000`.\n            // We use `0x00000000` for invalid, in convention with the reference implementation.\n            result := shl(224, mul(0x523e3260, iszero(iszero(isValid))))\n        }\n    }",
            "startLine": 143
          },
          {
            "name": "state",
            "signature": "state()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function state() public view virtual returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_ERC6551_STATE_SLOT)\n        }\n    }",
            "startLine": 177
          },
          {
            "name": "execute",
            "signature": "execute(address,uint256,bytes,uint8)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "operation",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "_updateState",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function execute(address target, uint256 value, bytes calldata data, uint8 operation)\n        public\n        payable\n        virtual\n        onlyValidSigner\n        returns (bytes memory result)\n    {\n        if (operation != 0) revert OperationNotSupported();\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, data.offset, data.length)\n            if iszero(call(gas(), target, value, result, data.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n        _updateState();\n    }",
            "startLine": 215
          },
          {
            "name": "executeBatch",
            "signature": "executeBatch(Call[],uint8)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "calls",
                "type": "Call[]"
              },
              {
                "name": "operation",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "results",
                "type": "bytes[]"
              }
            ],
            "calls": [
              {
                "target": "_updateState",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function executeBatch(Call[] calldata calls, uint8 operation)\n        public\n        payable\n        virtual\n        onlyValidSigner\n        returns (bytes[] memory results)\n    {\n        if (operation != 0) revert OperationNotSupported();\n        /// @solidity memory-safe-assembly\n        assembly {\n            results := mload(0x40)\n            mstore(results, calls.length)\n            let r := add(0x20, results)\n            let m := add(r, shl(5, calls.length))\n            calldatacopy(r, calls.offset, shl(5, calls.length))\n            for { let end := m } iszero(eq(r, end)) { r := add(r, 0x20) } {\n                let e := add(calls.offset, mload(r))\n                let o := add(e, calldataload(add(e, 0x40)))\n                calldatacopy(m, add(o, 0x20), calldataload(o))\n                // forgefmt: disable-next-item\n                if iszero(call(gas(), calldataload(e), calldataload(add(e, 0x20)),\n                    m, calldataload(o), codesize(), 0x00)) {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n                mstore(r, m) // Append `m` into `results`.\n                mstore(m, returndatasize()) // Store the length,\n                let p := add(m, 0x20)\n                returndatacopy(p, 0x00, returndatasize()) // and copy the returndata.\n                m := add(p, returndatasize()) // Advance `m`.\n            }\n            mstore(0x40, m) // Allocate the memory.\n        }\n        _updateState();\n    }",
            "startLine": 245
          },
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC6551: 0x6faff5f1, ERC6551Executable: 0x51945447.\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x6faff5f1)), eq(s, 0x51945447))\n        }\n    }",
            "startLine": 289
          },
          {
            "name": "fallback",
            "signature": "fallback()",
            "selector": "",
            "visibility": "external",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_useLibZipCdFallback",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "LibZip.cdFallback",
                "type": "library",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "fallback() external payable virtual override(Receiver) receiverFallback {\n        if (_useLibZipCdFallback()) {\n            // Reverts with out-of-gas by recursing infinitely if the first 4 bytes\n            // of the decompressed `msg.data` doesn't match any function selector.\n            LibZip.cdFallback();\n        } else {\n            revert FnSelectorNotRecognized();\n        }\n    }",
            "startLine": 412
          }
        ],
        "internalFunctions": [
          {
            "name": "_isValidSigner",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "extraData",
                "type": "bytes32"
              },
              {
                "name": "context",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "owner",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _isValidSigner(address signer, bytes32 extraData, bytes calldata context)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        extraData = extraData; // Silence unused variable warning.\n        context = context; // Silence unused variable warning.\n        return signer == owner();\n    }",
            "startLine": 128
          },
          {
            "name": "_emptyContext",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "context",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _emptyContext() internal pure returns (bytes calldata context) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            context.length := 0\n        }\n    }",
            "startLine": 159
          },
          {
            "name": "_updateState",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _updateState() internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := _ERC6551_STATE_SLOT\n            let m := mload(0x40)\n            mstore(m, sload(s))\n            mstore(add(0x20, m), 0x40)\n            mstore(add(0x40, m), calldatasize())\n            calldatacopy(add(0x60, m), 0x00, add(0x20, calldatasize()))\n            sstore(s, keccak256(m, and(add(0x7f, calldatasize()), not(0x1f))))\n        }\n    }",
            "startLine": 186
          },
          {
            "name": "_hasOwnershipCycle",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _hasOwnershipCycle() internal view virtual returns (bool result) {\n        uint256 cachedChainId = _cachedChainId;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            extcodecopy(address(), 0x00, 0x4d, 0x60) // `(chainId, tokenContract, tokenId)`.\n            mstore(0x60, 0xfc0c546a) // `token()`.\n            for {} 1 {} {\n                let tokenContract := mload(0x20)\n                mstore(0x20, 0x6352211e) // `ownerOf(uint256)`.\n                let currentOwner :=\n                    mul( // `chainId == cachedChainId ? tokenContract.ownerOf(tokenId) : address(0)`.\n                        mload(0x20),\n                        and(\n                            and(gt(returndatasize(), 0x1f), eq(mload(0x00), cachedChainId)),\n                            staticcall(gas(), tokenContract, 0x3c, 0x24, 0x20, 0x20)\n                        )\n                    )\n                if iszero(eq(currentOwner, address())) {\n                    if iszero(\n                        and( // `(chainId, tokenContract, tokenId) = currentOwner.token()`.\n                            gt(returndatasize(), 0x5f),\n                            staticcall(gas(), currentOwner, 0x7c, 0x04, 0x00, 0x60)\n                        )\n                    ) { break }\n                    continue\n                }\n                result := 1\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }",
            "startLine": 303
          },
          {
            "name": "_authorizeUpgrade",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_updateState",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _authorizeUpgrade(address)\n        internal\n        virtual\n        override(UUPSUpgradeable)\n        onlyValidSigner\n        onlyViaERC6551Proxy\n    {\n        _updateState();\n    }",
            "startLine": 344
          },
          {
            "name": "_erc1271Signer",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "owner",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _erc1271Signer() internal view virtual override(ERC1271) returns (address) {\n        return owner();\n    }",
            "startLine": 370
          },
          {
            "name": "_useLibZipCdFallback",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _useLibZipCdFallback() internal view virtual returns (bool) {\n        return true;\n    }",
            "startLine": 406
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "Unauthorized",
            "parameters": [],
            "startLine": 56
          },
          {
            "name": "OperationNotSupported",
            "parameters": [],
            "startLine": 59
          },
          {
            "name": "SelfOwnDetected",
            "parameters": [],
            "startLine": 62
          }
        ],
        "structs": [
          {
            "name": "Call",
            "members": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "startLine": 45
          }
        ],
        "stateVariables": [
          {
            "name": "_ERC6551_STATE_SLOT",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 74
          },
          {
            "name": "_cachedChainId",
            "type": "uint256",
            "visibility": "private",
            "isConstant": false,
            "isImmutable": true,
            "startLine": 79
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./Receiver.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./ERC1271.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../utils/LibZip.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../utils/UUPSUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "ERC6551Proxy",
        "filePath": "accounts/ERC6551Proxy.sol",
        "kind": "contract",
        "inherits": [],
        "implements": [],
        "category": "other",
        "externalFunctions": [
          {
            "name": "fallback",
            "signature": "fallback()",
            "selector": "",
            "visibility": "external",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "fallback() external payable virtual {\n        bytes32 implementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, returndatasize()) // Optimization trick to change `6080604052` into `3d604052`.\n            implementation := sload(_ERC1967_IMPLEMENTATION_SLOT)\n        }\n        if (implementation == bytes32(0)) {\n            implementation = _defaultImplementation;\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Only initialize if the calldatasize is zero, so that staticcalls to\n                // functions (which will have 4-byte function selectors) won't revert.\n                // Some users may be fine without Etherscan proxy detection and thus may\n                // choose to not initialize the ERC1967 implementation slot.\n                if iszero(calldatasize()) { sstore(_ERC1967_IMPLEMENTATION_SLOT, implementation) }\n            }\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(returndatasize(), returndatasize(), calldatasize())\n            // forgefmt: disable-next-item\n            if iszero(delegatecall(gas(), implementation,\n                returndatasize(), calldatasize(), codesize(), returndatasize())) {\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n            returndatacopy(0x00, 0x00, returndatasize())\n            return(0x00, returndatasize())\n        }\n    }",
            "startLine": 47
          }
        ],
        "internalFunctions": [
          {
            "name": "constructor",
            "visibility": "default",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "defaultImplementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "constructor(address defaultImplementation) payable {\n        _defaultImplementation = bytes32(uint256(uint160(defaultImplementation)));\n    }",
            "startLine": 39
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "_defaultImplementation",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": false,
            "isImmutable": true,
            "startLine": 24
          },
          {
            "name": "_ERC1967_IMPLEMENTATION_SLOT",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 32
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "ERC7821",
        "filePath": "accounts/ERC7821.sol",
        "kind": "contract",
        "inherits": [
          "Receiver"
        ],
        "implements": [],
        "category": "other",
        "externalFunctions": [
          {
            "name": "execute",
            "signature": "execute(bytes32,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              },
              {
                "name": "executionData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_executionModeId",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_executeBatchOfBatches",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_execute",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function execute(bytes32 mode, bytes calldata executionData) public payable virtual {\n        uint256 id = _executionModeId(mode);\n        if (id == 3) return _executeBatchOfBatches(mode, executionData);\n        Call[] calldata calls;\n        bytes calldata opData;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(id) {\n                mstore(0x00, 0x7f181275) // `UnsupportedExecutionMode()`.\n                revert(0x1c, 0x04)\n            }\n            // Use inline assembly to extract the calls and optional `opData` efficiently.\n            opData.length := 0\n            let o := add(executionData.offset, calldataload(executionData.offset))\n            calls.offset := add(o, 0x20)\n            calls.length := calldataload(o)\n            // If the offset of `executionData` allows for `opData`, and the mode supports it.\n            if gt(eq(id, 2), gt(0x40, calldataload(executionData.offset))) {\n                let q := add(executionData.offset, calldataload(add(0x20, executionData.offset)))\n                opData.offset := add(q, 0x20)\n                opData.length := calldataload(q)\n            }\n            // Bounds checking for `executionData` is skipped here for efficiency.\n            // This is safe if it is only used as an argument to `execute` externally.\n            // If `executionData` used as an argument to other functions externally,\n            // please perform the bounds checks via `LibERC7579.decodeBatchAndOpData`\n            /// or `abi.decode` in the other functions for safety.\n        }\n        _execute(mode, executionData, calls, opData);\n    }",
            "startLine": 73
          },
          {
            "name": "supportsExecutionMode",
            "signature": "supportsExecutionMode(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_executionModeId",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsExecutionMode(bytes32 mode) public view virtual returns (bool result) {\n        return _executionModeId(mode) != 0;\n    }",
            "startLine": 105
          }
        ],
        "internalFunctions": [
          {
            "name": "_executionModeId",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _executionModeId(bytes32 mode) internal view virtual returns (uint256 id) {\n        // Only supports atomic batched executions.\n        // For the encoding scheme, see: https://eips.ethereum.org/EIPS/eip-7579\n        // Bytes Layout:\n        // - [0]      ( 1 byte )  `0x01` for batch call.\n        // - [1]      ( 1 byte )  `0x00` for revert on any failure.\n        // - [2..5]   ( 4 bytes)  Reserved by ERC7579 for future standardization.\n        // - [6..9]   ( 4 bytes)  `0x00000000` or `0x78210001` or `0x78210002`.\n        // - [10..31] (22 bytes)  Unused. Free for use.\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := and(shr(mul(22, 8), mode), 0xffff00000000ffffffff)\n            id := eq(m, 0x01000000000000000000) // 1.\n            id := or(shl(1, eq(m, 0x01000000000078210001)), id) // 2.\n            id := or(mul(3, eq(m, 0x01000000000078210002)), id) // 3.\n        }\n    }",
            "startLine": 114
          },
          {
            "name": "_executeBatchOfBatches",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              },
              {
                "name": "executionData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "execute",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _executeBatchOfBatches(bytes32 mode, bytes calldata executionData) internal virtual {\n        // Replace with `0x0100________78210001...` while preserving optional and reserved fields.\n        mode ^= bytes32(uint256(3 << (22 * 8))); // `2 XOR 3 = 1`.\n        (uint256 n, uint256 o, uint256 e) = (0, 0, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let j := calldataload(executionData.offset)\n            let t := add(executionData.offset, j)\n            n := calldataload(t) // `batches.length`.\n            o := add(0x20, t) // Offset of `batches[0]`.\n            e := add(executionData.offset, executionData.length) // End of `executionData`.\n            // Do the bounds check on `executionData` treating it as `abi.encode(bytes[])`.\n            // Not too expensive, so we will just do it right here right now.\n            if or(shr(64, j), or(lt(executionData.length, 0x20), gt(add(o, shl(5, n)), e))) {\n                mstore(0x00, 0x3995943b) // `BatchOfBatchesDecodingError()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        unchecked {\n            for (uint256 i; i != n; ++i) {\n                bytes calldata batch;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let j := calldataload(add(o, shl(5, i)))\n                    let t := add(o, j)\n                    batch.offset := add(t, 0x20)\n                    batch.length := calldataload(t)\n                    // Validate that `batches[i]` is not out-of-bounds.\n                    if or(shr(64, j), gt(add(batch.offset, batch.length), e)) {\n                        mstore(0x00, 0x3995943b) // `BatchOfBatchesDecodingError()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                execute(mode, batch);\n            }\n        }\n    }",
            "startLine": 133
          },
          {
            "name": "_execute",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              },
              {
                "name": "executionData",
                "type": "bytes"
              },
              {
                "name": "calls",
                "type": "Call[]"
              },
              {
                "name": "opData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_execute",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _execute(\n        bytes32 mode,\n        bytes calldata executionData,\n        Call[] calldata calls,\n        bytes calldata opData\n    ) internal virtual {\n        // Silence compiler warning on unused variables.\n        mode = mode;\n        executionData = executionData;\n        // Very basic auth to only allow this contract to be called by itself.\n        // Override this function to perform more complex auth with `opData`.\n        if (opData.length == uint256(0)) {\n            require(msg.sender == address(this));\n            // Remember to return `_execute(calls, extraData)` when you override this function.\n            return _execute(calls, bytes32(0));\n        }\n        revert(); // In your override, replace this with logic to operate on `opData`.\n    }",
            "startLine": 174
          },
          {
            "name": "_execute",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "calls",
                "type": "Call[]"
              },
              {
                "name": "extraData",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_get",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_execute",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _execute(Call[] calldata calls, bytes32 extraData) internal virtual {\n        unchecked {\n            uint256 i;\n            if (calls.length == uint256(0)) return;\n            do {\n                (address to, uint256 value, bytes calldata data) = _get(calls, i);\n                _execute(to, value, data, extraData);\n            } while (++i != calls.length);\n        }\n    }",
            "startLine": 196
          },
          {
            "name": "_execute",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "extraData",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _execute(address to, uint256 value, bytes calldata data, bytes32 extraData)\n        internal\n        virtual\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extraData := extraData // Silence unused variable compiler warning.\n            let m := mload(0x40) // Grab the free memory pointer.\n            calldatacopy(m, data.offset, data.length)\n            if iszero(call(gas(), to, value, m, data.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(m, 0x00, returndatasize())\n                revert(m, returndatasize())\n            }\n        }\n    }",
            "startLine": 210
          },
          {
            "name": "_get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "calls",
                "type": "Call[]"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _get(Call[] calldata calls, uint256 i)\n        internal\n        view\n        virtual\n        returns (address to, uint256 value, bytes calldata data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let c := add(calls.offset, calldataload(add(calls.offset, shl(5, i))))\n            // Replaces `to` with `address(this)` if `address(0)` is provided.\n            let t := shr(96, shl(96, calldataload(c)))\n            to := or(mul(address(), iszero(t)), t)\n            value := calldataload(add(c, 0x20))\n            let o := add(c, calldataload(add(c, 0x40)))\n            data.offset := add(o, 0x20)\n            data.length := calldataload(o)\n        }\n    }",
            "startLine": 228
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "UnsupportedExecutionMode",
            "parameters": [],
            "startLine": 33
          },
          {
            "name": "BatchOfBatchesDecodingError",
            "parameters": [],
            "startLine": 36
          }
        ],
        "structs": [
          {
            "name": "Call",
            "members": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "startLine": 22
          }
        ],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./Receiver.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "LibEIP7702",
        "filePath": "accounts/LibEIP7702.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "delegationOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function delegationOf(address account) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(account, 0x00, 0x00, 0x20)\n            // Note: Checking that it starts with hex\"ef01\" is the most general and futureproof.\n            // 7702 bytecode is `abi.encodePacked(hex\"ef01\", uint8(version), address(delegation))`.\n            result := mul(shr(96, mload(0x03)), eq(0xef01, shr(240, mload(0x00))))\n        }\n    }",
            "startLine": 59
          },
          {
            "name": "delegationAndImplementationOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "delegation",
                "type": "address"
              },
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "delegationOf",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "isEIP7702Proxy",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function delegationAndImplementationOf(address account)\n        internal\n        view\n        returns (address delegation, address implementation)\n    {\n        delegation = delegationOf(account);\n        if (isEIP7702Proxy(delegation)) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(0x00, 0)\n                if iszero(staticcall(gas(), account, 0x00, 0x01, 0x00, 0x20)) {\n                    revert(0x00, 0x00)\n                }\n                implementation := mload(0x00)\n            }\n        }\n    }",
            "startLine": 71
          },
          {
            "name": "implementationOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "isEIP7702Proxy",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "delegationOf",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function implementationOf(address target) internal view returns (address result) {\n        if (!isEIP7702Proxy(target)) if (!isEIP7702Proxy(delegationOf(target))) return address(0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0)\n            if iszero(staticcall(gas(), target, 0x00, 0x01, 0x00, 0x20)) {\n                revert(0x00, 0x00)\n            }\n            result := mload(0x00)\n        }\n    }",
            "startLine": 91
          },
          {
            "name": "isEIP7702Proxy",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isEIP7702Proxy(address target) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            // Copy the runtime bytecode without the CBOR metadata.\n            extcodecopy(target, m, 0x00, EIP7702_PROXY_MINIMAL_CODE_LENGTH)\n            // Zeroize the immutables.\n            mstore(add(m, 0x06), 0) // The first `7f<immutable_word>`.\n            mstore(add(m, 0x27), 0) // The second `7f<immutable_word>`.\n            let h := keccak256(m, EIP7702_PROXY_MINIMAL_CODE_LENGTH)\n            result := eq(EIP7702_PROXY_MINIMAL_CODE_HASH, h)\n        }\n    }",
            "startLine": 104
          },
          {
            "name": "proxyInitCode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "initialImplementation",
                "type": "address"
              },
              {
                "name": "initialAdmin",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function proxyInitCode(address initialImplementation, address initialAdmin)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(\n            EIP7702_PROXY_CREATION_CODE,\n            uint256(uint160(initialImplementation)),\n            uint256(uint160(initialAdmin))\n        );\n    }",
            "startLine": 119
          },
          {
            "name": "deployProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialImplementation",
                "type": "address"
              },
              {
                "name": "initialAdmin",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "proxyInitCode",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployProxy(address initialImplementation, address initialAdmin)\n        internal\n        returns (address instance)\n    {\n        bytes memory initCode = proxyInitCode(initialImplementation, initialAdmin);\n        /// @solidity memory-safe-assembly\n        assembly {\n            instance := create(0, add(initCode, 0x20), mload(initCode))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 132
          },
          {
            "name": "deployProxyDeterministic",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialImplementation",
                "type": "address"
              },
              {
                "name": "initialAdmin",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "proxyInitCode",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployProxyDeterministic(\n        address initialImplementation,\n        address initialAdmin,\n        bytes32 salt\n    ) internal returns (address instance) {\n        bytes memory initCode = proxyInitCode(initialImplementation, initialAdmin);\n        /// @solidity memory-safe-assembly\n        assembly {\n            instance := create2(0, add(initCode, 0x20), mload(initCode), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 148
          },
          {
            "name": "proxyAdmin",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proxy",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function proxyAdmin(address proxy) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0xf851a440) // `admin()`.\n            let t := staticcall(gas(), proxy, 0x1c, 0x04, 0x00, 0x20)\n            if iszero(and(gt(returndatasize(), 0x1f), t)) {\n                mstore(0x00, 0x26ec9b6a) // `ProxyQueryFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }",
            "startLine": 166
          },
          {
            "name": "changeProxyAdmin",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proxy",
                "type": "address"
              },
              {
                "name": "newAdmin",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function changeProxyAdmin(address proxy, address newAdmin) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x8f283970) // `changeAdmin(address)`.\n            mstore(0x20, newAdmin) // The implementation will clean the upper 96 bits.\n            if iszero(and(eq(mload(0x00), 1), call(gas(), proxy, 0, 0x1c, 0x24, 0x00, 0x20))) {\n                mstore(0x00, 0xc502e37e) // `ChangeProxyAdminFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 181
          },
          {
            "name": "upgradeProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proxy",
                "type": "address"
              },
              {
                "name": "newImplementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function upgradeProxy(address proxy, address newImplementation) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x0900f010) // `upgrade(address)`.\n            mstore(0x20, newImplementation) // The implementation will clean the upper 96 bits.\n            if iszero(and(eq(mload(0x00), 1), call(gas(), proxy, 0, 0x1c, 0x24, 0x00, 0x20))) {\n                mstore(0x00, 0xc6edd882) // `UpgradeProxyFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 195
          },
          {
            "name": "upgradeProxyDelegation",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newImplementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function upgradeProxyDelegation(address newImplementation) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := ERC1967_IMPLEMENTATION_SLOT\n            // Preserve the upper 96 bits when updating in case they are used for some stuff.\n            mstore(0x00, sload(s))\n            mstore(0x0c, shl(96, newImplementation))\n            sstore(s, mload(0x00))\n        }\n    }",
            "startLine": 218
          },
          {
            "name": "requestProxyDelegationInitialization",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function requestProxyDelegationInitialization() internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, sload(ERC1967_IMPLEMENTATION_SLOT))) {\n                // Use a dedicated transient storage slot for better Swiss-cheese-model safety.\n                tstore(EIP7702_PROXY_DELEGATION_INITIALIZATION_REQUEST_SLOT, address())\n            }\n        }\n    }",
            "startLine": 232
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "DeploymentFailed",
            "parameters": [],
            "startLine": 12
          },
          {
            "name": "ProxyQueryFailed",
            "parameters": [],
            "startLine": 15
          },
          {
            "name": "ChangeProxyAdminFailed",
            "parameters": [],
            "startLine": 18
          },
          {
            "name": "UpgradeProxyFailed",
            "parameters": [],
            "startLine": 21
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "ERC1967_IMPLEMENTATION_SLOT",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 29
          },
          {
            "name": "EIP7702_PROXY_DELEGATION_INITIALIZATION_REQUEST_SLOT",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 36
          },
          {
            "name": "EIP7702_PROXY_CREATION_CODE",
            "type": "bytes",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 41
          },
          {
            "name": "EIP7702_PROXY_MINIMAL_CODE_HASH",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 46
          },
          {
            "name": "EIP7702_PROXY_MINIMAL_CODE_LENGTH",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 51
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibERC6551",
        "filePath": "accounts/LibERC6551.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "initCode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation_",
                "type": "address"
              },
              {
                "name": "salt_",
                "type": "bytes32"
              },
              {
                "name": "chainId_",
                "type": "uint256"
              },
              {
                "name": "tokenContract_",
                "type": "address"
              },
              {
                "name": "tokenId_",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCode(\n        address implementation_,\n        bytes32 salt_,\n        uint256 chainId_,\n        address tokenContract_,\n        uint256 tokenId_\n    ) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer..\n            // Layout the variables and bytecode backwards.\n            mstore(add(result, 0xb7), tokenId_)\n            mstore(add(result, 0x97), shr(96, shl(96, tokenContract_)))\n            mstore(add(result, 0x77), chainId_)\n            mstore(add(result, 0x57), salt_)\n            mstore(add(result, 0x37), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(result, 0x28), implementation_)\n            mstore(add(result, 0x14), 0x3d60ad80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(result, 0xb7) // Store the length.\n            mstore(0x40, add(result, 0xd7)) // Allocate the memory.\n        }\n    }",
            "startLine": 33
          },
          {
            "name": "initCodeHash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation_",
                "type": "address"
              },
              {
                "name": "salt_",
                "type": "bytes32"
              },
              {
                "name": "chainId_",
                "type": "uint256"
              },
              {
                "name": "tokenContract_",
                "type": "address"
              },
              {
                "name": "tokenId_",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeHash(\n        address implementation_,\n        bytes32 salt_,\n        uint256 chainId_,\n        address tokenContract_,\n        uint256 tokenId_\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer.\n            // Layout the variables and bytecode backwards.\n            mstore(add(result, 0xa3), tokenId_)\n            mstore(add(result, 0x83), shr(96, shl(96, tokenContract_)))\n            mstore(add(result, 0x63), chainId_)\n            mstore(add(result, 0x43), salt_)\n            mstore(add(result, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(result, 0x14), implementation_)\n            mstore(result, 0x3d60ad80600a3d3981f3363d3d373d3d3d363d73)\n            result := keccak256(add(result, 0x0c), 0xb7)\n        }\n    }",
            "startLine": 57
          },
          {
            "name": "createAccount",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation_",
                "type": "address"
              },
              {
                "name": "salt_",
                "type": "bytes32"
              },
              {
                "name": "chainId_",
                "type": "uint256"
              },
              {
                "name": "tokenContract_",
                "type": "address"
              },
              {
                "name": "tokenId_",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function createAccount(\n        address implementation_,\n        bytes32 salt_,\n        uint256 chainId_,\n        address tokenContract_,\n        uint256 tokenId_\n    ) internal returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x14), implementation_)\n            mstore(add(m, 0x34), salt_)\n            mstore(add(m, 0x54), chainId_)\n            mstore(add(m, 0x74), shr(96, shl(96, tokenContract_)))\n            mstore(add(m, 0x94), tokenId_)\n            // `createAccount(address,bytes32,uint256,address,uint256)`.\n            mstore(m, 0x8a54c52f000000000000000000000000)\n            if iszero(\n                and(\n                    gt(returndatasize(), 0x1f),\n                    call(gas(), REGISTRY, 0, add(m, 0x10), 0xa4, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x20188a59) // `AccountCreationFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }",
            "startLine": 80
          },
          {
            "name": "account",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation_",
                "type": "address"
              },
              {
                "name": "salt_",
                "type": "bytes32"
              },
              {
                "name": "chainId_",
                "type": "uint256"
              },
              {
                "name": "tokenContract_",
                "type": "address"
              },
              {
                "name": "tokenId_",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function account(\n        address implementation_,\n        bytes32 salt_,\n        uint256 chainId_,\n        address tokenContract_,\n        uint256 tokenId_\n    ) internal pure returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer.\n            // Layout the variables and bytecode backwards.\n            mstore(add(result, 0xa3), tokenId_)\n            mstore(add(result, 0x83), shr(96, shl(96, tokenContract_)))\n            mstore(add(result, 0x63), chainId_)\n            mstore(add(result, 0x43), salt_)\n            mstore(add(result, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(result, 0x14), implementation_)\n            mstore(result, 0x3d60ad80600a3d3981f3363d3d373d3d3d363d73)\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(add(result, 0x0c), 0xb7))\n            mstore(0x01, shl(96, REGISTRY))\n            mstore(0x15, salt_)\n            result := keccak256(0x00, 0x55)\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 111
          },
          {
            "name": "isERC6551Account",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "a",
                "type": "address"
              },
              {
                "name": "expectedImplementation",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isERC6551Account(address a, address expectedImplementation)\n        internal\n        view\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Grab the free memory pointer..\n            extcodecopy(a, add(m, 0x20), 0x0a, 0xa3)\n            let implementation_ := shr(96, mload(add(m, 0x20)))\n            if mul(\n                extcodesize(implementation_),\n                gt(eq(extcodesize(a), 0xad), shl(96, xor(expectedImplementation, implementation_)))\n            ) {\n                // Layout the variables and bytecode backwards.\n                mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n                mstore(add(m, 0x14), implementation_)\n                mstore(m, 0x3d60ad80600a3d3981f3363d3d373d3d3d363d73)\n                // Compute and store the bytecode hash.\n                mstore8(0x00, 0xff) // Write the prefix.\n                mstore(0x35, keccak256(add(m, 0x0c), 0xb7))\n                mstore(0x01, shl(96, REGISTRY))\n                mstore(0x15, mload(add(m, 0x43)))\n                result := iszero(shl(96, xor(a, keccak256(0x00, 0x55))))\n                mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n            }\n        }\n    }",
            "startLine": 140
          },
          {
            "name": "implementation",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "a",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function implementation(address a) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(a, 0x00, 0x0a, 0x14)\n            result := shr(96, mload(0x00))\n        }\n    }",
            "startLine": 170
          },
          {
            "name": "context",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "a",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "salt_",
                "type": "bytes32"
              },
              {
                "name": "chainId_",
                "type": "uint256"
              },
              {
                "name": "tokenContract_",
                "type": "address"
              },
              {
                "name": "tokenId_",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function context(address a)\n        internal\n        view\n        returns (bytes32 salt_, uint256 chainId_, address tokenContract_, uint256 tokenId_)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            extcodecopy(a, 0x00, 0x2d, 0x80)\n            salt_ := mload(0x00)\n            chainId_ := mload(0x20)\n            tokenContract_ := mload(0x40)\n            tokenId_ := mload(0x60)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }",
            "startLine": 179
          },
          {
            "name": "salt",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "a",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function salt(address a) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(a, 0x00, 0x2d, 0x20)\n            result := mload(0x00)\n        }\n    }",
            "startLine": 198
          },
          {
            "name": "chainId",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "a",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function chainId(address a) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(a, 0x00, 0x4d, 0x20)\n            result := mload(0x00)\n        }\n    }",
            "startLine": 207
          },
          {
            "name": "tokenContract",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "a",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tokenContract(address a) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(a, 0x00, 0x6d, 0x20)\n            result := mload(0x00)\n        }\n    }",
            "startLine": 216
          },
          {
            "name": "tokenId",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "a",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tokenId(address a) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(a, 0x00, 0x8d, 0x20)\n            result := mload(0x00)\n        }\n    }",
            "startLine": 225
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "AccountCreationFailed",
            "parameters": [],
            "startLine": 13
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "REGISTRY",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 20
          },
          {
            "name": "REGISTRY_BYTECODE",
            "type": "bytes",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 25
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibERC7579",
        "filePath": "accounts/LibERC7579.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "encodeMode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "callType",
                "type": "bytes1"
              },
              {
                "name": "execType",
                "type": "bytes1"
              },
              {
                "name": "selector",
                "type": "bytes4"
              },
              {
                "name": "payload",
                "type": "bytes22"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function encodeMode(bytes1 callType, bytes1 execType, bytes4 selector, bytes22 payload)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := or(shl(8, byte(0, callType)), byte(0, execType))\n            result := or(shr(224, selector), shl(64, result))\n            result := or(shr(80, payload), shl(176, result))\n        }\n    }",
            "startLine": 42
          },
          {
            "name": "getCallType",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes1"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getCallType(bytes32 mode) internal pure returns (bytes1) {\n        return bytes1(mode);\n    }",
            "startLine": 56
          },
          {
            "name": "getExecType",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes1"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getExecType(bytes32 mode) internal pure returns (bytes1) {\n        return mode[1];\n    }",
            "startLine": 61
          },
          {
            "name": "getSelector",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes4"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getSelector(bytes32 mode) internal pure returns (bytes4) {\n        return bytes4(bytes32(uint256(mode) << 48));\n    }",
            "startLine": 66
          },
          {
            "name": "getPayload",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes22"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getPayload(bytes32 mode) internal pure returns (bytes22) {\n        return bytes22(bytes32(uint256(mode) << 80));\n    }",
            "startLine": 71
          },
          {
            "name": "decodeSingle",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "executionData",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function decodeSingle(bytes calldata executionData)\n        internal\n        pure\n        returns (address target, uint256 value, bytes calldata data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(gt(executionData.length, 0x33)) {\n                mstore(0x00, 0xba597e7e) // `DecodingError()`.\n                revert(0x1c, 0x04)\n            }\n            target := shr(96, calldataload(executionData.offset))\n            value := calldataload(add(executionData.offset, 0x14))\n            data.offset := add(executionData.offset, 0x34)\n            data.length := sub(executionData.length, 0x34)\n        }\n    }",
            "startLine": 81
          },
          {
            "name": "decodeSingleUnchecked",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "executionData",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function decodeSingleUnchecked(bytes calldata executionData)\n        internal\n        pure\n        returns (address target, uint256 value, bytes calldata data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            target := shr(96, calldataload(executionData.offset))\n            value := calldataload(add(executionData.offset, 0x14))\n            data.offset := add(executionData.offset, 0x34)\n            data.length := sub(executionData.length, 0x34)\n        }\n    }",
            "startLine": 100
          },
          {
            "name": "decodeDelegate",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "executionData",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function decodeDelegate(bytes calldata executionData)\n        internal\n        pure\n        returns (address target, bytes calldata data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(gt(executionData.length, 0x13)) {\n                mstore(0x00, 0xba597e7e) // `DecodingError()`.\n                revert(0x1c, 0x04)\n            }\n            target := shr(96, calldataload(executionData.offset))\n            data.offset := add(executionData.offset, 0x14)\n            data.length := sub(executionData.length, 0x14)\n        }\n    }",
            "startLine": 116
          },
          {
            "name": "decodeDelegateUnchecked",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "executionData",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function decodeDelegateUnchecked(bytes calldata executionData)\n        internal\n        pure\n        returns (address target, bytes calldata data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            target := shr(96, calldataload(executionData.offset))\n            data.offset := add(executionData.offset, 0x14)\n            data.length := sub(executionData.length, 0x14)\n        }\n    }",
            "startLine": 134
          },
          {
            "name": "decodeBatch",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "executionData",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "pointers",
                "type": "bytes32[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function decodeBatch(bytes calldata executionData)\n        internal\n        pure\n        returns (bytes32[] calldata pointers)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let u := calldataload(executionData.offset)\n            let s := add(executionData.offset, u)\n            let e := sub(add(executionData.offset, executionData.length), 0x20)\n            pointers.offset := add(s, 0x20)\n            pointers.length := calldataload(s)\n            if or(shr(64, u), gt(add(s, shl(5, pointers.length)), e)) {\n                mstore(0x00, 0xba597e7e) // `DecodingError()`.\n                revert(0x1c, 0x04)\n            }\n            if pointers.length {\n                // Perform bounds checks on the decoded `pointers`.\n                // Loop runs out-of-gas if `pointers.length` is big enough to cause overflows.\n                for { let i := pointers.length } 1 {} {\n                    i := sub(i, 1)\n                    let p := calldataload(add(pointers.offset, shl(5, i)))\n                    let c := add(pointers.offset, p)\n                    let q := calldataload(add(c, 0x40))\n                    let o := add(c, q)\n                    // forgefmt: disable-next-item\n                    if or(shr(64, or(calldataload(o), or(p, q))),\n                        or(gt(add(c, 0x40), e), gt(add(o, calldataload(o)), e))) {\n                        mstore(0x00, 0xba597e7e) // `DecodingError()`.\n                        revert(0x1c, 0x04)\n                    }\n                    if iszero(i) { break }\n                }\n            }\n        }\n    }",
            "startLine": 149
          },
          {
            "name": "decodeBatchUnchecked",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "executionData",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "pointers",
                "type": "bytes32[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function decodeBatchUnchecked(bytes calldata executionData)\n        internal\n        pure\n        returns (bytes32[] calldata pointers)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := add(executionData.offset, calldataload(executionData.offset))\n            pointers.offset := add(o, 0x20)\n            pointers.length := calldataload(o)\n        }\n    }",
            "startLine": 189
          },
          {
            "name": "decodeBatchAndOpData",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "executionData",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "pointers",
                "type": "bytes32[]"
              },
              {
                "name": "opData",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "emptyCalldataBytes",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "decodeBatch",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "hasOpData",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function decodeBatchAndOpData(bytes calldata executionData)\n        internal\n        pure\n        returns (bytes32[] calldata pointers, bytes calldata opData)\n    {\n        opData = emptyCalldataBytes();\n        pointers = decodeBatch(executionData);\n        if (hasOpData(executionData)) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let e := sub(add(executionData.offset, executionData.length), 0x20)\n                let p := calldataload(add(0x20, executionData.offset))\n                let q := add(executionData.offset, p)\n                opData.offset := add(q, 0x20)\n                opData.length := calldataload(q)\n                if or(shr(64, or(opData.length, p)), gt(add(q, opData.length), e)) {\n                    mstore(0x00, 0xba597e7e) // `DecodingError()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 204
          },
          {
            "name": "decodeBatchAndOpDataUnchecked",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "executionData",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "pointers",
                "type": "bytes32[]"
              },
              {
                "name": "opData",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "emptyCalldataBytes",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "decodeBatchUnchecked",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "hasOpData",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function decodeBatchAndOpDataUnchecked(bytes calldata executionData)\n        internal\n        pure\n        returns (bytes32[] calldata pointers, bytes calldata opData)\n    {\n        opData = emptyCalldataBytes();\n        pointers = decodeBatchUnchecked(executionData);\n        if (hasOpData(executionData)) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let q := add(executionData.offset, calldataload(add(0x20, executionData.offset)))\n                opData.offset := add(q, 0x20)\n                opData.length := calldataload(q)\n            }\n        }\n    }",
            "startLine": 230
          },
          {
            "name": "hasOpData",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "executionData",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hasOpData(bytes calldata executionData) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(\n                or(lt(executionData.length, 0x40), lt(calldataload(executionData.offset), 0x40))\n            )\n        }\n    }",
            "startLine": 248
          },
          {
            "name": "getExecution",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "pointers",
                "type": "bytes32[]"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getExecution(bytes32[] calldata pointers, uint256 i)\n        internal\n        pure\n        returns (address target, uint256 value, bytes calldata data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let c := add(pointers.offset, calldataload(add(pointers.offset, shl(5, i))))\n            target := calldataload(c)\n            value := calldataload(add(c, 0x20))\n            let o := add(c, calldataload(add(c, 0x40)))\n            data.offset := add(o, 0x20)\n            data.length := calldataload(o)\n        }\n    }",
            "startLine": 259
          },
          {
            "name": "reencodeBatch",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "executionData",
                "type": "bytes"
              },
              {
                "name": "opData",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function reencodeBatch(bytes calldata executionData, bytes memory opData)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := add(0x64, mload(0x40)) // Give some space for `reencodeBatchAsExecuteCalldata`.\n            let s := calldataload(executionData.offset) // Offset of `calls`.\n            let n := sub(executionData.length, s) // Byte length of `calls`.\n            mstore(add(result, 0x20), 0x40) // Store the new offset of `calls`.\n            calldatacopy(add(result, 0x60), add(executionData.offset, s), n)\n            mstore(add(result, 0x40), add(0x40, n)) // Store the new offset of `opData`.\n            let o := add(add(result, 0x60), n) // Start offset of `opData` destination in memory.\n            let d := sub(opData, o) // Offset difference between `opData` source and `o`.\n            let end := add(mload(opData), add(0x20, o)) // End of `opData` destination in memory.\n            for {} 1 {} {\n                mstore(o, mload(add(o, d)))\n                o := add(o, 0x20)\n                if iszero(lt(o, end)) { break }\n            }\n            mstore(result, sub(o, add(result, 0x20))) // Store the length of `result`.\n            calldatacopy(end, calldatasize(), 0x40) // Zeroize the bytes after `end`.\n            mstore(0x40, add(0x20, o)) // Allocate memory.\n        }\n    }",
            "startLine": 279
          },
          {
            "name": "reencodeBatchAsExecuteCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              },
              {
                "name": "executionData",
                "type": "bytes"
              },
              {
                "name": "opData",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "reencodeBatch",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function reencodeBatchAsExecuteCalldata(\n        bytes32 mode,\n        bytes calldata executionData,\n        bytes memory opData\n    ) internal pure returns (bytes memory result) {\n        result = reencodeBatch(executionData, opData);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(result)\n            result := sub(result, 0x64)\n            mstore(add(result, 0x44), 0x40) // Offset of `executionData`.\n            mstore(add(result, 0x24), mode)\n            mstore(add(result, 0x04), 0xe9ae5c53) // `execute(bytes32,bytes)`.\n            mstore(result, add(0x64, n))\n        }\n    }",
            "startLine": 307
          },
          {
            "name": "emptyCalldataBytes",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function emptyCalldataBytes() internal pure returns (bytes calldata result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.offset := 0\n            result.length := 0\n        }\n    }",
            "startLine": 329
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "DecodingError",
            "parameters": [],
            "startLine": 13
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "CALLTYPE_SINGLE",
            "type": "bytes1",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 20
          },
          {
            "name": "CALLTYPE_BATCH",
            "type": "bytes1",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 23
          },
          {
            "name": "CALLTYPE_STATICCALL",
            "type": "bytes1",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 26
          },
          {
            "name": "CALLTYPE_DELEGATECALL",
            "type": "bytes1",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 29
          },
          {
            "name": "EXECTYPE_DEFAULT",
            "type": "bytes1",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 32
          },
          {
            "name": "EXECTYPE_TRY",
            "type": "bytes1",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 35
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "Receiver",
        "filePath": "accounts/Receiver.sol",
        "kind": "abstract",
        "inherits": [],
        "implements": [],
        "category": "other",
        "externalFunctions": [
          {
            "name": "receive",
            "signature": "receive()",
            "selector": "",
            "visibility": "external",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "receive() external payable virtual {}",
            "startLine": 24
          },
          {
            "name": "fallback",
            "signature": "fallback()",
            "selector": "",
            "visibility": "external",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "fallback() external payable virtual receiverFallback {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x3c10b94e) // `FnSelectorNotRecognized()`.\n            revert(0x1c, 0x04)\n        }\n    }",
            "startLine": 27
          }
        ],
        "internalFunctions": [
          {
            "name": "_useReceiverFallbackBody",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _useReceiverFallbackBody() internal view virtual returns (bool) {\n        return true;\n    }",
            "startLine": 57
          },
          {
            "name": "_beforeReceiverFallbackBody",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _beforeReceiverFallbackBody() internal virtual {}",
            "startLine": 62
          },
          {
            "name": "_afterReceiverFallbackBody",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _afterReceiverFallbackBody() internal virtual {}",
            "startLine": 65
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "FnSelectorNotRecognized",
            "parameters": [],
            "startLine": 17
          }
        ],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "Timelock",
        "filePath": "accounts/Timelock.sol",
        "kind": "contract",
        "inherits": [
          "ERC7821",
          "EnumerableRoles"
        ],
        "implements": [],
        "category": "other",
        "externalFunctions": [
          {
            "name": "initialize",
            "signature": "initialize(uint256,address,address[],address[],address[])",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialMinDelay",
                "type": "uint256"
              },
              {
                "name": "initialAdmin",
                "type": "address"
              },
              {
                "name": "proposers",
                "type": "address[]"
              },
              {
                "name": "executors",
                "type": "address[]"
              },
              {
                "name": "cancellers",
                "type": "address[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initializeTimelockAuthorizationCheck",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_setRole",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_bulkSetRole",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function initialize(\n        uint256 initialMinDelay,\n        address initialAdmin,\n        address[] calldata proposers,\n        address[] calldata executors,\n        address[] calldata cancellers\n    ) public virtual {\n        _initializeTimelockAuthorizationCheck();\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(254, initialMinDelay) {\n                mstore(0x00, 0xd1efaf25) // `TimelockDelayOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            let s := _TIMELOCK_SLOT\n            if sload(s) {\n                mstore(0x00, 0xc44f149c) // `TimelockAlreadyInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(s, not(initialMinDelay))\n            mstore(0x00, initialMinDelay)\n            log1(0x00, 0x20, _MIN_DELAY_SET_EVENT_SIGNATURE)\n        }\n        if (initialAdmin != address(0)) {\n            _setRole(initialAdmin, ADMIN_ROLE, true);\n        }\n        _bulkSetRole(proposers, PROPOSER_ROLE, true);\n        _bulkSetRole(executors, EXECUTOR_ROLE, true);\n        _bulkSetRole(cancellers, CANCELLER_ROLE, true);\n    }",
            "startLine": 166
          },
          {
            "name": "propose",
            "signature": "propose(bytes32,bytes,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              },
              {
                "name": "executionData",
                "type": "bytes"
              },
              {
                "name": "delay",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "LibERC7579.decodeBatchAndOpData",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "minDelay",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function propose(bytes32 mode, bytes calldata executionData, uint256 delay)\n        public\n        virtual\n        onlyRole(PROPOSER_ROLE)\n        returns (bytes32 id)\n    {\n        LibERC7579.decodeBatchAndOpData(executionData); // Check if properly encoded.\n        uint256 t = minDelay();\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(254, delay) {\n                mstore(0x00, 0xd1efaf25) // `TimelockDelayOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            if lt(delay, t) {\n                mstore(0x00, 0x54336609) // `TimelockInsufficientDelay(uint256,uint256)`.\n                mstore(0x20, delay)\n                mstore(0x40, t)\n                revert(0x1c, 0x44)\n            }\n            let m := mload(0x40)\n            calldatacopy(add(m, 0x80), executionData.offset, executionData.length)\n            mstore(0x00, mode)\n            mstore(0x20, keccak256(add(m, 0x80), executionData.length))\n            id := keccak256(0x00, 0x40)\n            mstore(0x09, _TIMELOCK_SLOT)\n            mstore(0x00, id)\n            let s := keccak256(0x00, 0x29) // Operation slot.\n            if sload(s) {\n                mstore(0x00, 0xd639b0bf) // `TimelockInvalidOperation(bytes32,uint256)`.\n                mstore(0x20, id)\n                mstore(0x40, 1) // `1 << OperationState.Unset`\n                revert(0x1c, 0x44)\n            }\n            // Emits the {Proposed} event.\n            mstore(m, mode)\n            mstore(add(m, 0x20), 0x60)\n            let r := add(delay, timestamp()) // `readyTimestamp`.\n            sstore(s, shl(1, r)) // Update the operation in the storage.\n            mstore(add(m, 0x40), r)\n            mstore(add(m, 0x60), executionData.length)\n            // Some indexers require the bytes to be zero-right padded.\n            mstore(add(add(m, 0x80), executionData.length), 0) // Zeroize the slot after the end.\n            // forgefmt: disable-next-item\n            log2(m, add(0x80, and(not(0x1f), add(0x1f, executionData.length))),\n                _PROPOSED_EVENT_SIGNATURE, id)\n        }\n    }",
            "startLine": 227
          },
          {
            "name": "cancel",
            "signature": "cancel(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x09, _TIMELOCK_SLOT)\n            mstore(0x00, id)\n            let s := keccak256(0x00, 0x29) // Operation slot.\n            let p := sload(s)\n            if or(and(1, p), iszero(p)) {\n                mstore(0x00, 0xd639b0bf) // `TimelockInvalidOperation(bytes32,uint256)`.\n                mstore(0x20, id)\n                mstore(0x40, 6) // `(1 << OperationState.Waiting) | (1 << OperationState.Ready)`\n                revert(0x1c, 0x44)\n            }\n            sstore(s, 0) // Clears the operation's storage slot.\n            // Emits the {Cancelled} event.\n            log2(0x00, 0x00, _CANCELLED_EVENT_SIGNATURE, id)\n        }\n    }",
            "startLine": 278
          },
          {
            "name": "setMinDelay",
            "signature": "setMinDelay(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newMinDelay",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setMinDelay(uint256 newMinDelay) public virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(caller(), address())) {\n                mstore(0x00, 0x55140ae8) // `TimelockUnauthorized()`.\n                revert(0x1c, 0x04)\n            }\n            if shr(254, newMinDelay) {\n                mstore(0x00, 0xd1efaf25) // `TimelockDelayOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(_TIMELOCK_SLOT, not(newMinDelay))\n            // Emits the {SetMinDelay} event.\n            mstore(0x00, newMinDelay)\n            log1(0x00, 0x20, _MIN_DELAY_SET_EVENT_SIGNATURE)\n        }\n    }",
            "startLine": 299
          },
          {
            "name": "minDelay",
            "signature": "minDelay()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function minDelay() public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(sload(_TIMELOCK_SLOT))\n        }\n    }",
            "startLine": 322
          },
          {
            "name": "readyTimestamp",
            "signature": "readyTimestamp(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function readyTimestamp(bytes32 id) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x09, _TIMELOCK_SLOT)\n            mstore(0x00, id)\n            result := shr(1, sload(keccak256(0x00, 0x29)))\n        }\n    }",
            "startLine": 330
          },
          {
            "name": "operationState",
            "signature": "operationState(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "OperationState"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function operationState(bytes32 id) public view virtual returns (OperationState result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x09, _TIMELOCK_SLOT)\n            mstore(0x00, id)\n            result := sload(keccak256(0x00, 0x29))\n            // forgefmt: disable-next-item\n            result := mul(iszero(iszero(result)),\n                add(and(result, 1), sub(2, lt(timestamp(), shr(1, result)))))\n        }\n    }",
            "startLine": 340
          }
        ],
        "internalFunctions": [
          {
            "name": "_initializeTimelockAuthorizationCheck",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _initializeTimelockAuthorizationCheck() internal virtual {\n        uint256 self = __timelockSelf;\n        uint256 deployer = __timelockDeployer;\n        uint256 deployerOrigin = __timelockDeployerOrigin;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(self, address()) {\n                if iszero(or(eq(caller(), deployer), eq(caller(), deployerOrigin))) {\n                    mstore(0x00, 0x55140ae8) // `TimelockUnauthorized()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 206
          },
          {
            "name": "_bulkSetRole",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "addresses",
                "type": "address[]"
              },
              {
                "name": "role",
                "type": "uint256"
              },
              {
                "name": "active",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setRole",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _bulkSetRole(address[] calldata addresses, uint256 role, bool active)\n        internal\n        virtual\n    {\n        for (uint256 i; i != addresses.length;) {\n            address a;\n            /// @solidity memory-safe-assembly\n            assembly {\n                a := calldataload(add(addresses.offset, shl(5, i)))\n                i := add(i, 1)\n            }\n            _setRole(a, role, active);\n        }\n    }",
            "startLine": 357
          },
          {
            "name": "_execute",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              },
              {
                "name": "executionData",
                "type": "bytes"
              },
              {
                "name": "calls",
                "type": "Call[]"
              },
              {
                "name": "opData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "hasRole",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_checkRole",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_execute",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _execute(\n        bytes32 mode,\n        bytes calldata executionData,\n        Call[] calldata calls,\n        bytes calldata opData\n    ) internal virtual override(ERC7821) {\n        if (!hasRole(OPEN_ROLE_HOLDER, EXECUTOR_ROLE)) {\n            _checkRole(EXECUTOR_ROLE);\n        }\n        bytes32 id;\n        uint256 s;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Copies the `executionData` for the event and to compute the `id`.\n            calldatacopy(mload(0x40), executionData.offset, executionData.length)\n            mstore(0x00, mode)\n            mstore(0x20, keccak256(mload(0x40), executionData.length))\n            id := keccak256(0x00, 0x40)\n            mstore(0x09, _TIMELOCK_SLOT)\n            mstore(0x00, id)\n            s := keccak256(0x00, 0x29)\n            let p := sload(s)\n            if or(or(and(1, p), iszero(p)), lt(timestamp(), shr(1, p))) {\n                mstore(0x00, 0xd639b0bf) // `TimelockInvalidOperation(bytes32,uint256)`.\n                mstore(0x20, id)\n                mstore(0x40, 4) // `1 << OperationState.Ready`\n                revert(0x1c, 0x44)\n            }\n            // Check if optional predecessor has been executed.\n            if iszero(lt(opData.length, 0x20)) {\n                let b := calldataload(opData.offset) // Predecessor's id.\n                mstore(0x00, b) // `_TIMELOCK_SLOT` is already at `0x09`.\n                if iszero(or(iszero(b), and(1, sload(keccak256(0x00, 0x29))))) {\n                    mstore(0x00, 0x90a9a618) // `TimelockUnexecutedPredecessor(bytes32)`.\n                    mstore(0x20, b)\n                    revert(0x1c, 0x24)\n                }\n            }\n        }\n        _execute(calls, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Recheck the operation after the calls, in case of reentrancy.\n            let p := sload(s)\n            if or(or(and(1, p), iszero(p)), lt(timestamp(), shr(1, p))) {\n                mstore(0x00, 0xd639b0bf) // `TimelockInvalidOperation(bytes32,uint256)`.\n                mstore(0x20, id)\n                mstore(0x40, 4) // `1 << OperationState.Ready`\n                revert(0x1c, 0x44)\n            }\n            let m := mload(0x40)\n            // Copies the `executionData` for the event.\n            calldatacopy(add(m, 0x60), executionData.offset, executionData.length)\n            // Emits the {Executed} event.\n            mstore(m, mode)\n            mstore(add(m, 0x20), 0x40)\n            mstore(add(m, 0x40), executionData.length)\n            // Some indexers require the bytes to be zero-right padded.\n            mstore(add(add(m, 0x60), executionData.length), 0) // Zeroize the slot after the end.\n            // forgefmt: disable-next-item\n            log2(m, add(0x60, and(not(0x1f), add(0x1f, executionData.length))),\n                _EXECUTED_EVENT_SIGNATURE, id)\n            sstore(s, or(1, p)) // Set the operation as executed in the storage.\n        }\n    }",
            "startLine": 380
          },
          {
            "name": "_authorizeSetRole",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_checkRole",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _authorizeSetRole(address, uint256, bool) internal virtual override(EnumerableRoles) {\n        if (msg.sender != address(this)) _checkRole(ADMIN_ROLE);\n    }",
            "startLine": 448
          }
        ],
        "events": [
          {
            "name": "Proposed",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "mode",
                "type": "bytes32",
                "indexed": false
              },
              {
                "name": "executionData",
                "type": "bytes",
                "indexed": false
              },
              {
                "name": "readyTimestamp",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 134
          },
          {
            "name": "Executed",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "mode",
                "type": "bytes32",
                "indexed": false
              },
              {
                "name": "executionData",
                "type": "bytes",
                "indexed": false
              }
            ],
            "startLine": 137
          },
          {
            "name": "Cancelled",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32",
                "indexed": true
              }
            ],
            "startLine": 140
          },
          {
            "name": "MinDelaySet",
            "parameters": [
              {
                "name": "newMinDelay",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 143
          }
        ],
        "errors": [
          {
            "name": "TimelockInsufficientDelay",
            "parameters": [
              {
                "name": "delay",
                "type": "uint256"
              },
              {
                "name": "minDelay",
                "type": "uint256"
              }
            ],
            "startLine": 79
          },
          {
            "name": "TimelockInvalidOperation",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              },
              {
                "name": "expectedStates",
                "type": "uint256"
              }
            ],
            "startLine": 84
          },
          {
            "name": "TimelockUnexecutedPredecessor",
            "parameters": [
              {
                "name": "predecessor",
                "type": "bytes32"
              }
            ],
            "startLine": 87
          },
          {
            "name": "TimelockUnauthorized",
            "parameters": [],
            "startLine": 90
          },
          {
            "name": "TimelockDelayOverflow",
            "parameters": [],
            "startLine": 93
          },
          {
            "name": "TimelockAlreadyInitialized",
            "parameters": [],
            "startLine": 96
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "ADMIN_ROLE",
            "type": "uint256",
            "visibility": "public",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 44
          },
          {
            "name": "PROPOSER_ROLE",
            "type": "uint256",
            "visibility": "public",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 47
          },
          {
            "name": "EXECUTOR_ROLE",
            "type": "uint256",
            "visibility": "public",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 50
          },
          {
            "name": "CANCELLER_ROLE",
            "type": "uint256",
            "visibility": "public",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 53
          },
          {
            "name": "MAX_ROLE",
            "type": "uint256",
            "visibility": "public",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 56
          },
          {
            "name": "OPEN_ROLE_HOLDER",
            "type": "address",
            "visibility": "public",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 60
          },
          {
            "name": "_TIMELOCK_SLOT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 114
          },
          {
            "name": "__timelockSelf",
            "type": "uint256",
            "visibility": "private",
            "isConstant": false,
            "isImmutable": true,
            "startLine": 121
          },
          {
            "name": "__timelockDeployer",
            "type": "uint256",
            "visibility": "private",
            "isConstant": false,
            "isImmutable": true,
            "startLine": 124
          },
          {
            "name": "__timelockDeployerOrigin",
            "type": "uint256",
            "visibility": "private",
            "isConstant": false,
            "isImmutable": true,
            "startLine": 127
          },
          {
            "name": "_PROPOSED_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 146
          },
          {
            "name": "_EXECUTED_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 150
          },
          {
            "name": "_CANCELLED_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 154
          },
          {
            "name": "_MIN_DELAY_SET_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 158
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./ERC7821.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./LibERC7579.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../auth/EnumerableRoles.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "ERC7821",
        "filePath": "accounts/ext/ithaca/ERC7821.sol",
        "kind": "contract",
        "inherits": [
          "Receiver"
        ],
        "implements": [],
        "category": "other",
        "externalFunctions": [
          {
            "name": "execute",
            "signature": "execute(bytes32,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              },
              {
                "name": "executionData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_executionModeId",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_executeBatchOfBatches",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_executeOptimizedBatch",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_execute",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function execute(bytes32 mode, bytes calldata executionData) public payable virtual {\n        uint256 id = _executionModeId(mode);\n        if (id == 3) return _executeBatchOfBatches(mode, executionData);\n        if (id == 4) return _executeOptimizedBatch(mode, executionData);\n        Call[] calldata calls;\n        bytes calldata opData;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(id) {\n                mstore(0x00, 0x7f181275) // `UnsupportedExecutionMode()`.\n                revert(0x1c, 0x04)\n            }\n            // Use inline assembly to extract the calls and optional `opData` efficiently.\n            opData.length := 0\n            let o := add(executionData.offset, calldataload(executionData.offset))\n            calls.offset := add(o, 0x20)\n            calls.length := calldataload(o)\n            // If the offset of `executionData` allows for `opData`, and the mode supports it.\n            if gt(eq(id, 2), gt(0x40, calldataload(executionData.offset))) {\n                let q := add(executionData.offset, calldataload(add(0x20, executionData.offset)))\n                opData.offset := add(q, 0x20)\n                opData.length := calldataload(q)\n            }\n            // Bounds checking for `executionData` is skipped here for efficiency.\n            // This is safe if it is only used as an argument to `execute` externally.\n            // If `executionData` used as an argument to other functions externally,\n            // please perform the bounds checks via `LibERC7579.decodeBatchAndOpData`\n            /// or `abi.decode` in the other functions for safety.\n        }\n        _execute(mode, executionData, calls, opData);\n    }",
            "startLine": 78
          },
          {
            "name": "supportsExecutionMode",
            "signature": "supportsExecutionMode(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_executionModeId",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsExecutionMode(bytes32 mode) public view virtual returns (bool result) {\n        return _executionModeId(mode) != 0;\n    }",
            "startLine": 112
          }
        ],
        "internalFunctions": [
          {
            "name": "_executionModeId",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _executionModeId(bytes32 mode) internal view virtual returns (uint256 id) {\n        // Only supports atomic batched executions.\n        // For the encoding scheme, see: https://eips.ethereum.org/EIPS/eip-7579\n        // Bytes Layout:\n        // - [0]      ( 1 byte )  `0x01` for batch call.\n        // - [1]      ( 1 byte )  `0x00` for revert on any failure.\n        // - [2..5]   ( 4 bytes)  Reserved by ERC7579 for future standardization.\n        // - [6..9]   ( 4 bytes)  `0x00000000` or `0x78210001` or `0x78210002`.\n        // - [10..31] (22 bytes)  Unused. Free for use.\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := and(shr(mul(22, 8), mode), 0xffff00000000ffffffff)\n            id := eq(m, 0x01000000000000000000) // 1.\n            id := or(shl(1, eq(m, 0x01000000000078210001)), id) // 2.\n            id := or(mul(3, eq(m, 0x01000000000078210002)), id) // 3.\n            id := or(mul(4, eq(m, 0x01000000000078210003)), id) // 4.\n        }\n    }",
            "startLine": 121
          },
          {
            "name": "_executeOptimizedBatch",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              },
              {
                "name": "executionData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_executeOptimizedBatch",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _executeOptimizedBatch(bytes32 mode, bytes calldata executionData) internal virtual {\n        address to;\n        bytes[] calldata dataArr;\n        bytes calldata opData;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // This line is needed to ensure that `opData` is valid in all code paths.\n            // Otherwise the compiler complains.\n            opData.length := 0\n\n            to := calldataload(executionData.offset)\n\n            let b := calldataload(add(0x20, executionData.offset)) // Relative offset of `dataArr`.\n            let c := add(executionData.offset, b) // Absolute offset of `dataArr.length`.\n            dataArr.offset := add(c, 0x20)\n            dataArr.length := calldataload(c)\n\n            let e := add(executionData.offset, executionData.length) // End of `executionData`.\n\n            // Perform bounds checking, to ensure:\n            // - `to` is within `executionData`.\n            // - `dataArr` and all of its elements are within `executionData`.\n            // - `opData` is within `executionData`, if provided.\n            // As this is a non-standard ERC7821 mode, `LibERC7579` will not include the decoding\n            // functions with bound checks. So we simply do the checks here.\n            if or(\n                shr(64, or(b, or(executionData.length, executionData.offset))),\n                or(gt(dataArr.offset, e), lt(executionData.length, 0x40))\n            ) {\n                mstore(0x00, 0x6f23de0b) // `OptimizedBatchDecodingError()`.\n                revert(0x1c, 0x04)\n            }\n            // If the relative offset of `dataArr` is 3 words or more,\n            // it indicates the possible presence of a relative `opData` offset.\n            if iszero(lt(b, 0x60)) {\n                let p := calldataload(add(0x40, executionData.offset)) // Relative offset of `opData`.\n                let q := add(executionData.offset, p) // Absolute offset of `opData.length`.\n                opData.offset := add(q, 0x20)\n                opData.length := calldataload(q)\n                if or(shr(64, or(opData.length, p)), gt(add(opData.length, opData.offset), e)) {\n                    mstore(0x00, 0x6f23de0b) // `OptimizedBatchDecodingError()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            if dataArr.length {\n                // Perform bounds checks on the decoded `dataArr`.\n                // Loop runs out-of-gas if `dataArr.length` is big enough to cause overflows.\n                for { let i := dataArr.length } 1 {} {\n                    i := sub(i, 1)\n                    let p := calldataload(add(dataArr.offset, shl(5, i))) // Relative offset of `dataArr[i]`.\n                    let u := add(dataArr.offset, p) // Absolute offset of `dataArr[i].length`.\n                    let l := calldataload(u) // `dataArr[i].length`.\n                    if or(shr(64, or(p, l)), gt(add(l, add(0x20, u)), e)) {\n                        mstore(0x00, 0x6f23de0b) // `OptimizedBatchDecodingError()`.\n                        revert(0x1c, 0x04)\n                    }\n                    if iszero(i) { break }\n                }\n            }\n        }\n\n        _executeOptimizedBatch(mode, executionData, to, dataArr, opData);\n    }",
            "startLine": 142
          },
          {
            "name": "_executeBatchOfBatches",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              },
              {
                "name": "executionData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "execute",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _executeBatchOfBatches(bytes32 mode, bytes calldata executionData) internal virtual {\n        // Replace with `0x0100________78210001...` while preserving optional and reserved fields.\n        mode ^= bytes32(uint256(3 << (22 * 8))); // `2 XOR 3 = 1`.\n        (uint256 n, uint256 o, uint256 e) = (0, 0, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let j := calldataload(executionData.offset)\n            let t := add(executionData.offset, j)\n            n := calldataload(t) // `batches.length`.\n            o := add(0x20, t) // Offset of `batches[0]`.\n            e := add(executionData.offset, executionData.length) // End of `executionData`.\n            // Do the bounds check on `executionData` treating it as `abi.encode(bytes[])`.\n            // Not too expensive, so we will just do it right here right now.\n            if or(shr(64, j), or(lt(executionData.length, 0x20), gt(add(o, shl(5, n)), e))) {\n                mstore(0x00, 0x3995943b) // `BatchOfBatchesDecodingError()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        unchecked {\n            for (uint256 i; i != n; ++i) {\n                bytes calldata batch;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let j := calldataload(add(o, shl(5, i)))\n                    let t := add(o, j)\n                    batch.offset := add(t, 0x20)\n                    batch.length := calldataload(t)\n                    // Validate that `batches[i]` is not out-of-bounds.\n                    if or(shr(64, j), gt(add(batch.offset, batch.length), e)) {\n                        mstore(0x00, 0x3995943b) // `BatchOfBatchesDecodingError()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                execute(mode, batch);\n            }\n        }\n    }",
            "startLine": 208
          },
          {
            "name": "_execute",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              },
              {
                "name": "executionData",
                "type": "bytes"
              },
              {
                "name": "calls",
                "type": "Call[]"
              },
              {
                "name": "opData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_execute",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _execute(\n        bytes32 mode,\n        bytes calldata executionData,\n        Call[] calldata calls,\n        bytes calldata opData\n    ) internal virtual {\n        // Silence compiler warning on unused variables.\n        mode = mode;\n        executionData = executionData;\n        // Very basic auth to only allow this contract to be called by itself.\n        // Override this function to perform more complex auth with `opData`.\n        if (opData.length == uint256(0)) {\n            require(msg.sender == address(this));\n            // Remember to return `_execute(calls, extraData)` when you override this function.\n            return _execute(calls, bytes32(0));\n        }\n        revert(); // In your override, replace this with logic to operate on `opData`.\n    }",
            "startLine": 249
          },
          {
            "name": "_executeOptimizedBatch",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              },
              {
                "name": "executionData",
                "type": "bytes"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "dataArr",
                "type": "bytes[]"
              },
              {
                "name": "opData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_executeOptimizedBatch",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _executeOptimizedBatch(\n        bytes32 mode,\n        bytes calldata executionData,\n        address to,\n        bytes[] calldata dataArr,\n        bytes calldata opData\n    ) internal virtual {\n        // Silence compiler warning on unused variables.\n        mode = mode;\n        executionData = executionData;\n        // Very basic auth to only allow this contract to be called by itself.\n        // Override this function to perform more complex auth with `opData`.\n        if (opData.length == uint256(0)) {\n            require(msg.sender == address(this));\n            // Remember to return `_executeOptimizedBatch(to, dataArr, extraData)`\n            // when you override this function.\n            return _executeOptimizedBatch(to, dataArr, bytes32(0));\n        }\n        revert(); // In your override, replace this with logic to operate on `opData`.\n    }",
            "startLine": 271
          },
          {
            "name": "_execute",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "calls",
                "type": "Call[]"
              },
              {
                "name": "extraData",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_get",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_execute",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _execute(Call[] calldata calls, bytes32 extraData) internal virtual {\n        unchecked {\n            uint256 i;\n            if (calls.length == uint256(0)) return;\n            do {\n                (address to, uint256 value, bytes calldata data) = _get(calls, i);\n                _execute(to, value, data, extraData);\n            } while (++i != calls.length);\n        }\n    }",
            "startLine": 295
          },
          {
            "name": "_executeOptimizedBatch",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "dataArr",
                "type": "bytes[]"
              },
              {
                "name": "extraData",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_execute",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_get",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _executeOptimizedBatch(address to, bytes[] calldata dataArr, bytes32 extraData)\n        internal\n        virtual\n    {\n        unchecked {\n            uint256 i;\n            /// @solidity memory-safe-assembly\n            assembly {\n                let t := shr(96, shl(96, to))\n                to := or(mul(address(), iszero(t)), t)\n            }\n            if (dataArr.length == uint256(0)) return;\n            do {\n                _execute(to, 0, _get(dataArr, i), extraData);\n            } while (++i != dataArr.length);\n        }\n    }",
            "startLine": 311
          },
          {
            "name": "_execute",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "extraData",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _execute(address to, uint256 value, bytes calldata data, bytes32 extraData)\n        internal\n        virtual\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extraData := extraData // Silence unused variable compiler warning.\n            let m := mload(0x40) // Grab the free memory pointer.\n            calldatacopy(m, data.offset, data.length)\n            if iszero(call(gas(), to, value, m, data.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(m, 0x00, returndatasize())\n                revert(m, returndatasize())\n            }\n        }\n    }",
            "startLine": 332
          },
          {
            "name": "_get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "calls",
                "type": "Call[]"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _get(Call[] calldata calls, uint256 i)\n        internal\n        view\n        virtual\n        returns (address to, uint256 value, bytes calldata data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let c := add(calls.offset, calldataload(add(calls.offset, shl(5, i))))\n            // Replaces `to` with `address(this)` if `address(0)` is provided.\n            let t := shr(96, shl(96, calldataload(c)))\n            to := or(mul(address(), iszero(t)), t)\n            value := calldataload(add(c, 0x20))\n            let o := add(c, calldataload(add(c, 0x40)))\n            data.offset := add(o, 0x20)\n            data.length := calldataload(o)\n        }\n    }",
            "startLine": 350
          },
          {
            "name": "_get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "dataArr",
                "type": "bytes[]"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _get(bytes[] calldata dataArr, uint256 i)\n        internal\n        view\n        virtual\n        returns (bytes calldata data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let c := add(dataArr.offset, calldataload(add(dataArr.offset, shl(5, i))))\n            data.offset := add(c, 0x20)\n            data.length := calldataload(c)\n        }\n    }",
            "startLine": 370
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "UnsupportedExecutionMode",
            "parameters": [],
            "startLine": 33
          },
          {
            "name": "BatchOfBatchesDecodingError",
            "parameters": [],
            "startLine": 36
          },
          {
            "name": "OptimizedBatchDecodingError",
            "parameters": [],
            "startLine": 40
          }
        ],
        "structs": [
          {
            "name": "Call",
            "members": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "startLine": 22
          }
        ],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../../Receiver.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "EnumerableRoles",
        "filePath": "auth/EnumerableRoles.sol",
        "kind": "abstract",
        "inherits": [],
        "implements": [],
        "category": "access",
        "externalFunctions": [
          {
            "name": "setRole",
            "signature": "setRole(address,uint256,bool)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "role",
                "type": "uint256"
              },
              {
                "name": "active",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_authorizeSetRole",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_setRole",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setRole(address holder, uint256 role, bool active) public payable virtual {\n        _authorizeSetRole(holder, role, active);\n        _setRole(holder, role, active);\n    }",
            "startLine": 76
          },
          {
            "name": "hasRole",
            "signature": "hasRole(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "role",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function hasRole(address holder, uint256 role) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x18, holder)\n            mstore(0x04, _ENUMERABLE_ROLES_SLOT_SEED)\n            mstore(0x00, role)\n            result := iszero(iszero(sload(keccak256(0x00, 0x38))))\n        }\n    }",
            "startLine": 86
          },
          {
            "name": "roleHolders",
            "signature": "roleHolders(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address[]"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function roleHolders(uint256 role) public view virtual returns (address[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(0x04, _ENUMERABLE_ROLES_SLOT_SEED)\n            mstore(0x00, role)\n            let rootSlot := keccak256(0x00, 0x24)\n            let rootPacked := sload(rootSlot)\n            let n := shr(160, shl(160, rootPacked))\n            let o := add(0x20, result)\n            mstore(o, shr(96, rootPacked))\n            for { let i := 1 } lt(i, n) { i := add(i, 1) } {\n                mstore(add(o, shl(5, i)), shr(96, sload(add(rootSlot, i))))\n            }\n            mstore(result, n)\n            mstore(0x40, add(o, shl(5, n)))\n        }\n    }",
            "startLine": 97
          },
          {
            "name": "roleHolderCount",
            "signature": "roleHolderCount(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function roleHolderCount(uint256 role) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ENUMERABLE_ROLES_SLOT_SEED)\n            mstore(0x00, role)\n            result := shr(160, shl(160, sload(keccak256(0x00, 0x24))))\n        }\n    }",
            "startLine": 117
          },
          {
            "name": "roleHolderAt",
            "signature": "roleHolderAt(uint256,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "uint256"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function roleHolderAt(uint256 role, uint256 i) public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ENUMERABLE_ROLES_SLOT_SEED)\n            mstore(0x00, role)\n            let rootSlot := keccak256(0x00, 0x24)\n            let rootPacked := sload(rootSlot)\n            if iszero(lt(i, shr(160, shl(160, rootPacked)))) {\n                mstore(0x00, 0x5694da8e) // `RoleHoldersIndexOutOfBounds()`.\n                revert(0x1c, 0x04)\n            }\n            result := shr(96, rootPacked)\n            if i { result := shr(96, sload(add(rootSlot, i))) }\n        }\n    }",
            "startLine": 127
          }
        ],
        "internalFunctions": [
          {
            "name": "_setRole",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "role",
                "type": "uint256"
              },
              {
                "name": "active",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateRole",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setRole(address holder, uint256 role, bool active) internal virtual {\n        _validateRole(role);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let holder_ := shl(96, holder)\n            if iszero(holder_) {\n                mstore(0x00, 0x82550143) // `RoleHolderIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x18, holder)\n            mstore(0x04, _ENUMERABLE_ROLES_SLOT_SEED)\n            mstore(0x00, role)\n            let rootSlot := keccak256(0x00, 0x24)\n            let n := shr(160, shl(160, sload(rootSlot)))\n            let positionSlot := keccak256(0x00, 0x38)\n            let position := sload(positionSlot)\n            for {} 1 {} {\n                if iszero(active) {\n                    if iszero(position) { break }\n                    let nSub := sub(n, 1)\n                    if iszero(eq(sub(position, 1), nSub)) {\n                        let lastHolder_ := shl(96, shr(96, sload(add(rootSlot, nSub))))\n                        sstore(add(rootSlot, sub(position, 1)), lastHolder_)\n                        sstore(add(rootSlot, nSub), 0)\n                        mstore(0x24, lastHolder_)\n                        sstore(keccak256(0x00, 0x38), position)\n                    }\n                    sstore(rootSlot, or(shl(96, shr(96, sload(rootSlot))), nSub))\n                    sstore(positionSlot, 0)\n                    break\n                }\n                if iszero(position) {\n                    sstore(add(rootSlot, n), holder_)\n                    sstore(positionSlot, add(n, 1))\n                    sstore(rootSlot, add(sload(rootSlot), 1))\n                }\n                break\n            }\n            // forgefmt: disable-next-item\n            log4(0x00, 0x00, _ROLE_SET_EVENT_SIGNATURE, shr(96, holder_), role, iszero(iszero(active)))\n        }\n    }",
            "startLine": 148
          },
          {
            "name": "_validateRole",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _validateRole(uint256 role) internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0xd24f19d5) // `MAX_ROLE()`.\n            if and(\n                and(gt(role, mload(0x00)), gt(returndatasize(), 0x1f)),\n                staticcall(gas(), address(), 0x1c, 0x04, 0x00, 0x20)\n            ) {\n                mstore(0x00, 0xd954416a) // `InvalidRole()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 193
          },
          {
            "name": "_authorizeSetRole",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "role",
                "type": "uint256"
              },
              {
                "name": "active",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_enumerableRolesSenderIsContractOwner",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _authorizeSetRole(address holder, uint256 role, bool active) internal virtual {\n        if (!_enumerableRolesSenderIsContractOwner()) _revertEnumerableRolesUnauthorized();\n        // Silence compiler warning on unused variables.\n        (holder, role, active) = (holder, role, active);\n    }",
            "startLine": 208
          },
          {
            "name": "_hasAnyRoles",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "encodedRoles",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _hasAnyRoles(address holder, bytes memory encodedRoles)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x18, holder)\n            mstore(0x04, _ENUMERABLE_ROLES_SLOT_SEED)\n            let end := add(encodedRoles, shl(5, shr(5, mload(encodedRoles))))\n            for {} lt(result, lt(encodedRoles, end)) {} {\n                encodedRoles := add(0x20, encodedRoles)\n                mstore(0x00, mload(encodedRoles))\n                result := sload(keccak256(0x00, 0x38))\n            }\n            result := iszero(iszero(result))\n        }\n    }",
            "startLine": 216
          },
          {
            "name": "_checkRole",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "hasRole",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkRole(uint256 role) internal view virtual {\n        if (!hasRole(msg.sender, role)) _revertEnumerableRolesUnauthorized();\n    }",
            "startLine": 237
          },
          {
            "name": "_checkRoles",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "encodedRoles",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_hasAnyRoles",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkRoles(bytes memory encodedRoles) internal view virtual {\n        if (!_hasAnyRoles(msg.sender, encodedRoles)) _revertEnumerableRolesUnauthorized();\n    }",
            "startLine": 242
          },
          {
            "name": "_checkOwnerOrRole",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_enumerableRolesSenderIsContractOwner",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_checkRole",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkOwnerOrRole(uint256 role) internal view virtual {\n        if (!_enumerableRolesSenderIsContractOwner()) _checkRole(role);\n    }",
            "startLine": 247
          },
          {
            "name": "_checkOwnerOrRoles",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "encodedRoles",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_enumerableRolesSenderIsContractOwner",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_checkRoles",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkOwnerOrRoles(bytes memory encodedRoles) internal view virtual {\n        if (!_enumerableRolesSenderIsContractOwner()) _checkRoles(encodedRoles);\n    }",
            "startLine": 253
          },
          {
            "name": "_enumerableRolesSenderIsContractOwner",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _enumerableRolesSenderIsContractOwner() private view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x8da5cb5b) // `owner()`.\n            result := and(\n                and(eq(caller(), mload(0x00)), gt(returndatasize(), 0x1f)),\n                staticcall(gas(), address(), 0x1c, 0x04, 0x00, 0x20)\n            )\n        }\n    }",
            "startLine": 295
          },
          {
            "name": "_revertEnumerableRolesUnauthorized",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _revertEnumerableRolesUnauthorized() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x99152cca) // `EnumerableRolesUnauthorized()`.\n            revert(0x1c, 0x04)\n        }\n    }",
            "startLine": 307
          }
        ],
        "events": [
          {
            "name": "RoleSet",
            "parameters": [
              {
                "name": "holder",
                "type": "address",
                "indexed": true
              },
              {
                "name": "role",
                "type": "uint256",
                "indexed": true
              },
              {
                "name": "active",
                "type": "bool",
                "indexed": true
              }
            ],
            "startLine": 32
          }
        ],
        "errors": [
          {
            "name": "RoleHoldersIndexOutOfBounds",
            "parameters": [],
            "startLine": 43
          },
          {
            "name": "RoleHolderIsZeroAddress",
            "parameters": [],
            "startLine": 46
          },
          {
            "name": "InvalidRole",
            "parameters": [],
            "startLine": 49
          },
          {
            "name": "EnumerableRolesUnauthorized",
            "parameters": [],
            "startLine": 52
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_ROLE_SET_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 35
          },
          {
            "name": "_ENUMERABLE_ROLES_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 69
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "Ownable",
        "filePath": "auth/Ownable.sol",
        "kind": "abstract",
        "inherits": [],
        "implements": [],
        "category": "access",
        "externalFunctions": [
          {
            "name": "transferOwnership",
            "signature": "transferOwnership(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setOwner",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }",
            "startLine": 174
          },
          {
            "name": "renounceOwnership",
            "signature": "renounceOwnership()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_setOwner",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }",
            "startLine": 186
          },
          {
            "name": "requestOwnershipHandover",
            "signature": "requestOwnershipHandover()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_ownershipHandoverValidFor",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }",
            "startLine": 192
          },
          {
            "name": "cancelOwnershipHandover",
            "signature": "cancelOwnershipHandover()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }",
            "startLine": 208
          },
          {
            "name": "completeOwnershipHandover",
            "signature": "completeOwnershipHandover(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "pendingOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setOwner",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }",
            "startLine": 222
          },
          {
            "name": "owner",
            "signature": "owner()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_OWNER_SLOT)\n        }\n    }",
            "startLine": 245
          },
          {
            "name": "ownershipHandoverExpiresAt",
            "signature": "ownershipHandoverExpiresAt(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "pendingOwner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }",
            "startLine": 253
          }
        ],
        "internalFunctions": [
          {
            "name": "_guardInitializeOwner",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "guard",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _guardInitializeOwner() internal pure virtual returns (bool guard) {}",
            "startLine": 85
          },
          {
            "name": "_initializeOwner",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_guardInitializeOwner",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _initializeOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                if sload(ownerSlot) {\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\n                    revert(0x1c, 0x04)\n                }\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(_OWNER_SLOT, newOwner)\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        }\n    }",
            "startLine": 94
          },
          {
            "name": "_setOwner",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_guardInitializeOwner",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, newOwner)\n            }\n        }\n    }",
            "startLine": 124
          },
          {
            "name": "_checkOwner",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 151
          },
          {
            "name": "_ownershipHandoverValidFor",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }",
            "startLine": 165
          }
        ],
        "events": [
          {
            "name": "OwnershipTransferred",
            "parameters": [
              {
                "name": "oldOwner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "newOwner",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 39
          },
          {
            "name": "OwnershipHandoverRequested",
            "parameters": [
              {
                "name": "pendingOwner",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 42
          },
          {
            "name": "OwnershipHandoverCanceled",
            "parameters": [
              {
                "name": "pendingOwner",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 45
          }
        ],
        "errors": [
          {
            "name": "Unauthorized",
            "parameters": [],
            "startLine": 20
          },
          {
            "name": "NewOwnerIsZeroAddress",
            "parameters": [],
            "startLine": 23
          },
          {
            "name": "NoHandoverRequest",
            "parameters": [],
            "startLine": 26
          },
          {
            "name": "AlreadyInitialized",
            "parameters": [],
            "startLine": 29
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 48
          },
          {
            "name": "_OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 52
          },
          {
            "name": "_OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 56
          },
          {
            "name": "_OWNER_SLOT",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 69
          },
          {
            "name": "_HANDOVER_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 78
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "OwnableRoles",
        "filePath": "auth/OwnableRoles.sol",
        "kind": "abstract",
        "inherits": [
          "Ownable"
        ],
        "implements": [],
        "category": "access",
        "externalFunctions": [
          {
            "name": "grantRoles",
            "signature": "grantRoles(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "user",
                "type": "address"
              },
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_grantRoles",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function grantRoles(address user, uint256 roles) public payable virtual onlyOwner {\n        _grantRoles(user, roles);\n    }",
            "startLine": 207
          },
          {
            "name": "revokeRoles",
            "signature": "revokeRoles(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "user",
                "type": "address"
              },
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_removeRoles",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function revokeRoles(address user, uint256 roles) public payable virtual onlyOwner {\n        _removeRoles(user, roles);\n    }",
            "startLine": 213
          },
          {
            "name": "renounceRoles",
            "signature": "renounceRoles(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_removeRoles",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function renounceRoles(uint256 roles) public payable virtual {\n        _removeRoles(msg.sender, roles);\n    }",
            "startLine": 219
          },
          {
            "name": "rolesOf",
            "signature": "rolesOf(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "user",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function rolesOf(address user) public view virtual returns (uint256 roles) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the role slot.\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, user)\n            // Load the stored value.\n            roles := sload(keccak256(0x0c, 0x20))\n        }\n    }",
            "startLine": 228
          },
          {
            "name": "hasAnyRole",
            "signature": "hasAnyRole(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "user",
                "type": "address"
              },
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "rolesOf",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function hasAnyRole(address user, uint256 roles) public view virtual returns (bool) {\n        return rolesOf(user) & roles != 0;\n    }",
            "startLine": 240
          },
          {
            "name": "hasAllRoles",
            "signature": "hasAllRoles(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "user",
                "type": "address"
              },
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "rolesOf",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function hasAllRoles(address user, uint256 roles) public view virtual returns (bool) {\n        return rolesOf(user) & roles == roles;\n    }",
            "startLine": 245
          }
        ],
        "internalFunctions": [
          {
            "name": "_setRoles",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "user",
                "type": "address"
              },
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _setRoles(address user, uint256 roles) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, user)\n            // Store the new value.\n            sstore(keccak256(0x0c, 0x20), roles)\n            // Emit the {RolesUpdated} event.\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, mload(0x0c)), roles)\n        }\n    }",
            "startLine": 49
          },
          {
            "name": "_updateRoles",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "user",
                "type": "address"
              },
              {
                "name": "roles",
                "type": "uint256"
              },
              {
                "name": "on",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _updateRoles(address user, uint256 roles, bool on) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, user)\n            let roleSlot := keccak256(0x0c, 0x20)\n            // Load the current value.\n            let current := sload(roleSlot)\n            // Compute the updated roles if `on` is true.\n            let updated := or(current, roles)\n            // Compute the updated roles if `on` is false.\n            // Use `and` to compute the intersection of `current` and `roles`,\n            // `xor` it with `current` to flip the bits in the intersection.\n            if iszero(on) { updated := xor(current, and(current, roles)) }\n            // Then, store the new value.\n            sstore(roleSlot, updated)\n            // Emit the {RolesUpdated} event.\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, mload(0x0c)), updated)\n        }\n    }",
            "startLine": 64
          },
          {
            "name": "_grantRoles",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "user",
                "type": "address"
              },
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_updateRoles",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _grantRoles(address user, uint256 roles) internal virtual {\n        _updateRoles(user, roles, true);\n    }",
            "startLine": 87
          },
          {
            "name": "_removeRoles",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "user",
                "type": "address"
              },
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_updateRoles",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _removeRoles(address user, uint256 roles) internal virtual {\n        _updateRoles(user, roles, false);\n    }",
            "startLine": 93
          },
          {
            "name": "_checkRoles",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _checkRoles(uint256 roles) internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the role slot.\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, caller())\n            // Load the stored value, and if the `and` intersection\n            // of the value and `roles` is zero, revert.\n            if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 98
          },
          {
            "name": "_checkOwnerOrRoles",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwnerOrRoles(uint256 roles) internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner.\n            // Note: `_ROLE_SLOT_SEED` is equal to `_OWNER_SLOT_NOT`.\n            if iszero(eq(caller(), sload(not(_ROLE_SLOT_SEED)))) {\n                // Compute the role slot.\n                mstore(0x0c, _ROLE_SLOT_SEED)\n                mstore(0x00, caller())\n                // Load the stored value, and if the `and` intersection\n                // of the value and `roles` is zero, revert.\n                if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\n                    mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 116
          },
          {
            "name": "_checkRolesOrOwner",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _checkRolesOrOwner(uint256 roles) internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the role slot.\n            mstore(0x0c, _ROLE_SLOT_SEED)\n            mstore(0x00, caller())\n            // Load the stored value, and if the `and` intersection\n            // of the value and `roles` is zero, revert.\n            if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\n                // If the caller is not the stored owner.\n                // Note: `_ROLE_SLOT_SEED` is equal to `_OWNER_SLOT_NOT`.\n                if iszero(eq(caller(), sload(not(_ROLE_SLOT_SEED)))) {\n                    mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 138
          },
          {
            "name": "_rolesFromOrdinals",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "ordinals",
                "type": "uint8[]"
              }
            ],
            "returnValues": [
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _rolesFromOrdinals(uint8[] memory ordinals) internal pure returns (uint256 roles) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let i := shl(5, mload(ordinals)) } i { i := sub(i, 0x20) } {\n                // We don't need to mask the values of `ordinals`, as Solidity\n                // cleans dirty upper bits when storing variables into memory.\n                roles := or(shl(mload(add(ordinals, i)), 1), roles)\n            }\n        }\n    }",
            "startLine": 161
          },
          {
            "name": "_ordinalsFromRoles",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "roles",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "ordinals",
                "type": "uint8[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _ordinalsFromRoles(uint256 roles) internal pure returns (uint8[] memory ordinals) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the pointer to the free memory.\n            ordinals := mload(0x40)\n            let ptr := add(ordinals, 0x20)\n            let o := 0\n            // The absence of lookup tables, De Bruijn, etc., here is intentional for\n            // smaller bytecode, as this function is not meant to be called on-chain.\n            for { let t := roles } 1 {} {\n                mstore(ptr, o)\n                // `shr` 5 is equivalent to multiplying by 0x20.\n                // Push back into the ordinals array if the bit is set.\n                ptr := add(ptr, shl(5, and(t, 1)))\n                o := add(o, 1)\n                t := shr(o, roles)\n                if iszero(t) { break }\n            }\n            // Store the length of `ordinals`.\n            mstore(ordinals, shr(5, sub(ptr, add(ordinals, 0x20))))\n            // Allocate the memory.\n            mstore(0x40, ptr)\n        }\n    }",
            "startLine": 176
          }
        ],
        "events": [
          {
            "name": "RolesUpdated",
            "parameters": [
              {
                "name": "user",
                "type": "address",
                "indexed": true
              },
              {
                "name": "roles",
                "type": "uint256",
                "indexed": true
              }
            ],
            "startLine": 23
          }
        ],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "_ROLES_UPDATED_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 26
          },
          {
            "name": "_ROLE_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 42
          },
          {
            "name": "_ROLE_0",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 279
          },
          {
            "name": "_ROLE_1",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 280
          },
          {
            "name": "_ROLE_2",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 281
          },
          {
            "name": "_ROLE_3",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 282
          },
          {
            "name": "_ROLE_4",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 283
          },
          {
            "name": "_ROLE_5",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 284
          },
          {
            "name": "_ROLE_6",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 285
          },
          {
            "name": "_ROLE_7",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 286
          },
          {
            "name": "_ROLE_8",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 287
          },
          {
            "name": "_ROLE_9",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 288
          },
          {
            "name": "_ROLE_10",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 289
          },
          {
            "name": "_ROLE_11",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 290
          },
          {
            "name": "_ROLE_12",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 291
          },
          {
            "name": "_ROLE_13",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 292
          },
          {
            "name": "_ROLE_14",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 293
          },
          {
            "name": "_ROLE_15",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 294
          },
          {
            "name": "_ROLE_16",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 295
          },
          {
            "name": "_ROLE_17",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 296
          },
          {
            "name": "_ROLE_18",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 297
          },
          {
            "name": "_ROLE_19",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 298
          },
          {
            "name": "_ROLE_20",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 299
          },
          {
            "name": "_ROLE_21",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 300
          },
          {
            "name": "_ROLE_22",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 301
          },
          {
            "name": "_ROLE_23",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 302
          },
          {
            "name": "_ROLE_24",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 303
          },
          {
            "name": "_ROLE_25",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 304
          },
          {
            "name": "_ROLE_26",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 305
          },
          {
            "name": "_ROLE_27",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 306
          },
          {
            "name": "_ROLE_28",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 307
          },
          {
            "name": "_ROLE_29",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 308
          },
          {
            "name": "_ROLE_30",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 309
          },
          {
            "name": "_ROLE_31",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 310
          },
          {
            "name": "_ROLE_32",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 311
          },
          {
            "name": "_ROLE_33",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 312
          },
          {
            "name": "_ROLE_34",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 313
          },
          {
            "name": "_ROLE_35",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 314
          },
          {
            "name": "_ROLE_36",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 315
          },
          {
            "name": "_ROLE_37",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 316
          },
          {
            "name": "_ROLE_38",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 317
          },
          {
            "name": "_ROLE_39",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 318
          },
          {
            "name": "_ROLE_40",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 319
          },
          {
            "name": "_ROLE_41",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 320
          },
          {
            "name": "_ROLE_42",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 321
          },
          {
            "name": "_ROLE_43",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 322
          },
          {
            "name": "_ROLE_44",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 323
          },
          {
            "name": "_ROLE_45",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 324
          },
          {
            "name": "_ROLE_46",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 325
          },
          {
            "name": "_ROLE_47",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 326
          },
          {
            "name": "_ROLE_48",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 327
          },
          {
            "name": "_ROLE_49",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 328
          },
          {
            "name": "_ROLE_50",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 329
          },
          {
            "name": "_ROLE_51",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 330
          },
          {
            "name": "_ROLE_52",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 331
          },
          {
            "name": "_ROLE_53",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 332
          },
          {
            "name": "_ROLE_54",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 333
          },
          {
            "name": "_ROLE_55",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 334
          },
          {
            "name": "_ROLE_56",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 335
          },
          {
            "name": "_ROLE_57",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 336
          },
          {
            "name": "_ROLE_58",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 337
          },
          {
            "name": "_ROLE_59",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 338
          },
          {
            "name": "_ROLE_60",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 339
          },
          {
            "name": "_ROLE_61",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 340
          },
          {
            "name": "_ROLE_62",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 341
          },
          {
            "name": "_ROLE_63",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 342
          },
          {
            "name": "_ROLE_64",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 343
          },
          {
            "name": "_ROLE_65",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 344
          },
          {
            "name": "_ROLE_66",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 345
          },
          {
            "name": "_ROLE_67",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 346
          },
          {
            "name": "_ROLE_68",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 347
          },
          {
            "name": "_ROLE_69",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 348
          },
          {
            "name": "_ROLE_70",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 349
          },
          {
            "name": "_ROLE_71",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 350
          },
          {
            "name": "_ROLE_72",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 351
          },
          {
            "name": "_ROLE_73",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 352
          },
          {
            "name": "_ROLE_74",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 353
          },
          {
            "name": "_ROLE_75",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 354
          },
          {
            "name": "_ROLE_76",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 355
          },
          {
            "name": "_ROLE_77",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 356
          },
          {
            "name": "_ROLE_78",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 357
          },
          {
            "name": "_ROLE_79",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 358
          },
          {
            "name": "_ROLE_80",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 359
          },
          {
            "name": "_ROLE_81",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 360
          },
          {
            "name": "_ROLE_82",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 361
          },
          {
            "name": "_ROLE_83",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 362
          },
          {
            "name": "_ROLE_84",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 363
          },
          {
            "name": "_ROLE_85",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 364
          },
          {
            "name": "_ROLE_86",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 365
          },
          {
            "name": "_ROLE_87",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 366
          },
          {
            "name": "_ROLE_88",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 367
          },
          {
            "name": "_ROLE_89",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 368
          },
          {
            "name": "_ROLE_90",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 369
          },
          {
            "name": "_ROLE_91",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 370
          },
          {
            "name": "_ROLE_92",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 371
          },
          {
            "name": "_ROLE_93",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 372
          },
          {
            "name": "_ROLE_94",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 373
          },
          {
            "name": "_ROLE_95",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 374
          },
          {
            "name": "_ROLE_96",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 375
          },
          {
            "name": "_ROLE_97",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 376
          },
          {
            "name": "_ROLE_98",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 377
          },
          {
            "name": "_ROLE_99",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 378
          },
          {
            "name": "_ROLE_100",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 379
          },
          {
            "name": "_ROLE_101",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 380
          },
          {
            "name": "_ROLE_102",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 381
          },
          {
            "name": "_ROLE_103",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 382
          },
          {
            "name": "_ROLE_104",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 383
          },
          {
            "name": "_ROLE_105",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 384
          },
          {
            "name": "_ROLE_106",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 385
          },
          {
            "name": "_ROLE_107",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 386
          },
          {
            "name": "_ROLE_108",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 387
          },
          {
            "name": "_ROLE_109",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 388
          },
          {
            "name": "_ROLE_110",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 389
          },
          {
            "name": "_ROLE_111",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 390
          },
          {
            "name": "_ROLE_112",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 391
          },
          {
            "name": "_ROLE_113",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 392
          },
          {
            "name": "_ROLE_114",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 393
          },
          {
            "name": "_ROLE_115",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 394
          },
          {
            "name": "_ROLE_116",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 395
          },
          {
            "name": "_ROLE_117",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 396
          },
          {
            "name": "_ROLE_118",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 397
          },
          {
            "name": "_ROLE_119",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 398
          },
          {
            "name": "_ROLE_120",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 399
          },
          {
            "name": "_ROLE_121",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 400
          },
          {
            "name": "_ROLE_122",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 401
          },
          {
            "name": "_ROLE_123",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 402
          },
          {
            "name": "_ROLE_124",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 403
          },
          {
            "name": "_ROLE_125",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 404
          },
          {
            "name": "_ROLE_126",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 405
          },
          {
            "name": "_ROLE_127",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 406
          },
          {
            "name": "_ROLE_128",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 407
          },
          {
            "name": "_ROLE_129",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 408
          },
          {
            "name": "_ROLE_130",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 409
          },
          {
            "name": "_ROLE_131",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 410
          },
          {
            "name": "_ROLE_132",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 411
          },
          {
            "name": "_ROLE_133",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 412
          },
          {
            "name": "_ROLE_134",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 413
          },
          {
            "name": "_ROLE_135",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 414
          },
          {
            "name": "_ROLE_136",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 415
          },
          {
            "name": "_ROLE_137",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 416
          },
          {
            "name": "_ROLE_138",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 417
          },
          {
            "name": "_ROLE_139",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 418
          },
          {
            "name": "_ROLE_140",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 419
          },
          {
            "name": "_ROLE_141",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 420
          },
          {
            "name": "_ROLE_142",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 421
          },
          {
            "name": "_ROLE_143",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 422
          },
          {
            "name": "_ROLE_144",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 423
          },
          {
            "name": "_ROLE_145",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 424
          },
          {
            "name": "_ROLE_146",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 425
          },
          {
            "name": "_ROLE_147",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 426
          },
          {
            "name": "_ROLE_148",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 427
          },
          {
            "name": "_ROLE_149",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 428
          },
          {
            "name": "_ROLE_150",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 429
          },
          {
            "name": "_ROLE_151",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 430
          },
          {
            "name": "_ROLE_152",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 431
          },
          {
            "name": "_ROLE_153",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 432
          },
          {
            "name": "_ROLE_154",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 433
          },
          {
            "name": "_ROLE_155",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 434
          },
          {
            "name": "_ROLE_156",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 435
          },
          {
            "name": "_ROLE_157",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 436
          },
          {
            "name": "_ROLE_158",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 437
          },
          {
            "name": "_ROLE_159",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 438
          },
          {
            "name": "_ROLE_160",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 439
          },
          {
            "name": "_ROLE_161",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 440
          },
          {
            "name": "_ROLE_162",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 441
          },
          {
            "name": "_ROLE_163",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 442
          },
          {
            "name": "_ROLE_164",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 443
          },
          {
            "name": "_ROLE_165",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 444
          },
          {
            "name": "_ROLE_166",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 445
          },
          {
            "name": "_ROLE_167",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 446
          },
          {
            "name": "_ROLE_168",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 447
          },
          {
            "name": "_ROLE_169",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 448
          },
          {
            "name": "_ROLE_170",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 449
          },
          {
            "name": "_ROLE_171",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 450
          },
          {
            "name": "_ROLE_172",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 451
          },
          {
            "name": "_ROLE_173",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 452
          },
          {
            "name": "_ROLE_174",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 453
          },
          {
            "name": "_ROLE_175",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 454
          },
          {
            "name": "_ROLE_176",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 455
          },
          {
            "name": "_ROLE_177",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 456
          },
          {
            "name": "_ROLE_178",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 457
          },
          {
            "name": "_ROLE_179",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 458
          },
          {
            "name": "_ROLE_180",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 459
          },
          {
            "name": "_ROLE_181",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 460
          },
          {
            "name": "_ROLE_182",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 461
          },
          {
            "name": "_ROLE_183",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 462
          },
          {
            "name": "_ROLE_184",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 463
          },
          {
            "name": "_ROLE_185",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 464
          },
          {
            "name": "_ROLE_186",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 465
          },
          {
            "name": "_ROLE_187",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 466
          },
          {
            "name": "_ROLE_188",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 467
          },
          {
            "name": "_ROLE_189",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 468
          },
          {
            "name": "_ROLE_190",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 469
          },
          {
            "name": "_ROLE_191",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 470
          },
          {
            "name": "_ROLE_192",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 471
          },
          {
            "name": "_ROLE_193",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 472
          },
          {
            "name": "_ROLE_194",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 473
          },
          {
            "name": "_ROLE_195",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 474
          },
          {
            "name": "_ROLE_196",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 475
          },
          {
            "name": "_ROLE_197",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 476
          },
          {
            "name": "_ROLE_198",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 477
          },
          {
            "name": "_ROLE_199",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 478
          },
          {
            "name": "_ROLE_200",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 479
          },
          {
            "name": "_ROLE_201",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 480
          },
          {
            "name": "_ROLE_202",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 481
          },
          {
            "name": "_ROLE_203",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 482
          },
          {
            "name": "_ROLE_204",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 483
          },
          {
            "name": "_ROLE_205",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 484
          },
          {
            "name": "_ROLE_206",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 485
          },
          {
            "name": "_ROLE_207",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 486
          },
          {
            "name": "_ROLE_208",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 487
          },
          {
            "name": "_ROLE_209",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 488
          },
          {
            "name": "_ROLE_210",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 489
          },
          {
            "name": "_ROLE_211",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 490
          },
          {
            "name": "_ROLE_212",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 491
          },
          {
            "name": "_ROLE_213",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 492
          },
          {
            "name": "_ROLE_214",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 493
          },
          {
            "name": "_ROLE_215",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 494
          },
          {
            "name": "_ROLE_216",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 495
          },
          {
            "name": "_ROLE_217",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 496
          },
          {
            "name": "_ROLE_218",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 497
          },
          {
            "name": "_ROLE_219",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 498
          },
          {
            "name": "_ROLE_220",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 499
          },
          {
            "name": "_ROLE_221",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 500
          },
          {
            "name": "_ROLE_222",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 501
          },
          {
            "name": "_ROLE_223",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 502
          },
          {
            "name": "_ROLE_224",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 503
          },
          {
            "name": "_ROLE_225",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 504
          },
          {
            "name": "_ROLE_226",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 505
          },
          {
            "name": "_ROLE_227",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 506
          },
          {
            "name": "_ROLE_228",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 507
          },
          {
            "name": "_ROLE_229",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 508
          },
          {
            "name": "_ROLE_230",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 509
          },
          {
            "name": "_ROLE_231",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 510
          },
          {
            "name": "_ROLE_232",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 511
          },
          {
            "name": "_ROLE_233",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 512
          },
          {
            "name": "_ROLE_234",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 513
          },
          {
            "name": "_ROLE_235",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 514
          },
          {
            "name": "_ROLE_236",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 515
          },
          {
            "name": "_ROLE_237",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 516
          },
          {
            "name": "_ROLE_238",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 517
          },
          {
            "name": "_ROLE_239",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 518
          },
          {
            "name": "_ROLE_240",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 519
          },
          {
            "name": "_ROLE_241",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 520
          },
          {
            "name": "_ROLE_242",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 521
          },
          {
            "name": "_ROLE_243",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 522
          },
          {
            "name": "_ROLE_244",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 523
          },
          {
            "name": "_ROLE_245",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 524
          },
          {
            "name": "_ROLE_246",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 525
          },
          {
            "name": "_ROLE_247",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 526
          },
          {
            "name": "_ROLE_248",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 527
          },
          {
            "name": "_ROLE_249",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 528
          },
          {
            "name": "_ROLE_250",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 529
          },
          {
            "name": "_ROLE_251",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 530
          },
          {
            "name": "_ROLE_252",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 531
          },
          {
            "name": "_ROLE_253",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 532
          },
          {
            "name": "_ROLE_254",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 533
          },
          {
            "name": "_ROLE_255",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 534
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./Ownable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "TimedRoles",
        "filePath": "auth/TimedRoles.sol",
        "kind": "abstract",
        "inherits": [],
        "implements": [],
        "category": "access",
        "externalFunctions": [
          {
            "name": "setTimedRole",
            "signature": "setTimedRole(address,uint256,uint40,uint40)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "timedRole",
                "type": "uint256"
              },
              {
                "name": "start",
                "type": "uint40"
              },
              {
                "name": "expires",
                "type": "uint40"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_authorizeSetTimedRole",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_setTimedRole",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setTimedRole(address holder, uint256 timedRole, uint40 start, uint40 expires)\n        public\n        payable\n        virtual\n    {\n        _authorizeSetTimedRole(holder, timedRole, start, expires);\n        _setTimedRole(holder, timedRole, start, expires);\n    }",
            "startLine": 84
          },
          {
            "name": "timedRoleActive",
            "signature": "timedRoleActive(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "timedRole",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "isActive",
                "type": "bool"
              },
              {
                "name": "start",
                "type": "uint40"
              },
              {
                "name": "expires",
                "type": "uint40"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function timedRoleActive(address holder, uint256 timedRole)\n        public\n        view\n        virtual\n        returns (bool isActive, uint40 start, uint40 expires)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x18, holder)\n            mstore(0x04, _TIMED_ROLES_SLOT_SEED)\n            mstore(0x00, timedRole)\n            let p := sload(keccak256(0x00, 0x38))\n            start := shr(216, p)\n            expires := and(0xffffffffff, p)\n            isActive := iszero(or(lt(timestamp(), start), gt(timestamp(), expires)))\n        }\n    }",
            "startLine": 98
          }
        ],
        "internalFunctions": [
          {
            "name": "_setTimedRole",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "timedRole",
                "type": "uint256"
              },
              {
                "name": "start",
                "type": "uint40"
              },
              {
                "name": "expires",
                "type": "uint40"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateTimedRole",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setTimedRole(address holder, uint256 timedRole, uint40 start, uint40 expires)\n        internal\n        virtual\n    {\n        _validateTimedRole(timedRole);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let holder_ := shl(96, holder)\n            if iszero(holder_) {\n                mstore(0x00, 0x093a136f) // `TimedRoleHolderIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // Clean the upper bits.\n            start := and(0xffffffffff, start)\n            expires := and(0xffffffffff, expires)\n            // Validate the range.\n            if lt(expires, start) {\n                mstore(0x00, 0x3304dd8c) // `InvalidTimedRoleRange()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the range.\n            mstore(0x18, holder)\n            mstore(0x04, _TIMED_ROLES_SLOT_SEED)\n            mstore(0x00, timedRole)\n            sstore(keccak256(0x00, 0x38), or(shl(216, start), expires))\n            // Emit the {TimedRoleSet} event.\n            mstore(0x00, start)\n            mstore(0x20, expires)\n            log3(0x00, 0x40, _TIMED_ROLE_SET_EVENT_SIGNATURE, shr(96, holder_), timedRole)\n        }\n    }",
            "startLine": 121
          },
          {
            "name": "_validateTimedRole",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "timedRole",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _validateTimedRole(uint256 timedRole) internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x32bc6439) // `MAX_TIMED_ROLE()`.\n            if and(\n                and(gt(timedRole, mload(0x00)), gt(returndatasize(), 0x1f)),\n                staticcall(gas(), address(), 0x1c, 0x04, 0x00, 0x20)\n            ) {\n                mstore(0x00, 0x802ee27f) // `InvalidTimedRole()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 155
          },
          {
            "name": "_authorizeSetTimedRole",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "timedRole",
                "type": "uint256"
              },
              {
                "name": "start",
                "type": "uint40"
              },
              {
                "name": "expires",
                "type": "uint40"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_timedRolesSenderIsContractOwner",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _authorizeSetTimedRole(address holder, uint256 timedRole, uint40 start, uint40 expires)\n        internal\n        virtual\n    {\n        if (!_timedRolesSenderIsContractOwner()) _revertTimedRolesUnauthorized();\n        // Silence compiler warning on unused variables.\n        (holder, timedRole, start, expires) = (holder, timedRole, start, expires);\n    }",
            "startLine": 170
          },
          {
            "name": "_hasAnyTimedRoles",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "holder",
                "type": "address"
              },
              {
                "name": "encodedTimeRoles",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _hasAnyTimedRoles(address holder, bytes memory encodedTimeRoles)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x18, holder)\n            mstore(0x04, _TIMED_ROLES_SLOT_SEED)\n            let end := add(encodedTimeRoles, shl(5, shr(5, mload(encodedTimeRoles))))\n            for {} lt(result, lt(encodedTimeRoles, end)) {} {\n                encodedTimeRoles := add(0x20, encodedTimeRoles)\n                mstore(0x00, mload(encodedTimeRoles))\n                let p := sload(keccak256(0x00, 0x38))\n                result := iszero(\n                    or(lt(timestamp(), shr(216, p)), gt(timestamp(), and(0xffffffffff, p)))\n                )\n            }\n        }\n    }",
            "startLine": 181
          },
          {
            "name": "_checkTimedRole",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "timedRole",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "timedRoleActive",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkTimedRole(uint256 timedRole) internal view virtual {\n        (bool isActive,,) = timedRoleActive(msg.sender, timedRole);\n        if (!isActive) _revertTimedRolesUnauthorized();\n    }",
            "startLine": 204
          },
          {
            "name": "_checkTimedRoles",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "encodedTimedRoles",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_hasAnyTimedRoles",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkTimedRoles(bytes memory encodedTimedRoles) internal view virtual {\n        if (!_hasAnyTimedRoles(msg.sender, encodedTimedRoles)) _revertTimedRolesUnauthorized();\n    }",
            "startLine": 210
          },
          {
            "name": "_checkOwnerOrTimedRole",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "timedRole",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_timedRolesSenderIsContractOwner",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_checkTimedRole",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkOwnerOrTimedRole(uint256 timedRole) internal view virtual {\n        if (!_timedRolesSenderIsContractOwner()) _checkTimedRole(timedRole);\n    }",
            "startLine": 215
          },
          {
            "name": "_checkOwnerOrTimedRoles",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "encodedTimedRoles",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_timedRolesSenderIsContractOwner",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_checkTimedRoles",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkOwnerOrTimedRoles(bytes memory encodedTimedRoles) internal view virtual {\n        if (!_timedRolesSenderIsContractOwner()) _checkTimedRoles(encodedTimedRoles);\n    }",
            "startLine": 221
          },
          {
            "name": "_timedRolesSenderIsContractOwner",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _timedRolesSenderIsContractOwner() private view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x8da5cb5b) // `owner()`.\n            result := and(\n                and(eq(caller(), mload(0x00)), gt(returndatasize(), 0x1f)),\n                staticcall(gas(), address(), 0x1c, 0x04, 0x00, 0x20)\n            )\n        }\n    }",
            "startLine": 263
          },
          {
            "name": "_revertTimedRolesUnauthorized",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _revertTimedRolesUnauthorized() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0xb0c7b036) // `TimedRolesUnauthorized()`.\n            revert(0x1c, 0x04)\n        }\n    }",
            "startLine": 275
          }
        ],
        "events": [
          {
            "name": "TimedRoleSet",
            "parameters": [
              {
                "name": "holder",
                "type": "address",
                "indexed": true
              },
              {
                "name": "timedRole",
                "type": "uint256",
                "indexed": true
              },
              {
                "name": "start",
                "type": "uint40",
                "indexed": false
              },
              {
                "name": "expires",
                "type": "uint40",
                "indexed": false
              }
            ],
            "startLine": 38
          }
        ],
        "errors": [
          {
            "name": "TimedRoleHolderIsZeroAddress",
            "parameters": [],
            "startLine": 51
          },
          {
            "name": "InvalidTimedRole",
            "parameters": [],
            "startLine": 54
          },
          {
            "name": "TimedRolesUnauthorized",
            "parameters": [],
            "startLine": 57
          },
          {
            "name": "InvalidTimedRoleRange",
            "parameters": [],
            "startLine": 60
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_TIMED_ROLE_SET_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 43
          },
          {
            "name": "_TIMED_ROLES_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 76
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "ERC1155",
        "filePath": "tokens/ERC1155.sol",
        "kind": "abstract",
        "inherits": [],
        "implements": [],
        "category": "token",
        "externalFunctions": [
          {
            "name": "uri",
            "signature": "uri(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function uri(uint256 id) public view virtual returns (string memory);",
            "startLine": 126
          },
          {
            "name": "balanceOf",
            "signature": "balanceOf(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address owner, uint256 id) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, id)\n            result := sload(keccak256(0x00, 0x40))\n        }\n    }",
            "startLine": 133
          },
          {
            "name": "isApprovedForAll",
            "signature": "isApprovedForAll(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, operator)\n            result := sload(keccak256(0x0c, 0x34))\n        }\n    }",
            "startLine": 144
          },
          {
            "name": "setApprovalForAll",
            "signature": "setApprovalForAll(address,bool)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "isApproved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setApprovalForAll(address operator, bool isApproved) public virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`msg.sender`, `operator`).\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, caller())\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            // forgefmt: disable-next-line\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator)))\n        }\n    }",
            "startLine": 162
          },
          {
            "name": "safeTransferFrom",
            "signature": "safeTransferFrom(address,address,uint256,uint256,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 5
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\n            mstore(0x20, fromSlotSeed)\n            // Clear the upper 96 bits.\n            from := shr(96, fromSlotSeed)\n            to := shr(96, toSlotSeed)\n            // Revert if `to` is the zero address.\n            if iszero(to) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // If the caller is not `from`, do the authorization check.\n            if iszero(eq(caller(), from)) {\n                mstore(0x00, caller())\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Subtract and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, toSlotSeed)\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), from, to)\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Do the {onERC1155Received} check if `to` is a smart contract.\n            if extcodesize(to) {\n                // Prepare the calldata.\n                let m := mload(0x40)\n                // `onERC1155Received(address,address,uint256,uint256,bytes)`.\n                mstore(m, 0xf23a6e61)\n                mstore(add(m, 0x20), caller())\n                mstore(add(m, 0x40), from)\n                mstore(add(m, 0x60), id)\n                mstore(add(m, 0x80), amount)\n                mstore(add(m, 0xa0), 0xa0)\n                mstore(add(m, 0xc0), data.length)\n                calldatacopy(add(m, 0xe0), data.offset, data.length)\n                // Revert if the call reverts.\n                if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, data.length), m, 0x20)) {\n                    if returndatasize() {\n                        // Bubble up the revert if the call reverts.\n                        returndatacopy(m, 0x00, returndatasize())\n                        revert(m, returndatasize())\n                    }\n                }\n                // Load the returndata and compare it with the function selector.\n                if iszero(eq(mload(m), shl(224, 0xf23a6e61))) {\n                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 190
          },
          {
            "name": "safeBatchTransferFrom",
            "signature": "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransferCalldata",
                "type": "internal",
                "argCount": 5
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(ids.length, amounts.length)) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\n            mstore(0x20, fromSlotSeed)\n            // Clear the upper 96 bits.\n            from := shr(96, fromSlotSeed)\n            to := shr(96, toSlotSeed)\n            // Revert if `to` is the zero address.\n            if iszero(to) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // If the caller is not `from`, do the authorization check.\n            if iszero(eq(caller(), from)) {\n                mstore(0x00, caller())\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                for { let i := shl(5, ids.length) } i {} {\n                    i := sub(i, 0x20)\n                    let amount := calldataload(add(amounts.offset, i))\n                    // Subtract and store the updated balance of `from`.\n                    {\n                        mstore(0x20, fromSlotSeed)\n                        mstore(0x00, calldataload(add(ids.offset, i)))\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\n                        let fromBalance := sload(fromBalanceSlot)\n                        if gt(amount, fromBalance) {\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\n                    }\n                    // Increase and store the updated balance of `to`.\n                    {\n                        mstore(0x20, toSlotSeed)\n                        let toBalanceSlot := keccak256(0x00, 0x40)\n                        let toBalanceBefore := sload(toBalanceSlot)\n                        let toBalanceAfter := add(toBalanceBefore, amount)\n                        if lt(toBalanceAfter, toBalanceBefore) {\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(toBalanceSlot, toBalanceAfter)\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := shl(5, ids.length)\n                mstore(add(m, 0x40), ids.length)\n                calldatacopy(add(m, 0x60), ids.offset, n)\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x60, n))\n                let o := add(add(m, n), 0x60)\n                mstore(o, ids.length)\n                calldatacopy(add(o, 0x20), amounts.offset, n)\n                // Do the emit.\n                log4(m, add(add(n, n), 0x80), _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), from, to)\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransferCalldata(from, to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Do the {onERC1155BatchReceived} check if `to` is a smart contract.\n            if extcodesize(to) {\n                mstore(0x00, to) // Cache `to` to prevent stack too deep.\n                let m := mload(0x40)\n                // Prepare the calldata.\n                // `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n                mstore(m, 0xbc197c81)\n                mstore(add(m, 0x20), caller())\n                mstore(add(m, 0x40), from)\n                // Copy the `ids`.\n                mstore(add(m, 0x60), 0xa0)\n                let n := shl(5, ids.length)\n                mstore(add(m, 0xc0), ids.length)\n                calldatacopy(add(m, 0xe0), ids.offset, n)\n                // Copy the `amounts`.\n                mstore(add(m, 0x80), add(0xc0, n))\n                let o := add(add(m, n), 0xe0)\n                mstore(o, ids.length)\n                calldatacopy(add(o, 0x20), amounts.offset, n)\n                // Copy the `data`.\n                mstore(add(m, 0xa0), add(add(0xe0, n), n))\n                o := add(add(o, n), 0x20)\n                mstore(o, data.length)\n                calldatacopy(add(o, 0x20), data.offset, data.length)\n                let nAll := add(0x104, add(data.length, add(n, n)))\n                // Revert if the call reverts.\n                if iszero(call(gas(), mload(0x00), 0, add(mload(0x40), 0x1c), nAll, m, 0x20)) {\n                    if returndatasize() {\n                        // Bubble up the revert if the call reverts.\n                        returndatacopy(m, 0x00, returndatasize())\n                        revert(m, returndatasize())\n                    }\n                }\n                // Load the returndata and compare it with the function selector.\n                if iszero(eq(mload(m), shl(224, 0xbc197c81))) {\n                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 295
          },
          {
            "name": "balanceOfBatch",
            "signature": "balanceOfBatch(address[],uint256[])",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owners",
                "type": "address[]"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "balances",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(ids.length, owners.length)) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            balances := mload(0x40)\n            mstore(balances, ids.length)\n            let o := add(balances, 0x20)\n            let i := shl(5, ids.length)\n            mstore(0x40, add(i, o))\n            // Loop through all the `ids` and load the balances.\n            for {} i {} {\n                i := sub(i, 0x20)\n                let owner := calldataload(add(owners.offset, i))\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner)))\n                mstore(0x00, calldataload(add(ids.offset, i)))\n                mstore(add(o, i), sload(keccak256(0x00, 0x40)))\n            }\n        }\n    }",
            "startLine": 429
          },
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC1155: 0xd9b67a26, ERC1155MetadataURI: 0x0e89341c.\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0xd9b67a26)), eq(s, 0x0e89341c))\n        }\n    }",
            "startLine": 460
          }
        ],
        "internalFunctions": [
          {
            "name": "_mint",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_hasCode",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(address(0), to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n                mstore(0x14, to)\n                mstore(0x00, id)\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), 0, shr(96, to_))\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(address(0), to, _single(id), _single(amount), data);\n        }\n        if (_hasCode(to)) _checkOnERC1155Received(address(0), to, id, amount, data);\n    }",
            "startLine": 481
          },
          {
            "name": "_batchMint",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_hasCode",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(address(0), to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(mload(ids), mload(amounts))) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, to_))\n                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {\n                    let amount := mload(add(amounts, i))\n                    // Increase and store the updated balance of `to`.\n                    {\n                        mstore(0x00, mload(add(ids, i)))\n                        let toBalanceSlot := keccak256(0x00, 0x40)\n                        let toBalanceBefore := sload(toBalanceSlot)\n                        let toBalanceAfter := add(toBalanceBefore, amount)\n                        if lt(toBalanceAfter, toBalanceBefore) {\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(toBalanceSlot, toBalanceAfter)\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, mload(ids)))\n                let o := add(m, 0x40)\n                pop(staticcall(gas(), 4, ids, n, o, n))\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, returndatasize()))\n                o := add(o, returndatasize())\n                n := add(0x20, shl(5, mload(amounts)))\n                pop(staticcall(gas(), 4, amounts, n, o, n))\n                n := sub(add(o, returndatasize()), m)\n                // Do the emit.\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), 0, shr(96, to_))\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(address(0), to, ids, amounts, data);\n        }\n        if (_hasCode(to)) _checkOnERC1155BatchReceived(address(0), to, ids, amounts, data);\n    }",
            "startLine": 526
          },
          {
            "name": "_burn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_burn",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        _burn(address(0), from, id, amount);\n    }",
            "startLine": 595
          },
          {
            "name": "_burn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _burn(address by, address from, uint256 id, uint256 amount) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, address(0), _single(id), _single(amount), \"\");\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            if iszero(or(iszero(shl(96, by)), eq(shl(96, by), from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Decrease and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), shr(96, from_), 0)\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, address(0), _single(id), _single(amount), \"\");\n        }\n    }",
            "startLine": 607
          },
          {
            "name": "_batchBurn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_batchBurn",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _batchBurn(address from, uint256[] memory ids, uint256[] memory amounts)\n        internal\n        virtual\n    {\n        _batchBurn(address(0), from, ids, amounts);\n    }",
            "startLine": 645
          },
          {
            "name": "_batchBurn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _batchBurn(address by, address from, uint256[] memory ids, uint256[] memory amounts)\n        internal\n        virtual\n    {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, address(0), ids, amounts, \"\");\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(mload(ids), mload(amounts))) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let from_ := shl(96, from)\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            let by_ := shl(96, by)\n            if iszero(or(iszero(by_), eq(by_, from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {\n                    let amount := mload(add(amounts, i))\n                    // Decrease and store the updated balance of `from`.\n                    {\n                        mstore(0x00, mload(add(ids, i)))\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\n                        let fromBalance := sload(fromBalanceSlot)\n                        if gt(amount, fromBalance) {\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, mload(ids)))\n                let o := add(m, 0x40)\n                pop(staticcall(gas(), 4, ids, n, o, n))\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, returndatasize()))\n                o := add(o, returndatasize())\n                n := add(0x20, shl(5, mload(amounts)))\n                pop(staticcall(gas(), 4, amounts, n, o, n))\n                n := sub(add(o, returndatasize()), m)\n                // Do the emit.\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), shr(96, from_), 0)\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, address(0), ids, amounts, \"\");\n        }\n    }",
            "startLine": 661
          },
          {
            "name": "_setApprovalForAll",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "isApproved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`by`, `operator`).\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, by)\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            let m := shr(96, not(0))\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, and(m, by), and(m, operator))\n        }\n    }",
            "startLine": 734
          },
          {
            "name": "_safeTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeTransfer",
                "type": "internal",
                "argCount": 6
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address from, address to, uint256 id, uint256 amount, bytes memory data)\n        internal\n        virtual\n    {\n        _safeTransfer(address(0), from, to, id, amount, data);\n    }",
            "startLine": 756
          },
          {
            "name": "_safeTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_hasCode",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(\n        address by,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            let by_ := shl(96, by)\n            if iszero(or(iszero(by_), eq(by_, from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Subtract and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, to_))\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            // forgefmt: disable-next-line\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), shr(96, from_), shr(96, to_))\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        if (_hasCode(to)) _checkOnERC1155Received(from, to, id, amount, data);\n    }",
            "startLine": 774
          },
          {
            "name": "_safeBatchTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeBatchTransfer",
                "type": "internal",
                "argCount": 6
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeBatchTransfer(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _safeBatchTransfer(address(0), from, to, ids, amounts, data);\n    }",
            "startLine": 840
          },
          {
            "name": "_safeBatchTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_hasCode",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeBatchTransfer(\n        address by,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(mload(ids), mload(amounts))) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let from_ := shl(96, from)\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, from_)\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, to_)\n            mstore(0x20, fromSlotSeed)\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            let by_ := shl(96, by)\n            if iszero(or(iszero(by_), eq(by_, from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {\n                    let amount := mload(add(amounts, i))\n                    // Subtract and store the updated balance of `from`.\n                    {\n                        mstore(0x20, fromSlotSeed)\n                        mstore(0x00, mload(add(ids, i)))\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\n                        let fromBalance := sload(fromBalanceSlot)\n                        if gt(amount, fromBalance) {\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\n                    }\n                    // Increase and store the updated balance of `to`.\n                    {\n                        mstore(0x20, toSlotSeed)\n                        let toBalanceSlot := keccak256(0x00, 0x40)\n                        let toBalanceBefore := sload(toBalanceSlot)\n                        let toBalanceAfter := add(toBalanceBefore, amount)\n                        if lt(toBalanceAfter, toBalanceBefore) {\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(toBalanceSlot, toBalanceAfter)\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, mload(ids)))\n                let o := add(m, 0x40)\n                pop(staticcall(gas(), 4, ids, n, o, n))\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, returndatasize()))\n                o := add(o, returndatasize())\n                n := add(0x20, shl(5, mload(amounts)))\n                pop(staticcall(gas(), 4, amounts, n, o, n))\n                n := sub(add(o, returndatasize()), m)\n                // Do the emit.\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), shr(96, from_), shr(96, to_))\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, ids, amounts, data);\n        }\n        if (_hasCode(to)) _checkOnERC1155BatchReceived(from, to, ids, amounts, data);\n    }",
            "startLine": 862
          },
          {
            "name": "_useBeforeTokenTransfer",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _useBeforeTokenTransfer() internal view virtual returns (bool) {\n        return false;\n    }",
            "startLine": 959
          },
          {
            "name": "_beforeTokenTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}",
            "startLine": 968
          },
          {
            "name": "_useAfterTokenTransfer",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _useAfterTokenTransfer() internal view virtual returns (bool) {\n        return false;\n    }",
            "startLine": 978
          },
          {
            "name": "_afterTokenTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}",
            "startLine": 987
          },
          {
            "name": "_afterTokenTransferCalldata",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _afterTokenTransferCalldata(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) private {\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, ids, amounts, data);\n        }\n    }",
            "startLine": 1001
          },
          {
            "name": "_hasCode",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "a",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _hasCode(address a) private view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := extcodesize(a) // Can handle dirty upper bits.\n        }\n    }",
            "startLine": 1014
          },
          {
            "name": "_checkOnERC1155Received",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _checkOnERC1155Received(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the calldata.\n            let m := mload(0x40)\n            // `onERC1155Received(address,address,uint256,uint256,bytes)`.\n            mstore(m, 0xf23a6e61)\n            mstore(add(m, 0x20), caller())\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            mstore(add(m, 0x60), id)\n            mstore(add(m, 0x80), amount)\n            mstore(add(m, 0xa0), 0xa0)\n            let n := mload(data)\n            mstore(add(m, 0xc0), n)\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xe0), n)) }\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, n), m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n            // Load the returndata and compare it with the function selector.\n            if iszero(eq(mload(m), shl(224, 0xf23a6e61))) {\n                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 1023
          },
          {
            "name": "_checkOnERC1155BatchReceived",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _checkOnERC1155BatchReceived(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the calldata.\n            let m := mload(0x40)\n            // `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n            mstore(m, 0xbc197c81)\n            mstore(add(m, 0x20), caller())\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            // Copy the `ids`.\n            mstore(add(m, 0x60), 0xa0)\n            let n := add(0x20, shl(5, mload(ids)))\n            let o := add(m, 0xc0)\n            pop(staticcall(gas(), 4, ids, n, o, n))\n            // Copy the `amounts`.\n            let s := add(0xa0, returndatasize())\n            mstore(add(m, 0x80), s)\n            o := add(o, returndatasize())\n            n := add(0x20, shl(5, mload(amounts)))\n            pop(staticcall(gas(), 4, amounts, n, o, n))\n            // Copy the `data`.\n            mstore(add(m, 0xa0), add(s, returndatasize()))\n            o := add(o, returndatasize())\n            n := add(0x20, mload(data))\n            pop(staticcall(gas(), 4, data, n, o, n))\n            n := sub(add(o, returndatasize()), add(m, 0x1c))\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), n, m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n            // Load the returndata and compare it with the function selector.\n            if iszero(eq(mload(m), shl(224, 0xbc197c81))) {\n                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 1062
          },
          {
            "name": "_single",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _single(uint256 x) private pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(0x40, add(result, 0x40))\n            mstore(result, 1)\n            mstore(add(result, 0x20), x)\n        }\n    }",
            "startLine": 1111
          }
        ],
        "events": [
          {
            "name": "TransferSingle",
            "parameters": [
              {
                "name": "operator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 51
          },
          {
            "name": "TransferBatch",
            "parameters": [
              {
                "name": "operator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "ids",
                "type": "uint256[]",
                "indexed": false
              },
              {
                "name": "amounts",
                "type": "uint256[]",
                "indexed": false
              }
            ],
            "startLine": 61
          },
          {
            "name": "ApprovalForAll",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "operator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "isApproved",
                "type": "bool",
                "indexed": false
              }
            ],
            "startLine": 70
          },
          {
            "name": "URI",
            "parameters": [
              {
                "name": "value",
                "type": "string",
                "indexed": false
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              }
            ],
            "startLine": 77
          }
        ],
        "errors": [
          {
            "name": "ArrayLengthsMismatch",
            "parameters": [],
            "startLine": 27
          },
          {
            "name": "TransferToZeroAddress",
            "parameters": [],
            "startLine": 30
          },
          {
            "name": "AccountBalanceOverflow",
            "parameters": [],
            "startLine": 33
          },
          {
            "name": "InsufficientBalance",
            "parameters": [],
            "startLine": 36
          },
          {
            "name": "NotOwnerNorApproved",
            "parameters": [],
            "startLine": 39
          },
          {
            "name": "TransferToNonERC1155ReceiverImplementer",
            "parameters": [],
            "startLine": 43
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_TRANSFER_SINGLE_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 80
          },
          {
            "name": "_TRANSFER_BATCH_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 84
          },
          {
            "name": "_APPROVAL_FOR_ALL_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 88
          },
          {
            "name": "_ERC1155_MASTER_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 113
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "ERC20",
        "filePath": "tokens/ERC20.sol",
        "kind": "abstract",
        "inherits": [],
        "implements": [],
        "category": "token",
        "externalFunctions": [
          {
            "name": "name",
            "signature": "name()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function name() public view virtual returns (string memory);",
            "startLine": 132
          },
          {
            "name": "symbol",
            "signature": "symbol()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function symbol() public view virtual returns (string memory);",
            "startLine": 135
          },
          {
            "name": "decimals",
            "signature": "decimals()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function decimals() public view virtual returns (uint8) {\n        return 18;\n    }",
            "startLine": 138
          },
          {
            "name": "totalSupply",
            "signature": "totalSupply()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function totalSupply() public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_TOTAL_SUPPLY_SLOT)\n        }\n    }",
            "startLine": 147
          },
          {
            "name": "balanceOf",
            "signature": "balanceOf(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }",
            "startLine": 155
          },
          {
            "name": "allowance",
            "signature": "allowance(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_givePermit2InfiniteAllowance",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        if (_givePermit2InfiniteAllowance()) {\n            if (spender == _PERMIT2) return type(uint256).max;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x34))\n        }\n    }",
            "startLine": 165
          },
          {
            "name": "approve",
            "signature": "approve(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_givePermit2InfiniteAllowance",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function approve(address spender, uint256 amount) public virtual returns (bool) {\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // If `spender == _PERMIT2 && amount != type(uint256).max`.\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\n        }\n        return true;\n    }",
            "startLine": 186
          },
          {
            "name": "transfer",
            "signature": "transfer(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(msg.sender, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, caller())\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(msg.sender, to, amount);\n        return true;\n    }",
            "startLine": 217
          },
          {
            "name": "transferFrom",
            "signature": "transferFrom(address,address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_givePermit2InfiniteAllowance",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n        _beforeTokenTransfer(from, to, amount);\n        // Code duplication is for zero-cost abstraction if possible.\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let from_ := shl(96, from)\n                if iszero(eq(caller(), _PERMIT2)) {\n                    // Compute the allowance slot and load its value.\n                    mstore(0x20, caller())\n                    mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\n                    let allowanceSlot := keccak256(0x0c, 0x34)\n                    let allowance_ := sload(allowanceSlot)\n                    // If the allowance is not the maximum uint256 value.\n                    if not(allowance_) {\n                        // Revert if the amount to be transferred exceeds the allowance.\n                        if gt(amount, allowance_) {\n                            mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        // Subtract and store the updated allowance.\n                        sstore(allowanceSlot, sub(allowance_, amount))\n                    }\n                }\n                // Compute the balance slot and load its value.\n                mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n                let fromBalanceSlot := keccak256(0x0c, 0x20)\n                let fromBalance := sload(fromBalanceSlot)\n                // Revert if insufficient balance.\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated balance.\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n                // Compute the balance slot of `to`.\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x20)\n                // Add and store the updated balance of `to`.\n                // Will not overflow because the sum of all user balances\n                // cannot exceed the maximum uint256 value.\n                sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n                // Emit the {Transfer} event.\n                mstore(0x20, amount)\n                log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let from_ := shl(96, from)\n                // Compute the allowance slot and load its value.\n                mstore(0x20, caller())\n                mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\n                let allowanceSlot := keccak256(0x0c, 0x34)\n                let allowance_ := sload(allowanceSlot)\n                // If the allowance is not the maximum uint256 value.\n                if not(allowance_) {\n                    // Revert if the amount to be transferred exceeds the allowance.\n                    if gt(amount, allowance_) {\n                        mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                        revert(0x1c, 0x04)\n                    }\n                    // Subtract and store the updated allowance.\n                    sstore(allowanceSlot, sub(allowance_, amount))\n                }\n                // Compute the balance slot and load its value.\n                mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n                let fromBalanceSlot := keccak256(0x0c, 0x20)\n                let fromBalance := sload(fromBalanceSlot)\n                // Revert if insufficient balance.\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated balance.\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n                // Compute the balance slot of `to`.\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x20)\n                // Add and store the updated balance of `to`.\n                // Will not overflow because the sum of all user balances\n                // cannot exceed the maximum uint256 value.\n                sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n                // Emit the {Transfer} event.\n                mstore(0x20, amount)\n                log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n            }\n        }\n        _afterTokenTransfer(from, to, amount);\n        return true;\n    }",
            "startLine": 257
          },
          {
            "name": "nonces",
            "signature": "nonces(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function nonces(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the nonce slot and load its value.\n            mstore(0x0c, _NONCES_SLOT_SEED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }",
            "startLine": 375
          },
          {
            "name": "permit",
            "signature": "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "deadline",
                "type": "uint256"
              },
              {
                "name": "v",
                "type": "uint8"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_givePermit2InfiniteAllowance",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_constantNameHash",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "name",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_versionHash",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // If `spender == _PERMIT2 && value != type(uint256).max`.\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(value)))) {\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        bytes32 versionHash = _versionHash();\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the block timestamp is greater than `deadline`.\n            if gt(timestamp(), deadline) {\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\n                revert(0x1c, 0x04)\n            }\n            let m := mload(0x40) // Grab the free memory pointer.\n            // Clean the upper 96 bits.\n            owner := shr(96, shl(96, owner))\n            spender := shr(96, shl(96, spender))\n            // Compute the nonce slot and load its value.\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\n            mstore(0x00, owner)\n            let nonceSlot := keccak256(0x0c, 0x20)\n            let nonceValue := sload(nonceSlot)\n            // Prepare the domain separator.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            mstore(0x2e, keccak256(m, 0xa0))\n            // Prepare the struct hash.\n            mstore(m, _PERMIT_TYPEHASH)\n            mstore(add(m, 0x20), owner)\n            mstore(add(m, 0x40), spender)\n            mstore(add(m, 0x60), value)\n            mstore(add(m, 0x80), nonceValue)\n            mstore(add(m, 0xa0), deadline)\n            mstore(0x4e, keccak256(m, 0xc0))\n            // Prepare the ecrecover calldata.\n            mstore(0x00, keccak256(0x2c, 0x42))\n            mstore(0x20, and(0xff, v))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            let t := staticcall(gas(), 1, 0x00, 0x80, 0x20, 0x20)\n            // If the ecrecover fails, the returndatasize will be 0x00,\n            // `owner` will be checked if it equals the hash at 0x00,\n            // which evaluates to false (i.e. 0), and we will revert.\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\n            // `owner` will be compared against the returned address at 0x20.\n            if iszero(eq(mload(returndatasize()), owner)) {\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\n                revert(0x1c, 0x04)\n            }\n            // Increment and store the updated nonce.\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\n            // Compute the allowance slot and store the value.\n            // The `owner` is already at slot 0x20.\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\n            sstore(keccak256(0x2c, 0x34), value)\n            // Emit the {Approval} event.\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }",
            "startLine": 389
          },
          {
            "name": "DOMAIN_SEPARATOR",
            "signature": "DOMAIN_SEPARATOR()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_constantNameHash",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "name",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_versionHash",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        bytes32 versionHash = _versionHash();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Grab the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            result := keccak256(m, 0xa0)\n        }\n    }",
            "startLine": 472
          }
        ],
        "internalFunctions": [
          {
            "name": "_constantNameHash",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _constantNameHash() internal view virtual returns (bytes32 result) {}",
            "startLine": 355
          },
          {
            "name": "_versionHash",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _versionHash() internal view virtual returns (bytes32 result) {\n        result = _DEFAULT_VERSION_HASH;\n    }",
            "startLine": 358
          },
          {
            "name": "_incrementNonce",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _incrementNonce(address owner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x0c, _NONCES_SLOT_SEED)\n            mstore(0x00, owner)\n            let nonceSlot := keccak256(0x0c, 0x20)\n            sstore(nonceSlot, add(1, sload(nonceSlot)))\n        }\n    }",
            "startLine": 363
          },
          {
            "name": "_mint",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _mint(address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\n            // Revert if the total supply overflows.\n            if lt(totalSupplyAfter, totalSupplyBefore) {\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(address(0), to, amount);\n    }",
            "startLine": 496
          },
          {
            "name": "_burn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _burn(address from, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot and load its value.\n            mstore(0x0c, _BALANCE_SLOT_SEED)\n            mstore(0x00, from)\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Subtract and store the updated total supply.\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\n            // Emit the {Transfer} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\n        }\n        _afterTokenTransfer(from, address(0), amount);\n    }",
            "startLine": 529
          },
          {
            "name": "_transfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _transfer(address from, address to, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, to, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            // Compute the balance slot and load its value.\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x00, to)\n            let toBalanceSlot := keccak256(0x0c, 0x20)\n            // Add and store the updated balance of `to`.\n            // Will not overflow because the sum of all user balances\n            // cannot exceed the maximum uint256 value.\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\n            // Emit the {Transfer} event.\n            mstore(0x20, amount)\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\n        }\n        _afterTokenTransfer(from, to, amount);\n    }",
            "startLine": 559
          },
          {
            "name": "_spendAllowance",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_givePermit2InfiniteAllowance",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        if (_givePermit2InfiniteAllowance()) {\n            if (spender == _PERMIT2) return; // Do nothing, as allowance is infinite.\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and load its value.\n            mstore(0x20, spender)\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\n            mstore(0x00, owner)\n            let allowanceSlot := keccak256(0x0c, 0x34)\n            let allowance_ := sload(allowanceSlot)\n            // If the allowance is not the maximum uint256 value.\n            if not(allowance_) {\n                // Revert if the amount to be transferred exceeds the allowance.\n                if gt(amount, allowance_) {\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\n                    revert(0x1c, 0x04)\n                }\n                // Subtract and store the updated allowance.\n                sstore(allowanceSlot, sub(allowance_, amount))\n            }\n        }\n    }",
            "startLine": 594
          },
          {
            "name": "_approve",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_givePermit2InfiniteAllowance",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _approve(address owner, address spender, uint256 amount) internal virtual {\n        if (_givePermit2InfiniteAllowance()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // If `spender == _PERMIT2 && amount != type(uint256).max`.\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let owner_ := shl(96, owner)\n            // Compute the allowance slot and store the amount.\n            mstore(0x20, spender)\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\n            sstore(keccak256(0x0c, 0x34), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\n        }\n    }",
            "startLine": 622
          },
          {
            "name": "_beforeTokenTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}",
            "startLine": 652
          },
          {
            "name": "_afterTokenTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}",
            "startLine": 656
          },
          {
            "name": "_givePermit2InfiniteAllowance",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _givePermit2InfiniteAllowance() internal view virtual returns (bool) {\n        return true;\n    }",
            "startLine": 667
          }
        ],
        "events": [
          {
            "name": "Transfer",
            "parameters": [
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 55
          },
          {
            "name": "Approval",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "spender",
                "type": "address",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 58
          }
        ],
        "errors": [
          {
            "name": "TotalSupplyOverflow",
            "parameters": [],
            "startLine": 27
          },
          {
            "name": "AllowanceOverflow",
            "parameters": [],
            "startLine": 30
          },
          {
            "name": "AllowanceUnderflow",
            "parameters": [],
            "startLine": 33
          },
          {
            "name": "InsufficientBalance",
            "parameters": [],
            "startLine": 36
          },
          {
            "name": "InsufficientAllowance",
            "parameters": [],
            "startLine": 39
          },
          {
            "name": "InvalidPermit",
            "parameters": [],
            "startLine": 42
          },
          {
            "name": "PermitExpired",
            "parameters": [],
            "startLine": 45
          },
          {
            "name": "Permit2AllowanceIsFixedAtInfinity",
            "parameters": [],
            "startLine": 48
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_TRANSFER_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 61
          },
          {
            "name": "_APPROVAL_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 65
          },
          {
            "name": "_TOTAL_SUPPLY_SLOT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 73
          },
          {
            "name": "_BALANCE_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 81
          },
          {
            "name": "_ALLOWANCE_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 90
          },
          {
            "name": "_NONCES_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 98
          },
          {
            "name": "_NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 105
          },
          {
            "name": "_DOMAIN_TYPEHASH",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 108
          },
          {
            "name": "_DEFAULT_VERSION_HASH",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 113
          },
          {
            "name": "_PERMIT_TYPEHASH",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 117
          },
          {
            "name": "_PERMIT2",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 125
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "ERC20Votes",
        "filePath": "tokens/ERC20Votes.sol",
        "kind": "abstract",
        "inherits": [
          "ERC20"
        ],
        "implements": [],
        "category": "token",
        "externalFunctions": [
          {
            "name": "CLOCK_MODE",
            "signature": "CLOCK_MODE()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function CLOCK_MODE() public view virtual returns (string memory) {\n        return \"mode=blocknumber&from=default\";\n    }",
            "startLine": 95
          },
          {
            "name": "clock",
            "signature": "clock()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "uint48"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function clock() public view virtual returns (uint48 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := number()\n            // Branch-less out-of-gas revert if `block.number >= 2 ** 48`.\n            returndatacopy(returndatasize(), returndatasize(), sub(0, shr(48, number())))\n        }\n    }",
            "startLine": 100
          },
          {
            "name": "getVotes",
            "signature": "getVotes(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_checkpointLatest",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_delegateCheckpointsSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getVotes(address account) public view virtual returns (uint256) {\n        return _checkpointLatest(_delegateCheckpointsSlot(account));\n    }",
            "startLine": 114
          },
          {
            "name": "getPastVotes",
            "signature": "getPastVotes(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "timepoint",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "clock",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_revertERC5805FutureLookup",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_checkpointUpperLookupRecent",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_delegateCheckpointsSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getPastVotes(address account, uint256 timepoint)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        if (timepoint >= clock()) _revertERC5805FutureLookup();\n        return _checkpointUpperLookupRecent(_delegateCheckpointsSlot(account), timepoint);\n    }",
            "startLine": 119
          },
          {
            "name": "delegates",
            "signature": "delegates(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "delegator",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function delegates(address delegator) public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ERC20_VOTES_MASTER_SLOT_SEED)\n            mstore(0x00, delegator)\n            result := sload(keccak256(0x0c, 0x18))\n        }\n    }",
            "startLine": 130
          },
          {
            "name": "delegate",
            "signature": "delegate(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegatee",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_delegate",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function delegate(address delegatee) public virtual {\n        _delegate(msg.sender, delegatee);\n    }",
            "startLine": 140
          },
          {
            "name": "delegateBySig",
            "signature": "delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegatee",
                "type": "address"
              },
              {
                "name": "nonce",
                "type": "uint256"
              },
              {
                "name": "expiry",
                "type": "uint256"
              },
              {
                "name": "v",
                "type": "uint8"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_constantNameHash",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "name",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_versionHash",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "nonces",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_incrementNonce",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_delegate",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        address signer;\n        bytes32 nameHash = _constantNameHash();\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\n        bytes32 versionHash = _versionHash();\n        /// @solidity memory-safe-assembly\n        assembly {\n            if gt(timestamp(), expiry) {\n                mstore(0x00, 0x3480e9e1) // `ERC5805DelegateSignatureExpired()`.\n                revert(0x1c, 0x04)\n            }\n            let m := mload(0x40)\n            // Prepare the struct hash.\n            mstore(0x00, _ERC5805_DELEGATION_TYPEHASH)\n            mstore(0x20, shr(96, shl(96, delegatee)))\n            mstore(0x40, nonce)\n            mstore(0x60, expiry)\n            mstore(0x40, keccak256(0x00, 0x80))\n            mstore(0x00, 0x1901) // Store \"\\x19\\x01\".\n            // Prepare the domain separator.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), nameHash)\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            mstore(0x20, keccak256(m, 0xa0))\n            // Prepare the ecrecover calldata.\n            mstore(0x00, keccak256(0x1e, 0x42))\n            mstore(0x20, and(0xff, v))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            signer := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            expiry := iszero(returndatasize()) // Reuse `expiry` to denote `ecrecover` failure.\n        }\n        if ((nonces(signer) ^ nonce) | expiry != 0) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(0x00, 0x1838d95c) // `ERC5805DelegateInvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _incrementNonce(signer);\n        _delegate(signer, delegatee);\n    }",
            "startLine": 145
          },
          {
            "name": "checkpointCount",
            "signature": "checkpointCount(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_delegateCheckpointsSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function checkpointCount(address account) public view virtual returns (uint256 result) {\n        result = _delegateCheckpointsSlot(account);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(208, shl(160, sload(result)))\n        }\n    }",
            "startLine": 206
          },
          {
            "name": "checkpointAt",
            "signature": "checkpointAt(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "checkpointClock",
                "type": "uint48"
              },
              {
                "name": "checkpointValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_delegateCheckpointsSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function checkpointAt(address account, uint256 i)\n        public\n        view\n        virtual\n        returns (uint48 checkpointClock, uint256 checkpointValue)\n    {\n        uint256 lengthSlot = _delegateCheckpointsSlot(account);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(i, shr(208, shl(160, sload(lengthSlot))))) {\n                mstore(0x00, 0x86df9d10) // `ERC5805CheckpointIndexOutOfBounds()`.\n                revert(0x1c, 0x04)\n            }\n            let checkpointPacked := sload(add(i, lengthSlot))\n            checkpointClock := and(0xffffffffffff, checkpointPacked)\n            checkpointValue := shr(96, checkpointPacked)\n            if eq(checkpointValue, address()) {\n                checkpointValue := sload(not(add(i, lengthSlot)))\n            }\n        }\n    }",
            "startLine": 215
          },
          {
            "name": "getVotesTotalSupply",
            "signature": "getVotesTotalSupply()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_checkpointLatest",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getVotesTotalSupply() public view virtual returns (uint256) {\n        return _checkpointLatest(_ERC20_VOTES_MASTER_SLOT_SEED << 96);\n    }",
            "startLine": 238
          },
          {
            "name": "getPastVotesTotalSupply",
            "signature": "getPastVotesTotalSupply(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "timepoint",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "clock",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_revertERC5805FutureLookup",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_checkpointUpperLookupRecent",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getPastVotesTotalSupply(uint256 timepoint) public view virtual returns (uint256) {\n        if (timepoint >= clock()) _revertERC5805FutureLookup();\n        return _checkpointUpperLookupRecent(_ERC20_VOTES_MASTER_SLOT_SEED << 96, timepoint);\n    }",
            "startLine": 243
          }
        ],
        "internalFunctions": [
          {
            "name": "_getVotingUnits",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "delegator",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "balanceOf",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _getVotingUnits(address delegator) internal view virtual returns (uint256) {\n        return balanceOf(delegator);\n    }",
            "startLine": 254
          },
          {
            "name": "_afterTokenTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferVotingUnits",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _afterTokenTransfer(address from, address to, uint256 amount)\n        internal\n        virtual\n        override\n    {\n        _transferVotingUnits(from, to, amount);\n    }",
            "startLine": 259
          },
          {
            "name": "_transferVotingUnits",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_checkpointPushDiff",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "clock",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_moveDelegateVotes",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "delegates",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _transferVotingUnits(address from, address to, uint256 amount) internal virtual {\n        if (from == address(0)) {\n            _checkpointPushDiff(_ERC20_VOTES_MASTER_SLOT_SEED << 96, clock(), amount, true);\n        }\n        if (to == address(0)) {\n            _checkpointPushDiff(_ERC20_VOTES_MASTER_SLOT_SEED << 96, clock(), amount, false);\n        }\n        _moveDelegateVotes(delegates(from), delegates(to), amount);\n    }",
            "startLine": 268
          },
          {
            "name": "_moveDelegateVotes",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_checkpointPushDiff",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_delegateCheckpointsSlot",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "clock",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _moveDelegateVotes(address from, address to, uint256 amount) internal virtual {\n        if (amount == uint256(0)) return;\n        (uint256 fromCleaned, uint256 toCleaned) = (uint256(uint160(from)), uint256(uint160(to)));\n        if (fromCleaned == toCleaned) return;\n        if (fromCleaned != 0) {\n            (uint256 oldValue, uint256 newValue) =\n                _checkpointPushDiff(_delegateCheckpointsSlot(from), clock(), amount, false);\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Emit the {DelegateVotesChanged} event.\n                mstore(0x00, oldValue)\n                mstore(0x20, newValue)\n                log2(0x00, 0x40, _DELEGATE_VOTES_CHANGED_EVENT_SIGNATURE, fromCleaned)\n            }\n        }\n        if (toCleaned != 0) {\n            (uint256 oldValue, uint256 newValue) =\n                _checkpointPushDiff(_delegateCheckpointsSlot(to), clock(), amount, true);\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Emit the {DelegateVotesChanged} event.\n                mstore(0x00, oldValue)\n                mstore(0x20, newValue)\n                log2(0x00, 0x40, _DELEGATE_VOTES_CHANGED_EVENT_SIGNATURE, toCleaned)\n            }\n        }\n    }",
            "startLine": 280
          },
          {
            "name": "_delegate",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "delegatee",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_moveDelegateVotes",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_getVotingUnits",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _delegate(address account, address delegatee) internal virtual {\n        address from;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let to := shr(96, shl(96, delegatee))\n            mstore(0x04, _ERC20_VOTES_MASTER_SLOT_SEED)\n            mstore(0x00, account)\n            let delegateSlot := keccak256(0x0c, 0x18)\n            from := sload(delegateSlot)\n            sstore(delegateSlot, to)\n            // Emit the {DelegateChanged} event.\n            log4(0x00, 0x00, _DELEGATE_CHANGED_EVENT_SIGNATURE, shr(96, mload(0x0c)), from, to)\n        }\n        _moveDelegateVotes(from, delegatee, _getVotingUnits(account));\n    }",
            "startLine": 310
          },
          {
            "name": "_delegateCheckpointsSlot",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _delegateCheckpointsSlot(address account) private pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ERC20_VOTES_MASTER_SLOT_SEED)\n            mstore(0x00, account)\n            result := keccak256(0x0c, 0x17)\n        }\n    }",
            "startLine": 331
          },
          {
            "name": "_checkpointPushDiff",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "lengthSlot",
                "type": "uint256"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "isAdd",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "oldValue",
                "type": "uint256"
              },
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _checkpointPushDiff(uint256 lengthSlot, uint256 key, uint256 amount, bool isAdd)\n        private\n        returns (uint256 oldValue, uint256 newValue)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let lengthSlotPacked := sload(lengthSlot)\n            for { let n := shr(208, shl(160, lengthSlotPacked)) } 1 {} {\n                if iszero(n) {\n                    if iszero(or(isAdd, iszero(amount))) {\n                        mstore(0x00, 0x5915f686) // `ERC5805CheckpointValueUnderflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    newValue := amount\n                    if iszero(or(eq(newValue, address()), shr(160, newValue))) {\n                        sstore(lengthSlot, or(or(key, shl(48, 1)), shl(96, newValue)))\n                        break\n                    }\n                    sstore(lengthSlot, or(or(key, shl(48, 1)), shl(96, address())))\n                    sstore(not(lengthSlot), newValue)\n                    break\n                }\n                let checkpointSlot := add(sub(n, 1), lengthSlot)\n                let lastPacked := sload(checkpointSlot)\n                oldValue := shr(96, lastPacked)\n                if eq(oldValue, address()) { oldValue := sload(not(checkpointSlot)) }\n                for {} 1 {} {\n                    if iszero(isAdd) {\n                        newValue := sub(oldValue, amount)\n                        if iszero(gt(newValue, oldValue)) { break }\n                        mstore(0x00, 0x5915f686) // `ERC5805CheckpointValueUnderflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    newValue := add(oldValue, amount)\n                    if iszero(lt(newValue, oldValue)) { break }\n                    mstore(0x00, 0x9dbbeb75) // `ERC5805CheckpointValueOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                let lastKey := and(0xffffffffffff, lastPacked)\n                if iszero(eq(lastKey, key)) {\n                    n := add(1, n)\n                    checkpointSlot := add(1, checkpointSlot)\n                    sstore(lengthSlot, add(shl(48, 1), lengthSlotPacked))\n                }\n                if or(gt(lastKey, key), shr(48, n)) { invalid() }\n                if iszero(or(eq(newValue, address()), shr(160, newValue))) {\n                    sstore(checkpointSlot, or(or(key, shl(48, n)), shl(96, newValue)))\n                    break\n                }\n                sstore(checkpointSlot, or(or(key, shl(48, n)), shl(96, address())))\n                sstore(not(checkpointSlot), newValue)\n                break\n            }\n        }\n    }",
            "startLine": 341
          },
          {
            "name": "_checkpointLatest",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "lengthSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _checkpointLatest(uint256 lengthSlot) private view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(208, shl(160, sload(lengthSlot)))\n            if result {\n                lengthSlot := add(sub(result, 1), lengthSlot) // Reuse for `checkpointSlot`.\n                result := shr(96, sload(lengthSlot))\n                if eq(result, address()) { result := sload(not(lengthSlot)) }\n            }\n        }\n    }",
            "startLine": 398
          },
          {
            "name": "_checkpointUpperLookupRecent",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "lengthSlot",
                "type": "uint256"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _checkpointUpperLookupRecent(uint256 lengthSlot, uint256 key)\n        private\n        view\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := 0 // Low.\n            let h := shr(208, shl(160, sload(lengthSlot))) // High.\n            // Start the binary search nearer to the right to optimize for recent checkpoints.\n            for {} iszero(lt(h, 6)) {} {\n                let m := shl(4, lt(0xffff, h))\n                m := shl(shr(1, or(m, shl(3, lt(0xff, shr(m, h))))), 16)\n                m := shr(1, add(m, div(h, m)))\n                m := shr(1, add(m, div(h, m)))\n                m := shr(1, add(m, div(h, m)))\n                m := shr(1, add(m, div(h, m)))\n                m := shr(1, add(m, div(h, m)))\n                m := sub(h, shr(1, add(m, div(h, m)))) // Approx `h - sqrt(h)`.\n                if iszero(lt(key, and(sload(add(m, lengthSlot)), 0xffffffffffff))) {\n                    l := add(1, m)\n                    break\n                }\n                h := m\n                break\n            }\n            // Binary search.\n            for {} lt(l, h) {} {\n                let m := shr(1, add(l, h)) // Won't overflow in practice.\n                if iszero(lt(key, and(sload(add(m, lengthSlot)), 0xffffffffffff))) {\n                    l := add(1, m)\n                    continue\n                }\n                h := m\n            }\n            let checkpointSlot := add(sub(h, 1), lengthSlot)\n            result := mul(iszero(iszero(h)), shr(96, sload(checkpointSlot)))\n            if eq(result, address()) { result := sload(not(checkpointSlot)) }\n        }\n    }",
            "startLine": 411
          },
          {
            "name": "_revertERC5805FutureLookup",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _revertERC5805FutureLookup() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0xf9874464) // `ERC5805FutureLookup()`.\n            revert(0x1c, 0x04)\n        }\n    }",
            "startLine": 453
          }
        ],
        "events": [
          {
            "name": "DelegateChanged",
            "parameters": [
              {
                "name": "delegator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 37
          },
          {
            "name": "DelegateVotesChanged",
            "parameters": [
              {
                "name": "delegate",
                "type": "address",
                "indexed": true
              },
              {
                "name": "oldValue",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "newValue",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 40
          }
        ],
        "errors": [
          {
            "name": "ERC5805FutureLookup",
            "parameters": [],
            "startLine": 15
          },
          {
            "name": "ERC5805DelegateSignatureExpired",
            "parameters": [],
            "startLine": 18
          },
          {
            "name": "ERC5805DelegateInvalidSignature",
            "parameters": [],
            "startLine": 21
          },
          {
            "name": "ERC5805CheckpointIndexOutOfBounds",
            "parameters": [],
            "startLine": 24
          },
          {
            "name": "ERC5805CheckpointValueOverflow",
            "parameters": [],
            "startLine": 27
          },
          {
            "name": "ERC5805CheckpointValueUnderflow",
            "parameters": [],
            "startLine": 30
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_DELEGATE_CHANGED_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 43
          },
          {
            "name": "_DELEGATE_VOTES_CHANGED_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 47
          },
          {
            "name": "_DOMAIN_TYPEHASH",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 55
          },
          {
            "name": "_ERC5805_DELEGATION_TYPEHASH",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 59
          },
          {
            "name": "_ERC20_VOTES_MASTER_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 88
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./ERC20.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "ERC2981",
        "filePath": "tokens/ERC2981.sol",
        "kind": "abstract",
        "inherits": [],
        "implements": [],
        "category": "token",
        "externalFunctions": [
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC2981: 0x2a55205a.\n            result := or(eq(s, 0x01ffc9a7), eq(s, 0x2a55205a))\n        }\n    }",
            "startLine": 58
          },
          {
            "name": "royaltyInfo",
            "signature": "royaltyInfo(uint256,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "salePrice",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "royaltyAmount",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_feeDenominator",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        public\n        view\n        virtual\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        uint256 feeDenominator = _feeDenominator();\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, tokenId)\n            mstore(0x20, _ERC2981_MASTER_SLOT_SEED)\n            let packed := sload(keccak256(0x00, 0x40))\n            receiver := shr(96, packed)\n            if iszero(receiver) {\n                packed := sload(mload(0x20))\n                receiver := shr(96, packed)\n            }\n            let x := salePrice\n            let y := xor(packed, shl(96, receiver)) // `feeNumerator`.\n            // Overflow check, equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            // Out-of-gas revert. Should not be triggered in practice, but included for safety.\n            returndatacopy(returndatasize(), returndatasize(), mul(y, gt(x, div(not(0), y))))\n            royaltyAmount := div(mul(x, y), feeDenominator)\n        }\n    }",
            "startLine": 68
          }
        ],
        "internalFunctions": [
          {
            "name": "constructor",
            "visibility": "default",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_feeDenominator",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "constructor() {\n        require(_feeDenominator() != 0, \"Fee denominator cannot be zero.\");\n    }",
            "startLine": 44
          },
          {
            "name": "_feeDenominator",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint96"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }",
            "startLine": 51
          },
          {
            "name": "_setDefaultRoyalty",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "feeNumerator",
                "type": "uint96"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_feeDenominator",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        uint256 feeDenominator = _feeDenominator();\n        /// @solidity memory-safe-assembly\n        assembly {\n            feeNumerator := shr(160, shl(160, feeNumerator))\n            if gt(feeNumerator, feeDenominator) {\n                mstore(0x00, 0x350a88b3) // `RoyaltyOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            let packed := shl(96, receiver)\n            if iszero(packed) {\n                mstore(0x00, 0xb4457eaa) // `RoyaltyReceiverIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(_ERC2981_MASTER_SLOT_SEED, or(packed, feeNumerator))\n        }\n    }",
            "startLine": 99
          },
          {
            "name": "_deleteDefaultRoyalty",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _deleteDefaultRoyalty() internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(_ERC2981_MASTER_SLOT_SEED, 0)\n        }\n    }",
            "startLine": 118
          },
          {
            "name": "_setTokenRoyalty",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "feeNumerator",
                "type": "uint96"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_feeDenominator",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator)\n        internal\n        virtual\n    {\n        uint256 feeDenominator = _feeDenominator();\n        /// @solidity memory-safe-assembly\n        assembly {\n            feeNumerator := shr(160, shl(160, feeNumerator))\n            if gt(feeNumerator, feeDenominator) {\n                mstore(0x00, 0x350a88b3) // `RoyaltyOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            let packed := shl(96, receiver)\n            if iszero(packed) {\n                mstore(0x00, 0xb4457eaa) // `RoyaltyReceiverIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, tokenId)\n            mstore(0x20, _ERC2981_MASTER_SLOT_SEED)\n            sstore(keccak256(0x00, 0x40), or(packed, feeNumerator))\n        }\n    }",
            "startLine": 130
          },
          {
            "name": "_resetTokenRoyalty",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, tokenId)\n            mstore(0x20, _ERC2981_MASTER_SLOT_SEED)\n            sstore(keccak256(0x00, 0x40), 0)\n        }\n    }",
            "startLine": 154
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "RoyaltyOverflow",
            "parameters": [],
            "startLine": 13
          },
          {
            "name": "RoyaltyReceiverIsZeroAddress",
            "parameters": [],
            "startLine": 16
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_ERC2981_MASTER_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 37
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "ERC4626",
        "filePath": "tokens/ERC4626.sol",
        "kind": "abstract",
        "inherits": [
          "ERC20"
        ],
        "implements": [],
        "category": "token",
        "externalFunctions": [
          {
            "name": "asset",
            "signature": "asset()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function asset() public view virtual returns (address);",
            "startLine": 71
          },
          {
            "name": "decimals",
            "signature": "decimals()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [
              {
                "target": "_useVirtualShares",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_underlyingDecimals",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_decimalsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function decimals() public view virtual override(ERC20) returns (uint8) {\n        if (!_useVirtualShares()) return _underlyingDecimals();\n        return _underlyingDecimals() + _decimalsOffset();\n    }",
            "startLine": 103
          },
          {
            "name": "totalAssets",
            "signature": "totalAssets()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "SafeTransferLib.balanceOf",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "asset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function totalAssets() public view virtual returns (uint256 assets) {\n        assets = SafeTransferLib.balanceOf(asset(), address(this));\n    }",
            "startLine": 151
          },
          {
            "name": "convertToShares",
            "signature": "convertToShares(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_useVirtualShares",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "totalSupply",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_eitherIsZero",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_initialConvertToShares",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "FixedPointMathLib.fullMulDiv",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "totalAssets",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_decimalsOffset",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_inc",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function convertToShares(uint256 assets) public view virtual returns (uint256 shares) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return _eitherIsZero(assets, supply)\n                ? _initialConvertToShares(assets)\n                : FixedPointMathLib.fullMulDiv(assets, supply, totalAssets());\n        }\n        uint256 o = _decimalsOffset();\n        if (o == uint256(0)) {\n            return FixedPointMathLib.fullMulDiv(assets, totalSupply() + 1, _inc(totalAssets()));\n        }\n        return FixedPointMathLib.fullMulDiv(assets, totalSupply() + 10 ** o, _inc(totalAssets()));\n    }",
            "startLine": 166
          },
          {
            "name": "convertToAssets",
            "signature": "convertToAssets(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_useVirtualShares",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "totalSupply",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_initialConvertToAssets",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "FixedPointMathLib.fullMulDiv",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "totalAssets",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_decimalsOffset",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_inc",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function convertToAssets(uint256 shares) public view virtual returns (uint256 assets) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return supply == uint256(0)\n                ? _initialConvertToAssets(shares)\n                : FixedPointMathLib.fullMulDiv(shares, totalAssets(), supply);\n        }\n        uint256 o = _decimalsOffset();\n        if (o == uint256(0)) {\n            return FixedPointMathLib.fullMulDiv(shares, totalAssets() + 1, _inc(totalSupply()));\n        }\n        return FixedPointMathLib.fullMulDiv(shares, totalAssets() + 1, totalSupply() + 10 ** o);\n    }",
            "startLine": 191
          },
          {
            "name": "previewDeposit",
            "signature": "previewDeposit(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "convertToShares",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function previewDeposit(uint256 assets) public view virtual returns (uint256 shares) {\n        shares = convertToShares(assets);\n    }",
            "startLine": 219
          },
          {
            "name": "previewMint",
            "signature": "previewMint(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_useVirtualShares",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "totalSupply",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_initialConvertToAssets",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "FixedPointMathLib.fullMulDivUp",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "totalAssets",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_decimalsOffset",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_inc",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function previewMint(uint256 shares) public view virtual returns (uint256 assets) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return supply == uint256(0)\n                ? _initialConvertToAssets(shares)\n                : FixedPointMathLib.fullMulDivUp(shares, totalAssets(), supply);\n        }\n        uint256 o = _decimalsOffset();\n        if (o == uint256(0)) {\n            return FixedPointMathLib.fullMulDivUp(shares, totalAssets() + 1, _inc(totalSupply()));\n        }\n        return FixedPointMathLib.fullMulDivUp(shares, totalAssets() + 1, totalSupply() + 10 ** o);\n    }",
            "startLine": 237
          },
          {
            "name": "previewWithdraw",
            "signature": "previewWithdraw(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_useVirtualShares",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "totalSupply",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_eitherIsZero",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_initialConvertToShares",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "FixedPointMathLib.fullMulDivUp",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "totalAssets",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_decimalsOffset",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_inc",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function previewWithdraw(uint256 assets) public view virtual returns (uint256 shares) {\n        if (!_useVirtualShares()) {\n            uint256 supply = totalSupply();\n            return _eitherIsZero(assets, supply)\n                ? _initialConvertToShares(assets)\n                : FixedPointMathLib.fullMulDivUp(assets, supply, totalAssets());\n        }\n        uint256 o = _decimalsOffset();\n        if (o == uint256(0)) {\n            return FixedPointMathLib.fullMulDivUp(assets, totalSupply() + 1, _inc(totalAssets()));\n        }\n        return FixedPointMathLib.fullMulDivUp(assets, totalSupply() + 10 ** o, _inc(totalAssets()));\n    }",
            "startLine": 265
          },
          {
            "name": "previewRedeem",
            "signature": "previewRedeem(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "convertToAssets",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function previewRedeem(uint256 shares) public view virtual returns (uint256 assets) {\n        assets = convertToAssets(shares);\n    }",
            "startLine": 293
          },
          {
            "name": "maxDeposit",
            "signature": "maxDeposit(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "maxAssets",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function maxDeposit(address to) public view virtual returns (uint256 maxAssets) {\n        to = to; // Silence unused variable warning.\n        maxAssets = type(uint256).max;\n    }",
            "startLine": 325
          },
          {
            "name": "maxMint",
            "signature": "maxMint(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "maxShares",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function maxMint(address to) public view virtual returns (uint256 maxShares) {\n        to = to; // Silence unused variable warning.\n        maxShares = type(uint256).max;\n    }",
            "startLine": 336
          },
          {
            "name": "maxWithdraw",
            "signature": "maxWithdraw(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "maxAssets",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "convertToAssets",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "balanceOf",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function maxWithdraw(address owner) public view virtual returns (uint256 maxAssets) {\n        maxAssets = convertToAssets(balanceOf(owner));\n    }",
            "startLine": 346
          },
          {
            "name": "maxRedeem",
            "signature": "maxRedeem(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "maxShares",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "balanceOf",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function maxRedeem(address owner) public view virtual returns (uint256 maxShares) {\n        maxShares = balanceOf(owner);\n    }",
            "startLine": 356
          },
          {
            "name": "deposit",
            "signature": "deposit(uint256,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "to",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "maxDeposit",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_revert",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "previewDeposit",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_deposit",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function deposit(uint256 assets, address to) public virtual returns (uint256 shares) {\n        if (assets > maxDeposit(to)) _revert(0xb3c61a83); // `DepositMoreThanMax()`.\n        shares = previewDeposit(assets);\n        _deposit(msg.sender, to, assets, shares);\n    }",
            "startLine": 375
          },
          {
            "name": "mint",
            "signature": "mint(uint256,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "shares",
                "type": "uint256"
              },
              {
                "name": "to",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "maxMint",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_revert",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "previewMint",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_deposit",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function mint(uint256 shares, address to) public virtual returns (uint256 assets) {\n        if (shares > maxMint(to)) _revert(0x6a695959); // `MintMoreThanMax()`.\n        assets = previewMint(shares);\n        _deposit(msg.sender, to, assets, shares);\n    }",
            "startLine": 392
          },
          {
            "name": "withdraw",
            "signature": "withdraw(uint256,address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "maxWithdraw",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_revert",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "previewWithdraw",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_withdraw",
                "type": "internal",
                "argCount": 5
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function withdraw(uint256 assets, address to, address owner)\n        public\n        virtual\n        returns (uint256 shares)\n    {\n        if (assets > maxWithdraw(owner)) _revert(0x936941fc); // `WithdrawMoreThanMax()`.\n        shares = previewWithdraw(assets);\n        _withdraw(msg.sender, to, owner, assets, shares);\n    }",
            "startLine": 408
          },
          {
            "name": "redeem",
            "signature": "redeem(uint256,address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "shares",
                "type": "uint256"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "maxRedeem",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_revert",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "previewRedeem",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_withdraw",
                "type": "internal",
                "argCount": 5
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function redeem(uint256 shares, address to, address owner)\n        public\n        virtual\n        returns (uint256 assets)\n    {\n        if (shares > maxRedeem(owner)) _revert(0x4656425a); // `RedeemMoreThanMax()`.\n        assets = previewRedeem(shares);\n        _withdraw(msg.sender, to, owner, assets, shares);\n    }",
            "startLine": 428
          }
        ],
        "internalFunctions": [
          {
            "name": "_underlyingDecimals",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _underlyingDecimals() internal view virtual returns (uint8) {\n        return _DEFAULT_UNDERLYING_DECIMALS;\n    }",
            "startLine": 77
          },
          {
            "name": "_decimalsOffset",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _decimalsOffset() internal view virtual returns (uint8) {\n        return _DEFAULT_DECIMALS_OFFSET;\n    }",
            "startLine": 86
          },
          {
            "name": "_useVirtualShares",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _useVirtualShares() internal view virtual returns (bool) {\n        return true;\n    }",
            "startLine": 96
          },
          {
            "name": "_tryGetAssetDecimals",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "underlying",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "success",
                "type": "bool"
              },
              {
                "name": "result",
                "type": "uint8"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _tryGetAssetDecimals(address underlying)\n        internal\n        view\n        returns (bool success, uint8 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the function selector of `decimals()`.\n            mstore(0x00, 0x313ce567)\n            // Arguments are evaluated last to first.\n            success := and(\n                // Returned value is less than 256, at left-padded to 32 bytes.\n                and(lt(mload(0x00), 0x100), gt(returndatasize(), 0x1f)),\n                // The staticcall succeeds.\n                staticcall(gas(), underlying, 0x1c, 0x04, 0x00, 0x20)\n            )\n            result := mul(mload(0x00), success)\n        }\n    }",
            "startLine": 122
          },
          {
            "name": "_eitherIsZero",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256"
              },
              {
                "name": "b",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _eitherIsZero(uint256 a, uint256 b) private pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := or(iszero(a), iszero(b))\n        }\n    }",
            "startLine": 298
          },
          {
            "name": "_inc",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _inc(uint256 x) private pure returns (uint256) {\n        unchecked {\n            return x + 1;\n        }\n    }",
            "startLine": 309
          },
          {
            "name": "_revert",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _revert(uint256 s) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, s)\n            revert(0x1c, 0x04)\n        }\n    }",
            "startLine": 439
          },
          {
            "name": "_deposit",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "SafeTransferLib.safeTransferFrom",
                "type": "library",
                "argCount": 4
              },
              {
                "target": "asset",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_mint",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_afterDeposit",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _deposit(address by, address to, uint256 assets, uint256 shares) internal virtual {\n        SafeTransferLib.safeTransferFrom(asset(), by, address(this), assets);\n        _mint(to, shares);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Emit the {Deposit} event.\n            mstore(0x00, assets)\n            mstore(0x20, shares)\n            let m := shr(96, not(0))\n            log3(0x00, 0x40, _DEPOSIT_EVENT_SIGNATURE, and(m, by), and(m, to))\n        }\n        _afterDeposit(assets, shares);\n    }",
            "startLine": 454
          },
          {
            "name": "_withdraw",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_spendAllowance",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_beforeWithdraw",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_burn",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "SafeTransferLib.safeTransfer",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "asset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _withdraw(address by, address to, address owner, uint256 assets, uint256 shares)\n        internal\n        virtual\n    {\n        if (by != owner) _spendAllowance(owner, by, shares);\n        _beforeWithdraw(assets, shares);\n        _burn(owner, shares);\n        SafeTransferLib.safeTransfer(asset(), to, assets);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Emit the {Withdraw} event.\n            mstore(0x00, assets)\n            mstore(0x20, shares)\n            let m := shr(96, not(0))\n            log4(0x00, 0x40, _WITHDRAW_EVENT_SIGNATURE, and(m, by), and(m, to), and(m, owner))\n        }\n    }",
            "startLine": 471
          },
          {
            "name": "_initialConvertToShares",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _initialConvertToShares(uint256 assets)\n        internal\n        view\n        virtual\n        returns (uint256 shares)\n    {\n        shares = assets;\n    }",
            "startLine": 494
          },
          {
            "name": "_initialConvertToAssets",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _initialConvertToAssets(uint256 shares)\n        internal\n        view\n        virtual\n        returns (uint256 assets)\n    {\n        assets = shares;\n    }",
            "startLine": 508
          },
          {
            "name": "_beforeWithdraw",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}",
            "startLine": 522
          },
          {
            "name": "_afterDeposit",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _afterDeposit(uint256 assets, uint256 shares) internal virtual {}",
            "startLine": 525
          }
        ],
        "events": [
          {
            "name": "Deposit",
            "parameters": [
              {
                "name": "by",
                "type": "address",
                "indexed": true
              },
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "assets",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "shares",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 44
          },
          {
            "name": "Withdraw",
            "parameters": [
              {
                "name": "by",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "assets",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "shares",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 47
          }
        ],
        "errors": [
          {
            "name": "DepositMoreThanMax",
            "parameters": [],
            "startLine": 28
          },
          {
            "name": "MintMoreThanMax",
            "parameters": [],
            "startLine": 31
          },
          {
            "name": "WithdrawMoreThanMax",
            "parameters": [],
            "startLine": 34
          },
          {
            "name": "RedeemMoreThanMax",
            "parameters": [],
            "startLine": 37
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_DEFAULT_UNDERLYING_DECIMALS",
            "type": "uint8",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 18
          },
          {
            "name": "_DEFAULT_DECIMALS_OFFSET",
            "type": "uint8",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 21
          },
          {
            "name": "_DEPOSIT_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 56
          },
          {
            "name": "_WITHDRAW_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 60
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./ERC20.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../utils/FixedPointMathLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../utils/SafeTransferLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "ERC6909",
        "filePath": "tokens/ERC6909.sol",
        "kind": "abstract",
        "inherits": [],
        "implements": [],
        "category": "token",
        "externalFunctions": [
          {
            "name": "name",
            "signature": "name(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function name(uint256 id) public view virtual returns (string memory);",
            "startLine": 98
          },
          {
            "name": "symbol",
            "signature": "symbol(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function symbol(uint256 id) public view virtual returns (string memory);",
            "startLine": 101
          },
          {
            "name": "decimals",
            "signature": "decimals(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function decimals(uint256 id) public view virtual returns (uint8) {\n        id = id; // Silence compiler warning.\n        return 18;\n    }",
            "startLine": 106
          },
          {
            "name": "tokenURI",
            "signature": "tokenURI(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function tokenURI(uint256 id) public view virtual returns (string memory);",
            "startLine": 112
          },
          {
            "name": "balanceOf",
            "signature": "balanceOf(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address owner, uint256 id) public view virtual returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, id)\n            amount := sload(keccak256(0x00, 0x40))\n        }\n    }",
            "startLine": 119
          },
          {
            "name": "allowance",
            "signature": "allowance(address,address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function allowance(address owner, address spender, uint256 id)\n        public\n        view\n        virtual\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, owner)\n            mstore(0x14, spender)\n            mstore(0x00, id)\n            amount := sload(keccak256(0x00, 0x54))\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n    }",
            "startLine": 130
          },
          {
            "name": "isOperator",
            "signature": "isOperator(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "status",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function isOperator(address owner, address spender) public view virtual returns (bool status) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, spender)\n            status := sload(keccak256(0x0c, 0x34))\n        }\n    }",
            "startLine": 149
          },
          {
            "name": "transfer",
            "signature": "transfer(address,uint256,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function transfer(address to, uint256 id, uint256 amount)\n        public\n        payable\n        virtual\n        returns (bool)\n    {\n        _beforeTokenTransfer(msg.sender, to, id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            /// Compute the balance slot and load its value.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, caller())\n            mstore(0x00, id)\n            let fromBalanceSlot := keccak256(0x00, 0x40)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x14, to)\n            mstore(0x00, id)\n            let toBalanceSlot := keccak256(0x00, 0x40)\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n            // Revert if the balance overflows.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated balance of `to`.\n            sstore(toBalanceSlot, toBalanceAfter)\n            // Emit the {Transfer} event.\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, shl(96, to)), id)\n        }\n        _afterTokenTransfer(msg.sender, to, id, amount);\n        return true;\n    }",
            "startLine": 165
          },
          {
            "name": "transferFrom",
            "signature": "transferFrom(address,address,uint256,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function transferFrom(address from, address to, uint256 id, uint256 amount)\n        public\n        payable\n        virtual\n        returns (bool)\n    {\n        _beforeTokenTransfer(from, to, id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the operator slot and load its value.\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, from)\n            mstore(0x14, caller())\n            // Check if the caller is an operator.\n            if iszero(sload(keccak256(0x20, 0x34))) {\n                // Compute the allowance slot and load its value.\n                mstore(0x00, id)\n                let allowanceSlot := keccak256(0x00, 0x54)\n                let allowance_ := sload(allowanceSlot)\n                // If the allowance is not the maximum uint256 value.\n                if add(allowance_, 1) {\n                    // Revert if the amount to be transferred exceeds the allowance.\n                    if gt(amount, allowance_) {\n                        mstore(0x00, 0xdeda9030) // `InsufficientPermission()`.\n                        revert(0x1c, 0x04)\n                    }\n                    // Subtract and store the updated allowance.\n                    sstore(allowanceSlot, sub(allowance_, amount))\n                }\n            }\n            // Compute the balance slot and load its value.\n            mstore(0x14, id)\n            let fromBalanceSlot := keccak256(0x14, 0x40)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x28, to)\n            mstore(0x14, id)\n            let toBalanceSlot := keccak256(0x14, 0x40)\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n            // Revert if the balance overflows.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated balance of `to`.\n            sstore(toBalanceSlot, toBalanceAfter)\n            // Emit the {Transfer} event.\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            // forgefmt: disable-next-line\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), shr(96, shl(96, to)), id)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n        _afterTokenTransfer(from, to, id, amount);\n        return true;\n    }",
            "startLine": 222
          },
          {
            "name": "approve",
            "signature": "approve(address,uint256,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function approve(address spender, uint256 id, uint256 amount)\n        public\n        payable\n        virtual\n        returns (bool)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, caller())\n            mstore(0x14, spender)\n            mstore(0x00, id)\n            sstore(keccak256(0x00, 0x54), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            log4(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x20)), id)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n        return true;\n    }",
            "startLine": 291
          },
          {
            "name": "setOperator",
            "signature": "setOperator(address,bool)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "approved",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setOperator(address operator, bool approved) public payable virtual returns (bool) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert `approved` to `0` or `1`.\n            let approvedCleaned := iszero(iszero(approved))\n            // Compute the operator slot and store the approved.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, caller())\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), approvedCleaned)\n            // Emit the {OperatorSet} event.\n            mstore(0x20, approvedCleaned)\n            log3(0x20, 0x20, _OPERATOR_SET_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\n        }\n        return true;\n    }",
            "startLine": 317
          },
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC6909: 0x0f632fb3.\n            result := or(eq(s, 0x01ffc9a7), eq(s, 0x0f632fb3))\n        }\n    }",
            "startLine": 335
          }
        ],
        "internalFunctions": [
          {
            "name": "_mint",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _mint(address to, uint256 id, uint256 amount) internal virtual {\n        _beforeTokenTransfer(address(0), to, id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, to)\n            mstore(0x00, id)\n            let toBalanceSlot := keccak256(0x00, 0x40)\n            // Add and store the updated balance\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n            // Revert if the balance overflows.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(toBalanceSlot, toBalanceAfter)\n            // Emit the {Transfer} event.\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, shl(96, to)), id)\n        }\n        _afterTokenTransfer(address(0), to, id, amount);\n    }",
            "startLine": 351
          },
          {
            "name": "_burn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        _beforeTokenTransfer(from, address(0), id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the balance slot.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, from)\n            mstore(0x00, id)\n            let fromBalanceSlot := keccak256(0x00, 0x40)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Emit the {Transfer} event.\n            mstore(0x00, caller())\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0, id)\n        }\n        _afterTokenTransfer(from, address(0), id, amount);\n    }",
            "startLine": 380
          },
          {
            "name": "_transfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _transfer(address by, address from, address to, uint256 id, uint256 amount)\n        internal\n        virtual\n    {\n        _beforeTokenTransfer(from, to, id, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let bitmaskAddress := 0xffffffffffffffffffffffffffffffffffffffff\n            // Compute the operator slot and load its value.\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, from)\n            // If `by` is not the zero address.\n            if and(bitmaskAddress, by) {\n                mstore(0x14, by)\n                // Check if the `by` is an operator.\n                if iszero(sload(keccak256(0x20, 0x34))) {\n                    // Compute the allowance slot and load its value.\n                    mstore(0x00, id)\n                    let allowanceSlot := keccak256(0x00, 0x54)\n                    let allowance_ := sload(allowanceSlot)\n                    // If the allowance is not the maximum uint256 value.\n                    if add(allowance_, 1) {\n                        // Revert if the amount to be transferred exceeds the allowance.\n                        if gt(amount, allowance_) {\n                            mstore(0x00, 0xdeda9030) // `InsufficientPermission()`.\n                            revert(0x1c, 0x04)\n                        }\n                        // Subtract and store the updated allowance.\n                        sstore(allowanceSlot, sub(allowance_, amount))\n                    }\n                }\n            }\n            // Compute the balance slot and load its value.\n            mstore(0x14, id)\n            let fromBalanceSlot := keccak256(0x14, 0x40)\n            let fromBalance := sload(fromBalanceSlot)\n            // Revert if insufficient balance.\n            if gt(amount, fromBalance) {\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                revert(0x1c, 0x04)\n            }\n            // Subtract and store the updated balance.\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\n            // Compute the balance slot of `to`.\n            mstore(0x28, to)\n            mstore(0x14, id)\n            let toBalanceSlot := keccak256(0x14, 0x40)\n            let toBalanceBefore := sload(toBalanceSlot)\n            let toBalanceAfter := add(toBalanceBefore, amount)\n            // Revert if the balance overflows.\n            if lt(toBalanceAfter, toBalanceBefore) {\n                mstore(0x00, 0x89560ca1) // `BalanceOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            // Store the updated balance of `to`.\n            sstore(toBalanceSlot, toBalanceAfter)\n            // Emit the {Transfer} event.\n            mstore(0x00, and(bitmaskAddress, by))\n            mstore(0x20, amount)\n            // forgefmt: disable-next-line\n            log4(0x00, 0x40, _TRANSFER_EVENT_SIGNATURE, and(bitmaskAddress, from), and(bitmaskAddress, to), id)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n        _afterTokenTransfer(from, to, id, amount);\n    }",
            "startLine": 419
          },
          {
            "name": "_approve",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _approve(address owner, address spender, uint256 id, uint256 amount) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the allowance slot and store the amount.\n            mstore(0x34, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x28, owner)\n            mstore(0x14, spender)\n            mstore(0x00, id)\n            sstore(keccak256(0x00, 0x54), amount)\n            // Emit the {Approval} event.\n            mstore(0x00, amount)\n            // forgefmt: disable-next-line\n            log4(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x34)), shr(96, mload(0x20)), id)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x34, 0x00)\n        }\n    }",
            "startLine": 489
          },
          {
            "name": "_setOperator",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "approved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _setOperator(address owner, address operator, bool approved) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert `approved` to `0` or `1`.\n            let approvedCleaned := iszero(iszero(approved))\n            // Compute the operator slot and store the approved.\n            mstore(0x20, _ERC6909_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), approvedCleaned)\n            // Emit the {OperatorSet} event.\n            mstore(0x20, approvedCleaned)\n            // forgefmt: disable-next-line\n            log3(0x20, 0x20, _OPERATOR_SET_EVENT_SIGNATURE, shr(96, shl(96, owner)), shr(96, mload(0x0c)))\n        }\n    }",
            "startLine": 510
          },
          {
            "name": "_beforeTokenTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _beforeTokenTransfer(address from, address to, uint256 id, uint256 amount)\n        internal\n        virtual {}",
            "startLine": 533
          },
          {
            "name": "_afterTokenTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _afterTokenTransfer(address from, address to, uint256 id, uint256 amount)\n        internal\n        virtual {}",
            "startLine": 539
          }
        ],
        "events": [
          {
            "name": "Transfer",
            "parameters": [
              {
                "name": "by",
                "type": "address",
                "indexed": false
              },
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 37
          },
          {
            "name": "OperatorSet",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "operator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "approved",
                "type": "bool",
                "indexed": false
              }
            ],
            "startLine": 42
          },
          {
            "name": "Approval",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "spender",
                "type": "address",
                "indexed": true
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 45
          }
        ],
        "errors": [
          {
            "name": "InsufficientBalance",
            "parameters": [],
            "startLine": 24
          },
          {
            "name": "InsufficientPermission",
            "parameters": [],
            "startLine": 27
          },
          {
            "name": "BalanceOverflow",
            "parameters": [],
            "startLine": 30
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_TRANSFER_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 50
          },
          {
            "name": "_OPERATOR_SET_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 54
          },
          {
            "name": "_APPROVAL_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 58
          },
          {
            "name": "_ERC6909_MASTER_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 91
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "ERC721",
        "filePath": "tokens/ERC721.sol",
        "kind": "abstract",
        "inherits": [],
        "implements": [],
        "category": "token",
        "externalFunctions": [
          {
            "name": "name",
            "signature": "name()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function name() public view virtual returns (string memory);",
            "startLine": 131
          },
          {
            "name": "symbol",
            "signature": "symbol()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function symbol() public view virtual returns (string memory);",
            "startLine": 134
          },
          {
            "name": "tokenURI",
            "signature": "tokenURI(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function tokenURI(uint256 id) public view virtual returns (string memory);",
            "startLine": 137
          },
          {
            "name": "ownerOf",
            "signature": "ownerOf(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_ownerOf",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function ownerOf(uint256 id) public view virtual returns (address result) {\n        result = _ownerOf(id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(result) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 147
          },
          {
            "name": "balanceOf",
            "signature": "balanceOf(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the `owner` is the zero address.\n            if iszero(owner) {\n                mstore(0x00, 0x8f4eb604) // `BalanceQueryForZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            result := and(sload(keccak256(0x0c, 0x1c)), _MAX_ACCOUNT_BALANCE)\n        }\n    }",
            "startLine": 162
          },
          {
            "name": "getApproved",
            "signature": "getApproved(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getApproved(uint256 id) public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            if iszero(shl(96, sload(ownershipSlot))) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            result := sload(add(1, ownershipSlot))\n        }\n    }",
            "startLine": 180
          },
          {
            "name": "approve",
            "signature": "approve(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_approve",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function approve(address account, uint256 id) public payable virtual {\n        _approve(msg.sender, account, id);\n    }",
            "startLine": 202
          },
          {
            "name": "isApprovedForAll",
            "signature": "isApprovedForAll(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, operator)\n            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x30))\n        }\n    }",
            "startLine": 207
          },
          {
            "name": "setApprovalForAll",
            "signature": "setApprovalForAll(address,bool)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "isApproved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setApprovalForAll(address operator, bool isApproved) public virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`msg.sender`, `operator`).\n            mstore(0x1c, operator)\n            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x30), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            // forgefmt: disable-next-item\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator)))\n        }\n    }",
            "startLine": 225
          },
          {
            "name": "transferFrom",
            "signature": "transferFrom(address,address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function transferFrom(address from, address to, uint256 id) public payable virtual {\n        _beforeTokenTransfer(from, to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            from := and(bitmaskAddress, from)\n            to := and(bitmaskAddress, to)\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, caller()))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            let owner := and(bitmaskAddress, ownershipPacked)\n            // Revert if the token does not exist, or if `from` is not the owner.\n            if iszero(mul(owner, eq(owner, from))) {\n                // `TokenDoesNotExist()`, `TransferFromIncorrectOwner()`.\n                mstore(shl(2, iszero(owner)), 0xceea21b6a1148100)\n                revert(0x1c, 0x04)\n            }\n            // Load, check, and update the token approval.\n            {\n                mstore(0x00, from)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // Revert if the caller is not the owner, nor approved.\n                if iszero(or(eq(caller(), from), eq(caller(), approvedAddress))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Update with the new owner.\n            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))\n            // Decrement the balance of `from`.\n            {\n                let fromBalanceSlot := keccak256(0x0c, 0x1c)\n                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))\n            }\n            // Increment the balance of `to`.\n            {\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x1c)\n                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\n        }\n        _afterTokenTransfer(from, to, id);\n    }",
            "startLine": 252
          },
          {
            "name": "safeTransferFrom",
            "signature": "safeTransferFrom(address,address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "transferFrom",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_hasCode",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\n        transferFrom(from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \"\");\n    }",
            "startLine": 313
          },
          {
            "name": "safeTransferFrom",
            "signature": "safeTransferFrom(address,address,uint256,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "transferFrom",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_hasCode",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\n        public\n        payable\n        virtual\n    {\n        transferFrom(from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }",
            "startLine": 330
          },
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\n        }\n    }",
            "startLine": 342
          }
        ],
        "internalFunctions": [
          {
            "name": "_exists",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _exists(uint256 id) internal view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := iszero(iszero(shl(96, sload(add(id, add(id, keccak256(0x00, 0x20)))))))\n        }\n    }",
            "startLine": 356
          },
          {
            "name": "_ownerOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _ownerOf(uint256 id) internal view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := shr(96, shl(96, sload(add(id, add(id, keccak256(0x00, 0x20))))))\n        }\n    }",
            "startLine": 367
          },
          {
            "name": "_getAux",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint224"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _getAux(address owner) internal view virtual returns (uint224 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            result := shr(32, sload(keccak256(0x0c, 0x1c)))\n        }\n    }",
            "startLine": 386
          },
          {
            "name": "_setAux",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint224"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _setAux(address owner, uint224 value) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            let balanceSlot := keccak256(0x0c, 0x1c)\n            let packed := sload(balanceSlot)\n            sstore(balanceSlot, xor(packed, shl(32, xor(value, shr(32, packed)))))\n        }\n    }",
            "startLine": 398
          },
          {
            "name": "_getExtraData",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint96"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _getExtraData(uint256 id) internal view virtual returns (uint96 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := shr(160, sload(add(id, add(id, keccak256(0x00, 0x20)))))\n        }\n    }",
            "startLine": 412
          },
          {
            "name": "_setExtraData",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint96"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _setExtraData(uint256 id, uint96 value) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let packed := sload(ownershipSlot)\n            sstore(ownershipSlot, xor(packed, shl(160, xor(value, shr(160, packed)))))\n        }\n    }",
            "startLine": 424
          },
          {
            "name": "_mint",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _mint(address to, uint256 id) internal virtual {\n        _beforeTokenTransfer(address(0), to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            to := shr(96, shl(96, to))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            // Revert if the token already exists.\n            if shl(96, ownershipPacked) {\n                mstore(0x00, 0xc991cbb1) // `TokenAlreadyExists()`.\n                revert(0x1c, 0x04)\n            }\n            // Update with the owner.\n            sstore(ownershipSlot, or(ownershipPacked, to))\n            // Increment the balance of the owner.\n            {\n                mstore(0x00, to)\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                let balanceSlotPacked := add(sload(balanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(balanceSlot, balanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)\n        }\n        _afterTokenTransfer(address(0), to, id);\n    }",
            "startLine": 447
          },
          {
            "name": "_mintAndSetExtraDataUnchecked",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint96"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _mintAndSetExtraDataUnchecked(address to, uint256 id, uint96 value) internal virtual {\n        _beforeTokenTransfer(address(0), to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            to := shr(96, shl(96, to))\n            // Update with the owner and extra data.\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            sstore(add(id, add(id, keccak256(0x00, 0x20))), or(shl(160, value), to))\n            // Increment the balance of the owner.\n            {\n                mstore(0x00, to)\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                let balanceSlotPacked := add(sload(balanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(balanceSlot, balanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)\n        }\n        _afterTokenTransfer(address(0), to, id);\n    }",
            "startLine": 492
          },
          {
            "name": "_safeMint",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeMint",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeMint(address to, uint256 id) internal virtual {\n        _safeMint(to, id, \"\");\n    }",
            "startLine": 522
          },
          {
            "name": "_safeMint",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_mint",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_hasCode",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\n        _mint(to, id);\n        if (_hasCode(to)) _checkOnERC721Received(address(0), to, id, data);\n    }",
            "startLine": 536
          },
          {
            "name": "_burn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_burn",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _burn(uint256 id) internal virtual {\n        _burn(address(0), id);\n    }",
            "startLine": 546
          },
          {
            "name": "_burn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "ownerOf",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _burn(address by, uint256 id) internal virtual {\n        address owner = ownerOf(id);\n        _beforeTokenTransfer(owner, address(0), id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            by := shr(96, shl(96, by))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            // Reload the owner in case it is changed in `_beforeTokenTransfer`.\n            owner := shr(96, shl(96, ownershipPacked))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // Load and check the token approval.\n            {\n                mstore(0x00, owner)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // If `by` is not the zero address, do the authorization check.\n                // Revert if the `by` is not the owner, nor approved.\n                if iszero(or(iszero(by), or(eq(by, owner), eq(by, approvedAddress)))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Clear the owner.\n            sstore(ownershipSlot, xor(ownershipPacked, owner))\n            // Decrement the balance of `owner`.\n            {\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                sstore(balanceSlot, sub(sload(balanceSlot), 1))\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, owner, 0, id)\n        }\n        _afterTokenTransfer(owner, address(0), id);\n    }",
            "startLine": 559
          },
          {
            "name": "_isApprovedOrOwner",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _isApprovedOrOwner(address account, uint256 id)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            // Clear the upper 96 bits.\n            account := shr(96, shl(96, account))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, account))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let owner := shr(96, shl(96, sload(ownershipSlot)))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // Check if `account` is the `owner`.\n            if iszero(eq(account, owner)) {\n                mstore(0x00, owner)\n                // Check if `account` is approved to manage the token.\n                if iszero(sload(keccak256(0x0c, 0x30))) {\n                    result := eq(account, sload(add(1, ownershipSlot)))\n                }\n            }\n        }\n    }",
            "startLine": 614
          },
          {
            "name": "_getApproved",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _getApproved(uint256 id) internal view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := sload(add(1, add(id, add(id, keccak256(0x00, 0x20)))))\n        }\n    }",
            "startLine": 648
          },
          {
            "name": "_approve",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_approve",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _approve(address account, uint256 id) internal virtual {\n        _approve(address(0), account, id);\n    }",
            "startLine": 658
          },
          {
            "name": "_approve",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _approve(address by, address account, uint256 id) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            account := and(bitmaskAddress, account)\n            by := and(bitmaskAddress, by)\n            // Load the owner of the token.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let owner := and(bitmaskAddress, sload(ownershipSlot))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // If `by` is not the zero address, do the authorization check.\n            // Revert if `by` is not the owner, nor approved.\n            if iszero(or(iszero(by), eq(by, owner))) {\n                mstore(0x00, owner)\n                if iszero(sload(keccak256(0x0c, 0x30))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Sets `account` as the approved account to manage `id`.\n            sstore(add(1, ownershipSlot), account)\n            // Emit the {Approval} event.\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, owner, account, id)\n        }\n    }",
            "startLine": 670
          },
          {
            "name": "_setApprovalForAll",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "isApproved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            by := shr(96, shl(96, by))\n            operator := shr(96, shl(96, operator))\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`by`, `operator`).\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))\n            mstore(0x00, by)\n            sstore(keccak256(0x0c, 0x30), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, by, operator)\n        }\n    }",
            "startLine": 707
          },
          {
            "name": "_transfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transfer",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _transfer(address from, address to, uint256 id) internal virtual {\n        _transfer(address(0), from, to, id);\n    }",
            "startLine": 730
          },
          {
            "name": "_transfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _transfer(address by, address from, address to, uint256 id) internal virtual {\n        _beforeTokenTransfer(from, to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            from := and(bitmaskAddress, from)\n            to := and(bitmaskAddress, to)\n            by := and(bitmaskAddress, by)\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            let owner := and(bitmaskAddress, ownershipPacked)\n            // Revert if the token does not exist, or if `from` is not the owner.\n            if iszero(mul(owner, eq(owner, from))) {\n                // `TokenDoesNotExist()`, `TransferFromIncorrectOwner()`.\n                mstore(shl(2, iszero(owner)), 0xceea21b6a1148100)\n                revert(0x1c, 0x04)\n            }\n            // Load, check, and update the token approval.\n            {\n                mstore(0x00, from)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // If `by` is not the zero address, do the authorization check.\n                // Revert if the `by` is not the owner, nor approved.\n                if iszero(or(iszero(by), or(eq(by, from), eq(by, approvedAddress)))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Update with the new owner.\n            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))\n            // Decrement the balance of `from`.\n            {\n                let fromBalanceSlot := keccak256(0x0c, 0x1c)\n                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))\n            }\n            // Increment the balance of `to`.\n            {\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x1c)\n                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\n        }\n        _afterTokenTransfer(from, to, id);\n    }",
            "startLine": 745
          },
          {
            "name": "_safeTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeTransfer",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address from, address to, uint256 id) internal virtual {\n        _safeTransfer(from, to, id, \"\");\n    }",
            "startLine": 808
          },
          {
            "name": "_safeTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transfer",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_hasCode",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address from, address to, uint256 id, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(address(0), from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }",
            "startLine": 824
          },
          {
            "name": "_safeTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeTransfer",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address by, address from, address to, uint256 id) internal virtual {\n        _safeTransfer(by, from, to, id, \"\");\n    }",
            "startLine": 833
          },
          {
            "name": "_safeTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transfer",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_hasCode",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address by, address from, address to, uint256 id, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(by, from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }",
            "startLine": 850
          },
          {
            "name": "_beforeTokenTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _beforeTokenTransfer(address from, address to, uint256 id) internal virtual {}",
            "startLine": 863
          },
          {
            "name": "_afterTokenTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _afterTokenTransfer(address from, address to, uint256 id) internal virtual {}",
            "startLine": 866
          },
          {
            "name": "_hasCode",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "a",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _hasCode(address a) private view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := extcodesize(a) // Can handle dirty upper bits.\n        }\n    }",
            "startLine": 873
          },
          {
            "name": "_checkOnERC721Received",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\n        private\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the calldata.\n            let m := mload(0x40)\n            let onERC721ReceivedSelector := 0x150b7a02\n            mstore(m, onERC721ReceivedSelector)\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            mstore(add(m, 0x60), id)\n            mstore(add(m, 0x80), 0x80)\n            let n := mload(data)\n            mstore(add(m, 0xa0), n)\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n            // Load the returndata and compare it.\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 882
          }
        ],
        "events": [
          {
            "name": "Transfer",
            "parameters": [
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              }
            ],
            "startLine": 67
          },
          {
            "name": "Approval",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "account",
                "type": "address",
                "indexed": true
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              }
            ],
            "startLine": 70
          },
          {
            "name": "ApprovalForAll",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "operator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "isApproved",
                "type": "bool",
                "indexed": false
              }
            ],
            "startLine": 73
          }
        ],
        "errors": [
          {
            "name": "NotOwnerNorApproved",
            "parameters": [],
            "startLine": 38
          },
          {
            "name": "TokenDoesNotExist",
            "parameters": [],
            "startLine": 41
          },
          {
            "name": "TokenAlreadyExists",
            "parameters": [],
            "startLine": 44
          },
          {
            "name": "BalanceQueryForZeroAddress",
            "parameters": [],
            "startLine": 47
          },
          {
            "name": "TransferToZeroAddress",
            "parameters": [],
            "startLine": 50
          },
          {
            "name": "TransferFromIncorrectOwner",
            "parameters": [],
            "startLine": 53
          },
          {
            "name": "AccountBalanceOverflow",
            "parameters": [],
            "startLine": 56
          },
          {
            "name": "TransferToNonERC721ReceiverImplementer",
            "parameters": [],
            "startLine": 60
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_MAX_ACCOUNT_BALANCE",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 31
          },
          {
            "name": "_TRANSFER_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 76
          },
          {
            "name": "_APPROVAL_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 80
          },
          {
            "name": "_APPROVAL_FOR_ALL_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 84
          },
          {
            "name": "_ERC721_MASTER_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 121
          },
          {
            "name": "_ERC721_MASTER_SLOT_SEED_MASKED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 124
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "WETH",
        "filePath": "tokens/WETH.sol",
        "kind": "contract",
        "inherits": [
          "ERC20"
        ],
        "implements": [],
        "category": "token",
        "externalFunctions": [
          {
            "name": "name",
            "signature": "name()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function name() public view virtual override returns (string memory) {\n        return \"Wrapped Ether\";\n    }",
            "startLine": 23
          },
          {
            "name": "symbol",
            "signature": "symbol()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function symbol() public view virtual override returns (string memory) {\n        return \"WETH\";\n    }",
            "startLine": 28
          },
          {
            "name": "deposit",
            "signature": "deposit()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_mint",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function deposit() public payable virtual {\n        _mint(msg.sender, msg.value);\n    }",
            "startLine": 37
          },
          {
            "name": "withdraw",
            "signature": "withdraw(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_burn",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function withdraw(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gas(), caller(), amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 42
          },
          {
            "name": "receive",
            "signature": "receive()",
            "selector": "",
            "visibility": "external",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "deposit",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "receive() external payable virtual {\n        deposit();\n    }",
            "startLine": 55
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": [
          {
            "name": "ETHTransferFailed",
            "parameters": [],
            "startLine": 16
          }
        ],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./ERC20.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "ERC1155",
        "filePath": "tokens/ext/zksync/ERC1155.sol",
        "kind": "abstract",
        "inherits": [],
        "implements": [],
        "category": "token",
        "externalFunctions": [
          {
            "name": "uri",
            "signature": "uri(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function uri(uint256 id) public view virtual returns (string memory);",
            "startLine": 124
          },
          {
            "name": "balanceOf",
            "signature": "balanceOf(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address owner, uint256 id) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, id)\n            result := sload(keccak256(0x00, 0x40))\n        }\n    }",
            "startLine": 131
          },
          {
            "name": "isApprovedForAll",
            "signature": "isApprovedForAll(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, owner)\n            mstore(0x00, operator)\n            result := sload(keccak256(0x0c, 0x34))\n        }\n    }",
            "startLine": 142
          },
          {
            "name": "setApprovalForAll",
            "signature": "setApprovalForAll(address,bool)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "isApproved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setApprovalForAll(address operator, bool isApproved) public virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`msg.sender`, `operator`).\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, caller())\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            // forgefmt: disable-next-line\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator)))\n        }\n    }",
            "startLine": 160
          },
          {
            "name": "safeTransferFrom",
            "signature": "safeTransferFrom(address,address,uint256,uint256,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 5
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\n            mstore(0x20, fromSlotSeed)\n            // Clear the upper 96 bits.\n            from := shr(96, fromSlotSeed)\n            to := shr(96, toSlotSeed)\n            // Revert if `to` is the zero address.\n            if iszero(to) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // If the caller is not `from`, do the authorization check.\n            if iszero(eq(caller(), from)) {\n                mstore(0x00, caller())\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Subtract and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, toSlotSeed)\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), from, to)\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Do the {onERC1155Received} check if `to` is a smart contract.\n            if extcodesize(to) {\n                // Prepare the calldata.\n                let m := mload(0x40)\n                // `onERC1155Received(address,address,uint256,uint256,bytes)`.\n                mstore(m, 0xf23a6e61)\n                mstore(add(m, 0x20), caller())\n                mstore(add(m, 0x40), from)\n                mstore(add(m, 0x60), id)\n                mstore(add(m, 0x80), amount)\n                mstore(add(m, 0xa0), 0xa0)\n                mstore(add(m, 0xc0), data.length)\n                calldatacopy(add(m, 0xe0), data.offset, data.length)\n                // Revert if the call reverts.\n                if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, data.length), m, 0x20)) {\n                    if returndatasize() {\n                        // Bubble up the revert if the call reverts.\n                        returndatacopy(m, 0x00, returndatasize())\n                        revert(m, returndatasize())\n                    }\n                }\n                // Load the returndata and compare it with the function selector.\n                if iszero(eq(mload(m), shl(224, 0xf23a6e61))) {\n                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 188
          },
          {
            "name": "safeBatchTransferFrom",
            "signature": "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransferCalldata",
                "type": "internal",
                "argCount": 5
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(ids.length, amounts.length)) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))\n            mstore(0x20, fromSlotSeed)\n            // Clear the upper 96 bits.\n            from := shr(96, fromSlotSeed)\n            to := shr(96, toSlotSeed)\n            // Revert if `to` is the zero address.\n            if iszero(to) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // If the caller is not `from`, do the authorization check.\n            if iszero(eq(caller(), from)) {\n                mstore(0x00, caller())\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                for { let i := shl(5, ids.length) } i {} {\n                    i := sub(i, 0x20)\n                    let amount := calldataload(add(amounts.offset, i))\n                    // Subtract and store the updated balance of `from`.\n                    {\n                        mstore(0x20, fromSlotSeed)\n                        mstore(0x00, calldataload(add(ids.offset, i)))\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\n                        let fromBalance := sload(fromBalanceSlot)\n                        if gt(amount, fromBalance) {\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\n                    }\n                    // Increase and store the updated balance of `to`.\n                    {\n                        mstore(0x20, toSlotSeed)\n                        let toBalanceSlot := keccak256(0x00, 0x40)\n                        let toBalanceBefore := sload(toBalanceSlot)\n                        let toBalanceAfter := add(toBalanceBefore, amount)\n                        if lt(toBalanceAfter, toBalanceBefore) {\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(toBalanceSlot, toBalanceAfter)\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := shl(5, ids.length)\n                mstore(add(m, 0x40), ids.length)\n                calldatacopy(add(m, 0x60), ids.offset, n)\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x60, n))\n                let o := add(add(m, n), 0x60)\n                mstore(o, ids.length)\n                calldatacopy(add(o, 0x20), amounts.offset, n)\n                // Do the emit.\n                log4(m, add(add(n, n), 0x80), _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), from, to)\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransferCalldata(from, to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Do the {onERC1155BatchReceived} check if `to` is a smart contract.\n            if extcodesize(to) {\n                mstore(0x00, to) // Cache `to` to prevent stack too deep.\n                let m := mload(0x40)\n                // Prepare the calldata.\n                // `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n                mstore(m, 0xbc197c81)\n                mstore(add(m, 0x20), caller())\n                mstore(add(m, 0x40), from)\n                // Copy the `ids`.\n                mstore(add(m, 0x60), 0xa0)\n                let n := shl(5, ids.length)\n                mstore(add(m, 0xc0), ids.length)\n                calldatacopy(add(m, 0xe0), ids.offset, n)\n                // Copy the `amounts`.\n                mstore(add(m, 0x80), add(0xc0, n))\n                let o := add(add(m, n), 0xe0)\n                mstore(o, ids.length)\n                calldatacopy(add(o, 0x20), amounts.offset, n)\n                // Copy the `data`.\n                mstore(add(m, 0xa0), add(add(0xe0, n), n))\n                o := add(add(o, n), 0x20)\n                mstore(o, data.length)\n                calldatacopy(add(o, 0x20), data.offset, data.length)\n                let nAll := add(0x104, add(data.length, add(n, n)))\n                // Revert if the call reverts.\n                if iszero(call(gas(), mload(0x00), 0, add(mload(0x40), 0x1c), nAll, m, 0x20)) {\n                    if returndatasize() {\n                        // Bubble up the revert if the call reverts.\n                        returndatacopy(m, 0x00, returndatasize())\n                        revert(m, returndatasize())\n                    }\n                }\n                // Load the returndata and compare it with the function selector.\n                if iszero(eq(mload(m), shl(224, 0xbc197c81))) {\n                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 293
          },
          {
            "name": "balanceOfBatch",
            "signature": "balanceOfBatch(address[],uint256[])",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owners",
                "type": "address[]"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "balances",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(ids.length, owners.length)) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            balances := mload(0x40)\n            mstore(balances, ids.length)\n            let o := add(balances, 0x20)\n            let i := shl(5, ids.length)\n            mstore(0x40, add(i, o))\n            // Loop through all the `ids` and load the balances.\n            for {} i {} {\n                i := sub(i, 0x20)\n                let owner := calldataload(add(owners.offset, i))\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner)))\n                mstore(0x00, calldataload(add(ids.offset, i)))\n                mstore(add(o, i), sload(keccak256(0x00, 0x40)))\n            }\n        }\n    }",
            "startLine": 427
          },
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC1155: 0xd9b67a26, ERC1155MetadataURI: 0x0e89341c.\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0xd9b67a26)), eq(s, 0x0e89341c))\n        }\n    }",
            "startLine": 458
          }
        ],
        "internalFunctions": [
          {
            "name": "_mint",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_hasCode",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(address(0), to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n                mstore(0x14, to)\n                mstore(0x00, id)\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), 0, shr(96, to_))\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(address(0), to, _single(id), _single(amount), data);\n        }\n        if (_hasCode(to)) _checkOnERC1155Received(address(0), to, id, amount, data);\n    }",
            "startLine": 479
          },
          {
            "name": "_batchMint",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_hasCode",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(address(0), to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            function copy(dst_, src_, n_) {\n                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {\n                    mstore(add(dst_, i_), mload(add(src_, i_)))\n                }\n            }\n            if iszero(eq(mload(ids), mload(amounts))) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, to_))\n                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {\n                    let amount := mload(add(amounts, i))\n                    // Increase and store the updated balance of `to`.\n                    {\n                        mstore(0x00, mload(add(ids, i)))\n                        let toBalanceSlot := keccak256(0x00, 0x40)\n                        let toBalanceBefore := sload(toBalanceSlot)\n                        let toBalanceAfter := add(toBalanceBefore, amount)\n                        if lt(toBalanceAfter, toBalanceBefore) {\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(toBalanceSlot, toBalanceAfter)\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, mload(ids)))\n                let o := add(m, 0x40)\n                copy(o, ids, n)\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, n))\n                o := add(o, n)\n                n := add(0x20, shl(5, mload(amounts)))\n                copy(o, amounts, n)\n                n := sub(add(o, n), m)\n                // Do the emit.\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), 0, shr(96, to_))\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(address(0), to, ids, amounts, data);\n        }\n        if (_hasCode(to)) _checkOnERC1155BatchReceived(address(0), to, ids, amounts, data);\n    }",
            "startLine": 524
          },
          {
            "name": "_burn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_burn",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        _burn(address(0), from, id, amount);\n    }",
            "startLine": 598
          },
          {
            "name": "_burn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _burn(address by, address from, uint256 id, uint256 amount) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, address(0), _single(id), _single(amount), \"\");\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            if iszero(or(iszero(shl(96, by)), eq(shl(96, by), from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Decrease and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), shr(96, from_), 0)\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, address(0), _single(id), _single(amount), \"\");\n        }\n    }",
            "startLine": 610
          },
          {
            "name": "_batchBurn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_batchBurn",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _batchBurn(address from, uint256[] memory ids, uint256[] memory amounts)\n        internal\n        virtual\n    {\n        _batchBurn(address(0), from, ids, amounts);\n    }",
            "startLine": 648
          },
          {
            "name": "_batchBurn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _batchBurn(address by, address from, uint256[] memory ids, uint256[] memory amounts)\n        internal\n        virtual\n    {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, address(0), ids, amounts, \"\");\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            function copy(dst_, src_, n_) {\n                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {\n                    mstore(add(dst_, i_), mload(add(src_, i_)))\n                }\n            }\n            if iszero(eq(mload(ids), mload(amounts))) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let from_ := shl(96, from)\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            let by_ := shl(96, by)\n            if iszero(or(iszero(by_), eq(by_, from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {\n                    let amount := mload(add(amounts, i))\n                    // Decrease and store the updated balance of `from`.\n                    {\n                        mstore(0x00, mload(add(ids, i)))\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\n                        let fromBalance := sload(fromBalanceSlot)\n                        if gt(amount, fromBalance) {\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, mload(ids)))\n                let o := add(m, 0x40)\n                copy(o, ids, n)\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, n))\n                o := add(o, n)\n                n := add(0x20, shl(5, mload(amounts)))\n                copy(o, amounts, n)\n                n := sub(add(o, n), m)\n                // Do the emit.\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), shr(96, from_), 0)\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, address(0), ids, amounts, \"\");\n        }\n    }",
            "startLine": 664
          },
          {
            "name": "_setApprovalForAll",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "isApproved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`by`, `operator`).\n            mstore(0x20, _ERC1155_MASTER_SLOT_SEED)\n            mstore(0x14, by)\n            mstore(0x00, operator)\n            sstore(keccak256(0x0c, 0x34), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            let m := shr(96, not(0))\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, and(m, by), and(m, operator))\n        }\n    }",
            "startLine": 742
          },
          {
            "name": "_safeTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeTransfer",
                "type": "internal",
                "argCount": 6
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address from, address to, uint256 id, uint256 amount, bytes memory data)\n        internal\n        virtual\n    {\n        _safeTransfer(address(0), from, to, id, amount, data);\n    }",
            "startLine": 764
          },
          {
            "name": "_safeTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_hasCode",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(\n        address by,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let from_ := shl(96, from)\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, from_))\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            let by_ := shl(96, by)\n            if iszero(or(iszero(by_), eq(by_, from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Subtract and store the updated balance of `from`.\n            {\n                mstore(0x00, id)\n                let fromBalanceSlot := keccak256(0x00, 0x40)\n                let fromBalance := sload(fromBalanceSlot)\n                if gt(amount, fromBalance) {\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\n            }\n            // Increase and store the updated balance of `to`.\n            {\n                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, to_))\n                let toBalanceSlot := keccak256(0x00, 0x40)\n                let toBalanceBefore := sload(toBalanceSlot)\n                let toBalanceAfter := add(toBalanceBefore, amount)\n                if lt(toBalanceAfter, toBalanceBefore) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceAfter)\n            }\n            // Emit a {TransferSingle} event.\n            mstore(0x20, amount)\n            // forgefmt: disable-next-line\n            log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), shr(96, from_), shr(96, to_))\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, _single(id), _single(amount), data);\n        }\n        if (_hasCode(to)) _checkOnERC1155Received(from, to, id, amount, data);\n    }",
            "startLine": 782
          },
          {
            "name": "_safeBatchTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeBatchTransfer",
                "type": "internal",
                "argCount": 6
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeBatchTransfer(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _safeBatchTransfer(address(0), from, to, ids, amounts, data);\n    }",
            "startLine": 848
          },
          {
            "name": "_safeBatchTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useBeforeTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_hasCode",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeBatchTransfer(\n        address by,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (_useBeforeTokenTransfer()) {\n            _beforeTokenTransfer(from, to, ids, amounts, data);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            function copy(dst_, src_, n_) {\n                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {\n                    mstore(add(dst_, i_), mload(add(src_, i_)))\n                }\n            }\n            if iszero(eq(mload(ids), mload(amounts))) {\n                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.\n                revert(0x1c, 0x04)\n            }\n            let from_ := shl(96, from)\n            let to_ := shl(96, to)\n            // Revert if `to` is the zero address.\n            if iszero(to_) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, from_)\n            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, to_)\n            mstore(0x20, fromSlotSeed)\n            // If `by` is not the zero address, and not equal to `from`,\n            // check if it is approved to manage all the tokens of `from`.\n            let by_ := shl(96, by)\n            if iszero(or(iszero(by_), eq(by_, from_))) {\n                mstore(0x00, by)\n                if iszero(sload(keccak256(0x0c, 0x34))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Loop through all the `ids` and update the balances.\n            {\n                for { let i := shl(5, mload(ids)) } i { i := sub(i, 0x20) } {\n                    let amount := mload(add(amounts, i))\n                    // Subtract and store the updated balance of `from`.\n                    {\n                        mstore(0x20, fromSlotSeed)\n                        mstore(0x00, mload(add(ids, i)))\n                        let fromBalanceSlot := keccak256(0x00, 0x40)\n                        let fromBalance := sload(fromBalanceSlot)\n                        if gt(amount, fromBalance) {\n                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(fromBalanceSlot, sub(fromBalance, amount))\n                    }\n                    // Increase and store the updated balance of `to`.\n                    {\n                        mstore(0x20, toSlotSeed)\n                        let toBalanceSlot := keccak256(0x00, 0x40)\n                        let toBalanceBefore := sload(toBalanceSlot)\n                        let toBalanceAfter := add(toBalanceBefore, amount)\n                        if lt(toBalanceAfter, toBalanceBefore) {\n                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                            revert(0x1c, 0x04)\n                        }\n                        sstore(toBalanceSlot, toBalanceAfter)\n                    }\n                }\n            }\n            // Emit a {TransferBatch} event.\n            {\n                let m := mload(0x40)\n                // Copy the `ids`.\n                mstore(m, 0x40)\n                let n := add(0x20, shl(5, mload(ids)))\n                let o := add(m, 0x40)\n                copy(o, ids, n)\n                // Copy the `amounts`.\n                mstore(add(m, 0x20), add(0x40, n))\n                o := add(o, n)\n                n := add(0x20, shl(5, mload(amounts)))\n                copy(o, amounts, n)\n                n := sub(add(o, n), m)\n                // Do the emit.\n                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), shr(96, from_), shr(96, to_))\n            }\n        }\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, ids, amounts, data);\n        }\n        if (_hasCode(to)) _checkOnERC1155BatchReceived(from, to, ids, amounts, data);\n    }",
            "startLine": 870
          },
          {
            "name": "_useBeforeTokenTransfer",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _useBeforeTokenTransfer() internal view virtual returns (bool) {\n        return false;\n    }",
            "startLine": 972
          },
          {
            "name": "_beforeTokenTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}",
            "startLine": 981
          },
          {
            "name": "_useAfterTokenTransfer",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _useAfterTokenTransfer() internal view virtual returns (bool) {\n        return false;\n    }",
            "startLine": 991
          },
          {
            "name": "_afterTokenTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}",
            "startLine": 1000
          },
          {
            "name": "_afterTokenTransferCalldata",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useAfterTokenTransfer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _afterTokenTransferCalldata(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) private {\n        if (_useAfterTokenTransfer()) {\n            _afterTokenTransfer(from, to, ids, amounts, data);\n        }\n    }",
            "startLine": 1014
          },
          {
            "name": "_hasCode",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "a",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _hasCode(address a) private view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := extcodesize(a) // Can handle dirty upper bits.\n        }\n    }",
            "startLine": 1027
          },
          {
            "name": "_checkOnERC1155Received",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _checkOnERC1155Received(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function copy(dst_, src_, n_) {\n                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {\n                    mstore(add(dst_, i_), mload(add(src_, i_)))\n                }\n            }\n            // Prepare the calldata.\n            let m := mload(0x40)\n            // `onERC1155Received(address,address,uint256,uint256,bytes)`.\n            mstore(m, 0xf23a6e61)\n            mstore(add(m, 0x20), caller())\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            mstore(add(m, 0x60), id)\n            mstore(add(m, 0x80), amount)\n            mstore(add(m, 0xa0), 0xa0)\n            let n := mload(data)\n            mstore(add(m, 0xc0), n)\n            copy(add(m, 0xe0), add(data, 0x20), n)\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, n), m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n            // Load the returndata and compare it with the function selector.\n            if iszero(eq(mload(m), shl(224, 0xf23a6e61))) {\n                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 1036
          },
          {
            "name": "_checkOnERC1155BatchReceived",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "amounts",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _checkOnERC1155BatchReceived(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function copy(dst_, src_, n_) {\n                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {\n                    mstore(add(dst_, i_), mload(add(src_, i_)))\n                }\n            }\n            // Prepare the calldata.\n            let m := mload(0x40)\n            // `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n            mstore(m, 0xbc197c81)\n            mstore(add(m, 0x20), caller())\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            // Copy the `ids`.\n            mstore(add(m, 0x60), 0xa0)\n            let n := add(0x20, shl(5, mload(ids)))\n            let o := add(m, 0xc0)\n            copy(o, ids, n)\n            // Copy the `amounts`.\n            let s := add(0xa0, n)\n            mstore(add(m, 0x80), s)\n            o := add(o, n)\n            n := add(0x20, shl(5, mload(amounts)))\n            copy(o, amounts, n)\n            // Copy the `data`.\n            mstore(add(m, 0xa0), add(s, n))\n            o := add(o, n)\n            n := add(0x20, mload(data))\n            copy(o, data, n)\n            n := sub(add(o, n), add(m, 0x1c))\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), n, m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n            // Load the returndata and compare it with the function selector.\n            if iszero(eq(mload(m), shl(224, 0xbc197c81))) {\n                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 1080
          },
          {
            "name": "_single",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _single(uint256 x) private pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(0x40, add(result, 0x40))\n            mstore(result, 1)\n            mstore(add(result, 0x20), x)\n        }\n    }",
            "startLine": 1134
          }
        ],
        "events": [
          {
            "name": "TransferSingle",
            "parameters": [
              {
                "name": "operator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 49
          },
          {
            "name": "TransferBatch",
            "parameters": [
              {
                "name": "operator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "ids",
                "type": "uint256[]",
                "indexed": false
              },
              {
                "name": "amounts",
                "type": "uint256[]",
                "indexed": false
              }
            ],
            "startLine": 59
          },
          {
            "name": "ApprovalForAll",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "operator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "isApproved",
                "type": "bool",
                "indexed": false
              }
            ],
            "startLine": 68
          },
          {
            "name": "URI",
            "parameters": [
              {
                "name": "value",
                "type": "string",
                "indexed": false
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              }
            ],
            "startLine": 75
          }
        ],
        "errors": [
          {
            "name": "ArrayLengthsMismatch",
            "parameters": [],
            "startLine": 25
          },
          {
            "name": "TransferToZeroAddress",
            "parameters": [],
            "startLine": 28
          },
          {
            "name": "AccountBalanceOverflow",
            "parameters": [],
            "startLine": 31
          },
          {
            "name": "InsufficientBalance",
            "parameters": [],
            "startLine": 34
          },
          {
            "name": "NotOwnerNorApproved",
            "parameters": [],
            "startLine": 37
          },
          {
            "name": "TransferToNonERC1155ReceiverImplementer",
            "parameters": [],
            "startLine": 41
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_TRANSFER_SINGLE_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 78
          },
          {
            "name": "_TRANSFER_BATCH_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 82
          },
          {
            "name": "_APPROVAL_FOR_ALL_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 86
          },
          {
            "name": "_ERC1155_MASTER_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 111
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "ERC721",
        "filePath": "tokens/ext/zksync/ERC721.sol",
        "kind": "abstract",
        "inherits": [],
        "implements": [],
        "category": "token",
        "externalFunctions": [
          {
            "name": "name",
            "signature": "name()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function name() public view virtual returns (string memory);",
            "startLine": 129
          },
          {
            "name": "symbol",
            "signature": "symbol()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function symbol() public view virtual returns (string memory);",
            "startLine": 132
          },
          {
            "name": "tokenURI",
            "signature": "tokenURI(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function tokenURI(uint256 id) public view virtual returns (string memory);",
            "startLine": 135
          },
          {
            "name": "ownerOf",
            "signature": "ownerOf(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_ownerOf",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function ownerOf(uint256 id) public view virtual returns (address result) {\n        result = _ownerOf(id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(result) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 145
          },
          {
            "name": "balanceOf",
            "signature": "balanceOf(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the `owner` is the zero address.\n            if iszero(owner) {\n                mstore(0x00, 0x8f4eb604) // `BalanceQueryForZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            result := and(sload(keccak256(0x0c, 0x1c)), _MAX_ACCOUNT_BALANCE)\n        }\n    }",
            "startLine": 160
          },
          {
            "name": "getApproved",
            "signature": "getApproved(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getApproved(uint256 id) public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            if iszero(shl(96, sload(ownershipSlot))) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            result := sload(add(1, ownershipSlot))\n        }\n    }",
            "startLine": 178
          },
          {
            "name": "approve",
            "signature": "approve(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_approve",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function approve(address account, uint256 id) public payable virtual {\n        _approve(msg.sender, account, id);\n    }",
            "startLine": 200
          },
          {
            "name": "isApprovedForAll",
            "signature": "isApprovedForAll(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, operator)\n            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x30))\n        }\n    }",
            "startLine": 205
          },
          {
            "name": "setApprovalForAll",
            "signature": "setApprovalForAll(address,bool)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "isApproved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setApprovalForAll(address operator, bool isApproved) public virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`msg.sender`, `operator`).\n            mstore(0x1c, operator)\n            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x30), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            // forgefmt: disable-next-item\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator)))\n        }\n    }",
            "startLine": 223
          },
          {
            "name": "transferFrom",
            "signature": "transferFrom(address,address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function transferFrom(address from, address to, uint256 id) public payable virtual {\n        _beforeTokenTransfer(from, to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            from := and(bitmaskAddress, from)\n            to := and(bitmaskAddress, to)\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, caller()))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            let owner := and(bitmaskAddress, ownershipPacked)\n            // Revert if the token does not exist, or if `from` is not the owner.\n            if iszero(mul(owner, eq(owner, from))) {\n                // `TokenDoesNotExist()`, `TransferFromIncorrectOwner()`.\n                mstore(shl(2, iszero(owner)), 0xceea21b6a1148100)\n                revert(0x1c, 0x04)\n            }\n            // Load, check, and update the token approval.\n            {\n                mstore(0x00, from)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // Revert if the caller is not the owner, nor approved.\n                if iszero(or(eq(caller(), from), eq(caller(), approvedAddress))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Update with the new owner.\n            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))\n            // Decrement the balance of `from`.\n            {\n                let fromBalanceSlot := keccak256(0x0c, 0x1c)\n                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))\n            }\n            // Increment the balance of `to`.\n            {\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x1c)\n                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\n        }\n        _afterTokenTransfer(from, to, id);\n    }",
            "startLine": 250
          },
          {
            "name": "safeTransferFrom",
            "signature": "safeTransferFrom(address,address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "transferFrom",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_hasCode",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\n        transferFrom(from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \"\");\n    }",
            "startLine": 311
          },
          {
            "name": "safeTransferFrom",
            "signature": "safeTransferFrom(address,address,uint256,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "transferFrom",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_hasCode",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\n        public\n        payable\n        virtual\n    {\n        transferFrom(from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }",
            "startLine": 328
          },
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\n        }\n    }",
            "startLine": 340
          }
        ],
        "internalFunctions": [
          {
            "name": "_exists",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _exists(uint256 id) internal view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := iszero(iszero(shl(96, sload(add(id, add(id, keccak256(0x00, 0x20)))))))\n        }\n    }",
            "startLine": 354
          },
          {
            "name": "_ownerOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _ownerOf(uint256 id) internal view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := shr(96, shl(96, sload(add(id, add(id, keccak256(0x00, 0x20))))))\n        }\n    }",
            "startLine": 365
          },
          {
            "name": "_getAux",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint224"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _getAux(address owner) internal view virtual returns (uint224 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            result := shr(32, sload(keccak256(0x0c, 0x1c)))\n        }\n    }",
            "startLine": 384
          },
          {
            "name": "_setAux",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint224"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _setAux(address owner, uint224 value) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            let balanceSlot := keccak256(0x0c, 0x1c)\n            let packed := sload(balanceSlot)\n            sstore(balanceSlot, xor(packed, shl(32, xor(value, shr(32, packed)))))\n        }\n    }",
            "startLine": 396
          },
          {
            "name": "_getExtraData",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint96"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _getExtraData(uint256 id) internal view virtual returns (uint96 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := shr(160, sload(add(id, add(id, keccak256(0x00, 0x20)))))\n        }\n    }",
            "startLine": 410
          },
          {
            "name": "_setExtraData",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint96"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _setExtraData(uint256 id, uint96 value) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let packed := sload(ownershipSlot)\n            sstore(ownershipSlot, xor(packed, shl(160, xor(value, shr(160, packed)))))\n        }\n    }",
            "startLine": 422
          },
          {
            "name": "_mint",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _mint(address to, uint256 id) internal virtual {\n        _beforeTokenTransfer(address(0), to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            to := shr(96, shl(96, to))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            // Revert if the token already exists.\n            if shl(96, ownershipPacked) {\n                mstore(0x00, 0xc991cbb1) // `TokenAlreadyExists()`.\n                revert(0x1c, 0x04)\n            }\n            // Update with the owner.\n            sstore(ownershipSlot, or(ownershipPacked, to))\n            // Increment the balance of the owner.\n            {\n                mstore(0x00, to)\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                let balanceSlotPacked := add(sload(balanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(balanceSlot, balanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)\n        }\n        _afterTokenTransfer(address(0), to, id);\n    }",
            "startLine": 445
          },
          {
            "name": "_mintAndSetExtraDataUnchecked",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint96"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _mintAndSetExtraDataUnchecked(address to, uint256 id, uint96 value) internal virtual {\n        _beforeTokenTransfer(address(0), to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            to := shr(96, shl(96, to))\n            // Update with the owner and extra data.\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            sstore(add(id, add(id, keccak256(0x00, 0x20))), or(shl(160, value), to))\n            // Increment the balance of the owner.\n            {\n                mstore(0x00, to)\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                let balanceSlotPacked := add(sload(balanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(balanceSlot, balanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)\n        }\n        _afterTokenTransfer(address(0), to, id);\n    }",
            "startLine": 490
          },
          {
            "name": "_safeMint",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeMint",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeMint(address to, uint256 id) internal virtual {\n        _safeMint(to, id, \"\");\n    }",
            "startLine": 520
          },
          {
            "name": "_safeMint",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_mint",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_hasCode",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\n        _mint(to, id);\n        if (_hasCode(to)) _checkOnERC721Received(address(0), to, id, data);\n    }",
            "startLine": 534
          },
          {
            "name": "_burn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_burn",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _burn(uint256 id) internal virtual {\n        _burn(address(0), id);\n    }",
            "startLine": 544
          },
          {
            "name": "_burn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "ownerOf",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _burn(address by, uint256 id) internal virtual {\n        address owner = ownerOf(id);\n        _beforeTokenTransfer(owner, address(0), id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            by := shr(96, shl(96, by))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            // Reload the owner in case it is changed in `_beforeTokenTransfer`.\n            owner := shr(96, shl(96, ownershipPacked))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // Load and check the token approval.\n            {\n                mstore(0x00, owner)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // If `by` is not the zero address, do the authorization check.\n                // Revert if the `by` is not the owner, nor approved.\n                if iszero(or(iszero(by), or(eq(by, owner), eq(by, approvedAddress)))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Clear the owner.\n            sstore(ownershipSlot, xor(ownershipPacked, owner))\n            // Decrement the balance of `owner`.\n            {\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                sstore(balanceSlot, sub(sload(balanceSlot), 1))\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, owner, 0, id)\n        }\n        _afterTokenTransfer(owner, address(0), id);\n    }",
            "startLine": 557
          },
          {
            "name": "_isApprovedOrOwner",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _isApprovedOrOwner(address account, uint256 id)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            // Clear the upper 96 bits.\n            account := shr(96, shl(96, account))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, account))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let owner := shr(96, shl(96, sload(ownershipSlot)))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // Check if `account` is the `owner`.\n            if iszero(eq(account, owner)) {\n                mstore(0x00, owner)\n                // Check if `account` is approved to manage the token.\n                if iszero(sload(keccak256(0x0c, 0x30))) {\n                    result := eq(account, sload(add(1, ownershipSlot)))\n                }\n            }\n        }\n    }",
            "startLine": 612
          },
          {
            "name": "_getApproved",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _getApproved(uint256 id) internal view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := sload(add(1, add(id, add(id, keccak256(0x00, 0x20)))))\n        }\n    }",
            "startLine": 646
          },
          {
            "name": "_approve",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_approve",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _approve(address account, uint256 id) internal virtual {\n        _approve(address(0), account, id);\n    }",
            "startLine": 656
          },
          {
            "name": "_approve",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _approve(address by, address account, uint256 id) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            account := and(bitmaskAddress, account)\n            by := and(bitmaskAddress, by)\n            // Load the owner of the token.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let owner := and(bitmaskAddress, sload(ownershipSlot))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // If `by` is not the zero address, do the authorization check.\n            // Revert if `by` is not the owner, nor approved.\n            if iszero(or(iszero(by), eq(by, owner))) {\n                mstore(0x00, owner)\n                if iszero(sload(keccak256(0x0c, 0x30))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Sets `account` as the approved account to manage `id`.\n            sstore(add(1, ownershipSlot), account)\n            // Emit the {Approval} event.\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, owner, account, id)\n        }\n    }",
            "startLine": 668
          },
          {
            "name": "_setApprovalForAll",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "isApproved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            by := shr(96, shl(96, by))\n            operator := shr(96, shl(96, operator))\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`by`, `operator`).\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))\n            mstore(0x00, by)\n            sstore(keccak256(0x0c, 0x30), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, by, operator)\n        }\n    }",
            "startLine": 705
          },
          {
            "name": "_transfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transfer",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _transfer(address from, address to, uint256 id) internal virtual {\n        _transfer(address(0), from, to, id);\n    }",
            "startLine": 728
          },
          {
            "name": "_transfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beforeTokenTransfer",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_afterTokenTransfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _transfer(address by, address from, address to, uint256 id) internal virtual {\n        _beforeTokenTransfer(from, to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            from := and(bitmaskAddress, from)\n            to := and(bitmaskAddress, to)\n            by := and(bitmaskAddress, by)\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            let owner := and(bitmaskAddress, ownershipPacked)\n            // Revert if the token does not exist, or if `from` is not the owner.\n            if iszero(mul(owner, eq(owner, from))) {\n                // `TokenDoesNotExist()`, `TransferFromIncorrectOwner()`.\n                mstore(shl(2, iszero(owner)), 0xceea21b6a1148100)\n                revert(0x1c, 0x04)\n            }\n            // Load, check, and update the token approval.\n            {\n                mstore(0x00, from)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // If `by` is not the zero address, do the authorization check.\n                // Revert if the `by` is not the owner, nor approved.\n                if iszero(or(iszero(by), or(eq(by, from), eq(by, approvedAddress)))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Update with the new owner.\n            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))\n            // Decrement the balance of `from`.\n            {\n                let fromBalanceSlot := keccak256(0x0c, 0x1c)\n                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))\n            }\n            // Increment the balance of `to`.\n            {\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x1c)\n                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)\n                // Revert if `to` is the zero address, or if the account balance overflows.\n                if iszero(mul(to, and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE))) {\n                    // `TransferToZeroAddress()`, `AccountBalanceOverflow()`.\n                    mstore(shl(2, iszero(to)), 0xea553b3401336cea)\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\n        }\n        _afterTokenTransfer(from, to, id);\n    }",
            "startLine": 743
          },
          {
            "name": "_safeTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeTransfer",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address from, address to, uint256 id) internal virtual {\n        _safeTransfer(from, to, id, \"\");\n    }",
            "startLine": 806
          },
          {
            "name": "_safeTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transfer",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_hasCode",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address from, address to, uint256 id, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(address(0), from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }",
            "startLine": 822
          },
          {
            "name": "_safeTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeTransfer",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address by, address from, address to, uint256 id) internal virtual {\n        _safeTransfer(by, from, to, id, \"\");\n    }",
            "startLine": 831
          },
          {
            "name": "_safeTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "by",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transfer",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_hasCode",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address by, address from, address to, uint256 id, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(by, from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }",
            "startLine": 848
          },
          {
            "name": "_beforeTokenTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _beforeTokenTransfer(address from, address to, uint256 id) internal virtual {}",
            "startLine": 861
          },
          {
            "name": "_afterTokenTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _afterTokenTransfer(address from, address to, uint256 id) internal virtual {}",
            "startLine": 864
          },
          {
            "name": "_hasCode",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "a",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _hasCode(address a) private view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := extcodesize(a) // Can handle dirty upper bits.\n        }\n    }",
            "startLine": 871
          },
          {
            "name": "_checkOnERC721Received",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\n        private\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function copy(dst_, src_, n_) {\n                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {\n                    mstore(add(dst_, i_), mload(add(src_, i_)))\n                }\n            }\n            // Prepare the calldata.\n            let m := mload(0x40)\n            let onERC721ReceivedSelector := 0x150b7a02\n            mstore(m, onERC721ReceivedSelector)\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            mstore(add(m, 0x60), id)\n            mstore(add(m, 0x80), 0x80)\n            let n := mload(data)\n            mstore(add(m, 0xa0), n)\n            copy(add(m, 0xc0), add(data, 0x20), n)\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n            // Load the returndata and compare it.\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 880
          }
        ],
        "events": [
          {
            "name": "Transfer",
            "parameters": [
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              }
            ],
            "startLine": 65
          },
          {
            "name": "Approval",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "account",
                "type": "address",
                "indexed": true
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              }
            ],
            "startLine": 68
          },
          {
            "name": "ApprovalForAll",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "operator",
                "type": "address",
                "indexed": true
              },
              {
                "name": "isApproved",
                "type": "bool",
                "indexed": false
              }
            ],
            "startLine": 71
          }
        ],
        "errors": [
          {
            "name": "NotOwnerNorApproved",
            "parameters": [],
            "startLine": 36
          },
          {
            "name": "TokenDoesNotExist",
            "parameters": [],
            "startLine": 39
          },
          {
            "name": "TokenAlreadyExists",
            "parameters": [],
            "startLine": 42
          },
          {
            "name": "BalanceQueryForZeroAddress",
            "parameters": [],
            "startLine": 45
          },
          {
            "name": "TransferToZeroAddress",
            "parameters": [],
            "startLine": 48
          },
          {
            "name": "TransferFromIncorrectOwner",
            "parameters": [],
            "startLine": 51
          },
          {
            "name": "AccountBalanceOverflow",
            "parameters": [],
            "startLine": 54
          },
          {
            "name": "TransferToNonERC721ReceiverImplementer",
            "parameters": [],
            "startLine": 58
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_MAX_ACCOUNT_BALANCE",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 29
          },
          {
            "name": "_TRANSFER_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 74
          },
          {
            "name": "_APPROVAL_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 78
          },
          {
            "name": "_APPROVAL_FOR_ALL_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 82
          },
          {
            "name": "_ERC721_MASTER_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 119
          },
          {
            "name": "_ERC721_MASTER_SLOT_SEED_MASKED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 122
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "Base58",
        "filePath": "utils/Base58.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "encode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function encode(bytes memory data) internal pure returns (string memory result) {\n        uint256 l = data.length;\n        if (l == uint256(0)) return result;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let b := add(data, 0x20) // Start of `data` bytes.\n            let z := 0 // Number of leading zero bytes in `data`.\n            // Count leading zero bytes.\n            for {} lt(byte(0, mload(add(b, z))), lt(z, l)) {} { z := add(1, z) }\n\n            // Start the output offset by an over-estimate of the length.\n            let o := add(add(mload(0x40), 0x21), add(z, div(mul(sub(l, z), 8351), 6115)))\n            let e := o\n\n            let limbs := o\n            let limbsEnd := limbs\n            // Populate the uint248 limbs.\n            for {\n                let i := mod(l, 31)\n                if i {\n                    mstore(limbsEnd, shr(shl(3, add(1, sub(31, i))), mload(b)))\n                    limbsEnd := add(limbsEnd, 0x20)\n                }\n            } lt(i, l) { i := add(i, 31) } {\n                mstore(limbsEnd, shr(8, mload(add(b, i))))\n                limbsEnd := add(limbsEnd, 0x20)\n            }\n            // Use the extended scratch space for the lookup. We'll restore 0x40 later.\n            mstore(0x1f, \"123456789ABCDEFGHJKLMNPQRSTUVWXY\")\n            mstore(0x3f, \"Zabcdefghijkmnopqrstuvwxyz\")\n\n            let w := not(0) // -1.\n            mstore(limbsEnd, w) // Put sentinel after limbs for faster looping.\n            for {} 1 {} {\n                let i := limbs\n                for {} iszero(mload(i)) { i := add(i, 0x20) } {}\n                if iszero(not(mload(i))) { break } // Break if all limbs are zero.\n\n                let carry := 0\n                for { i := limbs } 1 {} {\n                    let acc := add(shl(248, carry), mload(i))\n                    mstore(i, div(acc, 58))\n                    carry := mod(acc, 58)\n                    i := add(i, 0x20)\n                    if eq(i, limbsEnd) { break }\n                }\n                o := add(o, w)\n                mstore8(o, mload(carry))\n            }\n            let j := o\n            for { o := sub(o, z) } gt(j, o) {} {\n                j := sub(j, 0x20)\n                mstore(j, mul(div(w, 0xff), 49)) // '1111...1111' in ASCII.\n            }\n\n            let n := sub(e, o) // Compute the final length.\n            result := sub(o, 0x20) // Move back one word for the length.\n            mstore(result, n) // Store the length.\n            mstore(add(add(result, 0x20), n), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(result, 0x40), n)) // Allocate memory.\n        }\n    }",
            "startLine": 20
          },
          {
            "name": "encodeWord",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function encodeWord(bytes32 data) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := add(mload(0x40), 0x4c) // 32 for word, 44 for maximum possible length.\n            let e := o\n\n            // Use the extended scratch space for the lookup. We'll restore 0x40 later.\n            mstore(0x1f, \"123456789ABCDEFGHJKLMNPQRSTUVWXY\")\n            mstore(0x3f, \"Zabcdefghijkmnopqrstuvwxyz\")\n\n            let w := not(0) // -1.\n            let z := shl(5, iszero(data)) // Number of leading zeroes in `data`.\n            if iszero(z) {\n                for { let v := data } v { v := div(v, 58) } {\n                    o := add(o, w)\n                    mstore8(o, mload(mod(v, 58)))\n                }\n                for {} // Just loop, `z` is often tiny.\n                 iszero(byte(z, data)) { z := add(z, 1) } {}\n            }\n            if z { mstore(sub(o, 0x20), mul(div(w, 0xff), 49))} // '1111...1111' in ASCII.\n            o := sub(o, z)\n\n            let n := sub(e, o) // Compute the final length.\n            result := sub(o, 0x20) // Move back one word for the length.\n            mstore(result, n) // Store the length.\n            mstore(add(add(result, 0x20), n), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(result, 0x40), n)) // Allocate memory.\n        }\n    }",
            "startLine": 84
          },
          {
            "name": "decode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "encoded",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function decode(string memory encoded) internal pure returns (bytes memory result) {\n        uint256 n = bytes(encoded).length;\n        if (n == uint256(0)) return result;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := add(encoded, 0x20)\n            let z := 0 // Number of leading '1' in `data`.\n            // Count leading '1'.\n            for {} and(eq(49, byte(0, mload(add(s, z)))), lt(z, n)) {} { z := add(1, z) }\n\n            // Start the output offset by an over-estimate of the length.\n            let o := add(add(mload(0x40), 0x21), add(z, div(mul(sub(n, z), 7323), 10000)))\n            let e := o\n            let limbs := o\n            let limbsEnd := limbs\n            let limbMask := shr(8, not(0))\n            // Use the extended scratch space for the lookup. We'll restore 0x40 later.\n            mstore(0x2a, 0x30313233343536373839)\n            mstore(0x20, 0x1718191a1b1c1d1e1f20ffffffffffff2122232425262728292a2bff2c2d2e2f)\n            mstore(0x00, 0x000102030405060708ffffffffffffff090a0b0c0d0e0f10ff1112131415ff16)\n\n            for { let j := 0 } 1 {} {\n                let c := sub(byte(0, mload(add(s, j))), 49)\n                // Check if the input character is valid.\n                if iszero(and(shl(c, 1), 0x3fff7ff03ffbeff01ff)) {\n                    mstore(0x00, 0xe8fad793) // `Base58DecodingError()`.\n                    revert(0x1c, 0x04)\n                }\n                let carry := byte(0, mload(c))\n                for { let i := limbs } iszero(eq(i, limbsEnd)) { i := add(i, 0x20) } {\n                    let acc := add(carry, mul(58, mload(i)))\n                    mstore(i, and(limbMask, acc))\n                    carry := shr(248, acc)\n                }\n                // Carry will always be < 58.\n                if carry {\n                    mstore(limbsEnd, carry)\n                    limbsEnd := add(limbsEnd, 0x20)\n                }\n                j := add(j, 1)\n                if eq(j, n) { break }\n            }\n            // Copy and compact the uint248 limbs.\n            for { let i := limbs } iszero(eq(i, limbsEnd)) { i := add(i, 0x20) } {\n                o := sub(o, 31)\n                mstore(sub(o, 1), mload(i))\n            }\n            // Strip any leading zeros from the limbs.\n            for {} lt(byte(0, mload(o)), lt(o, e)) {} { o := add(o, 1) }\n            o := sub(o, z) // Move back for the leading zero bytes.\n            calldatacopy(o, calldatasize(), z) // Fill the leading zero bytes.\n\n            let l := sub(e, o) // Compute the final length.\n            result := sub(o, 0x20) // Move back one word for the length.\n            mstore(result, l) // Store the length.\n            mstore(add(add(result, 0x20), l), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(result, 0x40), l)) // Allocate memory.\n        }\n    }",
            "startLine": 116
          },
          {
            "name": "decodeWord",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "encoded",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function decodeWord(string memory encoded) internal pure returns (bytes32 result) {\n        uint256 n = bytes(encoded).length;\n        if (n == uint256(0)) return result;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let s := add(encoded, 0x20)\n            let t := add(1, div(not(0), 58)) // Overflow threshold for multiplication.\n            // Use the extended scratch space for the lookup. We'll restore 0x40 later.\n            mstore(0x2a, 0x30313233343536373839)\n            mstore(0x20, 0x1718191a1b1c1d1e1f20ffffffffffff2122232425262728292a2bff2c2d2e2f)\n            mstore(0x00, 0x000102030405060708ffffffffffffff090a0b0c0d0e0f10ff1112131415ff16)\n\n            for { let j := 0 } 1 {} {\n                let c := sub(byte(0, mload(add(s, j))), 49)\n                let p := mul(result, 58)\n                let acc := add(byte(0, mload(c)), p)\n                // Check if the input character is valid.\n                if iszero(and(0x3fff7ff03ffbeff01ff, shl(c, lt(lt(acc, p), lt(result, t))))) {\n                    mstore(0x00, 0xe8fad793) // `Base58DecodingError()`.\n                    revert(0x1c, 0x04)\n                }\n                result := acc\n                j := add(j, 1)\n                if eq(j, n) { break }\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 177
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "Base58DecodingError",
            "parameters": [],
            "startLine": 13
          }
        ],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "Base64",
        "filePath": "utils/Base64.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "encode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "fileSafe",
                "type": "bool"
              },
              {
                "name": "noPadding",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function encode(bytes memory data, bool fileSafe, bool noPadding)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0670 will turn \"-_\" into \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, xor(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0670)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                let dataEnd := add(add(0x20, data), dataLength)\n                let dataEndValue := mload(dataEnd) // Cache the value at the `dataEnd` slot.\n                mstore(dataEnd, 0x00) // Zeroize the `dataEnd` slot to clear dirty bits.\n\n                // Run over the input, 3 bytes at a time.\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\n                    mstore8(3, mload(and(input, 0x3F)))\n                    mstore(ptr, mload(0x00))\n\n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(dataEnd, dataEndValue) // Restore the cached value at `dataEnd`.\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\n                let o := div(2, mod(dataLength, 3))\n                // Offset `ptr` and pad with '='. We can simply write over the end.\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\n                // Set `o` to zero if there is padding.\n                o := mul(iszero(iszero(noPadding)), o)\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\n                mstore(result, sub(encodedLength, o)) // Store the length.\n            }\n        }\n    }",
            "startLine": 17
          },
          {
            "name": "encode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "encode",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function encode(bytes memory data) internal pure returns (string memory result) {\n        result = encode(data, false, false);\n    }",
            "startLine": 81
          },
          {
            "name": "encode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "fileSafe",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "encode",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function encode(bytes memory data, bool fileSafe) internal pure returns (string memory result) {\n        result = encode(data, fileSafe, false);\n    }",
            "startLine": 87
          },
          {
            "name": "decode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function decode(string memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                for {} 1 {} {\n                    // If padded.\n                    if iszero(and(dataLength, 3)) {\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\n                        // forgefmt: disable-next-item\n                        decodedLength := sub(\n                            decodedLength,\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\n                        )\n                        break\n                    }\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                    break\n                }\n                result := mload(0x40)\n\n                // Write the length of the bytes.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, decodedLength)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    // forgefmt: disable-next-item\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n                    ptr := add(ptr, 3)\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                mstore(end, 0) // Zeroize the slot after the bytes.\n                mstore(0x60, 0) // Restore the zero slot.\n            }\n        }\n    }",
            "startLine": 105
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "BlockHashLib",
        "filePath": "utils/BlockHashLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "blockHash",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "blockNumber",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function blockHash(uint256 blockNumber) internal view returns (bytes32 result) {\n        unchecked {\n            // If `blockNumber + 256` overflows:\n            // - Typical chain height (`block.number > 255`) -> `staticcall` -> 0.\n            // - Very early chain (`block.number <= 255`) -> `blockhash` -> 0.\n            if (block.number <= blockNumber + 256) return blockhash(blockNumber);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, blockNumber)\n            mstore(0x00, 0)\n            pop(staticcall(gas(), HISTORY_STORAGE_ADDRESS, 0x20, 0x20, 0x00, 0x20))\n            result := mload(0x00)\n        }\n    }",
            "startLine": 46
          },
          {
            "name": "verifyBlock",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "encodedHeader",
                "type": "bytes"
              },
              {
                "name": "blockNumber",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "blockHash",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function verifyBlock(bytes calldata encodedHeader, uint256 blockNumber)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        result = blockHash(blockNumber);\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), encodedHeader.offset, encodedHeader.length)\n            if iszero(eq(result, keccak256(mload(0x40), encodedHeader.length))) {\n                mstore(0x00, 0xe42b5e7e) // `BlockHashMismatch()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 65
          },
          {
            "name": "toShortHeader",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "encodedHeader",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "ShortHeader"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toShortHeader(bytes calldata encodedHeader)\n        internal\n        pure\n        returns (ShortHeader memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, calldataload(add(4, encodedHeader.offset))) // `parentHash`.\n            mstore(add(0x20, result), calldataload(add(91, encodedHeader.offset))) // `stateRoot`.\n            mstore(add(0x40, result), calldataload(add(124, encodedHeader.offset))) // `transactionsRoot`.\n            mstore(add(0x60, result), calldataload(add(157, encodedHeader.offset))) // `receiptsRoot`.\n            calldatacopy(mload(add(0x80, result)), add(192, encodedHeader.offset), 0x100) // `logsBloom`.\n            if iszero( // Just perform some minimal light bounds checking.\n                and(\n                    gt(encodedHeader.length, 447), // `0x100 + 192 - 1`.\n                    eq(byte(0, calldataload(encodedHeader.offset)), 0xf9) // `0xff < len < 0x10000`.\n                )\n            ) {\n                mstore(0x00, 0x1a27c4e4) // `InvalidBlockHeaderEncoding()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 88
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "BlockHashMismatch",
            "parameters": [],
            "startLine": 26
          },
          {
            "name": "InvalidBlockHeaderEncoding",
            "parameters": [],
            "startLine": 29
          }
        ],
        "structs": [
          {
            "name": "ShortHeader",
            "members": [
              {
                "name": "parentHash",
                "type": "bytes32"
              },
              {
                "name": "stateRoot",
                "type": "bytes32"
              },
              {
                "name": "transactionsRoot",
                "type": "bytes32"
              },
              {
                "name": "receiptsRoot",
                "type": "bytes32"
              },
              {
                "name": "logsBloom",
                "type": "bytes32[]"
              }
            ],
            "startLine": 13
          }
        ],
        "stateVariables": [
          {
            "name": "HISTORY_STORAGE_ADDRESS",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 37
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "CREATE3",
        "filePath": "utils/CREATE3.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "deployDeterministic",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initCode",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "deployed",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployDeterministic",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployDeterministic(bytes memory initCode, bytes32 salt)\n        internal\n        returns (address deployed)\n    {\n        deployed = deployDeterministic(0, initCode, salt);\n    }",
            "startLine": 59
          },
          {
            "name": "deployDeterministic",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "initCode",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "deployed",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function deployDeterministic(uint256 value, bytes memory initCode, bytes32 salt)\n        internal\n        returns (address deployed)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, _PROXY_INITCODE) // Store the `_PROXY_INITCODE`.\n            let proxy := create2(0, 0x10, 0x10, salt)\n            if iszero(proxy) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, proxy) // Store the proxy's address.\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            mstore8(0x34, 0x01) // Nonce of the proxy contract (1).\n            deployed := keccak256(0x1e, 0x17)\n            if iszero(\n                mul( // The arguments of `mul` are evaluated last to first.\n                    extcodesize(deployed),\n                    call(gas(), proxy, value, add(initCode, 0x20), mload(initCode), 0x00, 0x00)\n                )\n            ) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 70
          },
          {
            "name": "predictDeterministicAddress",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "deployed",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "predictDeterministicAddress",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddress(bytes32 salt) internal view returns (address deployed) {\n        deployed = predictDeterministicAddress(salt, address(this));\n    }",
            "startLine": 101
          },
          {
            "name": "predictDeterministicAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "deployer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "deployed",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddress(bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address deployed)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, deployer) // Store `deployer`.\n            mstore8(0x0b, 0xff) // Store the prefix.\n            mstore(0x20, salt) // Store the salt.\n            mstore(0x40, PROXY_INITCODE_HASH) // Store the bytecode hash.\n\n            mstore(0x14, keccak256(0x0b, 0x55)) // Store the proxy's address.\n            mstore(0x40, m) // Restore the free memory pointer.\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            mstore8(0x34, 0x01) // Nonce of the proxy contract (1).\n            deployed := keccak256(0x1e, 0x17)\n        }\n    }",
            "startLine": 106
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "DeploymentFailed",
            "parameters": [],
            "startLine": 14
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_PROXY_INITCODE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 45
          },
          {
            "name": "PROXY_INITCODE_HASH",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 49
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "CallContextChecker",
        "filePath": "utils/CallContextChecker.sol",
        "kind": "contract",
        "inherits": [],
        "implements": [],
        "category": "utils",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "_onEIP7702Authority",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _onEIP7702Authority() internal view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(address(), 0x00, 0x00, 0x20)\n            // Note: Checking that it starts with hex\"ef01\" is the most general and futureproof.\n            // 7702 bytecode is `abi.encodePacked(hex\"ef01\", uint8(version), address(delegation))`.\n            result := eq(0xef01, shr(240, mload(0x00)))\n        }\n    }",
            "startLine": 34
          },
          {
            "name": "_selfImplementation",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _selfImplementation() internal view virtual returns (address) {\n        return address(uint160(__self));\n    }",
            "startLine": 45
          },
          {
            "name": "_onImplementation",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _onImplementation() internal view virtual returns (bool) {\n        return __self == uint160(address(this));\n    }",
            "startLine": 50
          },
          {
            "name": "_checkOnlyEIP7702Authority",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_onEIP7702Authority",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkOnlyEIP7702Authority() internal view virtual {\n        if (!_onEIP7702Authority()) _revertUnauthorizedCallContext();\n    }",
            "startLine": 55
          },
          {
            "name": "_checkOnlyProxy",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_onImplementation",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkOnlyProxy() internal view virtual {\n        if (_onImplementation()) _revertUnauthorizedCallContext();\n    }",
            "startLine": 60
          },
          {
            "name": "_checkNotDelegated",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_onImplementation",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkNotDelegated() internal view virtual {\n        if (!_onImplementation()) _revertUnauthorizedCallContext();\n    }",
            "startLine": 66
          },
          {
            "name": "_revertUnauthorizedCallContext",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _revertUnauthorizedCallContext() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x9f03a026) // `UnauthorizedCallContext()`.\n            revert(0x1c, 0x04)\n        }\n    }",
            "startLine": 93
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "UnauthorizedCallContext",
            "parameters": [],
            "startLine": 12
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "__self",
            "type": "uint256",
            "visibility": "private",
            "isConstant": false,
            "isImmutable": true,
            "startLine": 23
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "DateTimeLib",
        "filePath": "utils/DateTimeLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "dateToEpochDay",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "year",
                "type": "uint256"
              },
              {
                "name": "month",
                "type": "uint256"
              },
              {
                "name": "day",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "epochDay",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function dateToEpochDay(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (uint256 epochDay)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            year := sub(year, lt(month, 3))\n            let doy := add(shr(11, add(mul(62719, mod(add(month, 9), 12)), 769)), day)\n            let yoe := mod(year, 400)\n            let doe := sub(add(add(mul(yoe, 365), shr(2, yoe)), doy), div(yoe, 100))\n            epochDay := sub(add(mul(div(year, 400), 146097), doe), 719469)\n        }\n    }",
            "startLine": 65
          },
          {
            "name": "epochDayToDate",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "epochDay",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "year",
                "type": "uint256"
              },
              {
                "name": "month",
                "type": "uint256"
              },
              {
                "name": "day",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function epochDayToDate(uint256 epochDay)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            epochDay := add(epochDay, 719468)\n            let doe := mod(epochDay, 146097)\n            let yoe :=\n                div(sub(sub(add(doe, div(doe, 36524)), div(doe, 1460)), eq(doe, 146096)), 365)\n            let doy := sub(doe, sub(add(mul(365, yoe), shr(2, yoe)), div(yoe, 100)))\n            let mp := div(add(mul(5, doy), 2), 153)\n            day := add(sub(doy, shr(11, add(mul(mp, 62719), 769))), 1)\n            month := byte(mp, shl(160, 0x030405060708090a0b0c0102))\n            year := add(add(yoe, mul(div(epochDay, 146097), 400)), lt(month, 3))\n        }\n    }",
            "startLine": 83
          },
          {
            "name": "dateToTimestamp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "year",
                "type": "uint256"
              },
              {
                "name": "month",
                "type": "uint256"
              },
              {
                "name": "day",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "dateToEpochDay",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function dateToTimestamp(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            result = dateToEpochDay(year, month, day) * 86400;\n        }\n    }",
            "startLine": 105
          },
          {
            "name": "timestampToDate",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "year",
                "type": "uint256"
              },
              {
                "name": "month",
                "type": "uint256"
              },
              {
                "name": "day",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "epochDayToDate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day)\n    {\n        (year, month, day) = epochDayToDate(timestamp / 86400);\n    }",
            "startLine": 118
          },
          {
            "name": "dateTimeToTimestamp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "year",
                "type": "uint256"
              },
              {
                "name": "month",
                "type": "uint256"
              },
              {
                "name": "day",
                "type": "uint256"
              },
              {
                "name": "hour",
                "type": "uint256"
              },
              {
                "name": "minute",
                "type": "uint256"
              },
              {
                "name": "second",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "dateToEpochDay",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function dateTimeToTimestamp(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            result = dateToEpochDay(year, month, day) * 86400 + hour * 3600 + minute * 60 + second;\n        }\n    }",
            "startLine": 130
          },
          {
            "name": "timestampToDateTime",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "year",
                "type": "uint256"
              },
              {
                "name": "month",
                "type": "uint256"
              },
              {
                "name": "day",
                "type": "uint256"
              },
              {
                "name": "hour",
                "type": "uint256"
              },
              {
                "name": "minute",
                "type": "uint256"
              },
              {
                "name": "second",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "epochDayToDate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function timestampToDateTime(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        unchecked {\n            (year, month, day) = epochDayToDate(timestamp / 86400);\n            uint256 secs = timestamp % 86400;\n            hour = secs / 3600;\n            secs = secs % 3600;\n            minute = secs / 60;\n            second = secs % 60;\n        }\n    }",
            "startLine": 147
          },
          {
            "name": "isLeapYear",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "year",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "leap",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isLeapYear(uint256 year) internal pure returns (bool leap) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            leap := iszero(and(add(mul(iszero(mod(year, 25)), 12), 3), year))\n        }\n    }",
            "startLine": 170
          },
          {
            "name": "daysInMonth",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "year",
                "type": "uint256"
              },
              {
                "name": "month",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "isLeapYear",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function daysInMonth(uint256 year, uint256 month) internal pure returns (uint256 result) {\n        bool flag = isLeapYear(year);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `daysInMonths = [31,28,31,30,31,30,31,31,30,31,30,31]`.\n            // `result = daysInMonths[month - 1] + isLeapYear(year)`.\n            result := add(\n                byte(month, shl(152, 0x1f1c1f1e1f1e1f1f1e1f1e1f)),\n                and(eq(month, 2), flag)\n            )\n        }\n    }",
            "startLine": 178
          },
          {
            "name": "weekday",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function weekday(uint256 timestamp) internal pure returns (uint256 result) {\n        unchecked {\n            result = ((timestamp / 86400 + 3) % 7) + 1;\n        }\n    }",
            "startLine": 193
          },
          {
            "name": "isSupportedDate",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "year",
                "type": "uint256"
              },
              {
                "name": "month",
                "type": "uint256"
              },
              {
                "name": "day",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "daysInMonth",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function isSupportedDate(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (bool result)\n    {\n        uint256 md = daysInMonth(year, month);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(\n                lt(sub(year, 1970), sub(MAX_SUPPORTED_YEAR, 1969)),\n                and(lt(sub(month, 1), 12), lt(sub(day, 1), md))\n            )\n        }\n    }",
            "startLine": 203
          },
          {
            "name": "isSupportedDateTime",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "year",
                "type": "uint256"
              },
              {
                "name": "month",
                "type": "uint256"
              },
              {
                "name": "day",
                "type": "uint256"
              },
              {
                "name": "hour",
                "type": "uint256"
              },
              {
                "name": "minute",
                "type": "uint256"
              },
              {
                "name": "second",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "isSupportedDate",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function isSupportedDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (bool result) {\n        if (isSupportedDate(year, month, day)) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                result := and(lt(hour, 24), and(lt(minute, 60), lt(second, 60)))\n            }\n        }\n    }",
            "startLine": 225
          },
          {
            "name": "isSupportedEpochDay",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "epochDay",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isSupportedEpochDay(uint256 epochDay) internal pure returns (bool result) {\n        unchecked {\n            result = epochDay < MAX_SUPPORTED_EPOCH_DAY + 1;\n        }\n    }",
            "startLine": 242
          },
          {
            "name": "isSupportedTimestamp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isSupportedTimestamp(uint256 timestamp) internal pure returns (bool result) {\n        unchecked {\n            result = timestamp < MAX_SUPPORTED_TIMESTAMP + 1;\n        }\n    }",
            "startLine": 249
          },
          {
            "name": "nthWeekdayInMonthOfYearTimestamp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "year",
                "type": "uint256"
              },
              {
                "name": "month",
                "type": "uint256"
              },
              {
                "name": "n",
                "type": "uint256"
              },
              {
                "name": "wd",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "dateToEpochDay",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "daysInMonth",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function nthWeekdayInMonthOfYearTimestamp(uint256 year, uint256 month, uint256 n, uint256 wd)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        uint256 d = dateToEpochDay(year, month, 1);\n        uint256 md = daysInMonth(year, month);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let diff := sub(wd, add(mod(add(d, 3), 7), 1))\n            let date := add(mul(sub(n, 1), 7), add(mul(gt(diff, 6), 7), diff))\n            result := mul(mul(86400, add(date, d)), and(lt(date, md), iszero(iszero(n))))\n        }\n    }",
            "startLine": 259
          },
          {
            "name": "mondayTimestamp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function mondayTimestamp(uint256 timestamp) internal pure returns (uint256 result) {\n        uint256 t = timestamp;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let day := div(t, 86400)\n            result := mul(mul(sub(day, mod(add(day, 3), 7)), 86400), gt(t, 345599))\n        }\n    }",
            "startLine": 275
          },
          {
            "name": "isWeekEnd",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "weekday",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function isWeekEnd(uint256 timestamp) internal pure returns (bool result) {\n        result = weekday(timestamp) > FRI;\n    }",
            "startLine": 286
          },
          {
            "name": "addYears",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint256"
              },
              {
                "name": "numYears",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "epochDayToDate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function addYears(uint256 timestamp, uint256 numYears) internal pure returns (uint256 result) {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        result = _offsetted(year + numYears, month, day, timestamp);\n    }",
            "startLine": 301
          },
          {
            "name": "addMonths",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint256"
              },
              {
                "name": "numMonths",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "epochDayToDate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_sub",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_add",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function addMonths(uint256 timestamp, uint256 numMonths)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        month = _sub(month + numMonths, 1);\n        result = _offsetted(year + month / 12, _add(month % 12, 1), day, timestamp);\n    }",
            "startLine": 311
          },
          {
            "name": "addDays",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint256"
              },
              {
                "name": "numDays",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function addDays(uint256 timestamp, uint256 numDays) internal pure returns (uint256 result) {\n        result = timestamp + numDays * 86400;\n    }",
            "startLine": 322
          },
          {
            "name": "addHours",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint256"
              },
              {
                "name": "numHours",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function addHours(uint256 timestamp, uint256 numHours) internal pure returns (uint256 result) {\n        result = timestamp + numHours * 3600;\n    }",
            "startLine": 327
          },
          {
            "name": "addMinutes",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint256"
              },
              {
                "name": "numMinutes",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function addMinutes(uint256 timestamp, uint256 numMinutes)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp + numMinutes * 60;\n    }",
            "startLine": 332
          },
          {
            "name": "addSeconds",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint256"
              },
              {
                "name": "numSeconds",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function addSeconds(uint256 timestamp, uint256 numSeconds)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp + numSeconds;\n    }",
            "startLine": 341
          },
          {
            "name": "subYears",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint256"
              },
              {
                "name": "numYears",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "epochDayToDate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function subYears(uint256 timestamp, uint256 numYears) internal pure returns (uint256 result) {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        result = _offsetted(year - numYears, month, day, timestamp);\n    }",
            "startLine": 356
          },
          {
            "name": "subMonths",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint256"
              },
              {
                "name": "numMonths",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "epochDayToDate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_totalMonths",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_add",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function subMonths(uint256 timestamp, uint256 numMonths)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        uint256 yearMonth = _totalMonths(year, month) - _add(numMonths, 1);\n        result = _offsetted(yearMonth / 12, _add(yearMonth % 12, 1), day, timestamp);\n    }",
            "startLine": 366
          },
          {
            "name": "subDays",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint256"
              },
              {
                "name": "numDays",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function subDays(uint256 timestamp, uint256 numDays) internal pure returns (uint256 result) {\n        result = timestamp - numDays * 86400;\n    }",
            "startLine": 377
          },
          {
            "name": "subHours",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint256"
              },
              {
                "name": "numHours",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function subHours(uint256 timestamp, uint256 numHours) internal pure returns (uint256 result) {\n        result = timestamp - numHours * 3600;\n    }",
            "startLine": 382
          },
          {
            "name": "subMinutes",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint256"
              },
              {
                "name": "numMinutes",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function subMinutes(uint256 timestamp, uint256 numMinutes)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp - numMinutes * 60;\n    }",
            "startLine": 387
          },
          {
            "name": "subSeconds",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint256"
              },
              {
                "name": "numSeconds",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function subSeconds(uint256 timestamp, uint256 numSeconds)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp - numSeconds;\n    }",
            "startLine": 396
          },
          {
            "name": "diffYears",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "fromTimestamp",
                "type": "uint256"
              },
              {
                "name": "toTimestamp",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "epochDayToDate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_sub",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        toTimestamp - fromTimestamp;\n        (uint256 fromYear,,) = epochDayToDate(fromTimestamp / 86400);\n        (uint256 toYear,,) = epochDayToDate(toTimestamp / 86400);\n        result = _sub(toYear, fromYear);\n    }",
            "startLine": 409
          },
          {
            "name": "diffMonths",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "fromTimestamp",
                "type": "uint256"
              },
              {
                "name": "toTimestamp",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "epochDayToDate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_sub",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_totalMonths",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        toTimestamp - fromTimestamp;\n        (uint256 fromYear, uint256 fromMonth,) = epochDayToDate(fromTimestamp / 86400);\n        (uint256 toYear, uint256 toMonth,) = epochDayToDate(toTimestamp / 86400);\n        result = _sub(_totalMonths(toYear, toMonth), _totalMonths(fromYear, fromMonth));\n    }",
            "startLine": 425
          },
          {
            "name": "diffDays",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "fromTimestamp",
                "type": "uint256"
              },
              {
                "name": "toTimestamp",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 86400;\n    }",
            "startLine": 437
          },
          {
            "name": "diffHours",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "fromTimestamp",
                "type": "uint256"
              },
              {
                "name": "toTimestamp",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 3600;\n    }",
            "startLine": 446
          },
          {
            "name": "diffMinutes",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "fromTimestamp",
                "type": "uint256"
              },
              {
                "name": "toTimestamp",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 60;\n    }",
            "startLine": 455
          },
          {
            "name": "diffSeconds",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "fromTimestamp",
                "type": "uint256"
              },
              {
                "name": "toTimestamp",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = toTimestamp - fromTimestamp;\n    }",
            "startLine": 464
          },
          {
            "name": "_totalMonths",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "numYears",
                "type": "uint256"
              },
              {
                "name": "numMonths",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "total",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _totalMonths(uint256 numYears, uint256 numMonths)\n        private\n        pure\n        returns (uint256 total)\n    {\n        unchecked {\n            total = numYears * 12 + numMonths;\n        }\n    }",
            "startLine": 477
          },
          {
            "name": "_add",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256"
              },
              {
                "name": "b",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _add(uint256 a, uint256 b) private pure returns (uint256 c) {\n        unchecked {\n            c = a + b;\n        }\n    }",
            "startLine": 488
          },
          {
            "name": "_sub",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256"
              },
              {
                "name": "b",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _sub(uint256 a, uint256 b) private pure returns (uint256 c) {\n        unchecked {\n            c = a - b;\n        }\n    }",
            "startLine": 495
          },
          {
            "name": "_offsetted",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "year",
                "type": "uint256"
              },
              {
                "name": "month",
                "type": "uint256"
              },
              {
                "name": "day",
                "type": "uint256"
              },
              {
                "name": "timestamp",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "daysInMonth",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "dateToEpochDay",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _offsetted(uint256 year, uint256 month, uint256 day, uint256 timestamp)\n        private\n        pure\n        returns (uint256 result)\n    {\n        uint256 dm = daysInMonth(year, month);\n        if (day >= dm) {\n            day = dm;\n        }\n        result = dateToEpochDay(year, month, day) * 86400 + (timestamp % 86400);\n    }",
            "startLine": 502
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "MON",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 27
          },
          {
            "name": "TUE",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 28
          },
          {
            "name": "WED",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 29
          },
          {
            "name": "THU",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 30
          },
          {
            "name": "FRI",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 31
          },
          {
            "name": "SAT",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 32
          },
          {
            "name": "SUN",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 33
          },
          {
            "name": "JAN",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 37
          },
          {
            "name": "FEB",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 38
          },
          {
            "name": "MAR",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 39
          },
          {
            "name": "APR",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 40
          },
          {
            "name": "MAY",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 41
          },
          {
            "name": "JUN",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 42
          },
          {
            "name": "JUL",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 43
          },
          {
            "name": "AUG",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 44
          },
          {
            "name": "SEP",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 45
          },
          {
            "name": "OCT",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 46
          },
          {
            "name": "NOV",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 47
          },
          {
            "name": "DEC",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 48
          },
          {
            "name": "MAX_SUPPORTED_YEAR",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 53
          },
          {
            "name": "MAX_SUPPORTED_EPOCH_DAY",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 54
          },
          {
            "name": "MAX_SUPPORTED_TIMESTAMP",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 55
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "DeploylessPredeployQueryer",
        "filePath": "utils/DeploylessPredeployQueryer.sol",
        "kind": "contract",
        "inherits": [],
        "implements": [],
        "category": "utils",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "constructor",
            "visibility": "default",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "targetQueryCalldata",
                "type": "bytes[]"
              },
              {
                "name": "factory",
                "type": "address"
              },
              {
                "name": "factoryCalldata",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "constructor(\n        address target,\n        bytes[] memory targetQueryCalldata,\n        address factory,\n        bytes memory factoryCalldata\n    ) payable {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            // If the target does not exist, deploy it.\n            if iszero(extcodesize(target)) {\n                if iszero(\n                    call(\n                        gas(),\n                        factory,\n                        selfbalance(),\n                        add(factoryCalldata, 0x20),\n                        mload(factoryCalldata),\n                        m,\n                        0x20\n                    )\n                ) {\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n                if iszero(and(gt(returndatasize(), 0x1f), eq(mload(m), target))) {\n                    mstore(0x00, 0xd1f6b812) // `ReturnedAddressMismatch()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            let l := mload(targetQueryCalldata)\n            let n := shl(5, l)\n            let r := add(m, 0x40)\n            let o := add(r, n)\n            for { let i := 0 } iszero(eq(i, n)) { i := add(0x20, i) } {\n                let j := mload(add(add(targetQueryCalldata, 0x20), i))\n                if iszero(\n                    call(gas(), target, selfbalance(), add(j, 0x20), mload(j), codesize(), 0x00)\n                ) {\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n                mstore(add(r, i), sub(o, r))\n                mstore(o, returndatasize())\n                returndatacopy(add(o, 0x20), 0x00, returndatasize())\n                o := and(add(add(o, returndatasize()), 0x3f), not(0x1f))\n            }\n            mstore(m, 0x20)\n            mstore(add(m, 0x20), l)\n            return(m, sub(o, m))\n        }\n    }",
            "startLine": 39
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ReturnedAddressMismatch",
            "parameters": [],
            "startLine": 27
          }
        ],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "DynamicArrayLib",
        "filePath": "utils/DynamicArrayLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "malloc",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function malloc(uint256 n) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := or(sub(0, shr(32, n)), mload(0x40))\n            mstore(result, n)\n            mstore(0x40, add(add(result, 0x20), shl(5, n)))\n        }\n    }",
            "startLine": 35
          },
          {
            "name": "zeroize",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function zeroize(uint256[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n            calldatacopy(add(result, 0x20), calldatasize(), shl(5, mload(result)))\n        }\n    }",
            "startLine": 45
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(uint256[] memory a, uint256 i) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 54
          },
          {
            "name": "getUint256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getUint256(uint256[] memory a, uint256 i) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 62
          },
          {
            "name": "getAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getAddress(uint256[] memory a, uint256 i) internal pure returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 70
          },
          {
            "name": "getBool",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getBool(uint256[] memory a, uint256 i) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 78
          },
          {
            "name": "getBytes32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getBytes32(uint256[] memory a, uint256 i) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 86
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "i",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(uint256[] memory a, uint256 i, uint256 data)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(result, 0x20), shl(5, i)), data)\n        }\n    }",
            "startLine": 94
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "i",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(uint256[] memory a, uint256 i, address data)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(result, 0x20), shl(5, i)), shr(96, shl(96, data)))\n        }\n    }",
            "startLine": 107
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "i",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(uint256[] memory a, uint256 i, bool data)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(result, 0x20), shl(5, i)), iszero(iszero(data)))\n        }\n    }",
            "startLine": 120
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "i",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(uint256[] memory a, uint256 i, bytes32 data)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(result, 0x20), shl(5, i)), data)\n        }\n    }",
            "startLine": 133
          },
          {
            "name": "asAddressArray",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function asAddressArray(uint256[] memory a) internal pure returns (address[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "startLine": 146
          },
          {
            "name": "asBoolArray",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function asBoolArray(uint256[] memory a) internal pure returns (bool[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "startLine": 154
          },
          {
            "name": "asBytes32Array",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function asBytes32Array(uint256[] memory a) internal pure returns (bytes32[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "startLine": 162
          },
          {
            "name": "toUint256Array",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint256Array(address[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "startLine": 170
          },
          {
            "name": "toUint256Array",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bool[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint256Array(bool[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "startLine": 178
          },
          {
            "name": "toUint256Array",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint256Array(bytes32[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "startLine": 186
          },
          {
            "name": "truncate",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function truncate(uint256[] memory a, uint256 n)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n            mstore(mul(lt(n, mload(result)), result), n)\n        }\n    }",
            "startLine": 195
          },
          {
            "name": "free",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function free(uint256[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n            let n := mload(result)\n            mstore(shl(6, lt(iszero(n), eq(add(shl(5, add(1, n)), result), mload(0x40)))), result)\n            mstore(result, 0)\n        }\n    }",
            "startLine": 208
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(uint256[] memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(a, 0x20), shl(5, mload(a)))\n        }\n    }",
            "startLine": 219
          },
          {
            "name": "slice",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function slice(uint256[] memory a, uint256 start, uint256 end)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let arrayLen := mload(a)\n            if iszero(gt(arrayLen, end)) { end := arrayLen }\n            if iszero(gt(arrayLen, start)) { start := arrayLen }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLen := sub(end, start)\n                mstore(result, resultLen)\n                a := add(a, shl(5, start))\n                // Copy the `a` one word at a time, backwards.\n                let o := shl(5, resultLen)\n                mstore(0x40, add(add(result, o), 0x20)) // Allocate memory.\n                for {} 1 {} {\n                    mstore(add(result, o), mload(add(a, o)))\n                    o := sub(o, 0x20)\n                    if iszero(o) { break }\n                }\n            }\n        }\n    }",
            "startLine": 227
          },
          {
            "name": "slice",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "slice",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function slice(uint256[] memory a, uint256 start)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        result = slice(a, start, type(uint256).max);\n    }",
            "startLine": 255
          },
          {
            "name": "copy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function copy(uint256[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let end := add(add(result, 0x20), shl(5, mload(a)))\n            let o := result\n            for { let d := sub(a, result) } 1 {} {\n                mstore(o, mload(add(o, d)))\n                o := add(0x20, o)\n                if eq(o, end) { break }\n            }\n            mstore(0x40, o)\n        }\n    }",
            "startLine": 264
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "needle",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(uint256[] memory a, uint256 needle) internal pure returns (bool) {\n        return ~indexOf(a, needle, 0) != 0;\n    }",
            "startLine": 280
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "needle",
                "type": "uint256"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function indexOf(uint256[] memory a, uint256 needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0)\n            if lt(from, mload(a)) {\n                let o := add(a, shl(5, from))\n                let end := add(shl(5, add(1, mload(a))), a)\n                let c := mload(end) // Cache the word after the array.\n                for { mstore(end, needle) } 1 {} {\n                    o := add(o, 0x20)\n                    if eq(mload(o), needle) { break }\n                }\n                mstore(end, c) // Restore the word after the array.\n                if iszero(eq(o, end)) { result := shr(5, sub(o, add(0x20, a))) }\n            }\n        }\n    }",
            "startLine": 286
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "needle",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(uint256[] memory a, uint256 needle) internal pure returns (uint256 result) {\n        result = indexOf(a, needle, 0);\n    }",
            "startLine": 310
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "needle",
                "type": "uint256"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(uint256[] memory a, uint256 needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0)\n            let n := mload(a)\n            if n {\n                if iszero(lt(from, n)) { from := sub(n, 1) }\n                let o := add(shl(5, add(2, from)), a)\n                for { mstore(a, needle) } 1 {} {\n                    o := sub(o, 0x20)\n                    if eq(mload(o), needle) { break }\n                }\n                mstore(a, n) // Restore the length.\n                if iszero(eq(o, a)) { result := shr(5, sub(o, add(0x20, a))) }\n            }\n        }\n    }",
            "startLine": 316
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "needle",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "lastIndexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(uint256[] memory a, uint256 needle)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(a, needle, NOT_FOUND);\n    }",
            "startLine": 340
          },
          {
            "name": "directReturn",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function directReturn(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let retStart := sub(a, 0x20)\n            mstore(retStart, 0x20)\n            return(retStart, add(0x40, shl(5, mload(a))))\n        }\n    }",
            "startLine": 349
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function length(DynamicArray memory a) internal pure returns (uint256) {\n        return a.data.length;\n    }",
            "startLine": 366
          },
          {
            "name": "wrap",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function wrap(uint256[] memory a) internal pure returns (DynamicArray memory result) {\n        result.data = a;\n    }",
            "startLine": 371
          },
          {
            "name": "wrap",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function wrap(address[] memory a) internal pure returns (DynamicArray memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, a)\n        }\n    }",
            "startLine": 376
          },
          {
            "name": "wrap",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bool[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function wrap(bool[] memory a) internal pure returns (DynamicArray memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, a)\n        }\n    }",
            "startLine": 384
          },
          {
            "name": "wrap",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function wrap(bytes32[] memory a) internal pure returns (DynamicArray memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, a)\n        }\n    }",
            "startLine": 392
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clear(DynamicArray memory a) internal pure returns (DynamicArray memory result) {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(mload(result), 0)\n        }\n    }",
            "startLine": 400
          },
          {
            "name": "free",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function free(DynamicArray memory a) internal pure returns (DynamicArray memory result) {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let arrData := mload(result)\n            if iszero(eq(arrData, 0x60)) {\n                let prime := 8188386068317523\n                let cap := mload(sub(arrData, 0x20))\n                // Extract `cap`, initializing it to zero if it is not a multiple of `prime`.\n                cap := mul(div(cap, prime), iszero(mod(cap, prime)))\n                // If `cap` is non-zero and the memory is contiguous, we can free it.\n                if lt(iszero(cap), eq(mload(0x40), add(arrData, add(0x20, cap)))) {\n                    mstore(0x40, sub(arrData, 0x20))\n                }\n                mstore(result, 0x60)\n            }\n        }\n    }",
            "startLine": 410
          },
          {
            "name": "resize",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "reserve",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function resize(DynamicArray memory a, uint256 n)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        reserve(result, n);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let arrData := mload(result)\n            let arrLen := mload(arrData)\n            if iszero(lt(n, arrLen)) {\n                calldatacopy(\n                    add(arrData, shl(5, add(1, arrLen))),\n                    calldatasize(),\n                    shl(5, sub(n, arrLen))\n                )\n            }\n            mstore(arrData, n)\n        }\n    }",
            "startLine": 431
          },
          {
            "name": "expand",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "reserve",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function expand(DynamicArray memory a, uint256 n)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        if (n >= a.data.length) {\n            reserve(result, n);\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(mload(result), n)\n            }\n        }\n    }",
            "startLine": 457
          },
          {
            "name": "truncate",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function truncate(DynamicArray memory a, uint256 n)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(mul(lt(n, mload(mload(result))), mload(result)), n)\n        }\n    }",
            "startLine": 475
          },
          {
            "name": "reserve",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "minimum",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function reserve(DynamicArray memory a, uint256 minimum)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(minimum, 0xffffffff)) { invalid() } // For extra safety.\n            for { let arrData := mload(a) } 1 {} {\n                // Some random prime number to multiply `cap`, so that\n                // we know that the `cap` is for a dynamic array.\n                // Selected to be larger than any memory pointer realistically.\n                let prime := 8188386068317523\n                // Special case for `arrData` pointing to zero pointer.\n                if eq(arrData, 0x60) {\n                    let newCap := shl(5, add(1, minimum))\n                    let capSlot := mload(0x40)\n                    mstore(capSlot, mul(prime, newCap)) // Store the capacity.\n                    let newArrData := add(0x20, capSlot)\n                    mstore(newArrData, 0) // Store the length.\n                    mstore(0x40, add(newArrData, add(0x20, newCap))) // Allocate memory.\n                    mstore(a, newArrData)\n                    break\n                }\n                let w := not(0x1f)\n                let cap := mload(add(arrData, w)) // `mload(sub(arrData, w))`.\n                // Extract `cap`, initializing it to zero if it is not a multiple of `prime`.\n                cap := mul(div(cap, prime), iszero(mod(cap, prime)))\n                let newCap := shl(5, minimum)\n                // If we don't need to grow the memory.\n                if iszero(and(gt(minimum, mload(arrData)), gt(newCap, cap))) { break }\n                // If the memory is contiguous, we can simply expand it.\n                if eq(mload(0x40), add(arrData, add(0x20, cap))) {\n                    mstore(add(arrData, w), mul(prime, newCap)) // Store the capacity.\n                    mstore(0x40, add(arrData, add(0x20, newCap))) // Expand the memory allocation.\n                    break\n                }\n                let capSlot := mload(0x40)\n                let newArrData := add(capSlot, 0x20)\n                mstore(0x40, add(newArrData, add(0x20, newCap))) // Reallocate the memory.\n                mstore(a, newArrData) // Store the `newArrData`.\n                // Copy `arrData` one word at a time, backwards.\n                for { let o := add(0x20, shl(5, mload(arrData))) } 1 {} {\n                    mstore(add(newArrData, o), mload(add(arrData, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                mstore(capSlot, mul(prime, newCap)) // Store the capacity.\n                mstore(newArrData, mload(arrData)) // Store the length.\n                break\n            }\n        }\n    }",
            "startLine": 489
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "data",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(DynamicArray memory a, uint256 data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let arrData := mload(a)\n            let newArrLen := add(mload(arrData), 1)\n            let newArrBytesLen := shl(5, newArrLen)\n            // Some random prime number to multiply `cap`, so that\n            // we know that the `cap` is for a dynamic array.\n            // Selected to be larger than any memory pointer realistically.\n            let prime := 8188386068317523\n            let cap := mload(sub(arrData, 0x20))\n            // Extract `cap`, initializing it to zero if it is not a multiple of `prime`.\n            cap := mul(div(cap, prime), iszero(mod(cap, prime)))\n\n            // Expand / Reallocate memory if required.\n            // Note that we need to allocate an extra word for the length.\n            for {} iszero(lt(newArrBytesLen, cap)) {} {\n                // Approximately more than double the capacity to ensure more than enough space.\n                let newCap := add(cap, or(cap, newArrBytesLen))\n                // If the memory is contiguous, we can simply expand it.\n                if iszero(or(xor(mload(0x40), add(arrData, add(0x20, cap))), iszero(cap))) {\n                    mstore(sub(arrData, 0x20), mul(prime, newCap)) // Store the capacity.\n                    mstore(0x40, add(arrData, add(0x20, newCap))) // Expand the memory allocation.\n                    break\n                }\n                // Set the `newArrData` to point to the word after `cap`.\n                let newArrData := add(mload(0x40), 0x20)\n                mstore(0x40, add(newArrData, add(0x20, newCap))) // Reallocate the memory.\n                mstore(a, newArrData) // Store the `newArrData`.\n                let w := not(0x1f)\n                // Copy `arrData` one word at a time, backwards.\n                for { let o := newArrBytesLen } 1 {} {\n                    mstore(add(newArrData, o), mload(add(arrData, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                mstore(add(newArrData, w), mul(prime, newCap)) // Store the memory.\n                arrData := newArrData // Assign `newArrData` to `arrData`.\n                break\n            }\n            mstore(add(arrData, newArrBytesLen), data) // Append `data`.\n            mstore(arrData, newArrLen) // Store the length.\n        }\n    }",
            "startLine": 546
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "data",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(DynamicArray memory a, address data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = p(a, uint256(uint160(data)));\n    }",
            "startLine": 598
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "data",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toUint",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(DynamicArray memory a, bool data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = p(a, _toUint(data));\n    }",
            "startLine": 608
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "data",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(DynamicArray memory a, bytes32 data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = p(a, uint256(data));\n    }",
            "startLine": 618
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function p() internal pure returns (DynamicArray memory result) {}",
            "startLine": 628
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(uint256 data) internal pure returns (DynamicArray memory result) {\n        p(result, uint256(data));\n    }",
            "startLine": 631
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(address data) internal pure returns (DynamicArray memory result) {\n        p(result, uint256(uint160(data)));\n    }",
            "startLine": 636
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toUint",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(bool data) internal pure returns (DynamicArray memory result) {\n        p(result, _toUint(data));\n    }",
            "startLine": 641
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(bytes32 data) internal pure returns (DynamicArray memory result) {\n        p(result, uint256(data));\n    }",
            "startLine": 646
          },
          {
            "name": "pop",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function pop(DynamicArray memory a) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := mload(a)\n            let n := mload(o)\n            result := mload(add(o, shl(5, n)))\n            mstore(o, sub(n, iszero(iszero(n))))\n        }\n    }",
            "startLine": 652
          },
          {
            "name": "popUint256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function popUint256(DynamicArray memory a) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := mload(a)\n            let n := mload(o)\n            result := mload(add(o, shl(5, n)))\n            mstore(o, sub(n, iszero(iszero(n))))\n        }\n    }",
            "startLine": 664
          },
          {
            "name": "popAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function popAddress(DynamicArray memory a) internal pure returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := mload(a)\n            let n := mload(o)\n            result := mload(add(o, shl(5, n)))\n            mstore(o, sub(n, iszero(iszero(n))))\n        }\n    }",
            "startLine": 676
          },
          {
            "name": "popBool",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function popBool(DynamicArray memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := mload(a)\n            let n := mload(o)\n            result := mload(add(o, shl(5, n)))\n            mstore(o, sub(n, iszero(iszero(n))))\n        }\n    }",
            "startLine": 688
          },
          {
            "name": "popBytes32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function popBytes32(DynamicArray memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := mload(a)\n            let n := mload(o)\n            result := mload(add(o, shl(5, n)))\n            mstore(o, sub(n, iszero(iszero(n))))\n        }\n    }",
            "startLine": 700
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(DynamicArray memory a, uint256 i) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(mload(a), 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 711
          },
          {
            "name": "getUint256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getUint256(DynamicArray memory a, uint256 i) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(mload(a), 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 719
          },
          {
            "name": "getAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getAddress(DynamicArray memory a, uint256 i) internal pure returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(mload(a), 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 727
          },
          {
            "name": "getBool",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getBool(DynamicArray memory a, uint256 i) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(mload(a), 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 735
          },
          {
            "name": "getBytes32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getBytes32(DynamicArray memory a, uint256 i) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(mload(a), 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 743
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "i",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(DynamicArray memory a, uint256 i, uint256 data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(mload(result), 0x20), shl(5, i)), data)\n        }\n    }",
            "startLine": 751
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "i",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(DynamicArray memory a, uint256 i, address data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(mload(result), 0x20), shl(5, i)), shr(96, shl(96, data)))\n        }\n    }",
            "startLine": 765
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "i",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(DynamicArray memory a, uint256 i, bool data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(mload(result), 0x20), shl(5, i)), iszero(iszero(data)))\n        }\n    }",
            "startLine": 779
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "i",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(DynamicArray memory a, uint256 i, bytes32 data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(mload(result), 0x20), shl(5, i)), data)\n        }\n    }",
            "startLine": 793
          },
          {
            "name": "asUint256Array",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function asUint256Array(DynamicArray memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(a)\n        }\n    }",
            "startLine": 807
          },
          {
            "name": "asAddressArray",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function asAddressArray(DynamicArray memory a) internal pure returns (address[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(a)\n        }\n    }",
            "startLine": 815
          },
          {
            "name": "asBoolArray",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function asBoolArray(DynamicArray memory a) internal pure returns (bool[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(a)\n        }\n    }",
            "startLine": 823
          },
          {
            "name": "asBytes32Array",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function asBytes32Array(DynamicArray memory a) internal pure returns (bytes32[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(a)\n        }\n    }",
            "startLine": 831
          },
          {
            "name": "slice",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "slice",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function slice(DynamicArray memory a, uint256 start, uint256 end)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        result.data = slice(a.data, start, end);\n    }",
            "startLine": 839
          },
          {
            "name": "slice",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "slice",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function slice(DynamicArray memory a, uint256 start)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        result.data = slice(a.data, start, type(uint256).max);\n    }",
            "startLine": 848
          },
          {
            "name": "copy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "copy",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function copy(DynamicArray memory a) internal pure returns (DynamicArray memory result) {\n        result.data = copy(a.data);\n    }",
            "startLine": 857
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(DynamicArray memory a, uint256 needle) internal pure returns (bool) {\n        return ~indexOf(a.data, needle, 0) != 0;\n    }",
            "startLine": 862
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(DynamicArray memory a, address needle) internal pure returns (bool) {\n        return ~indexOf(a.data, uint160(needle), 0) != 0;\n    }",
            "startLine": 867
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(DynamicArray memory a, bytes32 needle) internal pure returns (bool) {\n        return ~indexOf(a.data, uint256(needle), 0) != 0;\n    }",
            "startLine": 872
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "uint256"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(DynamicArray memory a, uint256 needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return indexOf(a.data, needle, from);\n    }",
            "startLine": 878
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "address"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(DynamicArray memory a, address needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return indexOf(a.data, uint160(needle), from);\n    }",
            "startLine": 888
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "bytes32"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(DynamicArray memory a, bytes32 needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return indexOf(a.data, uint256(needle), from);\n    }",
            "startLine": 898
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(DynamicArray memory a, uint256 needle) internal pure returns (uint256) {\n        return indexOf(a.data, needle, 0);\n    }",
            "startLine": 908
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(DynamicArray memory a, address needle) internal pure returns (uint256) {\n        return indexOf(a.data, uint160(needle), 0);\n    }",
            "startLine": 914
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(DynamicArray memory a, bytes32 needle) internal pure returns (uint256) {\n        return indexOf(a.data, uint256(needle), 0);\n    }",
            "startLine": 920
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "uint256"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "lastIndexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(DynamicArray memory a, uint256 needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(a.data, needle, from);\n    }",
            "startLine": 926
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "address"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "lastIndexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(DynamicArray memory a, address needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(a.data, uint160(needle), from);\n    }",
            "startLine": 936
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "bytes32"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "lastIndexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(DynamicArray memory a, bytes32 needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(a.data, uint256(needle), from);\n    }",
            "startLine": 946
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "lastIndexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(DynamicArray memory a, uint256 needle) internal pure returns (uint256) {\n        return lastIndexOf(a.data, needle, NOT_FOUND);\n    }",
            "startLine": 956
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "lastIndexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(DynamicArray memory a, address needle) internal pure returns (uint256) {\n        return lastIndexOf(a.data, uint160(needle), NOT_FOUND);\n    }",
            "startLine": 962
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "lastIndexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(DynamicArray memory a, bytes32 needle) internal pure returns (uint256) {\n        return lastIndexOf(a.data, uint256(needle), NOT_FOUND);\n    }",
            "startLine": 968
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(DynamicArray memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(mload(a), 0x20), shl(5, mload(mload(a))))\n        }\n    }",
            "startLine": 973
          },
          {
            "name": "directReturn",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function directReturn(DynamicArray memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let arrData := mload(a)\n            let retStart := sub(arrData, 0x20)\n            mstore(retStart, 0x20)\n            return(retStart, add(0x40, shl(5, mload(arrData))))\n        }\n    }",
            "startLine": 981
          },
          {
            "name": "_deallocate",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _deallocate(DynamicArray memory result) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Deallocate, as we have already allocated.\n        }\n    }",
            "startLine": 996
          },
          {
            "name": "_toUint",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "b",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toUint(bool b) private pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(iszero(b))\n        }\n    }",
            "startLine": 1004
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "DynamicArray",
            "members": [
              {
                "name": "data",
                "type": "uint256[]"
              }
            ],
            "startLine": 14
          }
        ],
        "stateVariables": [
          {
            "name": "NOT_FOUND",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 23
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "DynamicBufferLib",
        "filePath": "utils/DynamicBufferLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function length(DynamicBuffer memory buffer) internal pure returns (uint256) {\n        return buffer.data.length;\n    }",
            "startLine": 27
          },
          {
            "name": "reserve",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "minimum",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function reserve(DynamicBuffer memory buffer, uint256 minimum)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = buffer;\n        uint256 n = buffer.data.length;\n        if (minimum > n) {\n            uint256 i = 0x40;\n            do {} while ((i <<= 1) < minimum);\n            bytes memory data;\n            /// @solidity memory-safe-assembly\n            assembly {\n                data := 0x01\n                mstore(data, sub(i, n))\n            }\n            result = p(result, data);\n        }\n    }",
            "startLine": 32
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clear(DynamicBuffer memory buffer)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(mload(buffer), 0)\n        }\n        result = buffer;\n    }",
            "startLine": 54
          },
          {
            "name": "s",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function s(DynamicBuffer memory buffer) internal pure returns (string memory) {\n        return string(buffer.data);\n    }",
            "startLine": 69
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(DynamicBuffer memory buffer, bytes memory data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = buffer;\n        if (data.length == uint256(0)) return result;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let bufData := mload(buffer)\n            let bufDataLen := mload(bufData)\n            let newBufDataLen := add(mload(data), bufDataLen)\n            // Some random prime number to multiply `cap`, so that\n            // we know that the `cap` is for a dynamic buffer.\n            // Selected to be larger than any memory pointer realistically.\n            let prime := 1621250193422201\n            let cap := mload(add(bufData, w)) // `mload(sub(bufData, 0x20))`.\n            // Extract `cap`, initializing it to zero if it is not a multiple of `prime`.\n            cap := mul(div(cap, prime), iszero(mod(cap, prime)))\n\n            // Expand / Reallocate memory if required.\n            // Note that we need to allocate an extra word for the length, and\n            // and another extra word as a safety word (giving a total of 0x40 bytes).\n            // Without the safety word, the backwards copying can cause a buffer overflow.\n            for {} iszero(lt(newBufDataLen, cap)) {} {\n                // Approximately more than double the capacity to ensure more than enough space.\n                let newCap := and(add(cap, add(or(cap, newBufDataLen), 0x20)), w)\n                // If the memory is contiguous, we can simply expand it.\n                if iszero(or(xor(mload(0x40), add(bufData, add(0x40, cap))), iszero(cap))) {\n                    // Store `cap * prime` in the word before the length.\n                    mstore(add(bufData, w), mul(prime, newCap))\n                    mstore(0x40, add(bufData, add(0x40, newCap))) // Expand the memory allocation.\n                    break\n                }\n                // Set the `newBufData` to point to the word after `cap`.\n                let newBufData := add(mload(0x40), 0x20)\n                mstore(0x40, add(newBufData, add(0x40, newCap))) // Reallocate the memory.\n                mstore(buffer, newBufData) // Store the `newBufData`.\n                // Copy `bufData` one word at a time, backwards.\n                for { let o := and(add(bufDataLen, 0x20), w) } 1 {} {\n                    mstore(add(newBufData, o), mload(add(bufData, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Store `cap * prime` in the word before the length.\n                mstore(add(newBufData, w), mul(prime, newCap))\n                bufData := newBufData // Assign `newBufData` to `bufData`.\n                break\n            }\n            // If it's a reserve operation, set the variables to skip the appending.\n            if eq(data, 0x01) {\n                mstore(data, 0x00)\n                newBufDataLen := bufDataLen\n            }\n            // Copy `data` one word at a time, backwards.\n            for { let o := and(add(mload(data), 0x20), w) } 1 {} {\n                mstore(add(add(bufData, bufDataLen), o), mload(add(data, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            mstore(add(add(bufData, 0x20), newBufDataLen), 0) // Zeroize the word after the buffer.\n            mstore(bufData, newBufDataLen) // Store the length.\n        }\n    }",
            "startLine": 74
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(DynamicBuffer memory buffer, bytes memory data0, bytes memory data1)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(p(buffer, data0), data1);\n    }",
            "startLine": 142
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(buffer, data0), data1), data2);\n    }",
            "startLine": 152
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              },
              {
                "name": "data3",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(p(buffer, data0), data1), data2), data3);\n    }",
            "startLine": 163
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              },
              {
                "name": "data3",
                "type": "bytes"
              },
              {
                "name": "data4",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(p(p(buffer, data0), data1), data2), data3), data4);\n    }",
            "startLine": 175
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              },
              {
                "name": "data3",
                "type": "bytes"
              },
              {
                "name": "data4",
                "type": "bytes"
              },
              {
                "name": "data5",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4,\n        bytes memory data5\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(p(p(p(buffer, data0), data1), data2), data3), data4), data5);\n    }",
            "startLine": 188
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              },
              {
                "name": "data3",
                "type": "bytes"
              },
              {
                "name": "data4",
                "type": "bytes"
              },
              {
                "name": "data5",
                "type": "bytes"
              },
              {
                "name": "data6",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4,\n        bytes memory data5,\n        bytes memory data6\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(p(p(p(p(buffer, data0), data1), data2), data3), data4), data5), data6);\n    }",
            "startLine": 202
          },
          {
            "name": "pBool",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBool(DynamicBuffer memory buffer, bool data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        uint256 casted;\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := iszero(iszero(data))\n        }\n        result = p(buffer, _single(casted, 1));\n    }",
            "startLine": 217
          },
          {
            "name": "pAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pAddress(DynamicBuffer memory buffer, address data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(uint256(uint160(data)), 20));\n    }",
            "startLine": 232
          },
          {
            "name": "pUint8",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint8(DynamicBuffer memory buffer, uint8 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 1));\n    }",
            "startLine": 242
          },
          {
            "name": "pUint16",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint16"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint16(DynamicBuffer memory buffer, uint16 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 2));\n    }",
            "startLine": 252
          },
          {
            "name": "pUint24",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint24"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint24(DynamicBuffer memory buffer, uint24 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 3));\n    }",
            "startLine": 262
          },
          {
            "name": "pUint32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint32(DynamicBuffer memory buffer, uint32 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 4));\n    }",
            "startLine": 272
          },
          {
            "name": "pUint40",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint40"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint40(DynamicBuffer memory buffer, uint40 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 5));\n    }",
            "startLine": 282
          },
          {
            "name": "pUint48",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint48"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint48(DynamicBuffer memory buffer, uint48 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 6));\n    }",
            "startLine": 292
          },
          {
            "name": "pUint56",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint56"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint56(DynamicBuffer memory buffer, uint56 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 7));\n    }",
            "startLine": 302
          },
          {
            "name": "pUint64",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint64(DynamicBuffer memory buffer, uint64 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 8));\n    }",
            "startLine": 312
          },
          {
            "name": "pUint72",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint72"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint72(DynamicBuffer memory buffer, uint72 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 9));\n    }",
            "startLine": 322
          },
          {
            "name": "pUint80",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint80"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint80(DynamicBuffer memory buffer, uint80 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 10));\n    }",
            "startLine": 332
          },
          {
            "name": "pUint88",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint88"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint88(DynamicBuffer memory buffer, uint88 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 11));\n    }",
            "startLine": 342
          },
          {
            "name": "pUint96",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint96"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint96(DynamicBuffer memory buffer, uint96 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 12));\n    }",
            "startLine": 352
          },
          {
            "name": "pUint104",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint104"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint104(DynamicBuffer memory buffer, uint104 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 13));\n    }",
            "startLine": 362
          },
          {
            "name": "pUint112",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint112"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint112(DynamicBuffer memory buffer, uint112 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 14));\n    }",
            "startLine": 372
          },
          {
            "name": "pUint120",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint120"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint120(DynamicBuffer memory buffer, uint120 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 15));\n    }",
            "startLine": 382
          },
          {
            "name": "pUint128",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint128"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint128(DynamicBuffer memory buffer, uint128 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 16));\n    }",
            "startLine": 392
          },
          {
            "name": "pUint136",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint136"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint136(DynamicBuffer memory buffer, uint136 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 17));\n    }",
            "startLine": 402
          },
          {
            "name": "pUint144",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint144"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint144(DynamicBuffer memory buffer, uint144 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 18));\n    }",
            "startLine": 412
          },
          {
            "name": "pUint152",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint152"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint152(DynamicBuffer memory buffer, uint152 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 19));\n    }",
            "startLine": 422
          },
          {
            "name": "pUint160",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint160"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint160(DynamicBuffer memory buffer, uint160 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 20));\n    }",
            "startLine": 432
          },
          {
            "name": "pUint168",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint168"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint168(DynamicBuffer memory buffer, uint168 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 21));\n    }",
            "startLine": 442
          },
          {
            "name": "pUint176",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint176"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint176(DynamicBuffer memory buffer, uint176 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 22));\n    }",
            "startLine": 452
          },
          {
            "name": "pUint184",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint184"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint184(DynamicBuffer memory buffer, uint184 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 23));\n    }",
            "startLine": 462
          },
          {
            "name": "pUint192",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint192"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint192(DynamicBuffer memory buffer, uint192 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 24));\n    }",
            "startLine": 472
          },
          {
            "name": "pUint200",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint200"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint200(DynamicBuffer memory buffer, uint200 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 25));\n    }",
            "startLine": 482
          },
          {
            "name": "pUint208",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint208"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint208(DynamicBuffer memory buffer, uint208 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 26));\n    }",
            "startLine": 492
          },
          {
            "name": "pUint216",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint216"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint216(DynamicBuffer memory buffer, uint216 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 27));\n    }",
            "startLine": 502
          },
          {
            "name": "pUint224",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint224"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint224(DynamicBuffer memory buffer, uint224 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 28));\n    }",
            "startLine": 512
          },
          {
            "name": "pUint232",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint232"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint232(DynamicBuffer memory buffer, uint232 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 29));\n    }",
            "startLine": 522
          },
          {
            "name": "pUint240",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint240"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint240(DynamicBuffer memory buffer, uint240 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 30));\n    }",
            "startLine": 532
          },
          {
            "name": "pUint248",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint248"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint248(DynamicBuffer memory buffer, uint248 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 31));\n    }",
            "startLine": 542
          },
          {
            "name": "pUint256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint256(DynamicBuffer memory buffer, uint256 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 32));\n    }",
            "startLine": 552
          },
          {
            "name": "pBytes1",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes1"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes1(DynamicBuffer memory buffer, bytes1 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 1));\n    }",
            "startLine": 562
          },
          {
            "name": "pBytes2",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes2"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes2(DynamicBuffer memory buffer, bytes2 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 2));\n    }",
            "startLine": 572
          },
          {
            "name": "pBytes3",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes3"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes3(DynamicBuffer memory buffer, bytes3 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 3));\n    }",
            "startLine": 582
          },
          {
            "name": "pBytes4",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes4(DynamicBuffer memory buffer, bytes4 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 4));\n    }",
            "startLine": 592
          },
          {
            "name": "pBytes5",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes5"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes5(DynamicBuffer memory buffer, bytes5 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 5));\n    }",
            "startLine": 602
          },
          {
            "name": "pBytes6",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes6"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes6(DynamicBuffer memory buffer, bytes6 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 6));\n    }",
            "startLine": 612
          },
          {
            "name": "pBytes7",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes7"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes7(DynamicBuffer memory buffer, bytes7 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 7));\n    }",
            "startLine": 622
          },
          {
            "name": "pBytes8",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes8"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes8(DynamicBuffer memory buffer, bytes8 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 8));\n    }",
            "startLine": 632
          },
          {
            "name": "pBytes9",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes9"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes9(DynamicBuffer memory buffer, bytes9 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 9));\n    }",
            "startLine": 642
          },
          {
            "name": "pBytes10",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes10"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes10(DynamicBuffer memory buffer, bytes10 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 10));\n    }",
            "startLine": 652
          },
          {
            "name": "pBytes11",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes11"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes11(DynamicBuffer memory buffer, bytes11 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 11));\n    }",
            "startLine": 662
          },
          {
            "name": "pBytes12",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes12"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes12(DynamicBuffer memory buffer, bytes12 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 12));\n    }",
            "startLine": 672
          },
          {
            "name": "pBytes13",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes13"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes13(DynamicBuffer memory buffer, bytes13 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 13));\n    }",
            "startLine": 682
          },
          {
            "name": "pBytes14",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes14"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes14(DynamicBuffer memory buffer, bytes14 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 14));\n    }",
            "startLine": 692
          },
          {
            "name": "pBytes15",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes15"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes15(DynamicBuffer memory buffer, bytes15 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 15));\n    }",
            "startLine": 702
          },
          {
            "name": "pBytes16",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes16"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes16(DynamicBuffer memory buffer, bytes16 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 16));\n    }",
            "startLine": 712
          },
          {
            "name": "pBytes17",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes17"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes17(DynamicBuffer memory buffer, bytes17 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 17));\n    }",
            "startLine": 722
          },
          {
            "name": "pBytes18",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes18"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes18(DynamicBuffer memory buffer, bytes18 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 18));\n    }",
            "startLine": 732
          },
          {
            "name": "pBytes19",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes19"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes19(DynamicBuffer memory buffer, bytes19 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 19));\n    }",
            "startLine": 742
          },
          {
            "name": "pBytes20",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes20"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes20(DynamicBuffer memory buffer, bytes20 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 20));\n    }",
            "startLine": 752
          },
          {
            "name": "pBytes21",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes21"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes21(DynamicBuffer memory buffer, bytes21 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 21));\n    }",
            "startLine": 762
          },
          {
            "name": "pBytes22",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes22"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes22(DynamicBuffer memory buffer, bytes22 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 22));\n    }",
            "startLine": 772
          },
          {
            "name": "pBytes23",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes23"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes23(DynamicBuffer memory buffer, bytes23 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 23));\n    }",
            "startLine": 782
          },
          {
            "name": "pBytes24",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes24"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes24(DynamicBuffer memory buffer, bytes24 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 24));\n    }",
            "startLine": 792
          },
          {
            "name": "pBytes25",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes25"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes25(DynamicBuffer memory buffer, bytes25 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 25));\n    }",
            "startLine": 802
          },
          {
            "name": "pBytes26",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes26"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes26(DynamicBuffer memory buffer, bytes26 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 26));\n    }",
            "startLine": 812
          },
          {
            "name": "pBytes27",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes27"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes27(DynamicBuffer memory buffer, bytes27 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 27));\n    }",
            "startLine": 822
          },
          {
            "name": "pBytes28",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes28"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes28(DynamicBuffer memory buffer, bytes28 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 28));\n    }",
            "startLine": 832
          },
          {
            "name": "pBytes29",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes29"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes29(DynamicBuffer memory buffer, bytes29 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 29));\n    }",
            "startLine": 842
          },
          {
            "name": "pBytes30",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes30"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes30(DynamicBuffer memory buffer, bytes30 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 30));\n    }",
            "startLine": 852
          },
          {
            "name": "pBytes31",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes31"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes31(DynamicBuffer memory buffer, bytes31 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 31));\n    }",
            "startLine": 862
          },
          {
            "name": "pBytes32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes32(DynamicBuffer memory buffer, bytes32 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 32));\n    }",
            "startLine": 872
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function p() internal pure returns (DynamicBuffer memory result) {}",
            "startLine": 882
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(bytes memory data) internal pure returns (DynamicBuffer memory result) {\n        p(result, data);\n    }",
            "startLine": 885
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(bytes memory data0, bytes memory data1)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        p(p(result, data0), data1);\n    }",
            "startLine": 890
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(bytes memory data0, bytes memory data1, bytes memory data2)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        p(p(p(result, data0), data1), data2);\n    }",
            "startLine": 899
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              },
              {
                "name": "data3",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        p(p(p(p(result, data0), data1), data2), data3);\n    }",
            "startLine": 908
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              },
              {
                "name": "data3",
                "type": "bytes"
              },
              {
                "name": "data4",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4\n    ) internal pure returns (DynamicBuffer memory result) {\n        p(p(p(p(p(result, data0), data1), data2), data3), data4);\n    }",
            "startLine": 917
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              },
              {
                "name": "data3",
                "type": "bytes"
              },
              {
                "name": "data4",
                "type": "bytes"
              },
              {
                "name": "data5",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4,\n        bytes memory data5\n    ) internal pure returns (DynamicBuffer memory result) {\n        p(p(p(p(p(p(result, data0), data1), data2), data3), data4), data5);\n    }",
            "startLine": 928
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              },
              {
                "name": "data3",
                "type": "bytes"
              },
              {
                "name": "data4",
                "type": "bytes"
              },
              {
                "name": "data5",
                "type": "bytes"
              },
              {
                "name": "data6",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4,\n        bytes memory data5,\n        bytes memory data6\n    ) internal pure returns (DynamicBuffer memory result) {\n        p(p(p(p(p(p(p(result, data0), data1), data2), data3), data4), data5), data6);\n    }",
            "startLine": 940
          },
          {
            "name": "pBool",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBool",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBool(bool data) internal pure returns (DynamicBuffer memory result) {\n        pBool(result, data);\n    }",
            "startLine": 953
          },
          {
            "name": "pAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pAddress",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pAddress(address data) internal pure returns (DynamicBuffer memory result) {\n        pAddress(result, data);\n    }",
            "startLine": 958
          },
          {
            "name": "pUint8",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint8",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint8(uint8 data) internal pure returns (DynamicBuffer memory result) {\n        pUint8(result, data);\n    }",
            "startLine": 963
          },
          {
            "name": "pUint16",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint16"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint16",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint16(uint16 data) internal pure returns (DynamicBuffer memory result) {\n        pUint16(result, data);\n    }",
            "startLine": 968
          },
          {
            "name": "pUint24",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint24"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint24",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint24(uint24 data) internal pure returns (DynamicBuffer memory result) {\n        pUint24(result, data);\n    }",
            "startLine": 973
          },
          {
            "name": "pUint32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint32",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint32(uint32 data) internal pure returns (DynamicBuffer memory result) {\n        pUint32(result, data);\n    }",
            "startLine": 978
          },
          {
            "name": "pUint40",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint40"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint40",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint40(uint40 data) internal pure returns (DynamicBuffer memory result) {\n        pUint40(result, data);\n    }",
            "startLine": 983
          },
          {
            "name": "pUint48",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint48"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint48",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint48(uint48 data) internal pure returns (DynamicBuffer memory result) {\n        pUint48(result, data);\n    }",
            "startLine": 988
          },
          {
            "name": "pUint56",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint56"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint56",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint56(uint56 data) internal pure returns (DynamicBuffer memory result) {\n        pUint56(result, data);\n    }",
            "startLine": 993
          },
          {
            "name": "pUint64",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint64",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint64(uint64 data) internal pure returns (DynamicBuffer memory result) {\n        pUint64(result, data);\n    }",
            "startLine": 998
          },
          {
            "name": "pUint72",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint72"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint72",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint72(uint72 data) internal pure returns (DynamicBuffer memory result) {\n        pUint72(result, data);\n    }",
            "startLine": 1003
          },
          {
            "name": "pUint80",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint80"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint80",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint80(uint80 data) internal pure returns (DynamicBuffer memory result) {\n        pUint80(result, data);\n    }",
            "startLine": 1008
          },
          {
            "name": "pUint88",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint88"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint88",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint88(uint88 data) internal pure returns (DynamicBuffer memory result) {\n        pUint88(result, data);\n    }",
            "startLine": 1013
          },
          {
            "name": "pUint96",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint96"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint96",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint96(uint96 data) internal pure returns (DynamicBuffer memory result) {\n        pUint96(result, data);\n    }",
            "startLine": 1018
          },
          {
            "name": "pUint104",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint104"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint104",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint104(uint104 data) internal pure returns (DynamicBuffer memory result) {\n        pUint104(result, data);\n    }",
            "startLine": 1023
          },
          {
            "name": "pUint112",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint112"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint112",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint112(uint112 data) internal pure returns (DynamicBuffer memory result) {\n        pUint112(result, data);\n    }",
            "startLine": 1028
          },
          {
            "name": "pUint120",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint120"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint120",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint120(uint120 data) internal pure returns (DynamicBuffer memory result) {\n        pUint120(result, data);\n    }",
            "startLine": 1033
          },
          {
            "name": "pUint128",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint128"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint128",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint128(uint128 data) internal pure returns (DynamicBuffer memory result) {\n        pUint128(result, data);\n    }",
            "startLine": 1038
          },
          {
            "name": "pUint136",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint136"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint136",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint136(uint136 data) internal pure returns (DynamicBuffer memory result) {\n        pUint136(result, data);\n    }",
            "startLine": 1043
          },
          {
            "name": "pUint144",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint144"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint144",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint144(uint144 data) internal pure returns (DynamicBuffer memory result) {\n        pUint144(result, data);\n    }",
            "startLine": 1048
          },
          {
            "name": "pUint152",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint152"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint152",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint152(uint152 data) internal pure returns (DynamicBuffer memory result) {\n        pUint152(result, data);\n    }",
            "startLine": 1053
          },
          {
            "name": "pUint160",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint160"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint160",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint160(uint160 data) internal pure returns (DynamicBuffer memory result) {\n        pUint160(result, data);\n    }",
            "startLine": 1058
          },
          {
            "name": "pUint168",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint168"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint168",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint168(uint168 data) internal pure returns (DynamicBuffer memory result) {\n        pUint168(result, data);\n    }",
            "startLine": 1063
          },
          {
            "name": "pUint176",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint176"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint176",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint176(uint176 data) internal pure returns (DynamicBuffer memory result) {\n        pUint176(result, data);\n    }",
            "startLine": 1068
          },
          {
            "name": "pUint184",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint184"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint184",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint184(uint184 data) internal pure returns (DynamicBuffer memory result) {\n        pUint184(result, data);\n    }",
            "startLine": 1073
          },
          {
            "name": "pUint192",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint192"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint192",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint192(uint192 data) internal pure returns (DynamicBuffer memory result) {\n        pUint192(result, data);\n    }",
            "startLine": 1078
          },
          {
            "name": "pUint200",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint200"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint200",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint200(uint200 data) internal pure returns (DynamicBuffer memory result) {\n        pUint200(result, data);\n    }",
            "startLine": 1083
          },
          {
            "name": "pUint208",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint208"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint208",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint208(uint208 data) internal pure returns (DynamicBuffer memory result) {\n        pUint208(result, data);\n    }",
            "startLine": 1088
          },
          {
            "name": "pUint216",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint216"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint216",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint216(uint216 data) internal pure returns (DynamicBuffer memory result) {\n        pUint216(result, data);\n    }",
            "startLine": 1093
          },
          {
            "name": "pUint224",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint224"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint224",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint224(uint224 data) internal pure returns (DynamicBuffer memory result) {\n        pUint224(result, data);\n    }",
            "startLine": 1098
          },
          {
            "name": "pUint232",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint232"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint232",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint232(uint232 data) internal pure returns (DynamicBuffer memory result) {\n        pUint232(result, data);\n    }",
            "startLine": 1103
          },
          {
            "name": "pUint240",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint240"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint240",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint240(uint240 data) internal pure returns (DynamicBuffer memory result) {\n        pUint240(result, data);\n    }",
            "startLine": 1108
          },
          {
            "name": "pUint248",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint248"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint248",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint248(uint248 data) internal pure returns (DynamicBuffer memory result) {\n        pUint248(result, data);\n    }",
            "startLine": 1113
          },
          {
            "name": "pUint256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint256",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint256(uint256 data) internal pure returns (DynamicBuffer memory result) {\n        pUint256(result, data);\n    }",
            "startLine": 1118
          },
          {
            "name": "pBytes1",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes1"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes1",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes1(bytes1 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes1(result, data);\n    }",
            "startLine": 1123
          },
          {
            "name": "pBytes2",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes2"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes2",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes2(bytes2 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes2(result, data);\n    }",
            "startLine": 1128
          },
          {
            "name": "pBytes3",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes3"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes3",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes3(bytes3 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes3(result, data);\n    }",
            "startLine": 1133
          },
          {
            "name": "pBytes4",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes4",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes4(bytes4 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes4(result, data);\n    }",
            "startLine": 1138
          },
          {
            "name": "pBytes5",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes5"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes5",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes5(bytes5 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes5(result, data);\n    }",
            "startLine": 1143
          },
          {
            "name": "pBytes6",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes6"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes6",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes6(bytes6 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes6(result, data);\n    }",
            "startLine": 1148
          },
          {
            "name": "pBytes7",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes7"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes7",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes7(bytes7 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes7(result, data);\n    }",
            "startLine": 1153
          },
          {
            "name": "pBytes8",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes8"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes8",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes8(bytes8 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes8(result, data);\n    }",
            "startLine": 1158
          },
          {
            "name": "pBytes9",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes9"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes9",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes9(bytes9 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes9(result, data);\n    }",
            "startLine": 1163
          },
          {
            "name": "pBytes10",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes10"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes10",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes10(bytes10 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes10(result, data);\n    }",
            "startLine": 1168
          },
          {
            "name": "pBytes11",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes11"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes11",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes11(bytes11 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes11(result, data);\n    }",
            "startLine": 1173
          },
          {
            "name": "pBytes12",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes12"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes12",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes12(bytes12 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes12(result, data);\n    }",
            "startLine": 1178
          },
          {
            "name": "pBytes13",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes13"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes13",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes13(bytes13 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes13(result, data);\n    }",
            "startLine": 1183
          },
          {
            "name": "pBytes14",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes14"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes14",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes14(bytes14 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes14(result, data);\n    }",
            "startLine": 1188
          },
          {
            "name": "pBytes15",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes15"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes15",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes15(bytes15 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes15(result, data);\n    }",
            "startLine": 1193
          },
          {
            "name": "pBytes16",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes16"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes16",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes16(bytes16 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes16(result, data);\n    }",
            "startLine": 1198
          },
          {
            "name": "pBytes17",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes17"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes17",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes17(bytes17 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes17(result, data);\n    }",
            "startLine": 1203
          },
          {
            "name": "pBytes18",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes18"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes18",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes18(bytes18 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes18(result, data);\n    }",
            "startLine": 1208
          },
          {
            "name": "pBytes19",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes19"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes19",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes19(bytes19 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes19(result, data);\n    }",
            "startLine": 1213
          },
          {
            "name": "pBytes20",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes20"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes20",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes20(bytes20 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes20(result, data);\n    }",
            "startLine": 1218
          },
          {
            "name": "pBytes21",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes21"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes21",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes21(bytes21 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes21(result, data);\n    }",
            "startLine": 1223
          },
          {
            "name": "pBytes22",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes22"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes22",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes22(bytes22 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes22(result, data);\n    }",
            "startLine": 1228
          },
          {
            "name": "pBytes23",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes23"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes23",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes23(bytes23 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes23(result, data);\n    }",
            "startLine": 1233
          },
          {
            "name": "pBytes24",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes24"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes24",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes24(bytes24 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes24(result, data);\n    }",
            "startLine": 1238
          },
          {
            "name": "pBytes25",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes25"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes25",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes25(bytes25 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes25(result, data);\n    }",
            "startLine": 1243
          },
          {
            "name": "pBytes26",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes26"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes26",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes26(bytes26 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes26(result, data);\n    }",
            "startLine": 1248
          },
          {
            "name": "pBytes27",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes27"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes27",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes27(bytes27 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes27(result, data);\n    }",
            "startLine": 1253
          },
          {
            "name": "pBytes28",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes28"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes28",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes28(bytes28 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes28(result, data);\n    }",
            "startLine": 1258
          },
          {
            "name": "pBytes29",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes29"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes29",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes29(bytes29 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes29(result, data);\n    }",
            "startLine": 1263
          },
          {
            "name": "pBytes30",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes30"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes30",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes30(bytes30 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes30(result, data);\n    }",
            "startLine": 1268
          },
          {
            "name": "pBytes31",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes31"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes31",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes31(bytes31 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes31(result, data);\n    }",
            "startLine": 1273
          },
          {
            "name": "pBytes32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes32",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes32(bytes32 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes32(result, data);\n    }",
            "startLine": 1278
          },
          {
            "name": "_deallocate",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _deallocate(DynamicBuffer memory result) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Deallocate, as we have already allocated.\n        }\n    }",
            "startLine": 1287
          },
          {
            "name": "_single",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint256"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _single(uint256 data, uint256 n) private pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 0x00\n            mstore(n, data)\n            mstore(result, n)\n        }\n    }",
            "startLine": 1295
          },
          {
            "name": "_single",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes32"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _single(bytes32 data, uint256 n) private pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 0x00\n            mstore(0x20, data)\n            mstore(result, n)\n        }\n    }",
            "startLine": 1305
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "DynamicBuffer",
            "members": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "startLine": 15
          }
        ],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "ECDSA",
        "filePath": "utils/ECDSA.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "recover",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            } {\n                switch mload(signature)\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { continue }\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if returndatasize() { break }\n            }\n        }\n    }",
            "startLine": 51
          },
          {
            "name": "recoverCalldata",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function recoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            } {\n                switch signature.length\n                case 64 {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\n                }\n                default { continue }\n                mstore(0x00, hash)\n                result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if returndatasize() { break }\n            }\n        }\n    }",
            "startLine": 81
          },
          {
            "name": "recover",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "vs",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r)\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 116
          },
          {
            "name": "recover",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "v",
                "type": "uint8"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 137
          },
          {
            "name": "tryRecover",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {} {\n                switch mload(signature)\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { break }\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                result := mload(xor(0x60, returndatasize()))\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }",
            "startLine": 171
          },
          {
            "name": "tryRecoverCalldata",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {} {\n                switch signature.length\n                case 64 {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\n                }\n                default { break }\n                mstore(0x00, hash)\n                pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                result := mload(xor(0x60, returndatasize()))\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }",
            "startLine": 203
          },
          {
            "name": "tryRecover",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "vs",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r)\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 236
          },
          {
            "name": "tryRecover",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "v",
                "type": "uint8"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 258
          },
          {
            "name": "toEthSignedMessageHash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }",
            "startLine": 286
          },
          {
            "name": "toEthSignedMessageHash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }",
            "startLine": 300
          },
          {
            "name": "canonicalHash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function canonicalHash(bytes memory signature) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(signature)\n            for {} 1 {} {\n                mstore(0x00, mload(add(signature, 0x20))) // `r`.\n                let s := mload(add(signature, 0x40))\n                let v := mload(add(signature, 0x41))\n                if eq(l, 64) {\n                    v := add(shr(255, s), 27)\n                    s := shr(1, shl(1, s))\n                }\n                if iszero(lt(s, _HALF_N_PLUS_1)) {\n                    v := xor(v, 7)\n                    s := sub(N, s)\n                }\n                mstore(0x21, v)\n                mstore(0x20, s)\n                result := keccak256(0x00, 0x41)\n                mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n                break\n            }\n\n            // If the length is neither 64 nor 65, return a uniquely corrupted hash.\n            if iszero(lt(sub(l, 64), 2)) {\n                // `bytes4(keccak256(\"InvalidSignatureLength\"))`.\n                result := xor(keccak256(add(signature, 0x20), l), 0xd62f1ab2)\n            }\n        }\n    }",
            "startLine": 336
          },
          {
            "name": "canonicalHashCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function canonicalHashCalldata(bytes calldata signature)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                mstore(0x00, calldataload(signature.offset)) // `r`.\n                let s := calldataload(add(signature.offset, 0x20))\n                let v := calldataload(add(signature.offset, 0x21))\n                if eq(signature.length, 64) {\n                    v := add(shr(255, s), 27)\n                    s := shr(1, shl(1, s))\n                }\n                if iszero(lt(s, _HALF_N_PLUS_1)) {\n                    v := xor(v, 7)\n                    s := sub(N, s)\n                }\n                mstore(0x21, v)\n                mstore(0x20, s)\n                result := keccak256(0x00, 0x41)\n                mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n                break\n            }\n            // If the length is neither 64 nor 65, return a uniquely corrupted hash.\n            if iszero(lt(sub(signature.length, 64), 2)) {\n                calldatacopy(mload(0x40), signature.offset, signature.length)\n                // `bytes4(keccak256(\"InvalidSignatureLength\"))`.\n                result := xor(keccak256(mload(0x40), signature.length), 0xd62f1ab2)\n            }\n        }\n    }",
            "startLine": 368
          },
          {
            "name": "canonicalHash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "vs",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function canonicalHash(bytes32 r, bytes32 vs) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, r) // `r`.\n            let v := add(shr(255, vs), 27)\n            let s := shr(1, shl(1, vs))\n            mstore(0x21, v)\n            mstore(0x20, s)\n            result := keccak256(0x00, 0x41)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 403
          },
          {
            "name": "canonicalHash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v",
                "type": "uint8"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function canonicalHash(uint8 v, bytes32 r, bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, r) // `r`.\n            if iszero(lt(s, _HALF_N_PLUS_1)) {\n                v := xor(v, 7)\n                s := sub(N, s)\n            }\n            mstore(0x21, v)\n            mstore(0x20, s)\n            result := keccak256(0x00, 0x41)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 417
          },
          {
            "name": "emptySignature",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }",
            "startLine": 437
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "InvalidSignature",
            "parameters": [],
            "startLine": 44
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "N",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 32
          },
          {
            "name": "_HALF_N_PLUS_1",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 36
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "EIP712",
        "filePath": "utils/EIP712.sol",
        "kind": "abstract",
        "inherits": [],
        "implements": [],
        "category": "utils",
        "externalFunctions": [
          {
            "name": "eip712Domain",
            "signature": "eip712Domain()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "fields",
                "type": "bytes1"
              },
              {
                "name": "name",
                "type": "string"
              },
              {
                "name": "version",
                "type": "string"
              },
              {
                "name": "chainId",
                "type": "uint256"
              },
              {
                "name": "verifyingContract",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "extensions",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "_domainNameAndVersion",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        fields = hex\"0f\"; // `0b01111`.\n        (name, version) = _domainNameAndVersion();\n        chainId = block.chainid;\n        verifyingContract = address(this);\n        salt = salt; // `bytes32(0)`.\n        extensions = extensions; // `new uint256[](0)`.\n    }",
            "startLine": 241
          }
        ],
        "internalFunctions": [
          {
            "name": "constructor",
            "visibility": "default",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_domainNameAndVersionMayChange",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_domainNameAndVersion",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "constructor() {\n        _cachedThis = uint256(uint160(address(this)));\n        _cachedChainId = block.chainid;\n\n        string memory name;\n        string memory version;\n        if (!_domainNameAndVersionMayChange()) (name, version) = _domainNameAndVersion();\n        bytes32 nameHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(name));\n        bytes32 versionHash =\n            _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(version));\n        _cachedNameHash = nameHash;\n        _cachedVersionHash = versionHash;\n\n        bytes32 separator;\n        if (!_domainNameAndVersionMayChange()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let m := mload(0x40) // Load the free memory pointer.\n                mstore(m, _DOMAIN_TYPEHASH)\n                mstore(add(m, 0x20), nameHash)\n                mstore(add(m, 0x40), versionHash)\n                mstore(add(m, 0x60), chainid())\n                mstore(add(m, 0x80), address())\n                separator := keccak256(m, 0xa0)\n            }\n        }\n        _cachedDomainSeparator = separator;\n    }",
            "startLine": 53
          },
          {
            "name": "_domainNameAndVersion",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "name",
                "type": "string"
              },
              {
                "name": "version",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _domainNameAndVersion()\n        internal\n        view\n        virtual\n        returns (string memory name, string memory version);",
            "startLine": 101
          },
          {
            "name": "_domainNameAndVersionMayChange",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}",
            "startLine": 110
          },
          {
            "name": "_domainSeparator",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "separator",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_domainNameAndVersionMayChange",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_buildDomainSeparator",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _domainSeparator() internal view virtual returns (bytes32 separator) {\n        if (_domainNameAndVersionMayChange()) {\n            separator = _buildDomainSeparator();\n        } else {\n            separator = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\n        }\n    }",
            "startLine": 117
          },
          {
            "name": "_hashTypedData",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "structHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "digest",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_domainNameAndVersionMayChange",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_buildDomainSeparator",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\n        // We will use `digest` to store the domain separator to save a bit of gas.\n        if (_domainNameAndVersionMayChange()) {\n            digest = _buildDomainSeparator();\n        } else {\n            digest = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) digest = _buildDomainSeparator();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the digest.\n            mstore(0x00, 0x1901000000000000) // Store \"\\x19\\x01\".\n            mstore(0x1a, digest) // Store the domain separator.\n            mstore(0x3a, structHash) // Store the struct hash.\n            digest := keccak256(0x18, 0x42)\n            // Restore the part of the free memory slot that was overwritten.\n            mstore(0x3a, 0)\n        }\n    }",
            "startLine": 139
          },
          {
            "name": "_hashTypedDataSansChainId",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "structHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "digest",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_domainNameAndVersion",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _hashTypedDataSansChainId(bytes32 structHash)\n        internal\n        view\n        virtual\n        returns (bytes32 digest)\n    {\n        (string memory name, string memory version) = _domainNameAndVersion();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(0x00, _DOMAIN_TYPEHASH_SANS_CHAIN_ID)\n            mstore(0x20, keccak256(add(name, 0x20), mload(name)))\n            mstore(0x40, keccak256(add(version, 0x20), mload(version)))\n            mstore(0x60, address())\n            // Compute the digest.\n            mstore(0x20, keccak256(0x00, 0x80)) // Store the domain separator.\n            mstore(0x00, 0x1901) // Store \"\\x19\\x01\".\n            mstore(0x40, structHash) // Store the struct hash.\n            digest := keccak256(0x1e, 0x42)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }",
            "startLine": 161
          },
          {
            "name": "_hashTypedDataSansChainIdAndVerifyingContract",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "structHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "digest",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_domainNameAndVersion",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _hashTypedDataSansChainIdAndVerifyingContract(bytes32 structHash)\n        internal\n        view\n        virtual\n        returns (bytes32 digest)\n    {\n        (string memory name, string memory version) = _domainNameAndVersion();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(0x00, _DOMAIN_TYPEHASH_SANS_CHAIN_ID_AND_VERIFYING_CONTRACT)\n            mstore(0x20, keccak256(add(name, 0x20), mload(name)))\n            mstore(0x40, keccak256(add(version, 0x20), mload(version)))\n            // Compute the digest.\n            mstore(0x20, keccak256(0x00, 0x60)) // Store the domain separator.\n            mstore(0x00, 0x1901) // Store \"\\x19\\x01\".\n            mstore(0x40, structHash) // Store the struct hash.\n            digest := keccak256(0x1e, 0x42)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }",
            "startLine": 187
          },
          {
            "name": "_hashTypedDataSansVerifyingContract",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "structHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "digest",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_domainNameAndVersion",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _hashTypedDataSansVerifyingContract(bytes32 structHash)\n        internal\n        view\n        virtual\n        returns (bytes32 digest)\n    {\n        (string memory name, string memory version) = _domainNameAndVersion();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(0x00, _DOMAIN_TYPEHASH_SANS_VERIFYING_CONTRACT)\n            mstore(0x20, keccak256(add(name, 0x20), mload(name)))\n            mstore(0x40, keccak256(add(version, 0x20), mload(version)))\n            mstore(0x60, chainid())\n            // Compute the digest.\n            mstore(0x20, keccak256(0x00, 0x80)) // Store the domain separator.\n            mstore(0x00, 0x1901) // Store \"\\x19\\x01\".\n            mstore(0x40, structHash) // Store the struct hash.\n            digest := keccak256(0x1e, 0x42)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }",
            "startLine": 212
          },
          {
            "name": "_buildDomainSeparator",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "separator",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_domainNameAndVersionMayChange",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_domainNameAndVersion",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _buildDomainSeparator() private view returns (bytes32 separator) {\n        // We will use `separator` to store the name hash to save a bit of gas.\n        bytes32 versionHash;\n        if (_domainNameAndVersionMayChange()) {\n            (string memory name, string memory version) = _domainNameAndVersion();\n            separator = keccak256(bytes(name));\n            versionHash = keccak256(bytes(version));\n        } else {\n            separator = _cachedNameHash;\n            versionHash = _cachedVersionHash;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), separator) // Name hash.\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            separator := keccak256(m, 0xa0)\n        }\n    }",
            "startLine": 268
          },
          {
            "name": "_cachedDomainSeparatorInvalidated",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\n        uint256 cachedChainId = _cachedChainId;\n        uint256 cachedThis = _cachedThis;\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\n        }\n    }",
            "startLine": 292
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "_DOMAIN_TYPEHASH",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 21
          },
          {
            "name": "_DOMAIN_TYPEHASH_SANS_CHAIN_ID",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 26
          },
          {
            "name": "_DOMAIN_TYPEHASH_SANS_CHAIN_ID_AND_VERIFYING_CONTRACT",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 31
          },
          {
            "name": "_DOMAIN_TYPEHASH_SANS_VERIFYING_CONTRACT",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 36
          },
          {
            "name": "_cachedThis",
            "type": "uint256",
            "visibility": "private",
            "isConstant": false,
            "isImmutable": true,
            "startLine": 39
          },
          {
            "name": "_cachedChainId",
            "type": "uint256",
            "visibility": "private",
            "isConstant": false,
            "isImmutable": true,
            "startLine": 40
          },
          {
            "name": "_cachedNameHash",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": false,
            "isImmutable": true,
            "startLine": 41
          },
          {
            "name": "_cachedVersionHash",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": false,
            "isImmutable": true,
            "startLine": 42
          },
          {
            "name": "_cachedDomainSeparator",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": false,
            "isImmutable": true,
            "startLine": 43
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "ERC1967Factory",
        "filePath": "utils/ERC1967Factory.sol",
        "kind": "contract",
        "inherits": [],
        "implements": [],
        "category": "utils",
        "externalFunctions": [
          {
            "name": "adminOf",
            "signature": "adminOf(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proxy",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "admin",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function adminOf(address proxy) public view returns (address admin) {\n        assembly {\n            admin := sload(shl(96, proxy))\n        }\n    }",
            "startLine": 77
          },
          {
            "name": "changeAdmin",
            "signature": "changeAdmin(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proxy",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function changeAdmin(address proxy, address admin) public {\n        assembly {\n            // Check if the caller is the admin of the proxy.\n            if iszero(eq(sload(shl(96, proxy)), caller())) {\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n            // Store the admin for the proxy.\n            sstore(shl(96, proxy), admin)\n            // Emit the {AdminChanged} event.\n            log3(0, 0, _ADMIN_CHANGED_EVENT_SIGNATURE, proxy, admin)\n        }\n    }",
            "startLine": 85
          },
          {
            "name": "upgrade",
            "signature": "upgrade(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "proxy",
                "type": "address"
              },
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "upgradeAndCall",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_emptyData",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function upgrade(address proxy, address implementation) public payable {\n        upgradeAndCall(proxy, implementation, _emptyData());\n    }",
            "startLine": 105
          },
          {
            "name": "upgradeAndCall",
            "signature": "upgradeAndCall(address,address,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "proxy",
                "type": "address"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function upgradeAndCall(address proxy, address implementation, bytes calldata data)\n        public\n        payable\n    {\n        assembly {\n            // Check if the caller is the admin of the proxy.\n            if iszero(eq(sload(shl(96, proxy)), caller())) {\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n            // Set up the calldata to upgrade the proxy.\n            let m := mload(0x40)\n            mstore(m, implementation)\n            mstore(add(m, 0x20), _IMPLEMENTATION_SLOT)\n            calldatacopy(add(m, 0x40), data.offset, data.length)\n            // Try upgrading the proxy and revert upon failure.\n            if iszero(call(gas(), proxy, callvalue(), m, add(0x40, data.length), 0x00, 0x00)) {\n                // Revert with the `UpgradeFailed` selector if there is no error returndata.\n                if iszero(returndatasize()) {\n                    mstore(0x00, _UPGRADE_FAILED_ERROR_SELECTOR)\n                    revert(0x1c, 0x04)\n                }\n                // Otherwise, bubble up the returned error.\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n            // Emit the {Upgraded} event.\n            log3(0, 0, _UPGRADED_EVENT_SIGNATURE, proxy, implementation)\n        }\n    }",
            "startLine": 112
          },
          {
            "name": "deploy",
            "signature": "deploy(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "proxy",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployAndCall",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_emptyData",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function deploy(address implementation, address admin) public payable returns (address proxy) {\n        proxy = deployAndCall(implementation, admin, _emptyData());\n    }",
            "startLine": 150
          },
          {
            "name": "deployAndCall",
            "signature": "deployAndCall(address,address,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "proxy",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_deploy",
                "type": "internal",
                "argCount": 5
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function deployAndCall(address implementation, address admin, bytes calldata data)\n        public\n        payable\n        returns (address proxy)\n    {\n        proxy = _deploy(implementation, admin, bytes32(0), false, data);\n    }",
            "startLine": 158
          },
          {
            "name": "deployDeterministic",
            "signature": "deployDeterministic(address,address,bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "proxy",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployDeterministicAndCall",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_emptyData",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function deployDeterministic(address implementation, address admin, bytes32 salt)\n        public\n        payable\n        returns (address proxy)\n    {\n        proxy = deployDeterministicAndCall(implementation, admin, salt, _emptyData());\n    }",
            "startLine": 169
          },
          {
            "name": "deployDeterministicAndCall",
            "signature": "deployDeterministicAndCall(address,address,bytes32,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "proxy",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_deploy",
                "type": "internal",
                "argCount": 5
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function deployDeterministicAndCall(\n        address implementation,\n        address admin,\n        bytes32 salt,\n        bytes calldata data\n    ) public payable returns (address proxy) {\n        assembly {\n            // If the salt does not start with the zero address or the caller.\n            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {\n                mstore(0x00, _SALT_DOES_NOT_START_WITH_CALLER_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n        proxy = _deploy(implementation, admin, salt, true, data);\n    }",
            "startLine": 181
          },
          {
            "name": "predictDeterministicAddress",
            "signature": "predictDeterministicAddress(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "initCodeHash",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddress(bytes32 salt) public view returns (address predicted) {\n        bytes32 hash = initCodeHash();\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            // Note: `predicted` has dirty upper 96 bits. We won't clean it here\n            // as it will be automatically cleaned when it is copied into the returndata.\n            // Please clean as needed if used in other inline assembly blocks.\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }",
            "startLine": 242
          },
          {
            "name": "initCodeHash",
            "signature": "initCodeHash()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_initCode",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function initCodeHash() public view returns (bytes32 result) {\n        bytes32 m = _initCode();\n        assembly {\n            result := keccak256(add(m, 0x13), 0x88)\n        }\n    }",
            "startLine": 261
          }
        ],
        "internalFunctions": [
          {
            "name": "_deploy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "useSalt",
                "type": "bool"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "proxy",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_initCode",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _deploy(\n        address implementation,\n        address admin,\n        bytes32 salt,\n        bool useSalt,\n        bytes calldata data\n    ) internal returns (address proxy) {\n        bytes32 m = _initCode();\n        assembly {\n            // Create the proxy.\n            switch useSalt\n            case 0 { proxy := create(0, add(m, 0x13), 0x88) }\n            default { proxy := create2(0, add(m, 0x13), 0x88, salt) }\n            // Revert if the creation fails.\n            if iszero(proxy) {\n                mstore(0x00, _DEPLOYMENT_FAILED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n\n            // Set up the calldata to set the implementation of the proxy.\n            mstore(m, implementation)\n            mstore(add(m, 0x20), _IMPLEMENTATION_SLOT)\n            calldatacopy(add(m, 0x40), data.offset, data.length)\n            // Try setting the implementation on the proxy and revert upon failure.\n            if iszero(call(gas(), proxy, callvalue(), m, add(0x40, data.length), 0x00, 0x00)) {\n                // Revert with the `DeploymentFailed` selector if there is no error returndata.\n                if iszero(returndatasize()) {\n                    mstore(0x00, _DEPLOYMENT_FAILED_ERROR_SELECTOR)\n                    revert(0x1c, 0x04)\n                }\n                // Otherwise, bubble up the returned error.\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n\n            // Store the admin for the proxy.\n            sstore(shl(96, proxy), admin)\n\n            // Emit the {Deployed} event.\n            log4(0, 0, _DEPLOYED_EVENT_SIGNATURE, proxy, implementation, admin)\n        }\n    }",
            "startLine": 198
          },
          {
            "name": "_initCode",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "m",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _initCode() internal view returns (bytes32 m) {\n        assembly {\n            /**\n             * -------------------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                                   |\n             * -------------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic        | Stack               | Memory                          |\n             * -------------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize   | r                   |                                 |\n             * 3d         | RETURNDATASIZE  | 0 r                 |                                 |\n             * 81         | DUP2            | r 0 r               |                                 |\n             * 60 offset  | PUSH1 offset    | o r 0 r             |                                 |\n             * 3d         | RETURNDATASIZE  | 0 o r 0 r           |                                 |\n             * 39         | CODECOPY        | 0 r                 | [0..runSize): runtime code      |\n             * f3         | RETURN          |                     | [0..runSize): runtime code      |\n             * -------------------------------------------------------------------------------------|\n             * RUNTIME (127 bytes)                                                                  |\n             * -------------------------------------------------------------------------------------|\n             * Opcode      | Mnemonic       | Stack               | Memory                          |\n             * -------------------------------------------------------------------------------------|\n             *                                                                                      |\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | 0                   |                                 |\n             * 3d          | RETURNDATASIZE | 0 0                 |                                 |\n             *                                                                                      |\n             * ::: check if caller is factory ::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 33          | CALLER         | c 0 0               |                                 |\n             * 73 factory  | PUSH20 factory | f c 0 0             |                                 |\n             * 14          | EQ             | isf 0 0             |                                 |\n             * 60 0x57     | PUSH1 0x57     | dest isf 0 0        |                                 |\n             * 57          | JUMPI          | 0 0                 |                                 |\n             *                                                                                      |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36          | CALLDATASIZE   | cds 0 0             |                                 |\n             * 3d          | RETURNDATASIZE | 0 cds 0 0           |                                 |\n             * 3d          | RETURNDATASIZE | 0 0 cds 0 0         |                                 |\n             * 37          | CALLDATACOPY   | 0 0                 | [0..calldatasize): calldata     |\n             *                                                                                      |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36          | CALLDATASIZE   | cds 0 0             | [0..calldatasize): calldata     |\n             * 3d          | RETURNDATASIZE | 0 cds 0 0           | [0..calldatasize): calldata     |\n             * 7f slot     | PUSH32 slot    | s 0 cds 0 0         | [0..calldatasize): calldata     |\n             * 54          | SLOAD          | i 0 cds 0 0         | [0..calldatasize): calldata     |\n             * 5a          | GAS            | g i 0 cds 0 0       | [0..calldatasize): calldata     |\n             * f4          | DELEGATECALL   | succ                | [0..calldatasize): calldata     |\n             *                                                                                      |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds succ            | [0..calldatasize): calldata     |\n             * 60 0x00     | PUSH1 0x00     | 0 rds succ          | [0..calldatasize): calldata     |\n             * 80          | DUP1           | 0 0 rds succ        | [0..calldatasize): calldata     |\n             * 3e          | RETURNDATACOPY | succ                | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x52     | PUSH1 0x52     | dest succ           | [0..returndatasize): returndata |\n             * 57          | JUMPI          |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds                 | [0..returndatasize): returndata |\n             * 60 0x00     | PUSH1 0x00     | 0 rds               | [0..returndatasize): returndata |\n             * fd          | REVERT         |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b          | JUMPDEST       |                     | [0..returndatasize): returndata |\n             * 3d          | RETURNDATASIZE | rds                 | [0..returndatasize): returndata |\n             * 60 0x00     | PUSH1 0x00     | 0 rds               | [0..returndatasize): returndata |\n             * f3          | RETURN         |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: set new implementation (caller is factory) ::::::::::::::::::::::::::::::::::::: |\n             * 5b          | JUMPDEST       | 0 0                 |                                 |\n             * 3d          | RETURNDATASIZE | 0 0 0               |                                 |\n             * 35          | CALLDATALOAD   | impl 0 0            |                                 |\n             * 60 0x20     | PUSH1 0x20     | w impl 0 0          |                                 |\n             * 35          | CALLDATALOAD   | slot impl 0 0       |                                 |\n             * 55          | SSTORE         | 0 0                 |                                 |\n             *                                                                                      |\n             * ::: no extra calldata, return :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x40     | PUSH1 0x40     | 2w 0 0              |                                 |\n             * 80          | DUP1           | 2w 2w 0 0           |                                 |\n             * 36          | CALLDATASIZE   | cds 2w 2w 0 0       |                                 |\n             * 11          | GT             | gt 2w 0 0           |                                 |\n             * 15          | ISZERO         | lte 2w 0 0          |                                 |\n             * 60 0x52     | PUSH1 0x52     | dest lte 2w 0 0     |                                 |\n             * 57          | JUMPI          | 2w 0 0              |                                 |\n             *                                                                                      |\n             * ::: copy extra calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36          | CALLDATASIZE   | cds 2w 0 0          |                                 |\n             * 03          | SUB            | t 0 0               |                                 |\n             * 80          | DUP1           | t t 0 0             |                                 |\n             * 60 0x40     | PUSH1 0x40     | 2w t t 0 0          |                                 |\n             * 3d          | RETURNDATASIZE | 0 2w t t 0 0        |                                 |\n             * 37          | CALLDATACOPY   | t 0 0               | [0..t): extra calldata          |\n             *                                                                                      |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | 0 t 0 0             | [0..t): extra calldata          |\n             * 3d          | RETURNDATASIZE | 0 0 t 0 0           | [0..t): extra calldata          |\n             * 35          | CALLDATALOAD   | i 0 t 0 0           | [0..t): extra calldata          |\n             * 5a          | GAS            | g i 0 t 0 0         | [0..t): extra calldata          |\n             * f4          | DELEGATECALL   | succ                | [0..t): extra calldata          |\n             *                                                                                      |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds succ            | [0..t): extra calldata          |\n             * 60 0x00     | PUSH1 0x00     | 0 rds succ          | [0..t): extra calldata          |\n             * 80          | DUP1           | 0 0 rds succ        | [0..t): extra calldata          |\n             * 3e          | RETURNDATACOPY | succ                | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x52     | PUSH1 0x52     | dest succ           | [0..returndatasize): returndata |\n             * 57          | JUMPI          |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds                 | [0..returndatasize): returndata |\n             * 60 0x00     | PUSH1 0x00     | 0 rds               | [0..returndatasize): returndata |\n             * fd          | REVERT         |                     | [0..returndatasize): returndata |\n             * -------------------------------------------------------------------------------------+\n             */\n            m := mload(0x40)\n            // forgefmt: disable-start\n            switch shr(112, address())\n            case 0 {\n                // If the factory's address has six or more leading zero bytes.\n                mstore(add(m, 0x75), 0x604c573d6000fd) // 7\n                mstore(add(m, 0x6e), 0x3d3560203555604080361115604c5736038060403d373d3d355af43d6000803e) // 32\n                mstore(add(m, 0x4e), 0x3735a920a3ca505d382bbc545af43d6000803e604c573d6000fd5b3d6000f35b) // 32\n                mstore(add(m, 0x2e), 0x14605157363d3d37363d7f360894a13ba1a3210667c828492db98dca3e2076cc) // 32\n                mstore(add(m, 0x0e), address()) // 14\n                mstore(m, 0x60793d8160093d39f33d3d336d) // 9 + 4\n            }\n            default {\n                mstore(add(m, 0x7b), 0x6052573d6000fd) // 7\n                mstore(add(m, 0x74), 0x3d356020355560408036111560525736038060403d373d3d355af43d6000803e) // 32\n                mstore(add(m, 0x54), 0x3735a920a3ca505d382bbc545af43d6000803e6052573d6000fd5b3d6000f35b) // 32\n                mstore(add(m, 0x34), 0x14605757363d3d37363d7f360894a13ba1a3210667c828492db98dca3e2076cc) // 32\n                mstore(add(m, 0x14), address()) // 20\n                mstore(m, 0x607f3d8160093d39f33d3d3373) // 9 + 4\n            }\n            // forgefmt: disable-end\n        }\n    }",
            "startLine": 269
          },
          {
            "name": "_emptyData",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _emptyData() internal pure returns (bytes calldata data) {\n        assembly {\n            data.length := 0\n        }\n    }",
            "startLine": 413
          }
        ],
        "events": [
          {
            "name": "AdminChanged",
            "parameters": [
              {
                "name": "proxy",
                "type": "address",
                "indexed": true
              },
              {
                "name": "admin",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 41
          },
          {
            "name": "Upgraded",
            "parameters": [
              {
                "name": "proxy",
                "type": "address",
                "indexed": true
              },
              {
                "name": "implementation",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 44
          },
          {
            "name": "Deployed",
            "parameters": [
              {
                "name": "proxy",
                "type": "address",
                "indexed": true
              },
              {
                "name": "implementation",
                "type": "address",
                "indexed": true
              },
              {
                "name": "admin",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 47
          }
        ],
        "errors": [
          {
            "name": "Unauthorized",
            "parameters": [],
            "startLine": 13
          },
          {
            "name": "DeploymentFailed",
            "parameters": [],
            "startLine": 16
          },
          {
            "name": "UpgradeFailed",
            "parameters": [],
            "startLine": 19
          },
          {
            "name": "SaltDoesNotStartWithCaller",
            "parameters": [],
            "startLine": 22
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_UNAUTHORIZED_ERROR_SELECTOR",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 25
          },
          {
            "name": "_DEPLOYMENT_FAILED_ERROR_SELECTOR",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 28
          },
          {
            "name": "_UPGRADE_FAILED_ERROR_SELECTOR",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 31
          },
          {
            "name": "_SALT_DOES_NOT_START_WITH_CALLER_ERROR_SELECTOR",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 34
          },
          {
            "name": "_ADMIN_CHANGED_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 50
          },
          {
            "name": "_UPGRADED_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 54
          },
          {
            "name": "_DEPLOYED_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 58
          },
          {
            "name": "_IMPLEMENTATION_SLOT",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 69
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "ERC1967FactoryConstants",
        "filePath": "utils/ERC1967FactoryConstants.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "ADDRESS",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 29
          },
          {
            "name": "BYTECODE",
            "type": "bytes",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 34
          },
          {
            "name": "INITCODE",
            "type": "bytes",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 38
          },
          {
            "name": "SALT",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 43
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "EfficientHashLib",
        "filePath": "utils/EfficientHashLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(bytes32 v0) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            result := keccak256(0x00, 0x20)\n        }\n    }",
            "startLine": 20
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(uint256 v0) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            result := keccak256(0x00, 0x20)\n        }\n    }",
            "startLine": 29
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "bytes32"
              },
              {
                "name": "v1",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(bytes32 v0, bytes32 v1) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            mstore(0x20, v1)\n            result := keccak256(0x00, 0x40)\n        }\n    }",
            "startLine": 38
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "uint256"
              },
              {
                "name": "v1",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(uint256 v0, uint256 v1) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            mstore(0x20, v1)\n            result := keccak256(0x00, 0x40)\n        }\n    }",
            "startLine": 48
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "bytes32"
              },
              {
                "name": "v1",
                "type": "bytes32"
              },
              {
                "name": "v2",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(bytes32 v0, bytes32 v1, bytes32 v2) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            result := keccak256(m, 0x60)\n        }\n    }",
            "startLine": 58
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "uint256"
              },
              {
                "name": "v1",
                "type": "uint256"
              },
              {
                "name": "v2",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(uint256 v0, uint256 v1, uint256 v2) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            result := keccak256(m, 0x60)\n        }\n    }",
            "startLine": 70
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "bytes32"
              },
              {
                "name": "v1",
                "type": "bytes32"
              },
              {
                "name": "v2",
                "type": "bytes32"
              },
              {
                "name": "v3",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            result := keccak256(m, 0x80)\n        }\n    }",
            "startLine": 82
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "uint256"
              },
              {
                "name": "v1",
                "type": "uint256"
              },
              {
                "name": "v2",
                "type": "uint256"
              },
              {
                "name": "v3",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            result := keccak256(m, 0x80)\n        }\n    }",
            "startLine": 99
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "bytes32"
              },
              {
                "name": "v1",
                "type": "bytes32"
              },
              {
                "name": "v2",
                "type": "bytes32"
              },
              {
                "name": "v3",
                "type": "bytes32"
              },
              {
                "name": "v4",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            result := keccak256(m, 0xa0)\n        }\n    }",
            "startLine": 116
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "uint256"
              },
              {
                "name": "v1",
                "type": "uint256"
              },
              {
                "name": "v2",
                "type": "uint256"
              },
              {
                "name": "v3",
                "type": "uint256"
              },
              {
                "name": "v4",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            result := keccak256(m, 0xa0)\n        }\n    }",
            "startLine": 134
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "bytes32"
              },
              {
                "name": "v1",
                "type": "bytes32"
              },
              {
                "name": "v2",
                "type": "bytes32"
              },
              {
                "name": "v3",
                "type": "bytes32"
              },
              {
                "name": "v4",
                "type": "bytes32"
              },
              {
                "name": "v5",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            result := keccak256(m, 0xc0)\n        }\n    }",
            "startLine": 152
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "uint256"
              },
              {
                "name": "v1",
                "type": "uint256"
              },
              {
                "name": "v2",
                "type": "uint256"
              },
              {
                "name": "v3",
                "type": "uint256"
              },
              {
                "name": "v4",
                "type": "uint256"
              },
              {
                "name": "v5",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            result := keccak256(m, 0xc0)\n        }\n    }",
            "startLine": 171
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "bytes32"
              },
              {
                "name": "v1",
                "type": "bytes32"
              },
              {
                "name": "v2",
                "type": "bytes32"
              },
              {
                "name": "v3",
                "type": "bytes32"
              },
              {
                "name": "v4",
                "type": "bytes32"
              },
              {
                "name": "v5",
                "type": "bytes32"
              },
              {
                "name": "v6",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            result := keccak256(m, 0xe0)\n        }\n    }",
            "startLine": 190
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "uint256"
              },
              {
                "name": "v1",
                "type": "uint256"
              },
              {
                "name": "v2",
                "type": "uint256"
              },
              {
                "name": "v3",
                "type": "uint256"
              },
              {
                "name": "v4",
                "type": "uint256"
              },
              {
                "name": "v5",
                "type": "uint256"
              },
              {
                "name": "v6",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            result := keccak256(m, 0xe0)\n        }\n    }",
            "startLine": 214
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "bytes32"
              },
              {
                "name": "v1",
                "type": "bytes32"
              },
              {
                "name": "v2",
                "type": "bytes32"
              },
              {
                "name": "v3",
                "type": "bytes32"
              },
              {
                "name": "v4",
                "type": "bytes32"
              },
              {
                "name": "v5",
                "type": "bytes32"
              },
              {
                "name": "v6",
                "type": "bytes32"
              },
              {
                "name": "v7",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            result := keccak256(m, 0x100)\n        }\n    }",
            "startLine": 238
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "uint256"
              },
              {
                "name": "v1",
                "type": "uint256"
              },
              {
                "name": "v2",
                "type": "uint256"
              },
              {
                "name": "v3",
                "type": "uint256"
              },
              {
                "name": "v4",
                "type": "uint256"
              },
              {
                "name": "v5",
                "type": "uint256"
              },
              {
                "name": "v6",
                "type": "uint256"
              },
              {
                "name": "v7",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            result := keccak256(m, 0x100)\n        }\n    }",
            "startLine": 264
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "bytes32"
              },
              {
                "name": "v1",
                "type": "bytes32"
              },
              {
                "name": "v2",
                "type": "bytes32"
              },
              {
                "name": "v3",
                "type": "bytes32"
              },
              {
                "name": "v4",
                "type": "bytes32"
              },
              {
                "name": "v5",
                "type": "bytes32"
              },
              {
                "name": "v6",
                "type": "bytes32"
              },
              {
                "name": "v7",
                "type": "bytes32"
              },
              {
                "name": "v8",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            result := keccak256(m, 0x120)\n        }\n    }",
            "startLine": 290
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "uint256"
              },
              {
                "name": "v1",
                "type": "uint256"
              },
              {
                "name": "v2",
                "type": "uint256"
              },
              {
                "name": "v3",
                "type": "uint256"
              },
              {
                "name": "v4",
                "type": "uint256"
              },
              {
                "name": "v5",
                "type": "uint256"
              },
              {
                "name": "v6",
                "type": "uint256"
              },
              {
                "name": "v7",
                "type": "uint256"
              },
              {
                "name": "v8",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            result := keccak256(m, 0x120)\n        }\n    }",
            "startLine": 318
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "bytes32"
              },
              {
                "name": "v1",
                "type": "bytes32"
              },
              {
                "name": "v2",
                "type": "bytes32"
              },
              {
                "name": "v3",
                "type": "bytes32"
              },
              {
                "name": "v4",
                "type": "bytes32"
              },
              {
                "name": "v5",
                "type": "bytes32"
              },
              {
                "name": "v6",
                "type": "bytes32"
              },
              {
                "name": "v7",
                "type": "bytes32"
              },
              {
                "name": "v8",
                "type": "bytes32"
              },
              {
                "name": "v9",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            result := keccak256(m, 0x140)\n        }\n    }",
            "startLine": 346
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "uint256"
              },
              {
                "name": "v1",
                "type": "uint256"
              },
              {
                "name": "v2",
                "type": "uint256"
              },
              {
                "name": "v3",
                "type": "uint256"
              },
              {
                "name": "v4",
                "type": "uint256"
              },
              {
                "name": "v5",
                "type": "uint256"
              },
              {
                "name": "v6",
                "type": "uint256"
              },
              {
                "name": "v7",
                "type": "uint256"
              },
              {
                "name": "v8",
                "type": "uint256"
              },
              {
                "name": "v9",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            result := keccak256(m, 0x140)\n        }\n    }",
            "startLine": 376
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "bytes32"
              },
              {
                "name": "v1",
                "type": "bytes32"
              },
              {
                "name": "v2",
                "type": "bytes32"
              },
              {
                "name": "v3",
                "type": "bytes32"
              },
              {
                "name": "v4",
                "type": "bytes32"
              },
              {
                "name": "v5",
                "type": "bytes32"
              },
              {
                "name": "v6",
                "type": "bytes32"
              },
              {
                "name": "v7",
                "type": "bytes32"
              },
              {
                "name": "v8",
                "type": "bytes32"
              },
              {
                "name": "v9",
                "type": "bytes32"
              },
              {
                "name": "v10",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            result := keccak256(m, 0x160)\n        }\n    }",
            "startLine": 406
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "uint256"
              },
              {
                "name": "v1",
                "type": "uint256"
              },
              {
                "name": "v2",
                "type": "uint256"
              },
              {
                "name": "v3",
                "type": "uint256"
              },
              {
                "name": "v4",
                "type": "uint256"
              },
              {
                "name": "v5",
                "type": "uint256"
              },
              {
                "name": "v6",
                "type": "uint256"
              },
              {
                "name": "v7",
                "type": "uint256"
              },
              {
                "name": "v8",
                "type": "uint256"
              },
              {
                "name": "v9",
                "type": "uint256"
              },
              {
                "name": "v10",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            result := keccak256(m, 0x160)\n        }\n    }",
            "startLine": 438
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "bytes32"
              },
              {
                "name": "v1",
                "type": "bytes32"
              },
              {
                "name": "v2",
                "type": "bytes32"
              },
              {
                "name": "v3",
                "type": "bytes32"
              },
              {
                "name": "v4",
                "type": "bytes32"
              },
              {
                "name": "v5",
                "type": "bytes32"
              },
              {
                "name": "v6",
                "type": "bytes32"
              },
              {
                "name": "v7",
                "type": "bytes32"
              },
              {
                "name": "v8",
                "type": "bytes32"
              },
              {
                "name": "v9",
                "type": "bytes32"
              },
              {
                "name": "v10",
                "type": "bytes32"
              },
              {
                "name": "v11",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            result := keccak256(m, 0x180)\n        }\n    }",
            "startLine": 470
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "uint256"
              },
              {
                "name": "v1",
                "type": "uint256"
              },
              {
                "name": "v2",
                "type": "uint256"
              },
              {
                "name": "v3",
                "type": "uint256"
              },
              {
                "name": "v4",
                "type": "uint256"
              },
              {
                "name": "v5",
                "type": "uint256"
              },
              {
                "name": "v6",
                "type": "uint256"
              },
              {
                "name": "v7",
                "type": "uint256"
              },
              {
                "name": "v8",
                "type": "uint256"
              },
              {
                "name": "v9",
                "type": "uint256"
              },
              {
                "name": "v10",
                "type": "uint256"
              },
              {
                "name": "v11",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            result := keccak256(m, 0x180)\n        }\n    }",
            "startLine": 504
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "bytes32"
              },
              {
                "name": "v1",
                "type": "bytes32"
              },
              {
                "name": "v2",
                "type": "bytes32"
              },
              {
                "name": "v3",
                "type": "bytes32"
              },
              {
                "name": "v4",
                "type": "bytes32"
              },
              {
                "name": "v5",
                "type": "bytes32"
              },
              {
                "name": "v6",
                "type": "bytes32"
              },
              {
                "name": "v7",
                "type": "bytes32"
              },
              {
                "name": "v8",
                "type": "bytes32"
              },
              {
                "name": "v9",
                "type": "bytes32"
              },
              {
                "name": "v10",
                "type": "bytes32"
              },
              {
                "name": "v11",
                "type": "bytes32"
              },
              {
                "name": "v12",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11,\n        bytes32 v12\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            result := keccak256(m, 0x1a0)\n        }\n    }",
            "startLine": 538
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "uint256"
              },
              {
                "name": "v1",
                "type": "uint256"
              },
              {
                "name": "v2",
                "type": "uint256"
              },
              {
                "name": "v3",
                "type": "uint256"
              },
              {
                "name": "v4",
                "type": "uint256"
              },
              {
                "name": "v5",
                "type": "uint256"
              },
              {
                "name": "v6",
                "type": "uint256"
              },
              {
                "name": "v7",
                "type": "uint256"
              },
              {
                "name": "v8",
                "type": "uint256"
              },
              {
                "name": "v9",
                "type": "uint256"
              },
              {
                "name": "v10",
                "type": "uint256"
              },
              {
                "name": "v11",
                "type": "uint256"
              },
              {
                "name": "v12",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11,\n        uint256 v12\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            result := keccak256(m, 0x1a0)\n        }\n    }",
            "startLine": 574
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "bytes32"
              },
              {
                "name": "v1",
                "type": "bytes32"
              },
              {
                "name": "v2",
                "type": "bytes32"
              },
              {
                "name": "v3",
                "type": "bytes32"
              },
              {
                "name": "v4",
                "type": "bytes32"
              },
              {
                "name": "v5",
                "type": "bytes32"
              },
              {
                "name": "v6",
                "type": "bytes32"
              },
              {
                "name": "v7",
                "type": "bytes32"
              },
              {
                "name": "v8",
                "type": "bytes32"
              },
              {
                "name": "v9",
                "type": "bytes32"
              },
              {
                "name": "v10",
                "type": "bytes32"
              },
              {
                "name": "v11",
                "type": "bytes32"
              },
              {
                "name": "v12",
                "type": "bytes32"
              },
              {
                "name": "v13",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11,\n        bytes32 v12,\n        bytes32 v13\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            mstore(add(m, 0x1a0), v13)\n            result := keccak256(m, 0x1c0)\n        }\n    }",
            "startLine": 610
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v0",
                "type": "uint256"
              },
              {
                "name": "v1",
                "type": "uint256"
              },
              {
                "name": "v2",
                "type": "uint256"
              },
              {
                "name": "v3",
                "type": "uint256"
              },
              {
                "name": "v4",
                "type": "uint256"
              },
              {
                "name": "v5",
                "type": "uint256"
              },
              {
                "name": "v6",
                "type": "uint256"
              },
              {
                "name": "v7",
                "type": "uint256"
              },
              {
                "name": "v8",
                "type": "uint256"
              },
              {
                "name": "v9",
                "type": "uint256"
              },
              {
                "name": "v10",
                "type": "uint256"
              },
              {
                "name": "v11",
                "type": "uint256"
              },
              {
                "name": "v12",
                "type": "uint256"
              },
              {
                "name": "v13",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11,\n        uint256 v12,\n        uint256 v13\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            mstore(add(m, 0x1a0), v13)\n            result := keccak256(m, 0x1c0)\n        }\n    }",
            "startLine": 648
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(bytes32[] memory buffer) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(buffer, 0x20), shl(5, mload(buffer)))\n        }\n    }",
            "startLine": 690
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "bytes32[]"
              },
              {
                "name": "i",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(bytes32[] memory buffer, uint256 i, bytes32 value)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(buffer, shl(5, add(1, i))), value)\n        }\n        return buffer;\n    }",
            "startLine": 699
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "bytes32[]"
              },
              {
                "name": "i",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(bytes32[] memory buffer, uint256 i, uint256 value)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(buffer, shl(5, add(1, i))), value)\n        }\n        return buffer;\n    }",
            "startLine": 713
          },
          {
            "name": "malloc",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "buffer",
                "type": "bytes32[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function malloc(uint256 n) internal pure returns (bytes32[] memory buffer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            buffer := mload(0x40)\n            mstore(buffer, n)\n            mstore(0x40, add(shl(5, add(1, n)), buffer))\n        }\n    }",
            "startLine": 726
          },
          {
            "name": "free",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function free(bytes32[] memory buffer) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(buffer)\n            mstore(shl(6, lt(iszero(n), eq(add(shl(5, add(1, n)), buffer), mload(0x40)))), buffer)\n        }\n    }",
            "startLine": 737
          },
          {
            "name": "eq",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32"
              },
              {
                "name": "b",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function eq(bytes32 a, bytes memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(0x20, mload(b)), eq(a, mload(add(b, 0x20))))\n        }\n    }",
            "startLine": 750
          },
          {
            "name": "eq",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "b",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function eq(bytes memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(0x20, mload(a)), eq(b, mload(add(a, 0x20))))\n        }\n    }",
            "startLine": 758
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "b",
                "type": "bytes"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(bytes memory b, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            end := xor(end, mul(xor(end, n), lt(n, end)))\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            result := keccak256(add(add(b, 0x20), start), mul(gt(end, start), sub(end, start)))\n        }\n    }",
            "startLine": 771
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "b",
                "type": "bytes"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(bytes memory b, uint256 start) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            result := keccak256(add(add(b, 0x20), start), mul(gt(n, start), sub(n, start)))\n        }\n    }",
            "startLine": 786
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "b",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(bytes memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(b, 0x20), mload(b))\n        }\n    }",
            "startLine": 796
          },
          {
            "name": "hashCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "b",
                "type": "bytes"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hashCalldata(bytes calldata b, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(end, start), sub(end, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := keccak256(mload(0x40), n)\n        }\n    }",
            "startLine": 805
          },
          {
            "name": "hashCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "b",
                "type": "bytes"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hashCalldata(bytes calldata b, uint256 start) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(b.length, start), sub(b.length, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := keccak256(mload(0x40), n)\n        }\n    }",
            "startLine": 821
          },
          {
            "name": "hashCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "b",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hashCalldata(bytes calldata b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), b.offset, b.length)\n            result := keccak256(mload(0x40), b.length)\n        }\n    }",
            "startLine": 832
          },
          {
            "name": "sha2",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "b",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function sha2(bytes32 b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, b)\n            result := mload(staticcall(gas(), 2, 0x00, 0x20, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }",
            "startLine": 845
          },
          {
            "name": "sha2",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "b",
                "type": "bytes"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function sha2(bytes memory b, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            end := xor(end, mul(xor(end, n), lt(n, end)))\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            // forgefmt: disable-next-item\n            result := mload(staticcall(gas(), 2, add(add(b, 0x20), start),\n                mul(gt(end, start), sub(end, start)), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }",
            "startLine": 856
          },
          {
            "name": "sha2",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "b",
                "type": "bytes"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function sha2(bytes memory b, uint256 start) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            // forgefmt: disable-next-item\n            result := mload(staticcall(gas(), 2, add(add(b, 0x20), start),\n                mul(gt(n, start), sub(n, start)), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }",
            "startLine": 874
          },
          {
            "name": "sha2",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "b",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function sha2(bytes memory b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(staticcall(gas(), 2, add(b, 0x20), mload(b), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }",
            "startLine": 887
          },
          {
            "name": "sha2Calldata",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "b",
                "type": "bytes"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function sha2Calldata(bytes calldata b, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(end, start), sub(end, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := mload(staticcall(gas(), 2, mload(0x40), n, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }",
            "startLine": 897
          },
          {
            "name": "sha2Calldata",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "b",
                "type": "bytes"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function sha2Calldata(bytes calldata b, uint256 start) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(b.length, start), sub(b.length, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := mload(staticcall(gas(), 2, mload(0x40), n, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }",
            "startLine": 914
          },
          {
            "name": "sha2Calldata",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "b",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function sha2Calldata(bytes calldata b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), b.offset, b.length)\n            result := mload(staticcall(gas(), 2, mload(0x40), b.length, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }",
            "startLine": 926
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "EnumerableMapLib",
        "filePath": "utils/EnumerableMapLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "startLine": 81
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "bytes32"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value, uint256 cap)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key, cap);\n    }",
            "startLine": 92
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.remove",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "startLine": 102
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "bytes32"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        bytes32 value,\n        bool isAdd,\n        uint256 cap\n    ) internal returns (bool) {\n        return isAdd ? set(map, key, value, cap) : remove(map, key);\n    }",
            "startLine": 108
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return EnumerableSetLib.contains(map._keys, key);\n    }",
            "startLine": 119
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.length",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return EnumerableSetLib.length(map._keys);\n    }",
            "startLine": 124
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.at",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Bytes32ToBytes32Map storage map, uint256 i)\n        internal\n        view\n        returns (bytes32 key, bytes32 value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "startLine": 129
          },
          {
            "name": "tryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "exists",
                "type": "bool"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryGet(Bytes32ToBytes32Map storage map, bytes32 key)\n        internal\n        view\n        returns (bool exists, bytes32 value)\n    {\n        exists = (value = map._values[key]) != bytes32(0) || contains(map, key);\n    }",
            "startLine": 138
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(Bytes32ToBytes32Map storage map, bytes32 key)\n        internal\n        view\n        returns (bytes32 value)\n    {\n        if ((value = map._values[key]) == bytes32(0)) {\n            if (!contains(map, key)) _revertNotFound();\n        }\n    }",
            "startLine": 147
          },
          {
            "name": "keys",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32[]"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.values",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\n        return EnumerableSetLib.values(map._keys);\n    }",
            "startLine": 158
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Bytes32ToUint256Map storage map, bytes32 key, uint256 value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "startLine": 164
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Bytes32ToUint256Map storage map, bytes32 key, uint256 value, uint256 cap)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key, cap);\n    }",
            "startLine": 175
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.remove",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Bytes32ToUint256Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "startLine": 185
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(\n        Bytes32ToUint256Map storage map,\n        bytes32 key,\n        uint256 value,\n        bool isAdd,\n        uint256 cap\n    ) internal returns (bool) {\n        return isAdd ? set(map, key, value, cap) : remove(map, key);\n    }",
            "startLine": 191
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(Bytes32ToUint256Map storage map, bytes32 key) internal view returns (bool) {\n        return EnumerableSetLib.contains(map._keys, key);\n    }",
            "startLine": 202
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.length",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(Bytes32ToUint256Map storage map) internal view returns (uint256) {\n        return EnumerableSetLib.length(map._keys);\n    }",
            "startLine": 207
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.at",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Bytes32ToUint256Map storage map, uint256 i)\n        internal\n        view\n        returns (bytes32 key, uint256 value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "startLine": 212
          },
          {
            "name": "tryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "exists",
                "type": "bool"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryGet(Bytes32ToUint256Map storage map, bytes32 key)\n        internal\n        view\n        returns (bool exists, uint256 value)\n    {\n        exists = (value = map._values[key]) != uint256(0) || contains(map, key);\n    }",
            "startLine": 221
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(Bytes32ToUint256Map storage map, bytes32 key)\n        internal\n        view\n        returns (uint256 value)\n    {\n        if ((value = map._values[key]) == uint256(0)) {\n            if (!contains(map, key)) _revertNotFound();\n        }\n    }",
            "startLine": 230
          },
          {
            "name": "keys",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32[]"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.values",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function keys(Bytes32ToUint256Map storage map) internal view returns (bytes32[] memory) {\n        return EnumerableSetLib.values(map._keys);\n    }",
            "startLine": 241
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              },
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Bytes32ToAddressMap storage map, bytes32 key, address value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "startLine": 247
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              },
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "address"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Bytes32ToAddressMap storage map, bytes32 key, address value, uint256 cap)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key, cap);\n    }",
            "startLine": 258
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.remove",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Bytes32ToAddressMap storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "startLine": 268
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              },
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "address"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(\n        Bytes32ToAddressMap storage map,\n        bytes32 key,\n        address value,\n        bool isAdd,\n        uint256 cap\n    ) internal returns (bool) {\n        return isAdd ? set(map, key, value, cap) : remove(map, key);\n    }",
            "startLine": 274
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (bool) {\n        return EnumerableSetLib.contains(map._keys, key);\n    }",
            "startLine": 285
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.length",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(Bytes32ToAddressMap storage map) internal view returns (uint256) {\n        return EnumerableSetLib.length(map._keys);\n    }",
            "startLine": 290
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.at",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Bytes32ToAddressMap storage map, uint256 i)\n        internal\n        view\n        returns (bytes32 key, address value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "startLine": 295
          },
          {
            "name": "tryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "exists",
                "type": "bool"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryGet(Bytes32ToAddressMap storage map, bytes32 key)\n        internal\n        view\n        returns (bool exists, address value)\n    {\n        exists = (value = map._values[key]) != address(0) || contains(map, key);\n    }",
            "startLine": 304
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(Bytes32ToAddressMap storage map, bytes32 key)\n        internal\n        view\n        returns (address value)\n    {\n        if ((value = map._values[key]) == address(0)) {\n            if (!contains(map, key)) _revertNotFound();\n        }\n    }",
            "startLine": 313
          },
          {
            "name": "keys",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32[]"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.values",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function keys(Bytes32ToAddressMap storage map) internal view returns (bytes32[] memory) {\n        return EnumerableSetLib.values(map._keys);\n    }",
            "startLine": 324
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Uint256ToBytes32Map storage map, uint256 key, bytes32 value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "startLine": 330
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "bytes32"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Uint256ToBytes32Map storage map, uint256 key, bytes32 value, uint256 cap)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key, cap);\n    }",
            "startLine": 341
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.remove",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Uint256ToBytes32Map storage map, uint256 key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "startLine": 351
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "bytes32"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(\n        Uint256ToBytes32Map storage map,\n        uint256 key,\n        bytes32 value,\n        bool isAdd,\n        uint256 cap\n    ) internal returns (bool) {\n        return isAdd ? set(map, key, value, cap) : remove(map, key);\n    }",
            "startLine": 357
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(Uint256ToBytes32Map storage map, uint256 key) internal view returns (bool) {\n        return EnumerableSetLib.contains(map._keys, key);\n    }",
            "startLine": 368
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.length",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(Uint256ToBytes32Map storage map) internal view returns (uint256) {\n        return EnumerableSetLib.length(map._keys);\n    }",
            "startLine": 373
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.at",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Uint256ToBytes32Map storage map, uint256 i)\n        internal\n        view\n        returns (uint256 key, bytes32 value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "startLine": 378
          },
          {
            "name": "tryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "exists",
                "type": "bool"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryGet(Uint256ToBytes32Map storage map, uint256 key)\n        internal\n        view\n        returns (bool exists, bytes32 value)\n    {\n        exists = (value = map._values[key]) != bytes32(0) || contains(map, key);\n    }",
            "startLine": 387
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(Uint256ToBytes32Map storage map, uint256 key)\n        internal\n        view\n        returns (bytes32 value)\n    {\n        if ((value = map._values[key]) == bytes32(0)) {\n            if (!contains(map, key)) _revertNotFound();\n        }\n    }",
            "startLine": 396
          },
          {
            "name": "keys",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.values",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function keys(Uint256ToBytes32Map storage map) internal view returns (uint256[] memory) {\n        return EnumerableSetLib.values(map._keys);\n    }",
            "startLine": 407
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Uint256ToUint256Map storage map, uint256 key, uint256 value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "startLine": 413
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Uint256ToUint256Map storage map, uint256 key, uint256 value, uint256 cap)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key, cap);\n    }",
            "startLine": 424
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.remove",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Uint256ToUint256Map storage map, uint256 key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "startLine": 434
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(\n        Uint256ToUint256Map storage map,\n        uint256 key,\n        uint256 value,\n        bool isAdd,\n        uint256 cap\n    ) internal returns (bool) {\n        return isAdd ? set(map, key, value, cap) : remove(map, key);\n    }",
            "startLine": 440
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(Uint256ToUint256Map storage map, uint256 key) internal view returns (bool) {\n        return EnumerableSetLib.contains(map._keys, key);\n    }",
            "startLine": 451
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.length",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(Uint256ToUint256Map storage map) internal view returns (uint256) {\n        return EnumerableSetLib.length(map._keys);\n    }",
            "startLine": 456
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.at",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Uint256ToUint256Map storage map, uint256 i)\n        internal\n        view\n        returns (uint256 key, uint256 value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "startLine": 461
          },
          {
            "name": "tryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "exists",
                "type": "bool"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryGet(Uint256ToUint256Map storage map, uint256 key)\n        internal\n        view\n        returns (bool exists, uint256 value)\n    {\n        exists = (value = map._values[key]) != uint256(0) || contains(map, key);\n    }",
            "startLine": 470
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(Uint256ToUint256Map storage map, uint256 key)\n        internal\n        view\n        returns (uint256 value)\n    {\n        if ((value = map._values[key]) == uint256(0)) {\n            if (!contains(map, key)) _revertNotFound();\n        }\n    }",
            "startLine": 479
          },
          {
            "name": "keys",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.values",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function keys(Uint256ToUint256Map storage map) internal view returns (uint256[] memory) {\n        return EnumerableSetLib.values(map._keys);\n    }",
            "startLine": 490
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Uint256ToAddressMap storage map, uint256 key, address value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "startLine": 496
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "address"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Uint256ToAddressMap storage map, uint256 key, address value, uint256 cap)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key, cap);\n    }",
            "startLine": 507
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.remove",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Uint256ToAddressMap storage map, uint256 key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "startLine": 517
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "address"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(\n        Uint256ToAddressMap storage map,\n        uint256 key,\n        address value,\n        bool isAdd,\n        uint256 cap\n    ) internal returns (bool) {\n        return isAdd ? set(map, key, value, cap) : remove(map, key);\n    }",
            "startLine": 523
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(Uint256ToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return EnumerableSetLib.contains(map._keys, key);\n    }",
            "startLine": 534
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.length",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(Uint256ToAddressMap storage map) internal view returns (uint256) {\n        return EnumerableSetLib.length(map._keys);\n    }",
            "startLine": 539
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.at",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Uint256ToAddressMap storage map, uint256 i)\n        internal\n        view\n        returns (uint256 key, address value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "startLine": 544
          },
          {
            "name": "tryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "exists",
                "type": "bool"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryGet(Uint256ToAddressMap storage map, uint256 key)\n        internal\n        view\n        returns (bool exists, address value)\n    {\n        exists = (value = map._values[key]) != address(0) || contains(map, key);\n    }",
            "startLine": 553
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(Uint256ToAddressMap storage map, uint256 key)\n        internal\n        view\n        returns (address value)\n    {\n        if ((value = map._values[key]) == address(0)) {\n            if (!contains(map, key)) _revertNotFound();\n        }\n    }",
            "startLine": 562
          },
          {
            "name": "keys",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.values",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function keys(Uint256ToAddressMap storage map) internal view returns (uint256[] memory) {\n        return EnumerableSetLib.values(map._keys);\n    }",
            "startLine": 573
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              },
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(AddressToBytes32Map storage map, address key, bytes32 value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "startLine": 579
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              },
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "bytes32"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(AddressToBytes32Map storage map, address key, bytes32 value, uint256 cap)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key, cap);\n    }",
            "startLine": 590
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.remove",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(AddressToBytes32Map storage map, address key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "startLine": 600
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              },
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "bytes32"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(\n        AddressToBytes32Map storage map,\n        address key,\n        bytes32 value,\n        bool isAdd,\n        uint256 cap\n    ) internal returns (bool) {\n        return isAdd ? set(map, key, value, cap) : remove(map, key);\n    }",
            "startLine": 606
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(AddressToBytes32Map storage map, address key) internal view returns (bool) {\n        return EnumerableSetLib.contains(map._keys, key);\n    }",
            "startLine": 617
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.length",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(AddressToBytes32Map storage map) internal view returns (uint256) {\n        return EnumerableSetLib.length(map._keys);\n    }",
            "startLine": 622
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.at",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(AddressToBytes32Map storage map, uint256 i)\n        internal\n        view\n        returns (address key, bytes32 value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "startLine": 627
          },
          {
            "name": "tryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "exists",
                "type": "bool"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryGet(AddressToBytes32Map storage map, address key)\n        internal\n        view\n        returns (bool exists, bytes32 value)\n    {\n        exists = (value = map._values[key]) != bytes32(0) || contains(map, key);\n    }",
            "startLine": 636
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(AddressToBytes32Map storage map, address key)\n        internal\n        view\n        returns (bytes32 value)\n    {\n        if ((value = map._values[key]) == bytes32(0)) {\n            if (!contains(map, key)) _revertNotFound();\n        }\n    }",
            "startLine": 645
          },
          {
            "name": "keys",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address[]"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.values",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function keys(AddressToBytes32Map storage map) internal view returns (address[] memory) {\n        return EnumerableSetLib.values(map._keys);\n    }",
            "startLine": 656
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              },
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(AddressToUint256Map storage map, address key, uint256 value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "startLine": 662
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              },
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(AddressToUint256Map storage map, address key, uint256 value, uint256 cap)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key, cap);\n    }",
            "startLine": 673
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.remove",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(AddressToUint256Map storage map, address key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "startLine": 683
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              },
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(\n        AddressToUint256Map storage map,\n        address key,\n        uint256 value,\n        bool isAdd,\n        uint256 cap\n    ) internal returns (bool) {\n        return isAdd ? set(map, key, value, cap) : remove(map, key);\n    }",
            "startLine": 689
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(AddressToUint256Map storage map, address key) internal view returns (bool) {\n        return EnumerableSetLib.contains(map._keys, key);\n    }",
            "startLine": 700
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.length",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(AddressToUint256Map storage map) internal view returns (uint256) {\n        return EnumerableSetLib.length(map._keys);\n    }",
            "startLine": 705
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.at",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(AddressToUint256Map storage map, uint256 i)\n        internal\n        view\n        returns (address key, uint256 value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "startLine": 710
          },
          {
            "name": "tryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "exists",
                "type": "bool"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryGet(AddressToUint256Map storage map, address key)\n        internal\n        view\n        returns (bool exists, uint256 value)\n    {\n        exists = (value = map._values[key]) != uint256(0) || contains(map, key);\n    }",
            "startLine": 719
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(AddressToUint256Map storage map, address key)\n        internal\n        view\n        returns (uint256 value)\n    {\n        if ((value = map._values[key]) == uint256(0)) {\n            if (!contains(map, key)) _revertNotFound();\n        }\n    }",
            "startLine": 728
          },
          {
            "name": "keys",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address[]"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.values",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function keys(AddressToUint256Map storage map) internal view returns (address[] memory) {\n        return EnumerableSetLib.values(map._keys);\n    }",
            "startLine": 739
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              },
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(AddressToAddressMap storage map, address key, address value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "startLine": 745
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              },
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "address"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(AddressToAddressMap storage map, address key, address value, uint256 cap)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key, cap);\n    }",
            "startLine": 756
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.remove",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(AddressToAddressMap storage map, address key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "startLine": 766
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              },
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "address"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(\n        AddressToAddressMap storage map,\n        address key,\n        address value,\n        bool isAdd,\n        uint256 cap\n    ) internal returns (bool) {\n        return isAdd ? set(map, key, value, cap) : remove(map, key);\n    }",
            "startLine": 772
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(AddressToAddressMap storage map, address key) internal view returns (bool) {\n        return EnumerableSetLib.contains(map._keys, key);\n    }",
            "startLine": 783
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.length",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(AddressToAddressMap storage map) internal view returns (uint256) {\n        return EnumerableSetLib.length(map._keys);\n    }",
            "startLine": 788
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.at",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(AddressToAddressMap storage map, uint256 i)\n        internal\n        view\n        returns (address key, address value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "startLine": 793
          },
          {
            "name": "tryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "exists",
                "type": "bool"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryGet(AddressToAddressMap storage map, address key)\n        internal\n        view\n        returns (bool exists, address value)\n    {\n        exists = (value = map._values[key]) != address(0) || contains(map, key);\n    }",
            "startLine": 802
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(AddressToAddressMap storage map, address key)\n        internal\n        view\n        returns (address value)\n    {\n        if ((value = map._values[key]) == address(0)) {\n            if (!contains(map, key)) _revertNotFound();\n        }\n    }",
            "startLine": 811
          },
          {
            "name": "keys",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address[]"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.values",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function keys(AddressToAddressMap storage map) internal view returns (address[] memory) {\n        return EnumerableSetLib.values(map._keys);\n    }",
            "startLine": 822
          },
          {
            "name": "_revertNotFound",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _revertNotFound() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x88682bf3) // `EnumerableMapKeyNotFound()`.\n            revert(0x1c, 0x04)\n        }\n    }",
            "startLine": 831
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "EnumerableMapKeyNotFound",
            "parameters": [],
            "startLine": 15
          }
        ],
        "structs": [
          {
            "name": "Bytes32ToBytes32Map",
            "members": [
              {
                "name": "_keys",
                "type": "EnumerableSetLib.Bytes32Set"
              },
              {
                "name": "_values",
                "type": "mapping(bytes32 => bytes32)"
              }
            ],
            "startLine": 22
          },
          {
            "name": "Bytes32ToUint256Map",
            "members": [
              {
                "name": "_keys",
                "type": "EnumerableSetLib.Bytes32Set"
              },
              {
                "name": "_values",
                "type": "mapping(bytes32 => uint256)"
              }
            ],
            "startLine": 28
          },
          {
            "name": "Bytes32ToAddressMap",
            "members": [
              {
                "name": "_keys",
                "type": "EnumerableSetLib.Bytes32Set"
              },
              {
                "name": "_values",
                "type": "mapping(bytes32 => address)"
              }
            ],
            "startLine": 34
          },
          {
            "name": "Uint256ToBytes32Map",
            "members": [
              {
                "name": "_keys",
                "type": "EnumerableSetLib.Uint256Set"
              },
              {
                "name": "_values",
                "type": "mapping(uint256 => bytes32)"
              }
            ],
            "startLine": 40
          },
          {
            "name": "Uint256ToUint256Map",
            "members": [
              {
                "name": "_keys",
                "type": "EnumerableSetLib.Uint256Set"
              },
              {
                "name": "_values",
                "type": "mapping(uint256 => uint256)"
              }
            ],
            "startLine": 46
          },
          {
            "name": "Uint256ToAddressMap",
            "members": [
              {
                "name": "_keys",
                "type": "EnumerableSetLib.Uint256Set"
              },
              {
                "name": "_values",
                "type": "mapping(uint256 => address)"
              }
            ],
            "startLine": 52
          },
          {
            "name": "AddressToBytes32Map",
            "members": [
              {
                "name": "_keys",
                "type": "EnumerableSetLib.AddressSet"
              },
              {
                "name": "_values",
                "type": "mapping(address => bytes32)"
              }
            ],
            "startLine": 58
          },
          {
            "name": "AddressToUint256Map",
            "members": [
              {
                "name": "_keys",
                "type": "EnumerableSetLib.AddressSet"
              },
              {
                "name": "_values",
                "type": "mapping(address => uint256)"
              }
            ],
            "startLine": 64
          },
          {
            "name": "AddressToAddressMap",
            "members": [
              {
                "name": "_keys",
                "type": "EnumerableSetLib.AddressSet"
              },
              {
                "name": "_values",
                "type": "mapping(address => address)"
              }
            ],
            "startLine": 70
          }
        ],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./EnumerableSetLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "EnumerableSetLib",
        "filePath": "utils/EnumerableSetLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "AddressSet"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(AddressSet storage set) internal view returns (uint256 result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let rootPacked := sload(rootSlot)\n            let n := shr(160, shl(160, rootPacked))\n            result := shr(1, n)\n            for {} iszero(or(iszero(shr(96, rootPacked)), n)) {} {\n                result := 1\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 2\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 3\n                break\n            }\n        }\n    }",
            "startLine": 105
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Bytes32Set"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(Bytes32Set storage set) internal view returns (uint256 result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := sload(not(rootSlot))\n            result := shr(1, n)\n            for {} iszero(n) {} {\n                result := 0\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 1\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 2\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 3\n                break\n            }\n        }\n    }",
            "startLine": 124
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint256Set"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(Uint256Set storage set) internal view returns (uint256 result) {\n        result = length(_toBytes32Set(set));\n    }",
            "startLine": 144
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Int256Set"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(Int256Set storage set) internal view returns (uint256 result) {\n        result = length(_toBytes32Set(set));\n    }",
            "startLine": 149
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint8Set"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function length(Uint8Set storage set) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let packed := sload(set.slot) } packed { result := add(1, result) } {\n                packed := xor(packed, and(packed, add(1, not(packed))))\n            }\n        }\n    }",
            "startLine": 154
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "AddressSet"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(AddressSet storage set, address value) internal view returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := shr(96, shl(96, value))\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            let rootPacked := sload(rootSlot)\n            for {} 1 {} {\n                if iszero(shr(160, shl(160, rootPacked))) {\n                    result := 1\n                    if eq(shr(96, rootPacked), value) { break }\n                    if eq(shr(96, sload(add(rootSlot, 1))), value) { break }\n                    if eq(shr(96, sload(add(rootSlot, 2))), value) { break }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := iszero(iszero(sload(keccak256(0x00, 0x40))))\n                break\n            }\n        }\n    }",
            "startLine": 164
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Bytes32Set"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for {} 1 {} {\n                if iszero(sload(not(rootSlot))) {\n                    result := 1\n                    if eq(sload(rootSlot), value) { break }\n                    if eq(sload(add(rootSlot, 1)), value) { break }\n                    if eq(sload(add(rootSlot, 2)), value) { break }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := iszero(iszero(sload(keccak256(0x00, 0x40))))\n                break\n            }\n        }\n    }",
            "startLine": 193
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint256Set"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(Uint256Set storage set, uint256 value) internal view returns (bool result) {\n        result = contains(_toBytes32Set(set), bytes32(value));\n    }",
            "startLine": 220
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Int256Set"
              },
              {
                "name": "value",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(Int256Set storage set, int256 value) internal view returns (bool result) {\n        result = contains(_toBytes32Set(set), bytes32(uint256(value)));\n    }",
            "startLine": 225
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint8Set"
              },
              {
                "name": "value",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function contains(Uint8Set storage set, uint8 value) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(1, shr(and(0xff, value), sload(set.slot)))\n        }\n    }",
            "startLine": 230
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "AddressSet"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function add(AddressSet storage set, address value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := shr(96, shl(96, value))\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            let rootPacked := sload(rootSlot)\n            for { let n := shr(160, shl(160, rootPacked)) } 1 {} {\n                mstore(0x20, rootSlot)\n                if iszero(n) {\n                    let v0 := shr(96, rootPacked)\n                    if iszero(v0) {\n                        sstore(rootSlot, shl(96, value))\n                        result := 1\n                        break\n                    }\n                    if eq(v0, value) { break }\n                    let v1 := shr(96, sload(add(rootSlot, 1)))\n                    if iszero(v1) {\n                        sstore(add(rootSlot, 1), shl(96, value))\n                        result := 1\n                        break\n                    }\n                    if eq(v1, value) { break }\n                    let v2 := shr(96, sload(add(rootSlot, 2)))\n                    if iszero(v2) {\n                        sstore(add(rootSlot, 2), shl(96, value))\n                        result := 1\n                        break\n                    }\n                    if eq(v2, value) { break }\n                    mstore(0x00, v0)\n                    sstore(keccak256(0x00, 0x40), 1)\n                    mstore(0x00, v1)\n                    sstore(keccak256(0x00, 0x40), 2)\n                    mstore(0x00, v2)\n                    sstore(keccak256(0x00, 0x40), 3)\n                    rootPacked := or(rootPacked, 7)\n                    n := 7\n                }\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                if iszero(sload(p)) {\n                    n := shr(1, n)\n                    result := 1\n                    sstore(p, add(1, n))\n                    if iszero(n) {\n                        sstore(rootSlot, or(3, shl(96, value)))\n                        break\n                    }\n                    sstore(add(rootSlot, n), shl(96, value))\n                    sstore(rootSlot, add(2, rootPacked))\n                    break\n                }\n                break\n            }\n        }\n    }",
            "startLine": 238
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Bytes32Set"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function add(Bytes32Set storage set, bytes32 value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for { let n := sload(not(rootSlot)) } 1 {} {\n                mstore(0x20, rootSlot)\n                if iszero(n) {\n                    let v0 := sload(rootSlot)\n                    if iszero(v0) {\n                        sstore(rootSlot, value)\n                        result := 1\n                        break\n                    }\n                    if eq(v0, value) { break }\n                    let v1 := sload(add(rootSlot, 1))\n                    if iszero(v1) {\n                        sstore(add(rootSlot, 1), value)\n                        result := 1\n                        break\n                    }\n                    if eq(v1, value) { break }\n                    let v2 := sload(add(rootSlot, 2))\n                    if iszero(v2) {\n                        sstore(add(rootSlot, 2), value)\n                        result := 1\n                        break\n                    }\n                    if eq(v2, value) { break }\n                    mstore(0x00, v0)\n                    sstore(keccak256(0x00, 0x40), 1)\n                    mstore(0x00, v1)\n                    sstore(keccak256(0x00, 0x40), 2)\n                    mstore(0x00, v2)\n                    sstore(keccak256(0x00, 0x40), 3)\n                    n := 7\n                }\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                if iszero(sload(p)) {\n                    n := shr(1, n)\n                    sstore(add(rootSlot, n), value)\n                    sstore(p, add(1, n))\n                    sstore(not(rootSlot), or(1, shl(1, add(1, n))))\n                    result := 1\n                    break\n                }\n                break\n            }\n        }\n    }",
            "startLine": 302
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Uint256Set"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function add(Uint256Set storage set, uint256 value) internal returns (bool result) {\n        result = add(_toBytes32Set(set), bytes32(value));\n    }",
            "startLine": 359
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Int256Set"
              },
              {
                "name": "value",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function add(Int256Set storage set, int256 value) internal returns (bool result) {\n        result = add(_toBytes32Set(set), bytes32(uint256(value)));\n    }",
            "startLine": 364
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Uint8Set"
              },
              {
                "name": "value",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function add(Uint8Set storage set, uint8 value) internal returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(set.slot)\n            let mask := shl(and(0xff, value), 1)\n            sstore(set.slot, or(result, mask))\n            result := iszero(and(result, mask))\n        }\n    }",
            "startLine": 369
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "AddressSet"
              },
              {
                "name": "value",
                "type": "address"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function add(AddressSet storage set, address value, uint256 cap)\n        internal\n        returns (bool result)\n    {\n        if (result = add(set, value)) {\n            if (length(set) > cap) revert ExceedsCapacity();\n        }\n    }",
            "startLine": 381
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Bytes32Set"
              },
              {
                "name": "value",
                "type": "bytes32"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function add(Bytes32Set storage set, bytes32 value, uint256 cap)\n        internal\n        returns (bool result)\n    {\n        if (result = add(set, value)) {\n            if (length(set) > cap) revert ExceedsCapacity();\n        }\n    }",
            "startLine": 392
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Uint256Set"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function add(Uint256Set storage set, uint256 value, uint256 cap)\n        internal\n        returns (bool result)\n    {\n        if (result = add(set, value)) {\n            if (length(set) > cap) revert ExceedsCapacity();\n        }\n    }",
            "startLine": 403
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Int256Set"
              },
              {
                "name": "value",
                "type": "int256"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function add(Int256Set storage set, int256 value, uint256 cap) internal returns (bool result) {\n        if (result = add(set, value)) if (length(set) > cap) revert ExceedsCapacity();\n    }",
            "startLine": 414
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Uint8Set"
              },
              {
                "name": "value",
                "type": "uint8"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function add(Uint8Set storage set, uint8 value, uint256 cap) internal returns (bool result) {\n        if (result = add(set, value)) if (length(set) > cap) revert ExceedsCapacity();\n    }",
            "startLine": 420
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "AddressSet"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(AddressSet storage set, address value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := shr(96, shl(96, value))\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            let rootPacked := sload(rootSlot)\n            for { let n := shr(160, shl(160, rootPacked)) } 1 {} {\n                if iszero(n) {\n                    result := 1\n                    if eq(shr(96, rootPacked), value) {\n                        sstore(rootSlot, sload(add(rootSlot, 1)))\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 1))), value) {\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 2))), value) {\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                let position := sload(p)\n                if iszero(position) { break }\n                n := sub(shr(1, n), 1)\n                if iszero(eq(sub(position, 1), n)) {\n                    let lastValue := shr(96, sload(add(rootSlot, n)))\n                    sstore(add(rootSlot, sub(position, 1)), shl(96, lastValue))\n                    mstore(0x00, lastValue)\n                    sstore(keccak256(0x00, 0x40), position)\n                }\n                sstore(rootSlot, or(shl(96, shr(96, sload(rootSlot))), or(shl(1, n), 1)))\n                sstore(p, 0)\n                result := 1\n                break\n            }\n        }\n    }",
            "startLine": 425
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Bytes32Set"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Bytes32Set storage set, bytes32 value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for { let n := sload(not(rootSlot)) } 1 {} {\n                if iszero(n) {\n                    result := 1\n                    if eq(sload(rootSlot), value) {\n                        sstore(rootSlot, sload(add(rootSlot, 1)))\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 1)), value) {\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 2)), value) {\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                let position := sload(p)\n                if iszero(position) { break }\n                n := sub(shr(1, n), 1)\n                if iszero(eq(sub(position, 1), n)) {\n                    let lastValue := sload(add(rootSlot, n))\n                    sstore(add(rootSlot, sub(position, 1)), lastValue)\n                    mstore(0x00, lastValue)\n                    sstore(keccak256(0x00, 0x40), position)\n                }\n                sstore(not(rootSlot), or(shl(1, n), 1))\n                sstore(p, 0)\n                result := 1\n                break\n            }\n        }\n    }",
            "startLine": 478
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Uint256Set"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Uint256Set storage set, uint256 value) internal returns (bool result) {\n        result = remove(_toBytes32Set(set), bytes32(value));\n    }",
            "startLine": 529
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Int256Set"
              },
              {
                "name": "value",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Int256Set storage set, int256 value) internal returns (bool result) {\n        result = remove(_toBytes32Set(set), bytes32(uint256(value)));\n    }",
            "startLine": 534
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Uint8Set"
              },
              {
                "name": "value",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function remove(Uint8Set storage set, uint8 value) internal returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(set.slot)\n            let mask := shl(and(0xff, value), 1)\n            sstore(set.slot, and(result, not(mask)))\n            result := iszero(iszero(and(result, mask)))\n        }\n    }",
            "startLine": 539
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "AddressSet"
              },
              {
                "name": "value",
                "type": "address"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(AddressSet storage set, address value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }",
            "startLine": 550
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Bytes32Set"
              },
              {
                "name": "value",
                "type": "bytes32"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(Bytes32Set storage set, bytes32 value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }",
            "startLine": 558
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Uint256Set"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(Uint256Set storage set, uint256 value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }",
            "startLine": 566
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Int256Set"
              },
              {
                "name": "value",
                "type": "int256"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(Int256Set storage set, int256 value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }",
            "startLine": 574
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Uint8Set"
              },
              {
                "name": "value",
                "type": "uint8"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(Uint8Set storage set, uint8 value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }",
            "startLine": 582
          },
          {
            "name": "values",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "AddressSet"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address[]"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function values(AddressSet storage set) internal view returns (address[] memory result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let zs := _ZERO_SENTINEL\n            let rootPacked := sload(rootSlot)\n            let n := shr(160, shl(160, rootPacked))\n            result := mload(0x40)\n            let o := add(0x20, result)\n            let v := shr(96, rootPacked)\n            mstore(o, mul(v, iszero(eq(v, zs))))\n            for {} 1 {} {\n                if iszero(n) {\n                    if v {\n                        n := 1\n                        v := shr(96, sload(add(rootSlot, n)))\n                        if v {\n                            n := 2\n                            mstore(add(o, 0x20), mul(v, iszero(eq(v, zs))))\n                            v := shr(96, sload(add(rootSlot, n)))\n                            if v {\n                                n := 3\n                                mstore(add(o, 0x40), mul(v, iszero(eq(v, zs))))\n                            }\n                        }\n                    }\n                    break\n                }\n                n := shr(1, n)\n                for { let i := 1 } lt(i, n) { i := add(i, 1) } {\n                    v := shr(96, sload(add(rootSlot, i)))\n                    mstore(add(o, shl(5, i)), mul(v, iszero(eq(v, zs))))\n                }\n                break\n            }\n            mstore(result, n)\n            mstore(0x40, add(o, shl(5, n)))\n        }\n    }",
            "startLine": 591
          },
          {
            "name": "values",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Bytes32Set"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32[]"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function values(Bytes32Set storage set) internal view returns (bytes32[] memory result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let zs := _ZERO_SENTINEL\n            let n := sload(not(rootSlot))\n            result := mload(0x40)\n            let o := add(0x20, result)\n            for {} 1 {} {\n                if iszero(n) {\n                    let v := sload(rootSlot)\n                    if v {\n                        n := 1\n                        mstore(o, mul(v, iszero(eq(v, zs))))\n                        v := sload(add(rootSlot, n))\n                        if v {\n                            n := 2\n                            mstore(add(o, 0x20), mul(v, iszero(eq(v, zs))))\n                            v := sload(add(rootSlot, n))\n                            if v {\n                                n := 3\n                                mstore(add(o, 0x40), mul(v, iszero(eq(v, zs))))\n                            }\n                        }\n                    }\n                    break\n                }\n                n := shr(1, n)\n                for { let i := 0 } lt(i, n) { i := add(i, 1) } {\n                    let v := sload(add(rootSlot, i))\n                    mstore(add(o, shl(5, i)), mul(v, iszero(eq(v, zs))))\n                }\n                break\n            }\n            mstore(result, n)\n            mstore(0x40, add(o, shl(5, n)))\n        }\n    }",
            "startLine": 633
          },
          {
            "name": "values",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint256Set"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "values",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function values(Uint256Set storage set) internal view returns (uint256[] memory result) {\n        result = _toUints(values(_toBytes32Set(set)));\n    }",
            "startLine": 674
          },
          {
            "name": "values",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Int256Set"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "int256[]"
              }
            ],
            "calls": [
              {
                "target": "_toInts",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "values",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function values(Int256Set storage set) internal view returns (int256[] memory result) {\n        result = _toInts(values(_toBytes32Set(set)));\n    }",
            "startLine": 680
          },
          {
            "name": "values",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint8Set"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint8[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function values(Uint8Set storage set) internal view returns (uint8[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let ptr := add(result, 0x20)\n            let o := 0\n            for { let packed := sload(set.slot) } packed {} {\n                if iszero(and(packed, 0xffff)) {\n                    o := add(o, 16)\n                    packed := shr(16, packed)\n                    continue\n                }\n                mstore(ptr, o)\n                ptr := add(ptr, shl(5, and(packed, 1)))\n                o := add(o, 1)\n                packed := shr(1, packed)\n            }\n            mstore(result, shr(5, sub(ptr, add(result, 0x20))))\n            mstore(0x40, ptr)\n        }\n    }",
            "startLine": 685
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "AddressSet"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(AddressSet storage set, uint256 i) internal view returns (address result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(96, sload(add(rootSlot, i)))\n            result := mul(result, iszero(eq(result, _ZERO_SENTINEL)))\n        }\n        if (i >= length(set)) revert IndexOutOfBounds();\n    }",
            "startLine": 708
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Bytes32Set"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Bytes32Set storage set, uint256 i) internal view returns (bytes32 result) {\n        result = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(add(result, i))\n            result := mul(result, iszero(eq(result, _ZERO_SENTINEL)))\n        }\n        if (i >= length(set)) revert IndexOutOfBounds();\n    }",
            "startLine": 719
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint256Set"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "at",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Uint256Set storage set, uint256 i) internal view returns (uint256 result) {\n        result = uint256(at(_toBytes32Set(set), i));\n    }",
            "startLine": 730
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Int256Set"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "at",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Int256Set storage set, uint256 i) internal view returns (int256 result) {\n        result = int256(uint256(at(_toBytes32Set(set), i)));\n    }",
            "startLine": 735
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint8Set"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint8"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function at(Uint8Set storage set, uint256 i) internal view returns (uint8 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := sload(set.slot)\n            for {} 1 {\n                mstore(0x00, 0x4e23d035) // `IndexOutOfBounds()`.\n                revert(0x1c, 0x04)\n            } {\n                if iszero(lt(i, 256)) { continue }\n                for { let j := 0 } iszero(eq(i, j)) {} {\n                    packed := xor(packed, and(packed, add(1, not(packed))))\n                    j := add(j, 1)\n                }\n                if iszero(packed) { continue }\n                break\n            }\n            // Find first set subroutine, optimized for smaller bytecode size.\n            let x := and(packed, add(1, not(packed)))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            result := or(r, byte(and(div(0xd76453e0, shr(r, x)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }",
            "startLine": 740
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "AddressSet"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(AddressSet storage set, address value) internal view returns (uint256 result) {\n        result = NOT_FOUND;\n        if (uint160(value) == _ZERO_SENTINEL) return result;\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(value) { value := _ZERO_SENTINEL }\n            result := not(0)\n            let rootPacked := sload(rootSlot)\n            for {} 1 {} {\n                if iszero(shr(160, shl(160, rootPacked))) {\n                    if eq(shr(96, rootPacked), value) {\n                        result := 0\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 1))), value) {\n                        result := 1\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 2))), value) {\n                        result := 2\n                        break\n                    }\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := sub(sload(keccak256(0x00, 0x40)), 1)\n                break\n            }\n        }\n    }",
            "startLine": 769
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Bytes32Set"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(Bytes32Set storage set, bytes32 value) internal view returns (uint256 result) {\n        result = NOT_FOUND;\n        if (uint256(value) == _ZERO_SENTINEL) return result;\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for {} 1 {} {\n                if iszero(sload(not(rootSlot))) {\n                    if eq(sload(rootSlot), value) {\n                        result := 0\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 1)), value) {\n                        result := 1\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 2)), value) {\n                        result := 2\n                        break\n                    }\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := sub(sload(keccak256(0x00, 0x40)), 1)\n                break\n            }\n        }\n    }",
            "startLine": 803
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint256Set"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(Uint256Set storage set, uint256 i) internal view returns (uint256 result) {\n        result = indexOf(_toBytes32Set(set), bytes32(i));\n    }",
            "startLine": 835
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Int256Set"
              },
              {
                "name": "i",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(Int256Set storage set, int256 i) internal view returns (uint256 result) {\n        result = indexOf(_toBytes32Set(set), bytes32(uint256(i)));\n    }",
            "startLine": 840
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint8Set"
              },
              {
                "name": "value",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function indexOf(Uint8Set storage set, uint8 value) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0)\n            let packed := sload(set.slot)\n            let m := shl(and(0xff, value), 1)\n            if and(packed, m) {\n                result := 0\n                for { let p := and(packed, sub(m, 1)) } p {} {\n                    p := xor(p, and(p, add(1, not(p))))\n                    result := add(result, 1)\n                }\n            }\n        }\n    }",
            "startLine": 845
          },
          {
            "name": "_rootSlot",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "AddressSet"
              }
            ],
            "returnValues": [
              {
                "name": "r",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _rootSlot(AddressSet storage s) private pure returns (bytes32 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ENUMERABLE_ADDRESS_SET_SLOT_SEED)\n            mstore(0x00, s.slot)\n            r := keccak256(0x00, 0x24)\n        }\n    }",
            "startLine": 866
          },
          {
            "name": "_rootSlot",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "Bytes32Set"
              }
            ],
            "returnValues": [
              {
                "name": "r",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _rootSlot(Bytes32Set storage s) private pure returns (bytes32 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ENUMERABLE_WORD_SET_SLOT_SEED)\n            mstore(0x00, s.slot)\n            r := keccak256(0x00, 0x24)\n        }\n    }",
            "startLine": 876
          },
          {
            "name": "_toBytes32Set",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "Uint256Set"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "Bytes32Set"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toBytes32Set(Uint256Set storage s) private pure returns (Bytes32Set storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c.slot := s.slot\n        }\n    }",
            "startLine": 886
          },
          {
            "name": "_toBytes32Set",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "Int256Set"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "Bytes32Set"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toBytes32Set(Int256Set storage s) private pure returns (Bytes32Set storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c.slot := s.slot\n        }\n    }",
            "startLine": 894
          },
          {
            "name": "_toUints",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toUints(bytes32[] memory a) private pure returns (uint256[] memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := a\n        }\n    }",
            "startLine": 902
          },
          {
            "name": "_toInts",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "int256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toInts(bytes32[] memory a) private pure returns (int256[] memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := a\n        }\n    }",
            "startLine": 910
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "IndexOutOfBounds",
            "parameters": [],
            "startLine": 23
          },
          {
            "name": "ValueIsZeroSentinel",
            "parameters": [],
            "startLine": 26
          },
          {
            "name": "ExceedsCapacity",
            "parameters": [],
            "startLine": 29
          }
        ],
        "structs": [
          {
            "name": "AddressSet",
            "members": [
              {
                "name": "_spacer",
                "type": "uint256"
              }
            ],
            "startLine": 76
          },
          {
            "name": "Bytes32Set",
            "members": [
              {
                "name": "_spacer",
                "type": "uint256"
              }
            ],
            "startLine": 81
          },
          {
            "name": "Uint256Set",
            "members": [
              {
                "name": "_spacer",
                "type": "uint256"
              }
            ],
            "startLine": 86
          },
          {
            "name": "Int256Set",
            "members": [
              {
                "name": "_spacer",
                "type": "uint256"
              }
            ],
            "startLine": 91
          },
          {
            "name": "Uint8Set",
            "members": [
              {
                "name": "data",
                "type": "uint256"
              }
            ],
            "startLine": 96
          }
        ],
        "stateVariables": [
          {
            "name": "NOT_FOUND",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 36
          },
          {
            "name": "_ZERO_SENTINEL",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 41
          },
          {
            "name": "_ENUMERABLE_ADDRESS_SET_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 55
          },
          {
            "name": "_ENUMERABLE_WORD_SET_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 69
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "FixedPointMathLib",
        "filePath": "utils/FixedPointMathLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "mulWad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if gt(x, div(not(0), y)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }",
            "startLine": 64
          },
          {
            "name": "sMulWad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              },
              {
                "name": "y",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }",
            "startLine": 79
          },
          {
            "name": "rawMulWad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }",
            "startLine": 93
          },
          {
            "name": "rawSMulWad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              },
              {
                "name": "y",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }",
            "startLine": 101
          },
          {
            "name": "mulWadUp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if iszero(eq(div(z, y), x)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := add(iszero(iszero(mod(z, WAD))), div(z, WAD))\n        }\n    }",
            "startLine": 109
          },
          {
            "name": "rawMulWadUp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }",
            "startLine": 125
          },
          {
            "name": "divWad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }",
            "startLine": 133
          },
          {
            "name": "sDivWad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              },
              {
                "name": "y",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(mul(y, eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, y)\n        }\n    }",
            "startLine": 146
          },
          {
            "name": "rawDivWad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }",
            "startLine": 160
          },
          {
            "name": "rawSDivWad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              },
              {
                "name": "y",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }",
            "startLine": 168
          },
          {
            "name": "divWadUp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }",
            "startLine": 176
          },
          {
            "name": "rawDivWadUp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }",
            "startLine": 189
          },
          {
            "name": "powWad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              },
              {
                "name": "y",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "expWad",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "lnWad",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }",
            "startLine": 199
          },
          {
            "name": "expWad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "r",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18)  135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (- ln 2,  ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s  6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }",
            "startLine": 207
          },
          {
            "name": "lnWad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "r",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }",
            "startLine": 277
          },
          {
            "name": "lambertW0Wad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "w",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "lnWad",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "expWad",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lambertW0Wad(int256 x)\n        internal\n        pure\n        returns (int256 w)\n    {\n\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            (int256 wad, int256 p) = (int256(WAD), x);\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (uint256(w >> 63) == uint256(0)) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == uint256(0)) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != uint256(0));\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c == uint256(0)) return w;\n            int256 t = w | 1;\n            /// @solidity memory-safe-assembly\n            assembly {\n                x := sdiv(mul(x, wad), t)\n            }\n            x = (t * (wad + lnWad(x)));\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sdiv(x, add(wad, t))\n            }\n        }\n    }",
            "startLine": 353
          },
          {
            "name": "fullMulEq",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256"
              },
              {
                "name": "b",
                "type": "uint256"
              },
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function fullMulEq(uint256 a, uint256 b, uint256 x, uint256 y)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(mul(a, b), mul(x, y)), eq(mulmod(x, y, not(0)), mulmod(a, b, not(0))))\n        }\n    }",
            "startLine": 446
          },
          {
            "name": "fullMulDiv",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              },
              {
                "name": "d",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // 512-bit multiply `[p1 p0] = x * y`.\n            // Compute the product mod `2**256` and mod `2**256 - 1`\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that `product = p1 * 2**256 + p0`.\n\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`.\n            for {} 1 {} {\n                // If overflows.\n                if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n\n                    /*------------------- 512 by 256 division --------------------*/\n\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\n                    // Make sure `z` is less than `2**256`. Also prevents `d == 0`.\n                    // Placing the check here seems to give more optimal stack operations.\n                    if iszero(gt(d, p1)) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\n                    // Invert `d mod 2**256`\n                    // Now that `d` is an odd number, it has an inverse\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                    // Compute the inverse by starting with a seed that is correct\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                    let inv := xor(2, mul(3, d))\n                    // Now use Newton-Raphson iteration to improve the precision.\n                    // Thanks to Hensel's lifting lemma, this also works in modular\n                    // arithmetic, doubling the correct bits in each step.\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                    z := mul(\n                        // Divide [p1 p0] by the factors of two.\n                        // Shift in bits from `p1` into `p0`. For this we need\n                        // to flip `t` such that it is `2**256 / t`.\n                        or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                        mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\n                    )\n                    break\n                }\n                z := div(z, d)\n                break\n            }\n        }\n    }",
            "startLine": 460
          },
          {
            "name": "fullMulDivUnchecked",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              },
              {
                "name": "d",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            let mm := mulmod(x, y, not(0))\n            let p1 := sub(mm, add(z, lt(mm, z)))\n            let t := and(d, sub(0, d))\n            let r := mulmod(x, y, d)\n            d := div(d, t)\n            let inv := xor(2, mul(3, d))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            z := mul(\n                or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                mul(sub(2, mul(d, inv)), inv)\n            )\n        }\n    }",
            "startLine": 521
          },
          {
            "name": "fullMulDivUp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              },
              {
                "name": "d",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "fullMulDiv",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        z = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                z := add(z, 1)\n                if iszero(z) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 551
          },
          {
            "name": "fullMulDivN",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              },
              {
                "name": "n",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function fullMulDivN(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`. We'll call this `z`.\n            for {} 1 {} {\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    let k := and(n, 0xff) // `n`, cleaned.\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n                    //         |      p1     |      z     |\n                    // Before: | p1_0  p1_1 | z_0   z_1 |\n                    // Final:  |   0   p1_0 | p1_1  z_0 |\n                    // Check that final `z` doesn't overflow by checking that p1_0 = 0.\n                    if iszero(shr(k, p1)) {\n                        z := add(shl(sub(256, k), p1), shr(k, z))\n                        break\n                    }\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                z := shr(and(n, 0xff), z)\n                break\n            }\n        }\n    }",
            "startLine": 569
          },
          {
            "name": "mulDiv",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              },
              {
                "name": "d",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(z, d)\n        }\n    }",
            "startLine": 598
          },
          {
            "name": "mulDivUp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              },
              {
                "name": "d",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\n        }\n    }",
            "startLine": 613
          },
          {
            "name": "invMod",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function invMod(uint256 a, uint256 n) internal pure returns (uint256 x) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let g := n\n            let r := mod(a, n)\n            for { let y := 1 } 1 {} {\n                let q := div(g, r)\n                let t := g\n                g := r\n                r := sub(t, mul(r, q))\n                let u := x\n                x := y\n                y := sub(u, mul(y, q))\n                if iszero(r) { break }\n            }\n            x := mul(eq(g, 1), add(x, mul(slt(x, 0), n)))\n        }\n    }",
            "startLine": 627
          },
          {
            "name": "divUp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "d",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }",
            "startLine": 648
          },
          {
            "name": "zeroFloorSub",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }",
            "startLine": 660
          },
          {
            "name": "saturatingSub",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function saturatingSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }",
            "startLine": 668
          },
          {
            "name": "saturatingAdd",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function saturatingAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(sub(0, lt(add(x, y), x)), add(x, y))\n        }\n    }",
            "startLine": 676
          },
          {
            "name": "saturatingMul",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function saturatingMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(sub(or(iszero(x), eq(div(mul(x, y), x), y)), 1), mul(x, y))\n        }\n    }",
            "startLine": 684
          },
          {
            "name": "ternary",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "condition",
                "type": "bool"
              },
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }",
            "startLine": 692
          },
          {
            "name": "ternary",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "condition",
                "type": "bool"
              },
              {
                "name": "x",
                "type": "bytes32"
              },
              {
                "name": "y",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function ternary(bool condition, bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }",
            "startLine": 700
          },
          {
            "name": "ternary",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "condition",
                "type": "bool"
              },
              {
                "name": "x",
                "type": "address"
              },
              {
                "name": "y",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function ternary(bool condition, address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }",
            "startLine": 708
          },
          {
            "name": "coalesce",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function coalesce(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(x)))\n        }\n    }",
            "startLine": 716
          },
          {
            "name": "coalesce",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bytes32"
              },
              {
                "name": "y",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function coalesce(bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(x)))\n        }\n    }",
            "startLine": 724
          },
          {
            "name": "coalesce",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "address"
              },
              {
                "name": "y",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function coalesce(address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(shl(96, x))))\n        }\n    }",
            "startLine": 732
          },
          {
            "name": "rpow",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              },
              {
                "name": "b",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if x {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }",
            "startLine": 741
          },
          {
            "name": "sqrt",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }",
            "startLine": 778
          },
          {
            "name": "cbrt",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // Makeshift lookup table to nudge the approximate log2 result.\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n            // Newton-Raphson's.\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            // Round down.\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }",
            "startLine": 836
          },
          {
            "name": "sqrtWad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "sqrt",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "fullMulDivUnchecked",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\n            z = (1 + sqrt(x)) * 10 ** 9;\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\n        }\n    }",
            "startLine": 860
          },
          {
            "name": "cbrtWad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "cbrt",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "fullMulDivUnchecked",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\n            z = (1 + cbrt(x)) * 10 ** 12;\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let p := x\n            for {} 1 {} {\n                if iszero(shr(229, p)) {\n                    if iszero(shr(199, p)) {\n                        p := mul(p, 100000000000000000) // 10 ** 17.\n                        break\n                    }\n                    p := mul(p, 100000000) // 10 ** 8.\n                    break\n                }\n                if iszero(shr(249, p)) { p := mul(p, 100) }\n                break\n            }\n            let t := mulmod(mul(z, z), z, p)\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\n        }\n    }",
            "startLine": 875
          },
          {
            "name": "mulSqrt",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "rawMul",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "rawDiv",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "sqrt",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "saturatingMul",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "rawAdd",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "avg",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "fullMulDivUnchecked",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function mulSqrt(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        if (x == y) return x;\n        uint256 p = rawMul(x, y);\n        if (y == rawDiv(p, x)) return sqrt(p);\n        for (z = saturatingMul(rawAdd(sqrt(x), 1), rawAdd(sqrt(y), 1));; z = avg(z, p)) {\n            if ((p = fullMulDivUnchecked(x, y, z)) >= z) break;\n        }\n    }",
            "startLine": 902
          },
          {
            "name": "factorial",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function factorial(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := 1\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for {} x { x := sub(x, 1) } { z := mul(z, x) }\n        }\n    }",
            "startLine": 912
          },
          {
            "name": "log2",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "r",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }",
            "startLine": 927
          },
          {
            "name": "log2Up",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "r",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "log2",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }",
            "startLine": 943
          },
          {
            "name": "log10",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "r",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }",
            "startLine": 953
          },
          {
            "name": "log10Up",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "r",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "log10",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }",
            "startLine": 978
          },
          {
            "name": "log256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "r",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }",
            "startLine": 988
          },
          {
            "name": "log256Up",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "r",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "log256",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }",
            "startLine": 1001
          },
          {
            "name": "sci",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "mantissa",
                "type": "uint256"
              },
              {
                "name": "exponent",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }",
            "startLine": 1011
          },
          {
            "name": "packSci",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "packed",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "sci",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }",
            "startLine": 1056
          },
          {
            "name": "unpackSci",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "packed",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "unpacked",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }",
            "startLine": 1069
          },
          {
            "name": "avg",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }",
            "startLine": 1076
          },
          {
            "name": "avg",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              },
              {
                "name": "y",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }",
            "startLine": 1083
          },
          {
            "name": "abs",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function abs(int256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = (uint256(x) + uint256(x >> 255)) ^ uint256(x >> 255);\n        }\n    }",
            "startLine": 1090
          },
          {
            "name": "dist",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, gt(x, y)), sub(y, x)), gt(x, y))\n        }\n    }",
            "startLine": 1097
          },
          {
            "name": "dist",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              },
              {
                "name": "y",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, sgt(x, y)), sub(y, x)), sgt(x, y))\n        }\n    }",
            "startLine": 1105
          },
          {
            "name": "min",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }",
            "startLine": 1113
          },
          {
            "name": "min",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              },
              {
                "name": "y",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }",
            "startLine": 1121
          },
          {
            "name": "max",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }",
            "startLine": 1129
          },
          {
            "name": "max",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              },
              {
                "name": "y",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }",
            "startLine": 1137
          },
          {
            "name": "clamp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "minValue",
                "type": "uint256"
              },
              {
                "name": "maxValue",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }",
            "startLine": 1145
          },
          {
            "name": "clamp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              },
              {
                "name": "minValue",
                "type": "int256"
              },
              {
                "name": "maxValue",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }",
            "startLine": 1158
          },
          {
            "name": "gcd",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }",
            "startLine": 1167
          },
          {
            "name": "lerp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256"
              },
              {
                "name": "b",
                "type": "uint256"
              },
              {
                "name": "t",
                "type": "uint256"
              },
              {
                "name": "begin",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "fullMulDiv",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        unchecked {\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\n            return a - fullMulDiv(a - b, t - begin, end - begin);\n        }\n    }",
            "startLine": 1182
          },
          {
            "name": "lerp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "int256"
              },
              {
                "name": "b",
                "type": "int256"
              },
              {
                "name": "t",
                "type": "int256"
              },
              {
                "name": "begin",
                "type": "int256"
              },
              {
                "name": "end",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "fullMulDiv",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end)\n        internal\n        pure\n        returns (int256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        // forgefmt: disable-next-item\n        unchecked {\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b - a),\n                uint256(t - begin), uint256(end - begin)));\n            return int256(uint256(a) - fullMulDiv(uint256(a - b),\n                uint256(t - begin), uint256(end - begin)));\n        }\n    }",
            "startLine": 1200
          },
          {
            "name": "isEven",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isEven(uint256 x) internal pure returns (bool) {\n        return x & uint256(1) == uint256(0);\n    }",
            "startLine": 1218
          },
          {
            "name": "rawAdd",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }",
            "startLine": 1227
          },
          {
            "name": "rawAdd",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              },
              {
                "name": "y",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }",
            "startLine": 1234
          },
          {
            "name": "rawSub",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }",
            "startLine": 1241
          },
          {
            "name": "rawSub",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              },
              {
                "name": "y",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }",
            "startLine": 1248
          },
          {
            "name": "rawMul",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }",
            "startLine": 1255
          },
          {
            "name": "rawMul",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              },
              {
                "name": "y",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }",
            "startLine": 1262
          },
          {
            "name": "rawDiv",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }",
            "startLine": 1269
          },
          {
            "name": "rawSDiv",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              },
              {
                "name": "y",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }",
            "startLine": 1277
          },
          {
            "name": "rawMod",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }",
            "startLine": 1285
          },
          {
            "name": "rawSMod",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              },
              {
                "name": "y",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }",
            "startLine": 1293
          },
          {
            "name": "rawAddMod",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              },
              {
                "name": "d",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }",
            "startLine": 1301
          },
          {
            "name": "rawMulMod",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              },
              {
                "name": "d",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }",
            "startLine": 1309
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ExpOverflow",
            "parameters": [],
            "startLine": 13
          },
          {
            "name": "FactorialOverflow",
            "parameters": [],
            "startLine": 16
          },
          {
            "name": "RPowOverflow",
            "parameters": [],
            "startLine": 19
          },
          {
            "name": "MantissaOverflow",
            "parameters": [],
            "startLine": 22
          },
          {
            "name": "MulWadFailed",
            "parameters": [],
            "startLine": 25
          },
          {
            "name": "SMulWadFailed",
            "parameters": [],
            "startLine": 28
          },
          {
            "name": "DivWadFailed",
            "parameters": [],
            "startLine": 31
          },
          {
            "name": "SDivWadFailed",
            "parameters": [],
            "startLine": 34
          },
          {
            "name": "MulDivFailed",
            "parameters": [],
            "startLine": 37
          },
          {
            "name": "DivFailed",
            "parameters": [],
            "startLine": 40
          },
          {
            "name": "FullMulDivFailed",
            "parameters": [],
            "startLine": 44
          },
          {
            "name": "LnWadUndefined",
            "parameters": [],
            "startLine": 47
          },
          {
            "name": "OutOfDomain",
            "parameters": [],
            "startLine": 50
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "WAD",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 57
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "GasBurnerLib",
        "filePath": "utils/GasBurnerLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "burnPure",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function burnPure(uint256 x) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x10, or(1, x))\n            let n := mul(gt(x, 120), div(x, 91))\n            // We use keccak256 instead of blake2f precompile for better widespread compatibility.\n            for { let i := 0 } iszero(eq(i, n)) { i := add(i, 1) } {\n                mstore(0x10, keccak256(0x10, 0x10)) // Yes.\n            }\n            if iszero(mload(0x10)) { invalid() }\n        }\n    }",
            "startLine": 15
          },
          {
            "name": "burnView",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function burnView(uint256 x) internal view {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mul(gt(x, 3500), div(x, 3200))\n            let m := mload(0x40)\n            mstore(0x00, xor(address(), xor(origin(), timestamp())))\n            mstore(0x00, keccak256(0x00, 0x20))\n            mstore(0x20, 27) // `v`.\n            mstore(0x40, 45) // `r`.\n            mstore(0x60, 10) // `s`.\n            for { let i := 0 } iszero(eq(i, n)) { i := add(i, 1) } {\n                pop(staticcall(gas(), 1, 0x00, 0x81, 0x00, 0x20))\n            }\n            if iszero(mload(0x10)) { invalid() }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 29
          },
          {
            "name": "burn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function burn(uint256 x) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mul(gt(x, 18000), div(x, 17700))\n            mstore(m, xor(address(), xor(origin(), timestamp())))\n            codecopy(add(m, 0x20), and(keccak256(m, 0x20), 0xff), 2080)\n            for { let i := 0 } 1 { i := add(i, 1) } {\n                let h := keccak256(m, 0x21)\n                mstore(m, h)\n                codecopy(add(m, and(h, 0x7ff)), and(0xff, h), 0xff)\n                mstore(add(m, 2048), not(h))\n                if eq(i, n) {\n                    n := shr(3, mod(x, 17700))\n                    n := mul(gt(n, 0x30), sub(n, 0x30))\n                    mstore(add(m, n), h)\n                    log0(m, add(n, 0x20))\n                    break\n                }\n                log0(m, 2080)\n            }\n        }\n    }",
            "startLine": 49
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "Initializable",
        "filePath": "utils/Initializable.sol",
        "kind": "abstract",
        "inherits": [],
        "implements": [],
        "category": "utils",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "constructor",
            "visibility": "default",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_initializableSlot",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "constructor() {\n        // Construction time check to ensure that `_initializableSlot()` is not\n        // overridden to zero. Will be optimized away if there is no revert.\n        require(_initializableSlot() != bytes32(0));\n    }",
            "startLine": 46
          },
          {
            "name": "_initializableSlot",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _initializableSlot() internal pure virtual returns (bytes32) {\n        return _INITIALIZABLE_SLOT;\n    }",
            "startLine": 57
          },
          {
            "name": "_checkInitializing",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_initializableSlot",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(and(1, sload(s))) {\n                mstore(0x00, 0xd7e6bcf8) // `NotInitializing()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 141
          },
          {
            "name": "_disableInitializers",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_initializableSlot",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let i := sload(s)\n            if and(i, 1) {\n                mstore(0x00, 0xf92ee8a9) // `InvalidInitialization()`.\n                revert(0x1c, 0x04)\n            }\n            let uint64max := 0xffffffffffffffff\n            if iszero(eq(shr(1, i), uint64max)) {\n                // Set `initializing` to 0, `initializedVersion` to `2**64 - 1`.\n                sstore(s, shl(1, uint64max))\n                // Emit the {Initialized} event.\n                mstore(0x20, uint64max)\n                log1(0x20, 0x20, _INITIALIZED_EVENT_SIGNATURE)\n            }\n        }\n    }",
            "startLine": 159
          },
          {
            "name": "_getInitializedVersion",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "version",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_initializableSlot",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _getInitializedVersion() internal view virtual returns (uint64 version) {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            version := shr(1, sload(s))\n        }\n    }",
            "startLine": 180
          },
          {
            "name": "_isInitializing",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_initializableSlot",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _isInitializing() internal view virtual returns (bool result) {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(1, sload(s))\n        }\n    }",
            "startLine": 189
          }
        ],
        "events": [
          {
            "name": "Initialized",
            "parameters": [
              {
                "name": "version",
                "type": "uint64",
                "indexed": false
              }
            ],
            "startLine": 23
          }
        ],
        "errors": [
          {
            "name": "InvalidInitialization",
            "parameters": [],
            "startLine": 13
          },
          {
            "name": "NotInitializing",
            "parameters": [],
            "startLine": 16
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_INITIALIZED_EVENT_SIGNATURE",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 26
          },
          {
            "name": "_INITIALIZABLE_SLOT",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 39
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "JSONParserLib",
        "filePath": "utils/JSONParserLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "parse",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "Item"
              }
            ],
            "calls": [
              {
                "target": "_query",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toInput",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function parse(string memory s) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // We will use our own allocation instead.\n        }\n        bytes32 r = _query(_toInput(s), 255);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }",
            "startLine": 82
          },
          {
            "name": "value",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_query",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toInput",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function value(Item memory item) internal pure returns (string memory result) {\n        bytes32 r = _query(_toInput(item), 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }",
            "startLine": 116
          },
          {
            "name": "index",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function index(Item memory item) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if and(mload(item), _PARENT_IS_ARRAY) {\n                result := and(_BITMASK_POINTER, shr(_BITPOS_KEY, mload(item)))\n            }\n        }\n    }",
            "startLine": 126
          },
          {
            "name": "key",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_query",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toInput",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function key(Item memory item) internal pure returns (string memory result) {\n        if (item._data & _PARENT_IS_OBJECT != 0) {\n            bytes32 r = _query(_toInput(item), 1);\n            /// @solidity memory-safe-assembly\n            assembly {\n                result := r\n            }\n        }\n    }",
            "startLine": 141
          },
          {
            "name": "children",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "Item[]"
              }
            ],
            "calls": [
              {
                "target": "_query",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toInput",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function children(Item memory item) internal pure returns (Item[] memory result) {\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }",
            "startLine": 156
          },
          {
            "name": "size",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_query",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toInput",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function size(Item memory item) internal pure returns (uint256 result) {\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(r)\n        }\n    }",
            "startLine": 166
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "Item"
              }
            ],
            "calls": [
              {
                "target": "_query",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toInput",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Item memory item, uint256 i) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\n        }\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(r, 0x20), shl(5, i)))\n            if iszero(and(lt(i, mload(r)), eq(and(mload(item), _BITMASK_TYPE), TYPE_ARRAY))) {\n                result := 0x60 // Reset to the zero pointer.\n            }\n        }\n    }",
            "startLine": 177
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              },
              {
                "name": "k",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "Item"
              }
            ],
            "calls": [
              {
                "target": "isObject",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "children",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "key",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Item memory item, string memory k) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\n            result := 0x60 // Initialize to the zero pointer.\n        }\n        if (isObject(item)) {\n            bytes32 kHash = keccak256(bytes(k));\n            Item[] memory r = children(item);\n            // We'll just do a linear search. The alternatives are very bloated.\n            for (uint256 i = r.length << 5; i != 0;) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    item := mload(add(r, i))\n                    i := sub(i, 0x20)\n                }\n                if (keccak256(bytes(key(item))) != kHash) continue;\n                result = item;\n                break;\n            }\n        }\n    }",
            "startLine": 199
          },
          {
            "name": "getType",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint8"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getType(Item memory item) internal pure returns (uint8 result) {\n        result = uint8(item._data & _BITMASK_TYPE);\n    }",
            "startLine": 223
          },
          {
            "name": "isUndefined",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isUndefined(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_UNDEFINED;\n    }",
            "startLine": 230
          },
          {
            "name": "isArray",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isArray(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_ARRAY;\n    }",
            "startLine": 235
          },
          {
            "name": "isObject",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isObject(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_OBJECT;\n    }",
            "startLine": 240
          },
          {
            "name": "isNumber",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isNumber(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_NUMBER;\n    }",
            "startLine": 245
          },
          {
            "name": "isString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isString(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_STRING;\n    }",
            "startLine": 250
          },
          {
            "name": "isBoolean",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isBoolean(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_BOOLEAN;\n    }",
            "startLine": 255
          },
          {
            "name": "isNull",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isNull(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_NULL;\n    }",
            "startLine": 260
          },
          {
            "name": "parent",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "Item"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function parent(Item memory item) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We've already allocated.\n            result := and(shr(_BITPOS_SIBLING_OR_PARENT, mload(item)), _BITMASK_POINTER)\n            if iszero(result) { result := 0x60 } // Reset to the zero pointer.\n        }\n    }",
            "startLine": 266
          },
          {
            "name": "parseUint",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function parseUint(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            let preMulOverflowThres := div(not(0), 10)\n            for { let i := 0 } 1 {} {\n                i := add(i, 1)\n                let digit := sub(and(mload(add(s, i)), 0xff), 48)\n                let mulOverflowed := gt(result, preMulOverflowThres)\n                let product := mul(10, result)\n                result := add(product, digit)\n                n := mul(n, iszero(or(or(mulOverflowed, lt(result, product)), gt(digit, 9))))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 282
          },
          {
            "name": "parseInt",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "parseUint",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function parseInt(string memory s) internal pure returns (int256 result) {\n        uint256 n = bytes(s).length;\n        uint256 sign;\n        uint256 isNegative;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if n {\n                let c := and(mload(add(s, 1)), 0xff)\n                isNegative := eq(c, 45)\n                if or(eq(c, 43), isNegative) {\n                    sign := c\n                    s := add(s, 1)\n                    mstore(s, sub(n, 1))\n                }\n                if iszero(or(sign, lt(sub(c, 48), 10))) { s := 0x60 }\n            }\n        }\n        uint256 x = parseUint(s);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, add(shl(255, 1), isNegative))) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if sign {\n                mstore(s, sign)\n                s := sub(s, 1)\n                mstore(s, n)\n            }\n            result := xor(x, mul(xor(x, add(not(x), 1)), isNegative))\n        }\n    }",
            "startLine": 306
          },
          {
            "name": "parseUintFromHex",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function parseUintFromHex(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            // Skip two if starts with '0x' or '0X'.\n            let i := shl(1, and(eq(0x3078, or(shr(240, mload(add(s, 0x20))), 0x20)), gt(n, 1)))\n            for {} 1 {} {\n                i := add(i, 1)\n                let c :=\n                    byte(\n                        and(0x1f, shr(and(mload(add(s, i)), 0xff), 0x3e4088843e41bac000000000000)),\n                        0x3010a071000000b0104040208000c05090d060e0f\n                    )\n                n := mul(n, iszero(or(iszero(c), shr(252, result))))\n                result := add(shl(4, result), sub(c, 1))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 342
          },
          {
            "name": "decodeString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function decodeString(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function fail() {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            function decodeUnicodeEscapeSequence(pIn_, end_) -> _unicode, _pOut {\n                _pOut := add(pIn_, 4)\n                let b_ := iszero(gt(_pOut, end_))\n                let t_ := mload(pIn_) // Load the whole word.\n                for { let i_ := 0 } iszero(eq(i_, 4)) { i_ := add(i_, 1) } {\n                    let c_ := sub(byte(i_, t_), 48)\n                    if iszero(and(shr(c_, 0x7e0000007e03ff), b_)) { fail() } // Not hexadecimal.\n                    c_ := sub(c_, add(mul(gt(c_, 16), 7), shl(5, gt(c_, 48))))\n                    _unicode := add(shl(4, _unicode), c_)\n                }\n            }\n\n            function decodeUnicodeCodePoint(pIn_, end_) -> _unicode, _pOut {\n                _unicode, _pOut := decodeUnicodeEscapeSequence(pIn_, end_)\n                if iszero(or(lt(_unicode, 0xd800), gt(_unicode, 0xdbff))) {\n                    let t_ := mload(_pOut) // Load the whole word.\n                    end_ := mul(end_, eq(shr(240, t_), 0x5c75)) // Fail if not starting with '\\\\u'.\n                    t_, _pOut := decodeUnicodeEscapeSequence(add(_pOut, 2), end_)\n                    _unicode := add(0x10000, add(shl(10, and(0x3ff, _unicode)), and(0x3ff, t_)))\n                }\n            }\n\n            function appendCodePointAsUTF8(pIn_, c_) -> _pOut {\n                if iszero(gt(c_, 0x7f)) {\n                    mstore8(pIn_, c_)\n                    _pOut := add(pIn_, 1)\n                    leave\n                }\n                mstore8(0x1f, c_)\n                mstore8(0x1e, shr(6, c_))\n                if iszero(gt(c_, 0x7ff)) {\n                    mstore(pIn_, shl(240, or(0xc080, and(0x1f3f, mload(0x00)))))\n                    _pOut := add(pIn_, 2)\n                    leave\n                }\n                mstore8(0x1d, shr(12, c_))\n                if iszero(gt(c_, 0xffff)) {\n                    mstore(pIn_, shl(232, or(0xe08080, and(0x0f3f3f, mload(0x00)))))\n                    _pOut := add(pIn_, 3)\n                    leave\n                }\n                mstore8(0x1c, shr(18, c_))\n                mstore(pIn_, shl(224, or(0xf0808080, and(0x073f3f3f, mload(0x00)))))\n                _pOut := add(pIn_, shl(2, lt(c_, 0x110000)))\n            }\n\n            function chr(p_) -> _c {\n                _c := byte(0, mload(p_))\n            }\n\n            let n := mload(s)\n            let end := add(add(s, n), 0x1f)\n            if iszero(and(gt(n, 1), eq(0x2222, or(and(0xff00, mload(add(s, 2))), chr(end))))) {\n                fail() // Fail if not double-quoted.\n            }\n            let out := add(mload(0x40), 0x20)\n            for { let curr := add(s, 0x21) } iszero(eq(curr, end)) {} {\n                let c := chr(curr)\n                curr := add(curr, 1)\n                // Not '\\\\'.\n                if iszero(eq(c, 92)) {\n                    // Not '\"'.\n                    if iszero(eq(c, 34)) {\n                        mstore8(out, c)\n                        out := add(out, 1)\n                        continue\n                    }\n                    curr := end\n                }\n                if iszero(eq(curr, end)) {\n                    let escape := chr(curr)\n                    curr := add(curr, 1)\n                    // '\"', '/', '\\\\'.\n                    if and(shr(escape, 0x100000000000800400000000), 1) {\n                        mstore8(out, escape)\n                        out := add(out, 1)\n                        continue\n                    }\n                    // 'u'.\n                    if eq(escape, 117) {\n                        escape, curr := decodeUnicodeCodePoint(curr, end)\n                        out := appendCodePointAsUTF8(out, escape)\n                        continue\n                    }\n                    // `{'b':'\\b', 'f':'\\f', 'n':'\\n', 'r':'\\r', 't':'\\t'}`.\n                    escape := byte(sub(escape, 85), 0x080000000c000000000000000a0000000d0009)\n                    if escape {\n                        mstore8(out, escape)\n                        out := add(out, 1)\n                        continue\n                    }\n                }\n                fail()\n                break\n            }\n            mstore(out, 0) // Zeroize the last slot.\n            result := mload(0x40)\n            mstore(result, sub(out, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(out, 0x20)) // Allocate the memory.\n        }\n    }",
            "startLine": 370
          },
          {
            "name": "_query",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "bytes32"
              },
              {
                "name": "mode",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _query(bytes32 input, uint256 mode) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function fail() {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            function chr(p_) -> _c {\n                _c := byte(0, mload(p_))\n            }\n\n            function skipWhitespace(pIn_, end_) -> _pOut {\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(and(shr(chr(_pOut), 0x100002600), 1)) { leave } // Not in ' \\n\\r\\t'.\n                }\n            }\n\n            function setP(packed_, bitpos_, p_) -> _packed {\n                // Perform an out-of-gas revert if `p_` exceeds `_BITMASK_POINTER`.\n                returndatacopy(returndatasize(), returndatasize(), gt(p_, _BITMASK_POINTER))\n                _packed := or(and(not(shl(bitpos_, _BITMASK_POINTER)), packed_), shl(bitpos_, p_))\n            }\n\n            function getP(packed_, bitpos_) -> _p {\n                _p := and(_BITMASK_POINTER, shr(bitpos_, packed_))\n            }\n\n            function mallocItem(s_, packed_, pStart_, pCurr_, type_) -> _item {\n                _item := mload(0x40)\n                // forgefmt: disable-next-item\n                packed_ := setP(setP(packed_, _BITPOS_VALUE, sub(pStart_, add(s_, 0x20))),\n                    _BITPOS_VALUE_LENGTH, sub(pCurr_, pStart_))\n                mstore(_item, or(packed_, type_))\n                mstore(0x40, add(_item, 0x20)) // Allocate memory.\n            }\n\n            function parseValue(s_, sibling_, pIn_, end_) -> _item, _pOut {\n                let packed_ := setP(mload(0x00), _BITPOS_SIBLING_OR_PARENT, sibling_)\n                _pOut := skipWhitespace(pIn_, end_)\n                if iszero(lt(_pOut, end_)) { leave }\n                for { let c_ := chr(_pOut) } 1 {} {\n                    // If starts with '\"'.\n                    if eq(c_, 34) {\n                        let pStart_ := _pOut\n                        _pOut := parseStringSub(s_, packed_, _pOut, end_)\n                        _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_STRING)\n                        break\n                    }\n                    // If starts with '['.\n                    if eq(c_, 91) {\n                        _item, _pOut := parseArray(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    // If starts with '{'.\n                    if eq(c_, 123) {\n                        _item, _pOut := parseObject(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    // If starts with any in '0123456789-'.\n                    if and(shr(c_, shl(45, 0x1ff9)), 1) {\n                        _item, _pOut := parseNumber(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    if iszero(gt(add(_pOut, 4), end_)) {\n                        let pStart_ := _pOut\n                        let w_ := shr(224, mload(_pOut))\n                        // 'true' in hex format.\n                        if eq(w_, 0x74727565) {\n                            _pOut := add(_pOut, 4)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\n                            break\n                        }\n                        // 'null' in hex format.\n                        if eq(w_, 0x6e756c6c) {\n                            _pOut := add(_pOut, 4)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_NULL)\n                            break\n                        }\n                    }\n                    if iszero(gt(add(_pOut, 5), end_)) {\n                        let pStart_ := _pOut\n                        let w_ := shr(216, mload(_pOut))\n                        // 'false' in hex format.\n                        if eq(w_, 0x66616c7365) {\n                            _pOut := add(_pOut, 5)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\n                            break\n                        }\n                    }\n                    fail()\n                    break\n                }\n                _pOut := skipWhitespace(_pOut, end_)\n            }\n\n            function parseArray(s_, packed_, pIn_, end_) -> _item, _pOut {\n                let j_ := 0\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(_pOut, end_)) { fail() }\n                    if iszero(_item) {\n                        _pOut := skipWhitespace(_pOut, end_)\n                        if eq(chr(_pOut), 93) { break } // ']'.\n                    }\n                    _item, _pOut := parseValue(s_, _item, _pOut, end_)\n                    if _item {\n\n                        // forgefmt: disable-next-item\n                        mstore(_item, setP(or(_PARENT_IS_ARRAY, mload(_item)),\n                            _BITPOS_KEY, j_))\n                        j_ := add(j_, 1)\n                        let c_ := chr(_pOut)\n                        if eq(c_, 93) { break } // ']'.\n                        if eq(c_, 44) { continue } // ','.\n                    }\n                    _pOut := end_\n                }\n                _pOut := add(_pOut, 1)\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_ARRAY)\n            }\n\n            function parseObject(s_, packed_, pIn_, end_) -> _item, _pOut {\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(_pOut, end_)) { fail() }\n                    if iszero(_item) {\n                        _pOut := skipWhitespace(_pOut, end_)\n                        if eq(chr(_pOut), 125) { break } // '}'.\n                    }\n                    _pOut := skipWhitespace(_pOut, end_)\n                    let pKeyStart_ := _pOut\n                    let pKeyEnd_ := parseStringSub(s_, _item, _pOut, end_)\n                    _pOut := skipWhitespace(pKeyEnd_, end_)\n                    // If ':'.\n                    if eq(chr(_pOut), 58) {\n                        _item, _pOut := parseValue(s_, _item, add(_pOut, 1), end_)\n                        if _item {\n\n                            // forgefmt: disable-next-item\n                            mstore(_item, setP(setP(or(_PARENT_IS_OBJECT, mload(_item)),\n                                _BITPOS_KEY_LENGTH, sub(pKeyEnd_, pKeyStart_)),\n                                    _BITPOS_KEY, sub(pKeyStart_, add(s_, 0x20))))\n                            let c_ := chr(_pOut)\n                            if eq(c_, 125) { break } // '}'.\n                            if eq(c_, 44) { continue } // ','.\n                        }\n                    }\n                    _pOut := end_\n                }\n                _pOut := add(_pOut, 1)\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_OBJECT)\n            }\n\n            function checkStringU(p_, o_) {\n                // If not in '0123456789abcdefABCDEF', revert.\n                if iszero(and(shr(sub(chr(add(p_, o_)), 48), 0x7e0000007e03ff), 1)) { fail() }\n                if iszero(eq(o_, 5)) { checkStringU(p_, add(o_, 1)) }\n            }\n\n            function parseStringSub(s_, packed_, pIn_, end_) -> _pOut {\n                if iszero(lt(pIn_, end_)) { fail() }\n                for { _pOut := add(pIn_, 1) } 1 {} {\n                    let c_ := chr(_pOut)\n                    if eq(c_, 34) { break } // '\"'.\n                    // Not '\\'.\n                    if iszero(eq(c_, 92)) {\n                        _pOut := add(_pOut, 1)\n                        continue\n                    }\n                    c_ := chr(add(_pOut, 1))\n                    // '\"', '\\', '//', 'b', 'f', 'n', 'r', 't'.\n                    if and(shr(sub(c_, 34), 0x510110400000000002001), 1) {\n                        _pOut := add(_pOut, 2)\n                        continue\n                    }\n                    // 'u'.\n                    if eq(c_, 117) {\n                        checkStringU(_pOut, 2)\n                        _pOut := add(_pOut, 6)\n                        continue\n                    }\n                    _pOut := end_\n                    break\n                }\n                if iszero(lt(_pOut, end_)) { fail() }\n                _pOut := add(_pOut, 1)\n            }\n\n            function skip0To9s(pIn_, end_, atLeastOne_) -> _pOut {\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(sub(chr(_pOut), 48), 10)) { break } // Not '0'..'9'.\n                }\n                if and(atLeastOne_, eq(pIn_, _pOut)) { fail() }\n            }\n\n            function parseNumber(s_, packed_, pIn_, end_) -> _item, _pOut {\n                _pOut := pIn_\n                if eq(chr(_pOut), 45) { _pOut := add(_pOut, 1) } // '-'.\n                if iszero(lt(sub(chr(_pOut), 48), 10)) { fail() } // Not '0'..'9'.\n                let c_ := chr(_pOut)\n                _pOut := add(_pOut, 1)\n                if iszero(eq(c_, 48)) { _pOut := skip0To9s(_pOut, end_, 0) } // Not '0'.\n                if eq(chr(_pOut), 46) { _pOut := skip0To9s(add(_pOut, 1), end_, 1) } // '.'.\n                let t_ := mload(_pOut)\n                // 'E', 'e'.\n                if eq(\n                    or(0x20, byte(0, t_)),\n                    101\n                ) {\n\n                    // forgefmt: disable-next-item\n                    _pOut := skip0To9s(add(byte(sub(byte(1, t_), 14), 0x010001), // '+', '-'.\n                        add(_pOut, 1)), end_, 1)\n                }\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_NUMBER)\n            }\n\n            function copyStr(s_, offset_, len_) -> _sCopy {\n                _sCopy := mload(0x40)\n                s_ := add(s_, offset_)\n                let w_ := not(0x1f)\n                for { let i_ := and(add(len_, 0x1f), w_) } 1 {} {\n                    mstore(add(_sCopy, i_), mload(add(s_, i_)))\n                    i_ := add(i_, w_) // `sub(i_, 0x20)`.\n                    if iszero(i_) { break }\n                }\n                mstore(_sCopy, len_) // Copy the length.\n                mstore(add(add(_sCopy, 0x20), len_), 0) // Zeroize the last slot.\n                mstore(0x40, add(add(_sCopy, 0x40), len_)) // Allocate memory.\n            }\n\n            function value(item_) -> _value {\n                let packed_ := mload(item_)\n                _value := getP(packed_, _BITPOS_VALUE) // The offset in the string.\n                if iszero(and(_VALUE_INITED, packed_)) {\n                    let s_ := getP(packed_, _BITPOS_STRING)\n                    _value := copyStr(s_, _value, getP(packed_, _BITPOS_VALUE_LENGTH))\n                    packed_ := setP(packed_, _BITPOS_VALUE, _value)\n                    mstore(s_, or(_VALUE_INITED, packed_))\n                }\n            }\n\n            function children(item_) -> _arr {\n                _arr := 0x60 // Initialize to the zero pointer.\n                let packed_ := mload(item_)\n                for {} iszero(gt(and(_BITMASK_TYPE, packed_), TYPE_OBJECT)) {} {\n                    if or(iszero(packed_), iszero(item_)) { break }\n                    if and(packed_, _CHILDREN_INITED) {\n                        _arr := getP(packed_, _BITPOS_CHILD)\n                        break\n                    }\n                    _arr := mload(0x40)\n                    let o_ := add(_arr, 0x20)\n                    for { let h_ := getP(packed_, _BITPOS_CHILD) } h_ {} {\n                        mstore(o_, h_)\n                        let q_ := mload(h_)\n                        let y_ := getP(q_, _BITPOS_SIBLING_OR_PARENT)\n                        mstore(h_, setP(q_, _BITPOS_SIBLING_OR_PARENT, item_))\n                        h_ := y_\n                        o_ := add(o_, 0x20)\n                    }\n                    let w_ := not(0x1f)\n                    let n_ := add(w_, sub(o_, _arr))\n                    mstore(_arr, shr(5, n_))\n                    mstore(0x40, o_) // Allocate memory.\n                    packed_ := setP(packed_, _BITPOS_CHILD, _arr)\n                    mstore(item_, or(_CHILDREN_INITED, packed_))\n                    // Reverse the array.\n                    if iszero(lt(n_, 0x40)) {\n                        let lo_ := add(_arr, 0x20)\n                        let hi_ := add(_arr, n_)\n                        for {} 1 {} {\n                            let temp_ := mload(lo_)\n                            mstore(lo_, mload(hi_))\n                            mstore(hi_, temp_)\n                            hi_ := add(hi_, w_)\n                            lo_ := add(lo_, 0x20)\n                            if iszero(lt(lo_, hi_)) { break }\n                        }\n                    }\n                    break\n                }\n            }\n\n            function getStr(item_, bitpos_, bitposLength_, bitmaskInited_) -> _result {\n                _result := 0x60 // Initialize to the zero pointer.\n                let packed_ := mload(item_)\n                if or(iszero(item_), iszero(packed_)) { leave }\n                _result := getP(packed_, bitpos_)\n                if iszero(and(bitmaskInited_, packed_)) {\n                    let s_ := getP(packed_, _BITPOS_STRING)\n                    _result := copyStr(s_, _result, getP(packed_, bitposLength_))\n                    mstore(item_, or(bitmaskInited_, setP(packed_, bitpos_, _result)))\n                }\n            }\n\n            switch mode\n            // Get value.\n            case 0 { result := getStr(input, _BITPOS_VALUE, _BITPOS_VALUE_LENGTH, _VALUE_INITED) }\n            // Get key.\n            case 1 { result := getStr(input, _BITPOS_KEY, _BITPOS_KEY_LENGTH, _KEY_INITED) }\n            // Get children.\n            case 3 { result := children(input) }\n            // Parse.\n            default {\n                let p := add(input, 0x20)\n                let e := add(p, mload(input))\n                if iszero(eq(p, e)) {\n                    let c := chr(e)\n                    mstore8(e, 34) // Place a '\"' at the end to speed up parsing.\n                    // The `34 << 248` makes `mallocItem` preserve '\"' at the end.\n                    mstore(0x00, setP(shl(248, 34), _BITPOS_STRING, input))\n                    result, p := parseValue(input, 0, p, e)\n                    mstore8(e, c) // Restore the original char at the end.\n                }\n                if or(lt(p, e), iszero(result)) { fail() }\n            }\n        }\n    }",
            "startLine": 485
          },
          {
            "name": "_toInput",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toInput(string memory input) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := input\n        }\n    }",
            "startLine": 807
          },
          {
            "name": "_toInput",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toInput(Item memory input) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := input\n        }\n    }",
            "startLine": 815
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ParsingFailed",
            "parameters": [],
            "startLine": 12
          }
        ],
        "structs": [
          {
            "name": "Item",
            "members": [
              {
                "name": "_data",
                "type": "uint256"
              }
            ],
            "startLine": 48
          }
        ],
        "stateVariables": [
          {
            "name": "TYPE_UNDEFINED",
            "type": "uint8",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 23
          },
          {
            "name": "TYPE_ARRAY",
            "type": "uint8",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 26
          },
          {
            "name": "TYPE_OBJECT",
            "type": "uint8",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 29
          },
          {
            "name": "TYPE_NUMBER",
            "type": "uint8",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 32
          },
          {
            "name": "TYPE_STRING",
            "type": "uint8",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 35
          },
          {
            "name": "TYPE_BOOLEAN",
            "type": "uint8",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 38
          },
          {
            "name": "TYPE_NULL",
            "type": "uint8",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 41
          },
          {
            "name": "_BITPOS_STRING",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 55
          },
          {
            "name": "_BITPOS_KEY_LENGTH",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 56
          },
          {
            "name": "_BITPOS_KEY",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 57
          },
          {
            "name": "_BITPOS_VALUE_LENGTH",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 58
          },
          {
            "name": "_BITPOS_VALUE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 59
          },
          {
            "name": "_BITPOS_CHILD",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 60
          },
          {
            "name": "_BITPOS_SIBLING_OR_PARENT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 61
          },
          {
            "name": "_BITMASK_POINTER",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 62
          },
          {
            "name": "_BITMASK_TYPE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 63
          },
          {
            "name": "_KEY_INITED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 64
          },
          {
            "name": "_VALUE_INITED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 65
          },
          {
            "name": "_CHILDREN_INITED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 66
          },
          {
            "name": "_PARENT_IS_ARRAY",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 67
          },
          {
            "name": "_PARENT_IS_OBJECT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 68
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibBit",
        "filePath": "utils/LibBit.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "fls",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "r",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function fls(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }",
            "startLine": 16
          },
          {
            "name": "clz",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "r",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clz(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := add(xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff)), iszero(x))\n        }\n    }",
            "startLine": 33
          },
          {
            "name": "ffs",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "r",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function ffs(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Isolate the least significant bit.\n            x := and(x, add(not(x), 1))\n            // For the upper 3 bits of the result, use a De Bruijn-like lookup.\n            // Credit to adhusson: https://blog.adhusson.com/cheap-find-first-set-evm/\n            // forgefmt: disable-next-item\n            r := shl(5, shr(252, shl(shl(2, shr(250, mul(x,\n                0xb6db6db6ddddddddd34d34d349249249210842108c6318c639ce739cffffffff))),\n                0x8040405543005266443200005020610674053026020000107506200176117077)))\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(div(0xd76453e0, shr(r, x)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }",
            "startLine": 53
          },
          {
            "name": "popCount",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function popCount(uint256 x) internal pure returns (uint256 c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let max := not(0)\n            let isMax := eq(x, max)\n            x := sub(x, and(shr(1, x), div(max, 3)))\n            x := add(and(x, div(max, 5)), and(shr(2, x), div(max, 5)))\n            x := and(add(x, shr(4, x)), div(max, 17))\n            c := or(shl(8, isMax), shr(248, mul(x, div(max, 255))))\n        }\n    }",
            "startLine": 72
          },
          {
            "name": "countZeroBytes",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function countZeroBytes(uint256 x) internal pure returns (uint256 c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := 0x7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f\n            c := byte(0, mul(shr(7, not(m)), shr(7, not(or(or(add(and(x, m), m), x), m)))))\n        }\n    }",
            "startLine": 86
          },
          {
            "name": "countZeroBytes",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function countZeroBytes(bytes memory s) internal pure returns (uint256 c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function czb(x_) -> _c {\n                let _m := 0x7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f\n                _c := shr(7, not(or(or(add(and(x_, _m), _m), x_), _m)))\n                _c := byte(0, mul(shr(7, not(_m)), _c))\n            }\n            let n := mload(s)\n            let l := shl(5, shr(5, n))\n            s := add(s, 0x20)\n            for { let i } xor(i, l) { i := add(i, 0x20) } { c := add(czb(mload(add(s, i))), c) }\n            if lt(l, n) {\n                c := add(czb(or(shr(shl(3, sub(n, l)), not(0)), mload(add(s, l)))), c)\n            }\n        }\n    }",
            "startLine": 96
          },
          {
            "name": "countZeroBytesCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function countZeroBytesCalldata(bytes calldata s) internal pure returns (uint256 c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function czb(x_) -> _c {\n                let _m := 0x7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f\n                _c := shr(7, not(or(or(add(and(x_, _m), _m), x_), _m)))\n                _c := byte(0, mul(shr(7, not(_m)), _c))\n            }\n            let l := shl(5, shr(5, s.length))\n            for { let i } xor(i, l) { i := add(i, 0x20) } {\n                c := add(czb(calldataload(add(s.offset, i))), c)\n            }\n            if lt(l, s.length) {\n                let m := shr(shl(3, sub(s.length, l)), not(0))\n                c := add(czb(or(m, calldataload(add(s.offset, l)))), c)\n            }\n        }\n    }",
            "startLine": 116
          },
          {
            "name": "isPo2",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isPo2(uint256 x) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `x && !(x & (x - 1))`.\n            result := iszero(add(and(x, sub(x, 1)), iszero(x)))\n        }\n    }",
            "startLine": 136
          },
          {
            "name": "reverseBits",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "r",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "reverseBytes",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function reverseBits(uint256 x) internal pure returns (uint256 r) {\n        uint256 m0 = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\n        uint256 m1 = m0 ^ (m0 << 2);\n        uint256 m2 = m1 ^ (m1 << 1);\n        r = reverseBytes(x);\n        r = (m2 & (r >> 1)) | ((m2 & r) << 1);\n        r = (m1 & (r >> 2)) | ((m1 & r) << 2);\n        r = (m0 & (r >> 4)) | ((m0 & r) << 4);\n    }",
            "startLine": 145
          },
          {
            "name": "reverseBytes",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "r",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "toUint",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function reverseBytes(uint256 x) internal pure returns (uint256 r) {\n        unchecked {\n            // Computing masks on-the-fly reduces bytecode size by about 200 bytes.\n            uint256 m0 = 0x100000000000000000000000000000001 * (~toUint(x == uint256(0)) >> 192);\n            uint256 m1 = m0 ^ (m0 << 32);\n            uint256 m2 = m1 ^ (m1 << 16);\n            uint256 m3 = m2 ^ (m2 << 8);\n            r = (m3 & (x >> 8)) | ((m3 & x) << 8);\n            r = (m2 & (r >> 16)) | ((m2 & r) << 16);\n            r = (m1 & (r >> 32)) | ((m1 & r) << 32);\n            r = (m0 & (r >> 64)) | ((m0 & r) << 64);\n            r = (r >> 128) | (r << 128);\n        }\n    }",
            "startLine": 156
          },
          {
            "name": "commonBitPrefix",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "clz",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function commonBitPrefix(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            uint256 s = 256 - clz(x ^ y);\n            return (x >> s) << s;\n        }\n    }",
            "startLine": 172
          },
          {
            "name": "commonNibblePrefix",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "clz",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function commonNibblePrefix(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            uint256 s = (64 - (clz(x ^ y) >> 2)) << 2;\n            return (x >> s) << s;\n        }\n    }",
            "startLine": 180
          },
          {
            "name": "commonBytePrefix",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "clz",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function commonBytePrefix(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            uint256 s = (32 - (clz(x ^ y) >> 3)) << 3;\n            return (x >> s) << s;\n        }\n    }",
            "startLine": 188
          },
          {
            "name": "toNibbles",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toNibbles(bytes memory s) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := mload(s)\n            mstore(result, add(n, n)) // Store the new length.\n            s := add(s, 0x20)\n            let o := add(result, 0x20)\n            // forgefmt: disable-next-item\n            for { let i := 0 } lt(i, n) { i := add(i, 0x10) } {\n                let x := shr(128, mload(add(s, i)))\n                x := and(0x0000000000000000ffffffffffffffff0000000000000000ffffffffffffffff, or(shl(64, x), x))\n                x := and(0x00000000ffffffff00000000ffffffff00000000ffffffff00000000ffffffff, or(shl(32, x), x))\n                x := and(0x0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff, or(shl(16, x), x))\n                x := and(0x00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff, or(shl(8, x), x))\n                mstore(add(o, add(i, i)),\n                    and(0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f, or(shl(4, x), x)))\n            }\n            mstore(add(o, mload(result)), 0) // Zeroize slot after result.\n            mstore(0x40, add(0x40, add(o, mload(result)))) // Allocate memory.\n        }\n    }",
            "startLine": 196
          },
          {
            "name": "rawAnd",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bool"
              },
              {
                "name": "y",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawAnd(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := and(x, y)\n        }\n    }",
            "startLine": 233
          },
          {
            "name": "and",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bool"
              },
              {
                "name": "y",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function and(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := and(iszero(iszero(x)), iszero(iszero(y)))\n        }\n    }",
            "startLine": 241
          },
          {
            "name": "and",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "w",
                "type": "bool"
              },
              {
                "name": "x",
                "type": "bool"
              },
              {
                "name": "y",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function and(bool w, bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := iszero(or(iszero(w), or(iszero(x), iszero(y))))\n        }\n    }",
            "startLine": 249
          },
          {
            "name": "and",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v",
                "type": "bool"
              },
              {
                "name": "w",
                "type": "bool"
              },
              {
                "name": "x",
                "type": "bool"
              },
              {
                "name": "y",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function and(bool v, bool w, bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := iszero(or(or(iszero(v), iszero(w)), or(iszero(x), iszero(y))))\n        }\n    }",
            "startLine": 257
          },
          {
            "name": "rawOr",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bool"
              },
              {
                "name": "y",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawOr(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, y)\n        }\n    }",
            "startLine": 265
          },
          {
            "name": "or",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bool"
              },
              {
                "name": "y",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function or(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := iszero(iszero(or(x, y)))\n        }\n    }",
            "startLine": 273
          },
          {
            "name": "or",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "w",
                "type": "bool"
              },
              {
                "name": "x",
                "type": "bool"
              },
              {
                "name": "y",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function or(bool w, bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := iszero(iszero(or(w, or(x, y))))\n        }\n    }",
            "startLine": 281
          },
          {
            "name": "or",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "v",
                "type": "bool"
              },
              {
                "name": "w",
                "type": "bool"
              },
              {
                "name": "x",
                "type": "bool"
              },
              {
                "name": "y",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function or(bool v, bool w, bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := iszero(iszero(or(v, or(w, or(x, y)))))\n        }\n    }",
            "startLine": 289
          },
          {
            "name": "rawToUint",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "b",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function rawToUint(bool b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := b\n        }\n    }",
            "startLine": 297
          },
          {
            "name": "toUint",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "b",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint(bool b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := iszero(iszero(b))\n        }\n    }",
            "startLine": 305
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibBitmap",
        "filePath": "utils/LibBitmap.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "isSet",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(Bitmap storage bitmap, uint256 index) internal view returns (bool isSet) {\n        // It is better to set `isSet` to either 0 or 1, than zero vs non-zero.\n        // Both cost the same amount of gas, but the former allows the returned value\n        // to be reused without cleaning the upper bits.\n        uint256 b = (bitmap.map[index >> 8] >> (index & 0xff)) & 1;\n        /// @solidity memory-safe-assembly\n        assembly {\n            isSet := b\n        }\n    }",
            "startLine": 32
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(Bitmap storage bitmap, uint256 index) internal {\n        bitmap.map[index >> 8] |= (1 << (index & 0xff));\n    }",
            "startLine": 44
          },
          {
            "name": "unset",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function unset(Bitmap storage bitmap, uint256 index) internal {\n        bitmap.map[index >> 8] &= ~(1 << (index & 0xff));\n    }",
            "startLine": 49
          },
          {
            "name": "toggle",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "newIsSet",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toggle(Bitmap storage bitmap, uint256 index) internal returns (bool newIsSet) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, index))\n            let storageSlot := keccak256(0x00, 0x40)\n            let shift := and(index, 0xff)\n            let storageValue := xor(sload(storageSlot), shl(shift, 1))\n            // It makes sense to return the `newIsSet`,\n            // as it allow us to skip an additional warm `sload`,\n            // and it costs minimal gas (about 15),\n            // which may be optimized away if the returned value is unused.\n            newIsSet := and(1, shr(shift, storageValue))\n            sstore(storageSlot, storageValue)\n        }\n    }",
            "startLine": 55
          },
          {
            "name": "setTo",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "shouldSet",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function setTo(Bitmap storage bitmap, uint256 index, bool shouldSet) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, index))\n            let storageSlot := keccak256(0x00, 0x40)\n            let storageValue := sload(storageSlot)\n            let shift := and(index, 0xff)\n            sstore(\n                storageSlot,\n                // Unsets the bit at `shift` via `and`, then sets its new value via `or`.\n                or(and(storageValue, not(shl(shift, 1))), shl(shift, iszero(iszero(shouldSet))))\n            )\n        }\n    }",
            "startLine": 73
          },
          {
            "name": "setBatch",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function setBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let max := not(0)\n            let shift := and(start, 0xff)\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, start))\n            if iszero(lt(add(shift, amount), 257)) {\n                let storageSlot := keccak256(0x00, 0x40)\n                sstore(storageSlot, or(sload(storageSlot), shl(shift, max)))\n                let bucket := add(mload(0x00), 1)\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\n                amount := and(add(amount, shift), 0xff)\n                shift := 0\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\n                    mstore(0x00, bucket)\n                    sstore(keccak256(0x00, 0x40), max)\n                }\n                mstore(0x00, bucket)\n            }\n            let storageSlot := keccak256(0x00, 0x40)\n            sstore(storageSlot, or(sload(storageSlot), shl(shift, shr(sub(256, amount), max))))\n        }\n    }",
            "startLine": 90
          },
          {
            "name": "unsetBatch",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function unsetBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let shift := and(start, 0xff)\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, start))\n            if iszero(lt(add(shift, amount), 257)) {\n                let storageSlot := keccak256(0x00, 0x40)\n                sstore(storageSlot, and(sload(storageSlot), not(shl(shift, not(0)))))\n                let bucket := add(mload(0x00), 1)\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\n                amount := and(add(amount, shift), 0xff)\n                shift := 0\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\n                    mstore(0x00, bucket)\n                    sstore(keccak256(0x00, 0x40), 0)\n                }\n                mstore(0x00, bucket)\n            }\n            let storageSlot := keccak256(0x00, 0x40)\n            sstore(\n                storageSlot,\n                and(sload(storageSlot), not(shl(shift, shr(sub(256, amount), not(0)))))\n            )\n        }\n    }",
            "startLine": 116
          },
          {
            "name": "popCount",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "count",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "LibBit.popCount",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function popCount(Bitmap storage bitmap, uint256 start, uint256 amount)\n        internal\n        view\n        returns (uint256 count)\n    {\n        unchecked {\n            uint256 bucket = start >> 8;\n            uint256 shift = start & 0xff;\n            if (!(amount + shift < 257)) {\n                count = LibBit.popCount(bitmap.map[bucket] >> shift);\n                uint256 bucketEnd = bucket + ((amount + shift) >> 8);\n                amount = (amount + shift) & 0xff;\n                shift = 0;\n                for (++bucket; bucket != bucketEnd; ++bucket) {\n                    count += LibBit.popCount(bitmap.map[bucket]);\n                }\n            }\n            count += LibBit.popCount((bitmap.map[bucket] >> shift) << (256 - amount));\n        }\n    }",
            "startLine": 145
          },
          {
            "name": "findLastSet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "upTo",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "setBitIndex",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "LibBit.fls",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function findLastSet(Bitmap storage bitmap, uint256 upTo)\n        internal\n        view\n        returns (uint256 setBitIndex)\n    {\n        setBitIndex = NOT_FOUND;\n        uint256 bucket = upTo >> 8;\n        uint256 bits;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, bucket)\n            mstore(0x20, bitmap.slot)\n            let offset := and(0xff, not(upTo)) // `256 - (255 & upTo) - 1`.\n            bits := shr(offset, shl(offset, sload(keccak256(0x00, 0x40))))\n            if iszero(or(bits, iszero(bucket))) {\n                for {} 1 {} {\n                    bucket := add(bucket, setBitIndex) // `sub(bucket, 1)`.\n                    mstore(0x00, bucket)\n                    bits := sload(keccak256(0x00, 0x40))\n                    if or(bits, iszero(bucket)) { break }\n                }\n            }\n        }\n        if (bits != 0) {\n            setBitIndex = (bucket << 8) | LibBit.fls(bits);\n            /// @solidity memory-safe-assembly\n            assembly {\n                setBitIndex := or(setBitIndex, sub(0, gt(setBitIndex, upTo)))\n            }\n        }\n    }",
            "startLine": 168
          },
          {
            "name": "findFirstUnset",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "begin",
                "type": "uint256"
              },
              {
                "name": "upTo",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "unsetBitIndex",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "LibBit.ffs",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function findFirstUnset(Bitmap storage bitmap, uint256 begin, uint256 upTo)\n        internal\n        view\n        returns (uint256 unsetBitIndex)\n    {\n        unsetBitIndex = NOT_FOUND;\n        uint256 bucket = begin >> 8;\n        uint256 negBits;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, bucket)\n            mstore(0x20, bitmap.slot)\n            let offset := and(0xff, begin)\n            negBits := shl(offset, shr(offset, not(sload(keccak256(0x00, 0x40)))))\n            if iszero(negBits) {\n                let lastBucket := shr(8, upTo)\n                for {} 1 {} {\n                    bucket := add(bucket, 1)\n                    mstore(0x00, bucket)\n                    negBits := not(sload(keccak256(0x00, 0x40)))\n                    if or(negBits, gt(bucket, lastBucket)) { break }\n                }\n                if gt(bucket, lastBucket) {\n                    negBits := shl(and(0xff, not(upTo)), shr(and(0xff, not(upTo)), negBits))\n                }\n            }\n        }\n        if (negBits != 0) {\n            uint256 r = (bucket << 8) | LibBit.ffs(negBits);\n            /// @solidity memory-safe-assembly\n            assembly {\n                unsetBitIndex := or(r, sub(0, or(gt(r, upTo), lt(r, begin))))\n            }\n        }\n    }",
            "startLine": 202
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "Bitmap",
            "members": [
              {
                "name": "map",
                "type": "mapping(uint256 => uint256)"
              }
            ],
            "startLine": 23
          }
        ],
        "stateVariables": [
          {
            "name": "NOT_FOUND",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 16
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./LibBit.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "LibBytes",
        "filePath": "utils/LibBytes.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "BytesStorage"
              },
              {
                "name": "s",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(BytesStorage storage $, bytes memory s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            let packed := or(0xff, shl(8, n))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(n, 0xfe)) {\n                    i := 0x1f\n                    packed := or(n, shl(8, mload(add(s, i))))\n                    if iszero(gt(n, i)) { break }\n                }\n                let o := add(s, 0x20)\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), mload(add(o, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }",
            "startLine": 30
          },
          {
            "name": "setCalldata",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "BytesStorage"
              },
              {
                "name": "s",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function setCalldata(BytesStorage storage $, bytes calldata s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := or(0xff, shl(8, s.length))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(s.length, 0xfe)) {\n                    i := 0x1f\n                    packed := or(s.length, shl(8, shr(8, calldataload(s.offset))))\n                    if iszero(gt(s.length, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), calldataload(add(s.offset, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, s.length)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }",
            "startLine": 55
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "BytesStorage"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clear(BytesStorage storage $) internal {\n        delete $._spacer;\n    }",
            "startLine": 78
          },
          {
            "name": "isEmpty",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "BytesStorage"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isEmpty(BytesStorage storage $) internal view returns (bool) {\n        return uint256($._spacer) & 0xff == uint256(0);\n    }",
            "startLine": 83
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "BytesStorage"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function length(BytesStorage storage $) internal view returns (uint256 result) {\n        result = uint256($._spacer);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := and(0xff, result)\n            result := or(mul(shr(8, result), eq(0xff, n)), mul(n, iszero(eq(0xff, n))))\n        }\n    }",
            "startLine": 88
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "BytesStorage"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(BytesStorage storage $) internal view returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            let packed := sload($.slot)\n            let n := shr(8, packed)\n            for { let i := 0 } 1 {} {\n                if iszero(eq(or(packed, 0xff), packed)) {\n                    mstore(o, packed)\n                    n := and(0xff, packed)\n                    i := 0x1f\n                    if iszero(gt(n, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    mstore(add(o, i), sload(add(p, shr(5, i))))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            mstore(result, n) // Store the length of the memory.\n            mstore(add(o, n), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(o, n), 0x20)) // Allocate memory.\n        }\n    }",
            "startLine": 98
          },
          {
            "name": "uint8At",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "BytesStorage"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint8"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function uint8At(BytesStorage storage $, uint256 i) internal view returns (uint8 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let packed := sload($.slot) } 1 {} {\n                if iszero(eq(or(packed, 0xff), packed)) {\n                    if iszero(gt(i, 0x1e)) {\n                        result := byte(i, packed)\n                        break\n                    }\n                    if iszero(gt(i, and(0xff, packed))) {\n                        mstore(0x00, $.slot)\n                        let j := sub(i, 0x1f)\n                        result := byte(and(j, 0x1f), sload(add(keccak256(0x00, 0x20), shr(5, j))))\n                    }\n                    break\n                }\n                if iszero(gt(i, shr(8, packed))) {\n                    mstore(0x00, $.slot)\n                    result := byte(and(i, 0x1f), sload(add(keccak256(0x00, 0x20), shr(5, i))))\n                }\n                break\n            }\n        }\n    }",
            "startLine": 127
          },
          {
            "name": "replace",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes"
              },
              {
                "name": "replacement",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function replace(bytes memory subject, bytes memory needle, bytes memory replacement)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let needleLen := mload(needle)\n            let replacementLen := mload(replacement)\n            let d := sub(result, subject) // Memory difference.\n            let i := add(subject, 0x20) // Subject bytes pointer.\n            mstore(0x00, add(i, mload(subject))) // End of subject.\n            if iszero(gt(needleLen, mload(subject))) {\n                let subjectSearchEnd := add(sub(mload(0x00), needleLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(needleLen, 0x20)) {\n                    h := keccak256(add(needle, 0x20), needleLen)\n                }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(needleLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `needleLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, needleLen), h)) {\n                                mstore(add(i, d), t)\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let j := 0 } 1 {} {\n                            mstore(add(add(i, d), j), mload(add(add(replacement, 0x20), j)))\n                            j := add(j, 0x20)\n                            if iszero(lt(j, replacementLen)) { break }\n                        }\n                        d := sub(add(d, replacementLen), needleLen)\n                        if needleLen {\n                            i := add(i, needleLen)\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(add(i, d), t)\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n            }\n            let end := mload(0x00)\n            let n := add(sub(d, add(result, 0x20)), end)\n            // Copy the rest of the bytes one word at a time.\n            for {} lt(i, end) { i := add(i, 0x20) } { mstore(add(i, d), mload(i)) }\n            let o := add(i, d)\n            mstore(o, 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n            mstore(result, n) // Store the length.\n        }\n    }",
            "startLine": 157
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function indexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0) // Initialize to `NOT_FOUND`.\n            for { let subjectLen := mload(subject) } 1 {} {\n                if iszero(mload(needle)) {\n                    result := from\n                    if iszero(gt(from, subjectLen)) { break }\n                    result := subjectLen\n                    break\n                }\n                let needleLen := mload(needle)\n                let subjectStart := add(subject, 0x20)\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLen), needleLen), 1)\n                let m := shl(3, sub(0x20, and(needleLen, 0x1f)))\n                let s := mload(add(needle, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLen))) { break }\n\n                if iszero(lt(needleLen, 0x20)) {\n                    for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, needleLen), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }",
            "startLine": 221
          },
          {
            "name": "indexOfByte",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes1"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function indexOfByte(bytes memory subject, bytes1 needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0) // Initialize to `NOT_FOUND`.\n            if gt(mload(subject), from) {\n                let start := add(subject, 0x20)\n                let end := add(start, mload(subject))\n                let m := div(not(0), 255) // `0x0101 ... `.\n                let h := mul(byte(0, needle), m) // Replicating needle mask.\n                m := not(shl(7, m)) // `0x7f7f ... `.\n                for { let i := add(start, from) } 1 {} {\n                    let c := xor(mload(i), h) // Load 32-byte chunk and xor with mask.\n                    c := not(or(or(add(and(c, m), m), c), m)) // Each needle byte will be `0x80`.\n                    if c {\n                        c := and(not(shr(shl(3, sub(end, i)), not(0))), c) // Truncate bytes past the end.\n                        if c {\n                            let r := shl(7, lt(0x8421084210842108cc6318c6db6d54be, c)) // Save bytecode.\n                            r := or(shl(6, lt(0xffffffffffffffff, shr(r, c))), r)\n                            // forgefmt: disable-next-item\n                            result := add(sub(i, start), shr(3, xor(byte(and(0x1f, shr(byte(24,\n                                mul(0x02040810204081, shr(r, c))), 0x8421084210842108cc6318c6db6d54be)),\n                                0xc0c8c8d0c8e8d0d8c8e8e0e8d0d8e0f0c8d0e8d0e0e0d8f0d0d0e0d8f8f8f8f8), r)))\n                            break\n                        }\n                    }\n                    i := add(i, 0x20)\n                    if iszero(lt(i, end)) { break }\n                }\n            }\n        }\n    }",
            "startLine": 275
          },
          {
            "name": "indexOfByte",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes1"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOfByte",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOfByte(bytes memory subject, bytes1 needle)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        return indexOfByte(subject, needle, 0);\n    }",
            "startLine": 314
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(bytes memory subject, bytes memory needle) internal pure returns (uint256) {\n        return indexOf(subject, needle, 0);\n    }",
            "startLine": 325
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let needleLen := mload(needle)\n                if gt(needleLen, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), needleLen)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                    if eq(keccak256(subject, needleLen), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }",
            "startLine": 332
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "lastIndexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(subject, needle, type(uint256).max);\n    }",
            "startLine": 369
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(bytes memory subject, bytes memory needle) internal pure returns (bool) {\n        return indexOf(subject, needle) != NOT_FOUND;\n    }",
            "startLine": 378
          },
          {
            "name": "startsWith",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function startsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            // Just using keccak256 directly is actually cheaper.\n            let t := eq(keccak256(add(subject, 0x20), n), keccak256(add(needle, 0x20), n))\n            result := lt(gt(n, mload(subject)), t)\n        }\n    }",
            "startLine": 383
          },
          {
            "name": "endsWith",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function endsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            let notInRange := gt(n, mload(subject))\n            // `subject + 0x20 + max(subject.length - needle.length, 0)`.\n            let t := add(add(subject, 0x20), mul(iszero(notInRange), sub(mload(subject), n)))\n            // Just using keccak256 directly is actually cheaper.\n            result := gt(eq(keccak256(t, n), keccak256(add(needle, 0x20), n)), notInRange)\n        }\n    }",
            "startLine": 398
          },
          {
            "name": "repeat",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "times",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function repeat(bytes memory subject, uint256 times)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(or(iszero(times), iszero(l))) {\n                result := mload(0x40)\n                subject := add(subject, 0x20)\n                let o := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let j := 0 } 1 {} {\n                        mstore(add(o, j), mload(add(subject, j)))\n                        j := add(j, 0x20)\n                        if iszero(lt(j, l)) { break }\n                    }\n                    o := add(o, l)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            }\n        }\n    }",
            "startLine": 415
          },
          {
            "name": "slice",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function slice(bytes memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(gt(l, end)) { end := l }\n            if iszero(gt(l, start)) { start := l }\n            if lt(start, end) {\n                result := mload(0x40)\n                let n := sub(end, start)\n                let i := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let j := and(add(n, 0x1f), w) } 1 {} {\n                    mstore(add(result, j), mload(add(i, j)))\n                    j := add(j, w) // `sub(j, 0x20)`.\n                    if iszero(j) { break }\n                }\n                let o := add(add(result, 0x20), n)\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, n) // Store the length.\n            }\n        }\n    }",
            "startLine": 447
          },
          {
            "name": "slice",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "slice",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function slice(bytes memory subject, uint256 start)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        result = slice(subject, start, type(uint256).max);\n    }",
            "startLine": 478
          },
          {
            "name": "sliceCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function sliceCalldata(bytes calldata subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, subject.length), lt(subject.length, end)))\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\n            result.offset := add(subject.offset, start)\n            result.length := mul(lt(start, end), sub(end, start))\n        }\n    }",
            "startLine": 488
          },
          {
            "name": "sliceCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function sliceCalldata(bytes calldata subject, uint256 start)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\n            result.offset := add(subject.offset, start)\n            result.length := mul(lt(start, subject.length), sub(subject.length, start))\n        }\n    }",
            "startLine": 504
          },
          {
            "name": "truncate",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function truncate(bytes memory subject, uint256 n) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := subject\n            mstore(mul(lt(n, mload(result)), result), n)\n        }\n    }",
            "startLine": 519
          },
          {
            "name": "truncatedCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function truncatedCalldata(bytes calldata subject, uint256 n)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.offset := subject.offset\n            result.length := xor(n, mul(xor(n, subject.length), lt(subject.length, n)))\n        }\n    }",
            "startLine": 529
          },
          {
            "name": "indicesOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function indicesOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLen := mload(needle)\n            if iszero(gt(searchLen, mload(subject))) {\n                result := mload(0x40)\n                let i := add(subject, 0x20)\n                let o := add(result, 0x20)\n                let subjectSearchEnd := add(sub(add(i, mload(subject)), searchLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(searchLen, 0x20)) {\n                    h := keccak256(add(needle, 0x20), searchLen)\n                }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(searchLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `searchLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, searchLen), h)) {\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        mstore(o, sub(i, add(subject, 0x20))) // Append to `result`.\n                        o := add(o, 0x20)\n                        i := add(i, searchLen) // Advance `i` by `searchLen`.\n                        if searchLen {\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n                mstore(result, shr(5, sub(o, add(result, 0x20)))) // Store the length of `result`.\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(o, 0x20))\n            }\n        }\n    }",
            "startLine": 543
          },
          {
            "name": "split",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "delimiter",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes[]"
              }
            ],
            "calls": [
              {
                "target": "indicesOf",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function split(bytes memory subject, bytes memory delimiter)\n        internal\n        pure\n        returns (bytes[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            for { let prevIndex := 0 } 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let l := sub(index, prevIndex)\n                    mstore(element, l) // Store the length of the element.\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(l, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    mstore(add(add(element, 0x20), l), 0) // Zeroize the slot after the bytes.\n                    // Allocate memory for the length and the bytes, rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(l, 0x3f), w)))\n                    mstore(indexPtr, element) // Store the `element` into the array.\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }",
            "startLine": 592
          },
          {
            "name": "concat",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "b",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function concat(bytes memory a, bytes memory b) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let w := not(0x1f)\n            let aLen := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLen, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLen := mload(b)\n            let output := add(result, aLen)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLen, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLen := add(aLen, bLen)\n            let last := add(add(result, 0x20), totalLen)\n            mstore(last, 0) // Zeroize the slot after the bytes.\n            mstore(result, totalLen) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate memory.\n        }\n    }",
            "startLine": 637
          },
          {
            "name": "eq",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "b",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function eq(bytes memory a, bytes memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }",
            "startLine": 666
          },
          {
            "name": "eqs",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "b",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function eqs(bytes memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }",
            "startLine": 674
          },
          {
            "name": "cmp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "b",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function cmp(bytes memory a, bytes memory b) internal pure returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLen := mload(a)\n            let bLen := mload(b)\n            let n := and(xor(aLen, mul(xor(aLen, bLen), lt(bLen, aLen))), not(0x1f))\n            if n {\n                for { let i := 0x20 } 1 {} {\n                    let x := mload(add(a, i))\n                    let y := mload(add(b, i))\n                    if iszero(or(xor(x, y), eq(i, n))) {\n                        i := add(i, 0x20)\n                        continue\n                    }\n                    result := sub(gt(x, y), lt(x, y))\n                    break\n                }\n            }\n            // forgefmt: disable-next-item\n            if iszero(result) {\n                let l := 0x201f1e1d1c1b1a191817161514131211100f0e0d0c0b0a090807060504030201\n                let x := and(mload(add(add(a, 0x20), n)), shl(shl(3, byte(sub(aLen, n), l)), not(0)))\n                let y := and(mload(add(add(b, 0x20), n)), shl(shl(3, byte(sub(bLen, n), l)), not(0)))\n                result := sub(gt(x, y), lt(x, y))\n                if iszero(result) { result := sub(gt(aLen, bLen), lt(aLen, bLen)) }\n            }\n        }\n    }",
            "startLine": 693
          },
          {
            "name": "directReturn",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function directReturn(bytes memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Assumes that the bytes does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the bytes is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the bytes.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }",
            "startLine": 723
          },
          {
            "name": "directReturn",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes[]"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function directReturn(bytes[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a) // `a.length`.\n            let o := add(a, 0x20) // Start of elements in `a`.\n            let u := a // Highest memory slot.\n            let w := not(0x1f)\n            for { let i := 0 } iszero(eq(i, n)) { i := add(i, 1) } {\n                let c := add(o, shl(5, i)) // Location of pointer to `a[i]`.\n                let s := mload(c) // `a[i]`.\n                let l := mload(s) // `a[i].length`.\n                let r := and(l, 0x1f) // `a[i].length % 32`.\n                let z := add(0x20, and(l, w)) // Offset of last word in `a[i]` from `s`.\n                // If `s` comes before `o`, or `s` is not zero right padded.\n                if iszero(lt(lt(s, o), or(iszero(r), iszero(shl(shl(3, r), mload(add(s, z))))))) {\n                    let m := mload(0x40)\n                    mstore(m, l) // Copy `a[i].length`.\n                    for {} 1 {} {\n                        mstore(add(m, z), mload(add(s, z))) // Copy `a[i]`, backwards.\n                        z := add(z, w) // `sub(z, 0x20)`.\n                        if iszero(z) { break }\n                    }\n                    let e := add(add(m, 0x20), l)\n                    mstore(e, 0) // Zeroize the slot after the copied bytes.\n                    mstore(0x40, add(e, 0x20)) // Allocate memory.\n                    s := m\n                }\n                mstore(c, sub(s, o)) // Convert to calldata offset.\n                let t := add(l, add(s, 0x20))\n                if iszero(lt(t, u)) { u := t }\n            }\n            let retStart := add(a, w) // Assumes `a` doesn't start from scratch space.\n            mstore(retStart, 0x20) // Store the return offset.\n            return(retStart, add(0x40, sub(u, retStart))) // End the transaction.\n        }\n    }",
            "startLine": 739
          },
          {
            "name": "load",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "offset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function load(bytes memory a, uint256 offset) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), offset))\n        }\n    }",
            "startLine": 777
          },
          {
            "name": "loadCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "offset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function loadCalldata(bytes calldata a, uint256 offset) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := calldataload(add(a.offset, offset))\n        }\n    }",
            "startLine": 785
          },
          {
            "name": "staticStructInCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "offset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function staticStructInCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := sub(a.length, 0x20)\n            result.offset := add(a.offset, offset)\n            result.length := sub(a.length, offset)\n            if or(shr(64, or(l, a.offset)), gt(offset, l)) { revert(l, 0x00) }\n        }\n    }",
            "startLine": 793
          },
          {
            "name": "dynamicStructInCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "offset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function dynamicStructInCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := sub(a.length, 0x20)\n            let s := calldataload(add(a.offset, offset)) // Relative offset of `result` from `a.offset`.\n            result.offset := add(a.offset, s)\n            result.length := sub(a.length, s)\n            if or(shr(64, or(s, or(l, a.offset))), gt(offset, l)) { revert(l, 0x00) }\n        }\n    }",
            "startLine": 808
          },
          {
            "name": "bytesInCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "offset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function bytesInCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := sub(a.length, 0x20)\n            let s := calldataload(add(a.offset, offset)) // Relative offset of `result` from `a.offset`.\n            result.offset := add(add(a.offset, s), 0x20)\n            result.length := calldataload(add(a.offset, s))\n            // forgefmt: disable-next-item\n            if or(shr(64, or(result.length, or(s, or(l, a.offset)))),\n                or(gt(add(s, result.length), l), gt(offset, l))) { revert(l, 0x00) }\n        }\n    }",
            "startLine": 824
          },
          {
            "name": "checkInCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bytes"
              },
              {
                "name": "a",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function checkInCalldata(bytes calldata x, bytes calldata a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if or(\n                or(lt(x.offset, a.offset), gt(add(x.offset, x.length), add(a.length, a.offset))),\n                shr(64, or(x.length, x.offset))\n            ) { revert(0x00, 0x00) }\n        }\n    }",
            "startLine": 842
          },
          {
            "name": "checkInCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bytes[]"
              },
              {
                "name": "a",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function checkInCalldata(bytes[] calldata x, bytes calldata a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let e := sub(add(a.length, a.offset), 0x20)\n            if or(lt(x.offset, a.offset), shr(64, x.offset)) { revert(0x00, 0x00) }\n            for { let i := 0 } iszero(eq(x.length, i)) { i := add(i, 1) } {\n                let o := calldataload(add(x.offset, shl(5, i)))\n                let t := add(o, x.offset)\n                let l := calldataload(t)\n                if or(shr(64, or(l, o)), gt(add(t, l), e)) { revert(0x00, 0x00) }\n            }\n        }\n    }",
            "startLine": 853
          },
          {
            "name": "emptyCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function emptyCalldata() internal pure returns (bytes calldata result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.length := 0\n        }\n    }",
            "startLine": 868
          },
          {
            "name": "msbToAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function msbToAddress(bytes32 x) internal pure returns (address) {\n        return address(bytes20(x));\n    }",
            "startLine": 876
          },
          {
            "name": "lsbToAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function lsbToAddress(bytes32 x) internal pure returns (address) {\n        return address(uint160(uint256(x)));\n    }",
            "startLine": 881
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "BytesStorage",
            "members": [
              {
                "name": "_spacer",
                "type": "bytes32"
              }
            ],
            "startLine": 14
          }
        ],
        "stateVariables": [
          {
            "name": "NOT_FOUND",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 23
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibCall",
        "filePath": "utils/LibCall.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "callContract",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function callContract(address target, uint256 value, bytes memory data)\n        internal\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            if iszero(call(gas(), target, value, add(data, 0x20), mload(data), codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            if iszero(returndatasize()) {\n                if iszero(extcodesize(target)) {\n                    mstore(0x00, 0x5a836a5f) // `TargetIsNotContract()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }",
            "startLine": 31
          },
          {
            "name": "callContract",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function callContract(address target, bytes memory data)\n        internal\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            if iszero(call(gas(), target, 0, add(data, 0x20), mload(data), codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            if iszero(returndatasize()) {\n                if iszero(extcodesize(target)) {\n                    mstore(0x00, 0x5a836a5f) // `TargetIsNotContract()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }",
            "startLine": 57
          },
          {
            "name": "staticCallContract",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function staticCallContract(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            if iszero(staticcall(gas(), target, add(data, 0x20), mload(data), codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            if iszero(returndatasize()) {\n                if iszero(extcodesize(target)) {\n                    mstore(0x00, 0x5a836a5f) // `TargetIsNotContract()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }",
            "startLine": 83
          },
          {
            "name": "delegateCallContract",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function delegateCallContract(address target, bytes memory data)\n        internal\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            if iszero(delegatecall(gas(), target, add(data, 0x20), mload(data), codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            if iszero(returndatasize()) {\n                if iszero(extcodesize(target)) {\n                    mstore(0x00, 0x5a836a5f) // `TargetIsNotContract()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }",
            "startLine": 110
          },
          {
            "name": "tryCall",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "gasStipend",
                "type": "uint256"
              },
              {
                "name": "maxCopy",
                "type": "uint16"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "success",
                "type": "bool"
              },
              {
                "name": "exceededMaxCopy",
                "type": "bool"
              },
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tryCall(\n        address target,\n        uint256 value,\n        uint256 gasStipend,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bool exceededMaxCopy, bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            success := call(\n                gasStipend,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                codesize(),\n                0x00\n            )\n            let n := returndatasize()\n            if gt(returndatasize(), and(0xffff, maxCopy)) {\n                n := and(0xffff, maxCopy)\n                exceededMaxCopy := 1\n            }\n            mstore(result, n) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, n) // Copy the returndata.\n            mstore(0x40, add(o, n)) // Allocate the memory.\n        }\n    }",
            "startLine": 147
          },
          {
            "name": "tryStaticCall",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "gasStipend",
                "type": "uint256"
              },
              {
                "name": "maxCopy",
                "type": "uint16"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "success",
                "type": "bool"
              },
              {
                "name": "exceededMaxCopy",
                "type": "bool"
              },
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tryStaticCall(address target, uint256 gasStipend, uint16 maxCopy, bytes memory data)\n        internal\n        view\n        returns (bool success, bool exceededMaxCopy, bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            success := staticcall(\n                gasStipend,\n                target,\n                add(data, 0x20),\n                mload(data),\n                codesize(),\n                0x00\n            )\n            let n := returndatasize()\n            if gt(returndatasize(), and(0xffff, maxCopy)) {\n                n := and(0xffff, maxCopy)\n                exceededMaxCopy := 1\n            }\n            mstore(result, n) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, n) // Copy the returndata.\n            mstore(0x40, add(o, n)) // Allocate the memory.\n        }\n    }",
            "startLine": 181
          },
          {
            "name": "bubbleUpRevert",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "revertReturnData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function bubbleUpRevert(bytes memory revertReturnData) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            revert(add(0x20, revertReturnData), mload(revertReturnData))\n        }\n    }",
            "startLine": 214
          },
          {
            "name": "setSelector",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "newSelector",
                "type": "bytes4"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function setSelector(bytes4 newSelector, bytes memory data) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(gt(mload(data), 0x03)) {\n                mstore(0x00, 0x0acec8bd) // `DataTooShort()`.\n                revert(0x1c, 0x04)\n            }\n            let o := add(data, 0x20)\n            mstore(o, or(shr(32, shl(32, mload(o))), newSelector))\n        }\n    }",
            "startLine": 222
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "TargetIsNotContract",
            "parameters": [],
            "startLine": 17
          },
          {
            "name": "DataTooShort",
            "parameters": [],
            "startLine": 20
          }
        ],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibClone",
        "filePath": "utils/LibClone.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "clone",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "clone",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clone(address implementation) internal returns (address instance) {\n        instance = clone(0, implementation);\n    }",
            "startLine": 123
          },
          {
            "name": "clone",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clone(uint256 value, address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (44 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | 0                      |                       |\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create(value, 0x0c, 0x35)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 129
          },
          {
            "name": "cloneDeterministic",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "cloneDeterministic",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function cloneDeterministic(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, salt);\n    }",
            "startLine": 201
          },
          {
            "name": "cloneDeterministic",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function cloneDeterministic(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create2(value, 0x0c, 0x35, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 210
          },
          {
            "name": "initCode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCode(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x40), 0x5af43d3d93803e602a57fd5bf30000000000000000000000)\n            mstore(add(c, 0x28), implementation)\n            mstore(add(c, 0x14), 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            mstore(c, 0x35) // Store the length.\n            mstore(0x40, add(c, 0x60)) // Allocate memory.\n        }\n    }",
            "startLine": 229
          },
          {
            "name": "initCodeHash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "hash",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            hash := keccak256(0x0c, 0x35)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 242
          },
          {
            "name": "predictDeterministicAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "deployer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "initCodeHash",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "predictDeterministicAddress",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "startLine": 255
          },
          {
            "name": "clone_PUSH0",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "clone_PUSH0",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clone_PUSH0(address implementation) internal returns (address instance) {\n        instance = clone_PUSH0(0, implementation);\n    }",
            "startLine": 269
          },
          {
            "name": "clone_PUSH0",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clone_PUSH0(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 5f         | PUSH0             | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (45 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 5f      | PUSH0          | 0                      |                       |\n             * 5f      | PUSH0          | 0 0                    |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create(value, 0x0e, 0x36)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 275
          },
          {
            "name": "cloneDeterministic_PUSH0",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "cloneDeterministic_PUSH0",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic_PUSH0(0, implementation, salt);\n    }",
            "startLine": 351
          },
          {
            "name": "cloneDeterministic_PUSH0",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function cloneDeterministic_PUSH0(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create2(value, 0x0e, 0x36, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 360
          },
          {
            "name": "initCode_PUSH0",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCode_PUSH0(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x40), 0x5af43d5f5f3e6029573d5ffd5b3d5ff300000000000000000000) // 16\n            mstore(add(c, 0x26), implementation) // 20\n            mstore(add(c, 0x12), 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            mstore(c, 0x36) // Store the length.\n            mstore(0x40, add(c, 0x60)) // Allocate memory.\n        }\n    }",
            "startLine": 379
          },
          {
            "name": "initCodeHash_PUSH0",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "hash",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            hash := keccak256(0x0e, 0x36)\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 392
          },
          {
            "name": "predictDeterministicAddress_PUSH0",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "deployer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "initCodeHash_PUSH0",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "predictDeterministicAddress",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddress_PUSH0(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash_PUSH0(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "startLine": 405
          },
          {
            "name": "clone",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "clone",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clone(address implementation, bytes memory args) internal returns (address instance) {\n        instance = clone(0, implementation, args);\n    }",
            "startLine": 419
          },
          {
            "name": "clone",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clone(uint256 value, address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------+\n             * CREATION (10 bytes)                                                        |\n             * ---------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                        |\n             * ---------------------------------------------------------------------------|\n             * 61 runSize | PUSH2 runSize     | r         |                               |\n             * 3d         | RETURNDATASIZE    | 0 r       |                               |\n             * 81         | DUP2              | r 0 r     |                               |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                               |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                               |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code    |\n             * f3         | RETURN            |           | [0..runSize): runtime code    |\n             * ---------------------------------------------------------------------------|\n             * RUNTIME (45 bytes + extraLength)                                           |\n             * ---------------------------------------------------------------------------|\n             * Opcode   | Mnemonic       | Stack                  | Memory                |\n             * ---------------------------------------------------------------------------|\n             *                                                                            |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                    |                       |\n             * 3d       | RETURNDATASIZE | 0 cds                  |                       |\n             * 3d       | RETURNDATASIZE | 0 0 cds                |                       |\n             * 37       | CALLDATACOPY   |                        | [0..cds): calldata    |\n             *                                                                            |\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | 0                      | [0..cds): calldata    |\n             * 3d       | RETURNDATASIZE | 0 0                    | [0..cds): calldata    |\n             * 3d       | RETURNDATASIZE | 0 0 0                  | [0..cds): calldata    |\n             * 36       | CALLDATASIZE   | cds 0 0 0              | [0..cds): calldata    |\n             * 3d       | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n             * 73 addr  | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n             * 5a       | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n             * f4       | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n             *                                                                            |\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | rds success 0          | [0..cds): calldata    |\n             * 82       | DUP3           | 0 rds success 0         | [0..cds): calldata   |\n             * 80       | DUP1           | 0 0 rds success 0      | [0..cds): calldata    |\n             * 3e       | RETURNDATACOPY | success 0              | [0..rds): returndata  |\n             * 90       | SWAP1          | 0 success              | [0..rds): returndata  |\n             * 3d       | RETURNDATASIZE | rds 0 success          | [0..rds): returndata  |\n             * 91       | SWAP2          | success 0 rds          | [0..rds): returndata  |\n             *                                                                            |\n             * 60 0x2b  | PUSH1 0x2b     | 0x2b success 0 rds     | [0..rds): returndata  |\n             * 57       | JUMPI          | 0 rds                  | [0..rds): returndata  |\n             *                                                                            |\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd       | REVERT         |                        | [0..rds): returndata  |\n             *                                                                            |\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b       | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n             * f3       | RETURN         |                        | [0..rds): returndata  |\n             * ---------------------------------------------------------------------------+\n             */\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x43), n))\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            instance := create(value, add(m, add(0x0b, lt(n, 0xffd3))), add(n, 0x37))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 425
          },
          {
            "name": "cloneDeterministic",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "cloneDeterministic",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function cloneDeterministic(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, args, salt);\n    }",
            "startLine": 503
          },
          {
            "name": "cloneDeterministic",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function cloneDeterministic(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x43), n))\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            instance := create2(value, add(m, add(0x0b, lt(n, 0xffd3))), add(n, 0x37), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 512
          },
          {
            "name": "createDeterministicClone",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "alreadyDeployed",
                "type": "bool"
              },
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "createDeterministicClone",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function createDeterministicClone(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicClone(0, implementation, args, salt);\n    }",
            "startLine": 538
          },
          {
            "name": "createDeterministicClone",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "alreadyDeployed",
                "type": "bool"
              },
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function createDeterministicClone(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x43), n))\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            // forgefmt: disable-next-item\n            mstore(add(m, gt(n, 0xffd2)), add(0xfe61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(add(m, 0x0c), add(n, 0x37)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, add(m, 0x0c), add(n, 0x37), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 548
          },
          {
            "name": "initCode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCode(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffd2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x57), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x37), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(c, 0x28), implementation)\n            mstore(add(c, 0x14), add(0x61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            mstore(c, add(0x37, n)) // Store the length.\n            mstore(add(c, add(n, 0x57)), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(c, add(n, 0x77))) // Allocate memory.\n        }\n    }",
            "startLine": 593
          },
          {
            "name": "initCodeHash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "hash",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeHash(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffd2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x43), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0x61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            hash := keccak256(add(m, 0x0c), add(n, 0x37))\n        }\n    }",
            "startLine": 618
          },
          {
            "name": "predictDeterministicAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "deployer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "initCodeHash",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "predictDeterministicAddress",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddress(\n        address implementation,\n        bytes memory data,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash(implementation, data);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "startLine": 642
          },
          {
            "name": "argsOnClone",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function argsOnClone(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x2d))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x2d, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }",
            "startLine": 653
          },
          {
            "name": "argsOnClone",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function argsOnClone(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x2d))\n            let l := sub(n, and(0xffffff, mul(lt(start, n), start)))\n            extcodecopy(instance, args, add(start, 0x0d), add(l, 0x40))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }",
            "startLine": 664
          },
          {
            "name": "argsOnClone",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function argsOnClone(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x0d), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x2d)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }",
            "startLine": 685
          },
          {
            "name": "deployERC1967",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployERC1967",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployERC1967(address implementation) internal returns (address instance) {\n        instance = deployERC1967(0, implementation);\n    }",
            "startLine": 715
          },
          {
            "name": "deployERC1967",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function deployERC1967(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (61 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x38    | PUSH1 0x38     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            instance := create(value, 0x21, 0x5f)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "startLine": 721
          },
          {
            "name": "deployDeterministicERC1967",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployDeterministicERC1967",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployDeterministicERC1967(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967(0, implementation, salt);\n    }",
            "startLine": 805
          },
          {
            "name": "deployDeterministicERC1967",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function deployDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            instance := create2(value, 0x21, 0x5f, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "startLine": 814
          },
          {
            "name": "createDeterministicERC1967",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "alreadyDeployed",
                "type": "bool"
              },
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "createDeterministicERC1967",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function createDeterministicERC1967(address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967(0, implementation, salt);\n    }",
            "startLine": 839
          },
          {
            "name": "createDeterministicERC1967",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "alreadyDeployed",
                "type": "bool"
              },
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function createDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x21, 0x5f))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x21, 0x5f, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "startLine": 850
          },
          {
            "name": "initCodeERC1967",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeERC1967(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x60), 0x3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f300)\n            mstore(add(c, 0x40), 0x55f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076cc)\n            mstore(add(c, 0x20), or(shl(24, implementation), 0x600951))\n            mstore(add(c, 0x09), 0x603d3d8160223d3973)\n            mstore(c, 0x5f) // Store the length.\n            mstore(0x40, add(c, 0x80)) // Allocate memory.\n        }\n    }",
            "startLine": 891
          },
          {
            "name": "initCodeHashERC1967",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "hash",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeHashERC1967(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            hash := keccak256(0x21, 0x5f)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "startLine": 905
          },
          {
            "name": "predictDeterministicAddressERC1967",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "deployer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "initCodeHashERC1967",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "predictDeterministicAddress",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddressERC1967(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "startLine": 922
          },
          {
            "name": "deployERC1967",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployERC1967",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployERC1967(address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        instance = deployERC1967(0, implementation, args);\n    }",
            "startLine": 936
          },
          {
            "name": "deployERC1967",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function deployERC1967(uint256 value, address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x60), n))\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            mstore(gt(n, 0xffc2), add(0xfe61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            instance := create(value, m, add(n, 0x60))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 945
          },
          {
            "name": "deployDeterministicERC1967",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployDeterministicERC1967",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployDeterministicERC1967(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967(0, implementation, args, salt);\n    }",
            "startLine": 970
          },
          {
            "name": "deployDeterministicERC1967",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function deployDeterministicERC1967(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x60), n))\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            mstore(gt(n, 0xffc2), add(0xfe61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            instance := create2(value, m, add(n, 0x60), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 979
          },
          {
            "name": "createDeterministicERC1967",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "alreadyDeployed",
                "type": "bool"
              },
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "createDeterministicERC1967",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function createDeterministicERC1967(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967(0, implementation, args, salt);\n    }",
            "startLine": 1008
          },
          {
            "name": "createDeterministicERC1967",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "alreadyDeployed",
                "type": "bool"
              },
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function createDeterministicERC1967(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x60), n))\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            mstore(gt(n, 0xffc2), add(0xfe61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(m, add(n, 0x60)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, m, add(n, 0x60), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 1019
          },
          {
            "name": "initCodeERC1967",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeERC1967(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffc2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x80), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x60), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(c, 0x40), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(add(c, 0x20), 0x6009)\n            mstore(add(c, 0x1e), implementation)\n            mstore(add(c, 0x0a), add(0x61003d3d8160233d3973, shl(56, n)))\n            mstore(c, add(n, 0x60)) // Store the length.\n            mstore(add(c, add(n, 0x80)), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(c, add(n, 0xa0))) // Allocate memory.\n        }\n    }",
            "startLine": 1065
          },
          {
            "name": "initCodeHashERC1967",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "hash",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeHashERC1967(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffc2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x60), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            mstore(0x00, add(0x61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            hash := keccak256(m, add(n, 0x60))\n        }\n    }",
            "startLine": 1091
          },
          {
            "name": "predictDeterministicAddressERC1967",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "deployer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "initCodeHashERC1967",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "predictDeterministicAddress",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddressERC1967(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967(implementation, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "startLine": 1117
          },
          {
            "name": "argsOnERC1967",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function argsOnERC1967(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x3d))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x3d, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }",
            "startLine": 1128
          },
          {
            "name": "argsOnERC1967",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function argsOnERC1967(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x3d))\n            let l := sub(n, and(0xffffff, mul(lt(start, n), start)))\n            extcodecopy(instance, args, add(start, 0x1d), add(l, 0x40))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }",
            "startLine": 1139
          },
          {
            "name": "argsOnERC1967",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function argsOnERC1967(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x1d), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x3d)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }",
            "startLine": 1160
          },
          {
            "name": "deployERC1967I",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployERC1967I",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployERC1967I(address implementation) internal returns (address instance) {\n        instance = deployERC1967I(0, implementation);\n    }",
            "startLine": 1192
          },
          {
            "name": "deployERC1967I",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function deployERC1967I(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (82 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: check calldatasize ::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 58         | PC             | 1 cds            |                                 |\n             * 14         | EQ             | eqs              |                                 |\n             * 60 0x43    | PUSH1 0x43     | dest eqs         |                                 |\n             * 57         | JUMPI          |                  |                                 |\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x3E    | PUSH1 0x3E     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: implementation , return :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  |                                 |\n             * 60 0x20    | PUSH1 0x20     | 32               |                                 |\n             * 60 0x0F    | PUSH1 0x0F     | o 32             |                                 |\n             * 3d         | RETURNDATASIZE | 0 o 32           |                                 |\n             * 39         | CODECOPY       |                  | [0..32): implementation slot    |\n             * 3d         | RETURNDATASIZE | 0                | [0..32): implementation slot    |\n             * 51         | MLOAD          | slot             | [0..32): implementation slot    |\n             * 54         | SLOAD          | impl             | [0..32): implementation slot    |\n             * 3d         | RETURNDATASIZE | 0 impl           | [0..32): implementation slot    |\n             * 52         | MSTORE         |                  | [0..32): implementation address |\n             * 59         | MSIZE          | 32               | [0..32): implementation address |\n             * 3d         | RETURNDATASIZE | 0 32             | [0..32): implementation address |\n             * f3         | RETURN         |                  | [0..32): implementation address |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            instance := create(value, 0x0c, 0x74)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "startLine": 1198
          },
          {
            "name": "deployDeterministicERC1967I",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployDeterministicERC1967I",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployDeterministicERC1967I(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967I(0, implementation, salt);\n    }",
            "startLine": 1303
          },
          {
            "name": "deployDeterministicERC1967I",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function deployDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            instance := create2(value, 0x0c, 0x74, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "startLine": 1312
          },
          {
            "name": "createDeterministicERC1967I",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "alreadyDeployed",
                "type": "bool"
              },
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "createDeterministicERC1967I",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function createDeterministicERC1967I(address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967I(0, implementation, salt);\n    }",
            "startLine": 1336
          },
          {
            "name": "createDeterministicERC1967I",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "alreadyDeployed",
                "type": "bool"
              },
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function createDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x0c, 0x74, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "startLine": 1347
          },
          {
            "name": "initCodeERC1967I",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeERC1967I(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x74), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(c, 0x54), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(c, 0x34), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(c, 0x1d), implementation)\n            mstore(add(c, 0x09), 0x60523d8160223d3973)\n            mstore(add(c, 0x94), 0)\n            mstore(c, 0x74) // Store the length.\n            mstore(0x40, add(c, 0xa0)) // Allocate memory.\n        }\n    }",
            "startLine": 1387
          },
          {
            "name": "initCodeHashERC1967I",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "hash",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeHashERC1967I(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            hash := keccak256(0x0c, 0x74)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "startLine": 1403
          },
          {
            "name": "predictDeterministicAddressERC1967I",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "deployer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "initCodeHashERC1967I",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "predictDeterministicAddress",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddressERC1967I(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967I(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "startLine": 1419
          },
          {
            "name": "deployERC1967I",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployERC1967I",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployERC1967I(address implementation, bytes memory args) internal returns (address) {\n        return deployERC1967I(0, implementation, args);\n    }",
            "startLine": 1433
          },
          {
            "name": "deployERC1967I",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function deployERC1967I(uint256 value, address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n\n            mstore(add(m, 0x6b), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x4b), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x2b), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe6100523d8160233d3973, shl(56, n)))\n\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            instance := create(value, add(m, add(0x15, lt(n, 0xffae))), add(0x75, n))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 1439
          },
          {
            "name": "deployDeterministicERC1967I",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployDeterministicERC1967I",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployDeterministicERC1967I(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967I(0, implementation, args, salt);\n    }",
            "startLine": 1465
          },
          {
            "name": "deployDeterministicERC1967I",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function deployDeterministicERC1967I(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n\n            mstore(add(m, 0x6b), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x4b), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x2b), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe6100523d8160233d3973, shl(56, n)))\n\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            instance := create2(value, add(m, add(0x15, lt(n, 0xffae))), add(0x75, n), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 1474
          },
          {
            "name": "createDeterministicERC1967I",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "alreadyDeployed",
                "type": "bool"
              },
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "createDeterministicERC1967I",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function createDeterministicERC1967I(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967I(0, implementation, args, salt);\n    }",
            "startLine": 1504
          },
          {
            "name": "createDeterministicERC1967I",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "alreadyDeployed",
                "type": "bool"
              },
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function createDeterministicERC1967I(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x75), n))\n            mstore(add(m, 0x55), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x35), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x15), 0x5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x16, 0x600f)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(gt(n, 0xffad), add(0xfe6100523d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(m, add(n, 0x75)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, m, add(0x75, n), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 1515
          },
          {
            "name": "initCodeERC1967I",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeERC1967I(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x95), i), mload(add(add(args, 0x20), i)))\n            }\n\n            mstore(add(c, 0x75), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(c, 0x55), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(c, 0x35), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(c, 0x1e), implementation)\n            mstore(add(c, 0x0a), add(0x6100523d8160233d3973, shl(56, n)))\n            mstore(add(c, add(n, 0x95)), 0)\n            mstore(c, add(0x75, n)) // Store the length.\n            mstore(0x40, add(c, add(n, 0xb5))) // Allocate memory.\n        }\n    }",
            "startLine": 1562
          },
          {
            "name": "initCodeHashERC1967I",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "hash",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeHashERC1967I(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x75), i), mload(add(add(args, 0x20), i)))\n            }\n\n            mstore(add(m, 0x55), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x35), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x15), 0x5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x16, 0x600f)\n            mstore(0x14, implementation)\n            mstore(0x00, add(0x6100523d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            hash := keccak256(m, add(0x75, n))\n        }\n    }",
            "startLine": 1589
          },
          {
            "name": "predictDeterministicAddressERC1967I",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "deployer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "initCodeHashERC1967I",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "predictDeterministicAddress",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddressERC1967I(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967I(implementation, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "startLine": 1618
          },
          {
            "name": "argsOnERC1967I",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function argsOnERC1967I(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x52))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x52, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }",
            "startLine": 1629
          },
          {
            "name": "argsOnERC1967I",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function argsOnERC1967I(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x52))\n            let l := sub(n, and(0xffffff, mul(lt(start, n), start)))\n            extcodecopy(instance, args, add(start, 0x32), add(l, 0x40))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }",
            "startLine": 1640
          },
          {
            "name": "argsOnERC1967I",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function argsOnERC1967I(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x32), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x52)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }",
            "startLine": 1661
          },
          {
            "name": "erc1967Bootstrap",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "erc1967Bootstrap",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function erc1967Bootstrap() internal returns (address) {\n        return erc1967Bootstrap(address(this));\n    }",
            "startLine": 1697
          },
          {
            "name": "erc1967Bootstrap",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "authorizedUpgrader",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "bootstrap",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "initCodeERC1967Bootstrap",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "predictDeterministicAddress",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function erc1967Bootstrap(address authorizedUpgrader) internal returns (address bootstrap) {\n        bytes memory c = initCodeERC1967Bootstrap(authorizedUpgrader);\n        bootstrap = predictDeterministicAddress(keccak256(c), bytes32(0), address(this));\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(extcodesize(bootstrap)) {\n                if iszero(create2(0, add(c, 0x20), mload(c), 0)) {\n                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 1702
          },
          {
            "name": "bootstrapERC1967",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function bootstrapERC1967(address instance, address implementation) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, implementation)\n            if iszero(call(gas(), instance, 0, 0x0c, 0x14, codesize(), 0x00)) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 1717
          },
          {
            "name": "bootstrapERC1967AndCall",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function bootstrapERC1967AndCall(address instance, address implementation, bytes memory data)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            mstore(data, implementation)\n            if iszero(call(gas(), instance, 0, add(data, 0x0c), add(n, 0x14), codesize(), 0x00)) {\n                if iszero(returndatasize()) {\n                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                returndatacopy(mload(0x40), 0x00, returndatasize())\n                revert(mload(0x40), returndatasize())\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }",
            "startLine": 1729
          },
          {
            "name": "predictDeterministicAddressERC1967Bootstrap",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "predictDeterministicAddressERC1967Bootstrap",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddressERC1967Bootstrap() internal view returns (address) {\n        return predictDeterministicAddressERC1967Bootstrap(address(this), address(this));\n    }",
            "startLine": 1749
          },
          {
            "name": "predictDeterministicAddressERC1967Bootstrap",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "authorizedUpgrader",
                "type": "address"
              },
              {
                "name": "deployer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "initCodeHashERC1967Bootstrap",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "predictDeterministicAddress",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddressERC1967Bootstrap(\n        address authorizedUpgrader,\n        address deployer\n    ) internal pure returns (address) {\n        bytes32 hash = initCodeHashERC1967Bootstrap(authorizedUpgrader);\n        return predictDeterministicAddress(hash, bytes32(0), deployer);\n    }",
            "startLine": 1754
          },
          {
            "name": "initCodeERC1967Bootstrap",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "authorizedUpgrader",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeERC1967Bootstrap(address authorizedUpgrader)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x80), 0x3d3560601c5af46047573d6000383e3d38fd0000000000000000000000000000)\n            mstore(add(c, 0x60), 0xa920a3ca505d382bbc55601436116049575b005b363d3d373d3d601436036014)\n            mstore(add(c, 0x40), 0x0338573d3560601c7f360894a13ba1a3210667c828492db98dca3e2076cc3735)\n            mstore(add(c, 0x20), authorizedUpgrader)\n            mstore(add(c, 0x0c), 0x606880600a3d393df3fe3373)\n            mstore(c, 0x72)\n            mstore(0x40, add(c, 0xa0))\n        }\n    }",
            "startLine": 1763
          },
          {
            "name": "initCodeHashERC1967Bootstrap",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "authorizedUpgrader",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "initCodeERC1967Bootstrap",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function initCodeHashERC1967Bootstrap(address authorizedUpgrader)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(initCodeERC1967Bootstrap(authorizedUpgrader));\n    }",
            "startLine": 1782
          },
          {
            "name": "deployERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployERC1967BeaconProxy",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployERC1967BeaconProxy(address beacon) internal returns (address instance) {\n        instance = deployERC1967BeaconProxy(0, beacon);\n    }",
            "startLine": 1801
          },
          {
            "name": "deployERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "beacon",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function deployERC1967BeaconProxy(uint256 value, address beacon)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 beac    | PUSH20 beac    | beac 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos beac 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot beac 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (82 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ~~~~~~~ beacon staticcall sub procedure ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 60 0x20       | PUSH1 0x20       | 32                          |                 |\n             * 36            | CALLDATASIZE     | cds 32                      |                 |\n             * 60 0x04       | PUSH1 0x04       | 4 cds 32                    |                 |\n             * 36            | CALLDATASIZE     | cds 4 cds 32                |                 |\n             * 63 0x5c60da1b | PUSH4 0x5c60da1b | 0x5c60da1b cds 4 cds 32     |                 |\n             * 60 0xe0       | PUSH1 0xe0       | 224 0x5c60da1b cds 4 cds 32 |                 |\n             * 1b            | SHL              | sel cds 4 cds 32            |                 |\n             * 36            | CALLDATASIZE     | cds sel cds 4 cds 32        |                 |\n             * 52            | MSTORE           | cds 4 cds 32                | sel             |\n             * 7f slot       | PUSH32 slot      | s cds 4 cds 32              | sel             |\n             * 54            | SLOAD            | beac cds 4 cds 32           | sel             |\n             * 5a            | GAS              | g beac cds 4 cds 32         | sel             |\n             * fa            | STATICCALL       | succ                        | impl            |\n             * 50            | POP              |                             | impl            |\n             * 36            | CALLDATASIZE     | cds                         | impl            |\n             * 51            | MLOAD            | impl                        | impl            |\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 5a         | GAS            | g impl 0 cds 0 0 | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x4d    | PUSH1 0x4d     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create(value, 0x0c, 0x74)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "startLine": 1807
          },
          {
            "name": "deployDeterministicERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployDeterministicERC1967BeaconProxy",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967BeaconProxy(0, beacon, salt);\n    }",
            "startLine": 1907
          },
          {
            "name": "deployDeterministicERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function deployDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create2(value, 0x0c, 0x74, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "startLine": 1916
          },
          {
            "name": "createDeterministicERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "alreadyDeployed",
                "type": "bool"
              },
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "createDeterministicERC1967BeaconProxy",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function createDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967BeaconProxy(0, beacon, salt);\n    }",
            "startLine": 1940
          },
          {
            "name": "createDeterministicERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "alreadyDeployed",
                "type": "bool"
              },
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function createDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x0c, 0x74, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "startLine": 1951
          },
          {
            "name": "initCodeERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeERC1967BeaconProxy(address beacon) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x74), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(c, 0x54), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(c, 0x34), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(c, 0x1d), beacon)\n            mstore(add(c, 0x09), 0x60523d8160223d3973)\n            mstore(add(c, 0x94), 0)\n            mstore(c, 0x74) // Store the length.\n            mstore(0x40, add(c, 0xa0)) // Allocate memory.\n        }\n    }",
            "startLine": 1991
          },
          {
            "name": "initCodeHashERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "hash",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeHashERC1967BeaconProxy(address beacon) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            hash := keccak256(0x0c, 0x74)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "startLine": 2007
          },
          {
            "name": "predictDeterministicAddressERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "deployer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "initCodeHashERC1967BeaconProxy",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "predictDeterministicAddress",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddressERC1967BeaconProxy(\n        address beacon,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967BeaconProxy(beacon);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "startLine": 2023
          },
          {
            "name": "deployERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployERC1967BeaconProxy",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployERC1967BeaconProxy(address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        instance = deployERC1967BeaconProxy(0, beacon, args);\n    }",
            "startLine": 2037
          },
          {
            "name": "deployERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function deployERC1967BeaconProxy(uint256 value, address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(add(m, gt(n, 0xffad)), add(0xfe6100523d8160233d3973, shl(56, n)))\n            instance := create(value, add(m, 0x16), add(n, 0x75))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 2046
          },
          {
            "name": "deployDeterministicERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployDeterministicERC1967BeaconProxy",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployDeterministicERC1967BeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967BeaconProxy(0, beacon, args, salt);\n    }",
            "startLine": 2070
          },
          {
            "name": "deployDeterministicERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function deployDeterministicERC1967BeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(add(m, gt(n, 0xffad)), add(0xfe6100523d8160233d3973, shl(56, n)))\n            instance := create2(value, add(m, 0x16), add(n, 0x75), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 2079
          },
          {
            "name": "createDeterministicERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "alreadyDeployed",
                "type": "bool"
              },
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "createDeterministicERC1967BeaconProxy",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function createDeterministicERC1967BeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967BeaconProxy(0, beacon, args, salt);\n    }",
            "startLine": 2107
          },
          {
            "name": "createDeterministicERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "alreadyDeployed",
                "type": "bool"
              },
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function createDeterministicERC1967BeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(add(m, gt(n, 0xffad)), add(0xfe6100523d8160233d3973, shl(56, n)))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(add(m, 0x16), add(n, 0x75)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, add(m, 0x16), add(n, 0x75), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 2118
          },
          {
            "name": "initCodeERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeERC1967BeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x95), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x75), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(c, 0x55), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(c, 0x35), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(c, 0x1e), beacon)\n            mstore(add(c, 0x0a), add(0x6100523d8160233d3973, shl(56, n)))\n            mstore(c, add(n, 0x75)) // Store the length.\n            mstore(add(c, add(n, 0x95)), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(c, add(n, 0xb5))) // Allocate memory.\n        }\n    }",
            "startLine": 2163
          },
          {
            "name": "initCodeHashERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "hash",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeHashERC1967BeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x8b), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            mstore(m, add(0x6100523d8160233d3973, shl(56, n)))\n            hash := keccak256(add(m, 0x16), add(n, 0x75))\n        }\n    }",
            "startLine": 2189
          },
          {
            "name": "predictDeterministicAddressERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "deployer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "initCodeHashERC1967BeaconProxy",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "predictDeterministicAddress",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddressERC1967BeaconProxy(\n        address beacon,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967BeaconProxy(beacon, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "startLine": 2214
          },
          {
            "name": "argsOnERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function argsOnERC1967BeaconProxy(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x52))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x52, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }",
            "startLine": 2225
          },
          {
            "name": "argsOnERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function argsOnERC1967BeaconProxy(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x52))\n            let l := sub(n, and(0xffffff, mul(lt(start, n), start)))\n            extcodecopy(instance, args, add(start, 0x32), add(l, 0x40))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }",
            "startLine": 2236
          },
          {
            "name": "argsOnERC1967BeaconProxy",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function argsOnERC1967BeaconProxy(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x32), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x52)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }",
            "startLine": 2257
          },
          {
            "name": "deployERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployERC1967IBeaconProxy",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployERC1967IBeaconProxy(address beacon) internal returns (address instance) {\n        instance = deployERC1967IBeaconProxy(0, beacon);\n    }",
            "startLine": 2295
          },
          {
            "name": "deployERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "beacon",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function deployERC1967IBeaconProxy(uint256 value, address beacon)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 beac    | PUSH20 beac    | beac 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos beac 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot beac 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (87 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ~~~~~~~ beacon staticcall sub procedure ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 60 0x20       | PUSH1 0x20       | 32                          |                 |\n             * 36            | CALLDATASIZE     | cds 32                      |                 |\n             * 60 0x04       | PUSH1 0x04       | 4 cds 32                    |                 |\n             * 36            | CALLDATASIZE     | cds 4 cds 32                |                 |\n             * 63 0x5c60da1b | PUSH4 0x5c60da1b | 0x5c60da1b cds 4 cds 32     |                 |\n             * 60 0xe0       | PUSH1 0xe0       | 224 0x5c60da1b cds 4 cds 32 |                 |\n             * 1b            | SHL              | sel cds 4 cds 32            |                 |\n             * 36            | CALLDATASIZE     | cds sel cds 4 cds 32        |                 |\n             * 52            | MSTORE           | cds 4 cds 32                | sel             |\n             * 7f slot       | PUSH32 slot      | s cds 4 cds 32              | sel             |\n             * 54            | SLOAD            | beac cds 4 cds 32           | sel             |\n             * 5a            | GAS              | g beac cds 4 cds 32         | sel             |\n             * fa            | STATICCALL       | succ                        | impl            |\n             * ~~~~~~ check calldatasize ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 36            | CALLDATASIZE     | cds succ                    |                 |\n             * 14            | EQ               |                             | impl            |\n             * 60 0x52       | PUSH1 0x52       |                             | impl            |\n             * 57            | JUMPI            |                             | impl            |\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 36            | CALLDATASIZE     | cds                         | impl            |\n             * 51            | MLOAD            | impl                        | impl            |\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 5a         | GAS            | g impl 0 cds 0 0 | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 60 0x01    | PUSH1 0x01     | 1 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [1..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x52    | PUSH1 0x52     | dest succ        | [1..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [1..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [1..returndatasize): returndata |\n             * 60 0x01    | PUSH1 0x01     | 1 rds            | [1..returndatasize): returndata |\n             * fd         | REVERT         |                  | [1..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [1..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [1..returndatasize): returndata |\n             * 60 0x01    | PUSH1 0x01     | 1 rds            | [1..returndatasize): returndata |\n             * f3         | RETURN         |                  | [1..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create(value, 0x07, 0x79)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "startLine": 2301
          },
          {
            "name": "deployDeterministicERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployDeterministicERC1967IBeaconProxy",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployDeterministicERC1967IBeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967IBeaconProxy(0, beacon, salt);\n    }",
            "startLine": 2406
          },
          {
            "name": "deployDeterministicERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function deployDeterministicERC1967IBeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create2(value, 0x07, 0x79, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "startLine": 2415
          },
          {
            "name": "createDeterministicERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "alreadyDeployed",
                "type": "bool"
              },
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "createDeterministicERC1967IBeaconProxy",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function createDeterministicERC1967IBeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967IBeaconProxy(0, beacon, salt);\n    }",
            "startLine": 2439
          },
          {
            "name": "createDeterministicERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "alreadyDeployed",
                "type": "bool"
              },
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function createDeterministicERC1967IBeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x07, 0x79))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x07, 0x79, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "startLine": 2450
          },
          {
            "name": "initCodeERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeERC1967IBeaconProxy(address beacon) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x79), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(c, 0x59), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(c, 0x39), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(c, 0x1d), beacon)\n            mstore(add(c, 0x09), 0x60573d8160223d3973)\n            mstore(add(c, 0x99), 0)\n            mstore(c, 0x79) // Store the length.\n            mstore(0x40, add(c, 0xa0)) // Allocate memory.\n        }\n    }",
            "startLine": 2490
          },
          {
            "name": "initCodeHashERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "hash",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeHashERC1967IBeaconProxy(address beacon) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            hash := keccak256(0x07, 0x79)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "startLine": 2506
          },
          {
            "name": "predictDeterministicAddressERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "deployer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "initCodeHashERC1967IBeaconProxy",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "predictDeterministicAddress",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddressERC1967IBeaconProxy(\n        address beacon,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967IBeaconProxy(beacon);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "startLine": 2522
          },
          {
            "name": "deployERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployERC1967IBeaconProxy",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployERC1967IBeaconProxy(address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        instance = deployERC1967IBeaconProxy(0, beacon, args);\n    }",
            "startLine": 2536
          },
          {
            "name": "deployERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function deployERC1967IBeaconProxy(uint256 value, address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x90), n))\n            mstore(add(m, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(m, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(m, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            mstore(add(m, gt(n, 0xffa8)), add(0xfe6100573d8160233d3973, shl(56, n)))\n            instance := create(value, add(m, 0x16), add(n, 0x7a))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 2545
          },
          {
            "name": "deployDeterministicERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployDeterministicERC1967IBeaconProxy",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function deployDeterministicERC1967IBeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967IBeaconProxy(0, beacon, args, salt);\n    }",
            "startLine": 2569
          },
          {
            "name": "deployDeterministicERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function deployDeterministicERC1967IBeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x90), n))\n            mstore(add(m, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(m, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(m, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            mstore(add(m, gt(n, 0xffa8)), add(0xfe6100573d8160233d3973, shl(56, n)))\n            instance := create2(value, add(m, 0x16), add(n, 0x7a), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 2578
          },
          {
            "name": "createDeterministicERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "alreadyDeployed",
                "type": "bool"
              },
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "createDeterministicERC1967IBeaconProxy",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function createDeterministicERC1967IBeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967IBeaconProxy(0, beacon, args, salt);\n    }",
            "startLine": 2606
          },
          {
            "name": "createDeterministicERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "alreadyDeployed",
                "type": "bool"
              },
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function createDeterministicERC1967IBeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x90), n))\n            mstore(add(m, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(m, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(m, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            mstore(add(m, gt(n, 0xffa8)), add(0xfe6100573d8160233d3973, shl(56, n)))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(add(m, 0x16), add(n, 0x7a)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, add(m, 0x16), add(n, 0x7a), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 2617
          },
          {
            "name": "initCodeERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeERC1967IBeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffa8))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x9a), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x7a), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(c, 0x5a), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(c, 0x3a), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(c, 0x1e), beacon)\n            mstore(add(c, 0x0a), add(0x6100573d8160233d3973, shl(56, n)))\n            mstore(add(c, add(n, 0x9a)), 0)\n            mstore(c, add(n, 0x7a)) // Store the length.\n            mstore(0x40, add(c, add(n, 0xba))) // Allocate memory.\n        }\n    }",
            "startLine": 2662
          },
          {
            "name": "initCodeHashERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "hash",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeHashERC1967IBeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let c := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffa8))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x90), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(c, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(c, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(c, 0x14), beacon)\n            mstore(c, add(0x6100573d8160233d3973, shl(56, n)))\n            hash := keccak256(add(c, 0x16), add(n, 0x7a))\n        }\n    }",
            "startLine": 2688
          },
          {
            "name": "predictDeterministicAddressERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "deployer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "initCodeHashERC1967IBeaconProxy",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "predictDeterministicAddress",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddressERC1967IBeaconProxy(\n        address beacon,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967IBeaconProxy(beacon, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "startLine": 2713
          },
          {
            "name": "argsOnERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function argsOnERC1967IBeaconProxy(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x57))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x57, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }",
            "startLine": 2724
          },
          {
            "name": "argsOnERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function argsOnERC1967IBeaconProxy(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x57))\n            let l := sub(n, and(0xffffff, mul(lt(start, n), start)))\n            extcodecopy(instance, args, add(start, 0x37), add(l, 0x40))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }",
            "startLine": 2735
          },
          {
            "name": "argsOnERC1967IBeaconProxy",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "args",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function argsOnERC1967IBeaconProxy(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x37), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x57)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }",
            "startLine": 2756
          },
          {
            "name": "implementationOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function implementationOf(address instance) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { extcodecopy(instance, 0x00, 0x00, 0x57) } 1 {} {\n                if mload(0x2d) {\n                    // ERC1967I and ERC1967IBeaconProxy detection.\n                    if or(\n                        eq(keccak256(0x00, 0x52), ERC1967I_CODE_HASH),\n                        eq(keccak256(0x00, 0x57), ERC1967I_BEACON_PROXY_CODE_HASH)\n                    ) {\n                        pop(staticcall(gas(), instance, 0x00, 0x01, 0x00, 0x20))\n                        result := mload(0x0c)\n                        break\n                    }\n                }\n                // 0age clone detection.\n                result := mload(0x0b)\n                codecopy(0x0b, codesize(), 0x14) // Zeroize the 20 bytes for the address.\n                if iszero(xor(keccak256(0x00, 0x2c), CLONE_CODE_HASH)) { break }\n                mstore(0x0b, result) // Restore the zeroized memory.\n                // CWIA detection.\n                result := mload(0x0a)\n                codecopy(0x0a, codesize(), 0x14) // Zeroize the 20 bytes for the address.\n                if iszero(xor(keccak256(0x00, 0x2d), CWIA_CODE_HASH)) { break }\n                mstore(0x0a, result) // Restore the zeroized memory.\n                // PUSH0 clone detection.\n                result := mload(0x09)\n                codecopy(0x09, codesize(), 0x14) // Zeroize the 20 bytes for the address.\n                result := shr(xor(keccak256(0x00, 0x2d), PUSH0_CLONE_CODE_HASH), result)\n                break\n            }\n            result := shr(96, result)\n            mstore(0x37, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 2783
          },
          {
            "name": "predictDeterministicAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "deployer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 2822
          },
          {
            "name": "checkStartsWith",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "by",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function checkStartsWith(bytes32 salt, address by) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the salt does not start with the zero address or `by`.\n            if iszero(or(iszero(shr(96, salt)), eq(shr(96, shl(96, by)), shr(96, salt)))) {\n                mstore(0x00, 0x0c4549ef) // `SaltDoesNotStartWith()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 2840
          },
          {
            "name": "argLoad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "args",
                "type": "bytes"
              },
              {
                "name": "offset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function argLoad(bytes memory args, uint256 offset) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(args, 0x20), offset))\n        }\n    }",
            "startLine": 2853
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "DeploymentFailed",
            "parameters": [],
            "startLine": 110
          },
          {
            "name": "SaltDoesNotStartWith",
            "parameters": [],
            "startLine": 113
          },
          {
            "name": "ETHTransferFailed",
            "parameters": [],
            "startLine": 116
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "CLONE_CODE_HASH",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 76
          },
          {
            "name": "PUSH0_CLONE_CODE_HASH",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 81
          },
          {
            "name": "CWIA_CODE_HASH",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 86
          },
          {
            "name": "ERC1967_CODE_HASH",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 90
          },
          {
            "name": "ERC1967I_CODE_HASH",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 94
          },
          {
            "name": "ERC1967_BEACON_PROXY_CODE_HASH",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 98
          },
          {
            "name": "ERC1967I_BEACON_PROXY_CODE_HASH",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 102
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibMap",
        "filePath": "utils/LibMap.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint8Map"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint8"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(Uint8Map storage map, uint256 index) internal view returns (uint8 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(5, index))\n            result := byte(and(31, not(index)), sload(keccak256(0x00, 0x40)))\n        }\n    }",
            "startLine": 46
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint8Map"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(Uint8Map storage map, uint256 index, uint8 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(5, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            mstore(0x00, sload(s))\n            mstore8(and(31, not(index)), value)\n            sstore(s, mload(0x00))\n        }\n    }",
            "startLine": 56
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint16Map"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint16"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(Uint16Map storage map, uint256 index) internal view returns (uint16 result) {\n        result = uint16(map.map[index >> 4] >> ((index & 15) << 4));\n    }",
            "startLine": 69
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint16Map"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint16"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(Uint16Map storage map, uint256 index, uint16 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(4, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(4, and(index, 15)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }",
            "startLine": 74
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint32Map"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(Uint32Map storage map, uint256 index) internal view returns (uint32 result) {\n        result = uint32(map.map[index >> 3] >> ((index & 7) << 5));\n    }",
            "startLine": 88
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint32Map"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(Uint32Map storage map, uint256 index, uint32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(3, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }",
            "startLine": 93
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint40Map"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint40"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(Uint40Map storage map, uint256 index) internal view returns (uint40 result) {\n        unchecked {\n            result = uint40(map.map[index / 6] >> ((index % 6) * 40));\n        }\n    }",
            "startLine": 107
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint40Map"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint40"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(Uint40Map storage map, uint256 index, uint40 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, div(index, 6))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := mul(40, mod(index, 6)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }",
            "startLine": 114
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint64Map"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint64"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(Uint64Map storage map, uint256 index) internal view returns (uint64 result) {\n        result = uint64(map.map[index >> 2] >> ((index & 3) << 6));\n    }",
            "startLine": 128
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint64Map"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(Uint64Map storage map, uint256 index, uint64 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(2, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(6, and(index, 3)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffffffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }",
            "startLine": 133
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint128Map"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint128"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(Uint128Map storage map, uint256 index) internal view returns (uint128 result) {\n        result = uint128(map.map[index >> 1] >> ((index & 1) << 7));\n    }",
            "startLine": 147
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint128Map"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint128"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(Uint128Map storage map, uint256 index, uint128 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(1, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(7, and(index, 1)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffffffffffffffffffffffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }",
            "startLine": 152
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "mapping(uint256 => uint256)"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "bitWidth",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_rawDiv",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_rawMod",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(mapping(uint256 => uint256) storage map, uint256 index, uint256 bitWidth)\n        internal\n        view\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\n            result = (map[_rawDiv(index, d)] >> (_rawMod(index, d) * bitWidth)) & m;\n        }\n    }",
            "startLine": 166
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "mapping(uint256 => uint256)"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "bitWidth",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_rawDiv",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_rawMod",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(\n        mapping(uint256 => uint256) storage map,\n        uint256 index,\n        uint256 value,\n        uint256 bitWidth\n    ) internal {\n        unchecked {\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\n            uint256 o = _rawMod(index, d) * bitWidth; // Storage slot offset (bits).\n            map[_rawDiv(index, d)] ^= (((map[_rawDiv(index, d)] >> o) ^ value) & m) << o;\n        }\n    }",
            "startLine": 179
          },
          {
            "name": "searchSorted",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint8Map"
              },
              {
                "name": "needle",
                "type": "uint8"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "searchSorted",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function searchSorted(Uint8Map storage map, uint8 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 8);\n    }",
            "startLine": 204
          },
          {
            "name": "searchSorted",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint16Map"
              },
              {
                "name": "needle",
                "type": "uint16"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "searchSorted",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function searchSorted(Uint16Map storage map, uint16 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 16);\n    }",
            "startLine": 213
          },
          {
            "name": "searchSorted",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint32Map"
              },
              {
                "name": "needle",
                "type": "uint32"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "searchSorted",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function searchSorted(Uint32Map storage map, uint32 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 32);\n    }",
            "startLine": 222
          },
          {
            "name": "searchSorted",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint40Map"
              },
              {
                "name": "needle",
                "type": "uint40"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "searchSorted",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function searchSorted(Uint40Map storage map, uint40 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 40);\n    }",
            "startLine": 231
          },
          {
            "name": "searchSorted",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint64Map"
              },
              {
                "name": "needle",
                "type": "uint64"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "searchSorted",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function searchSorted(Uint64Map storage map, uint64 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 64);\n    }",
            "startLine": 240
          },
          {
            "name": "searchSorted",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint128Map"
              },
              {
                "name": "needle",
                "type": "uint128"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "searchSorted",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function searchSorted(Uint128Map storage map, uint128 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 128);\n    }",
            "startLine": 249
          },
          {
            "name": "searchSorted",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "mapping(uint256 => uint256)"
              },
              {
                "name": "needle",
                "type": "uint256"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              },
              {
                "name": "bitWidth",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_rawDiv",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_rawMod",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function searchSorted(\n        mapping(uint256 => uint256) storage map,\n        uint256 needle,\n        uint256 start,\n        uint256 end,\n        uint256 bitWidth\n    ) internal view returns (bool found, uint256 index) {\n        unchecked {\n            if (start >= end) end = start;\n            uint256 t;\n            uint256 o = start - 1; // Offset to derive the actual index.\n            uint256 l = 1; // Low.\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\n            uint256 h = end - start; // High.\n            while (true) {\n                index = (l & h) + ((l ^ h) >> 1);\n                if (l > h) break;\n                t = (map[_rawDiv(index + o, d)] >> (_rawMod(index + o, d) * bitWidth)) & m;\n                if (t == needle) break;\n                if (needle <= t) h = index - 1;\n                else l = index + 1;\n            }\n            /// @solidity memory-safe-assembly\n            assembly {\n                m := or(iszero(index), iszero(bitWidth))\n                found := iszero(or(xor(t, needle), m))\n                index := add(o, xor(index, mul(xor(index, 1), m)))\n            }\n        }\n    }",
            "startLine": 258
          },
          {
            "name": "_rawDiv",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _rawDiv(uint256 x, uint256 y) private pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }",
            "startLine": 295
          },
          {
            "name": "_rawMod",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _rawMod(uint256 x, uint256 y) private pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }",
            "startLine": 303
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "Uint8Map",
            "members": [
              {
                "name": "map",
                "type": "mapping(uint256 => uint256)"
              }
            ],
            "startLine": 12
          },
          {
            "name": "Uint16Map",
            "members": [
              {
                "name": "map",
                "type": "mapping(uint256 => uint256)"
              }
            ],
            "startLine": 17
          },
          {
            "name": "Uint32Map",
            "members": [
              {
                "name": "map",
                "type": "mapping(uint256 => uint256)"
              }
            ],
            "startLine": 22
          },
          {
            "name": "Uint40Map",
            "members": [
              {
                "name": "map",
                "type": "mapping(uint256 => uint256)"
              }
            ],
            "startLine": 27
          },
          {
            "name": "Uint64Map",
            "members": [
              {
                "name": "map",
                "type": "mapping(uint256 => uint256)"
              }
            ],
            "startLine": 32
          },
          {
            "name": "Uint128Map",
            "members": [
              {
                "name": "map",
                "type": "mapping(uint256 => uint256)"
              }
            ],
            "startLine": 37
          }
        ],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibPRNG",
        "filePath": "utils/LibPRNG.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "seed",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              },
              {
                "name": "state",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function seed(PRNG memory prng, uint256 state) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(prng, state)\n        }\n    }",
            "startLine": 61
          },
          {
            "name": "next",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function next(PRNG memory prng) internal pure returns (uint256 result) {\n        // We simply use `keccak256` for a great balance between\n        // runtime gas costs, bytecode size, and statistical properties.\n        //\n        // A high-quality LCG with a 32-byte state\n        // is only about 30% more gas efficient during runtime,\n        // but requires a 32-byte multiplier, which can cause bytecode bloat\n        // when this function is inlined.\n        //\n        // Using this method is about 2x more efficient than\n        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(prng, 0x20)\n            mstore(prng, result)\n        }\n    }",
            "startLine": 70
          },
          {
            "name": "uniform",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              },
              {
                "name": "upper",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := keccak256(prng, 0x20)\n                mstore(prng, result)\n                if iszero(lt(result, mod(sub(0, upper), upper))) { break }\n            }\n            result := mod(result, upper)\n        }\n    }",
            "startLine": 95
          },
          {
            "name": "standardNormalWad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function standardNormalWad(PRNG memory prng) internal pure returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Technically, this is the Irwin-Hall distribution with 20 samples.\n            // The chance of drawing a sample outside 10  from the standard normal distribution\n            // is  0.000000000000000000000015, which is insignificant for most practical purposes.\n            // Passes the Kolmogorov-Smirnov test for 200k samples. Uses about 322 gas.\n            result := keccak256(prng, 0x20)\n            mstore(prng, result)\n            let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\n            let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\n            let m := 0x1fffffffffffffff1fffffffffffffff1fffffffffffffff1fffffffffffffff\n            let s := 0x1000000000000000100000000000000010000000000000001\n            let r1 := mulmod(result, a, n)\n            let r2 := mulmod(r1, a, n)\n            let r3 := mulmod(r2, a, n)\n            // forgefmt: disable-next-item\n            result := sub(sar(96, mul(26614938895861601847173011183,\n                add(add(shr(192, mul(s, add(and(m, result), and(m, r1)))),\n                shr(192, mul(s, add(and(m, r2), and(m, r3))))),\n                shr(192, mul(s, and(m, mulmod(r3, a, n))))))), 7745966692414833770)\n        }\n    }",
            "startLine": 108
          },
          {
            "name": "exponentialWad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function exponentialWad(PRNG memory prng) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Passes the Kolmogorov-Smirnov test for 200k samples.\n            // Gas usage varies, starting from about 172+ gas.\n            let r := keccak256(prng, 0x20)\n            mstore(prng, r)\n            let p := shl(129, r)\n            let w := shl(1, r)\n            if iszero(gt(w, p)) {\n                let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\n                let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\n                for {} 1 {} {\n                    r := mulmod(r, a, n)\n                    if iszero(lt(shl(129, r), w)) {\n                        r := mulmod(r, a, n)\n                        result := add(1000000000000000000, result)\n                        w := shl(1, r)\n                        p := shl(129, r)\n                        if iszero(lt(w, p)) { break }\n                        continue\n                    }\n                    w := shl(1, r)\n                    if iszero(lt(w, shl(129, r))) { break }\n                }\n            }\n            result := add(div(p, shl(129, 170141183460469231732)), result)\n        }\n    }",
            "startLine": 133
          },
          {
            "name": "shuffle",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              },
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function shuffle(PRNG memory prng, uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a)\n            let w := not(0)\n            let mask := shr(128, w)\n            if n {\n                for { a := add(a, 0x20) } 1 {} {\n                    // We can just directly use `keccak256`, cuz\n                    // the other approaches don't save much.\n                    let r := keccak256(prng, 0x20)\n                    mstore(prng, r)\n\n                    // Note that there will be a very tiny modulo bias\n                    // if the length of the array is not a power of 2.\n                    // For all practical purposes, it is negligible\n                    // and will not be a fairness or security concern.\n                    {\n                        let j := add(a, shl(5, mod(shr(128, r), n)))\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let i := add(a, shl(5, n))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                    }\n\n                    {\n                        let j := add(a, shl(5, mod(and(r, mask), n)))\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let i := add(a, shl(5, n))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                    }\n                }\n            }\n        }\n    }",
            "startLine": 168
          },
          {
            "name": "shuffle",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              },
              {
                "name": "a",
                "type": "int256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "shuffle",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function shuffle(PRNG memory prng, int256[] memory a) internal pure {\n        shuffle(prng, _toUints(a));\n    }",
            "startLine": 212
          },
          {
            "name": "shuffle",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              },
              {
                "name": "a",
                "type": "address[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "shuffle",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function shuffle(PRNG memory prng, address[] memory a) internal pure {\n        shuffle(prng, _toUints(a));\n    }",
            "startLine": 217
          },
          {
            "name": "shuffle",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              },
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "k",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function shuffle(PRNG memory prng, uint256[] memory a, uint256 k) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a)\n            k := xor(k, mul(xor(k, n), lt(n, k))) // `min(n, k)`.\n            if k {\n                let mask := shr(128, not(0))\n                let b := 0\n                for { a := add(a, 0x20) } 1 {} {\n                    // We can just directly use `keccak256`, cuz\n                    // the other approaches don't save much.\n                    let r := keccak256(prng, 0x20)\n                    mstore(prng, r)\n\n                    // Note that there will be a very tiny modulo bias\n                    // if the length of the array is not a power of 2.\n                    // For all practical purposes, it is negligible\n                    // and will not be a fairness or security concern.\n                    {\n                        let j := add(a, shl(5, add(b, mod(shr(128, r), sub(n, b)))))\n                        let i := add(a, shl(5, b))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                        b := add(b, 1)\n                        if eq(b, k) { break }\n                    }\n\n                    {\n                        let j := add(a, shl(5, add(b, mod(and(r, mask), sub(n, b)))))\n                        let i := add(a, shl(5, b))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                        b := add(b, 1)\n                        if eq(b, k) { break }\n                    }\n                }\n            }\n        }\n    }",
            "startLine": 223
          },
          {
            "name": "shuffle",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              },
              {
                "name": "a",
                "type": "int256[]"
              },
              {
                "name": "k",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "shuffle",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function shuffle(PRNG memory prng, int256[] memory a, uint256 k) internal pure {\n        shuffle(prng, _toUints(a), k);\n    }",
            "startLine": 267
          },
          {
            "name": "shuffle",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              },
              {
                "name": "a",
                "type": "address[]"
              },
              {
                "name": "k",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "shuffle",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function shuffle(PRNG memory prng, address[] memory a, uint256 k) internal pure {\n        shuffle(prng, _toUints(a), k);\n    }",
            "startLine": 273
          },
          {
            "name": "shuffle",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              },
              {
                "name": "a",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function shuffle(PRNG memory prng, bytes memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a)\n            let w := not(0)\n            let mask := shr(128, w)\n            if n {\n                let b := add(a, 0x01)\n                for { a := add(a, 0x20) } 1 {} {\n                    // We can just directly use `keccak256`, cuz\n                    // the other approaches don't save much.\n                    let r := keccak256(prng, 0x20)\n                    mstore(prng, r)\n\n                    // Note that there will be a very tiny modulo bias\n                    // if the length of the array is not a power of 2.\n                    // For all practical purposes, it is negligible\n                    // and will not be a fairness or security concern.\n                    {\n                        let o := mod(shr(128, r), n)\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let t := mload(add(b, n))\n                        mstore8(add(a, n), mload(add(b, o)))\n                        mstore8(add(a, o), t)\n                    }\n\n                    {\n                        let o := mod(and(r, mask), n)\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let t := mload(add(b, n))\n                        mstore8(add(a, n), mload(add(b, o)))\n                        mstore8(add(a, o), t)\n                    }\n                }\n            }\n        }\n    }",
            "startLine": 278
          },
          {
            "name": "initialize",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "LazyShuffler"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initialize(LazyShuffler storage $, uint256 n) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(sub(n, 1), 0xfffffffe)) {\n                mstore(0x00, 0x83b53941) // `InvalidInitialLazyShufflerLength()`.\n                revert(0x1c, 0x04)\n            }\n            if sload($.slot) {\n                mstore(0x00, 0x0c9f11f2) // `LazyShufflerAlreadyInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, $.slot)\n            sstore($.slot, or(shl(224, n), shl(32, shr(64, keccak256(0x00, 0x20)))))\n        }\n    }",
            "startLine": 328
          },
          {
            "name": "grow",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "LazyShuffler"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function grow(LazyShuffler storage $, uint256 n) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot) // The packed value at `$`.\n            // If the new length is smaller than the old length, revert.\n            if lt(n, shr(224, state)) {\n                mstore(0x00, 0xbed37c6e) // `InvalidNewLazyShufflerLength()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(state) {\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            sstore($.slot, or(shl(224, n), shr(32, shl(32, state))))\n        }\n    }",
            "startLine": 346
          },
          {
            "name": "restart",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "LazyShuffler"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function restart(LazyShuffler storage $) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot)\n            if iszero(state) {\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            sstore($.slot, shl(32, shr(32, state)))\n        }\n    }",
            "startLine": 367
          },
          {
            "name": "numShuffled",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "LazyShuffler"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function numShuffled(LazyShuffler storage $) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(0xffffffff, sload($.slot))\n        }\n    }",
            "startLine": 380
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "LazyShuffler"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function length(LazyShuffler storage $) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(224, sload($.slot))\n        }\n    }",
            "startLine": 389
          },
          {
            "name": "initialized",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "LazyShuffler"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initialized(LazyShuffler storage $) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(iszero(sload($.slot)))\n        }\n    }",
            "startLine": 397
          },
          {
            "name": "finished",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "LazyShuffler"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function finished(LazyShuffler storage $) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot) // The packed value at `$`.\n            if iszero(state) {\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            result := eq(shr(224, state), and(0xffffffff, state))\n        }\n    }",
            "startLine": 406
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "LazyShuffler"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(LazyShuffler storage $, uint256 index) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot) // The packed value at `$`.\n            let n := shr(224, state) // Length of `$`.\n            if iszero(lt(index, n)) {\n                mstore(0x00, 0x61367cc4) // `LazyShufflerGetOutOfBounds()`.\n                revert(0x1c, 0x04)\n            }\n            let u32 := gt(n, 0xfffe)\n            let s := add(shr(sub(4, u32), index), shr(64, shl(32, state))) // Bucket slot.\n            let o := shl(add(4, u32), and(index, shr(u32, 15))) // Bucket slot offset (bits).\n            let m := sub(shl(shl(u32, 16), 1), 1) // Value mask.\n            result := and(m, shr(o, sload(s)))\n            result := xor(index, mul(xor(index, sub(result, 1)), iszero(iszero(result))))\n        }\n    }",
            "startLine": 420
          },
          {
            "name": "next",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "LazyShuffler"
              },
              {
                "name": "randomness",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "chosen",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function next(LazyShuffler storage $, uint256 randomness) internal returns (uint256 chosen) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function _get(u32_, state_, i_) -> _value {\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\n                _value := and(m_, shr(o_, sload(s_)))\n                _value := xor(i_, mul(xor(i_, sub(_value, 1)), iszero(iszero(_value))))\n            }\n            function _set(u32_, state_, i_, value_) {\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\n                let v_ := sload(s_) // Bucket slot value.\n                value_ := mul(iszero(eq(i_, value_)), add(value_, 1))\n                sstore(s_, xor(v_, shl(o_, and(m_, xor(shr(o_, v_), value_)))))\n            }\n            let state := sload($.slot) // The packed value at `$`.\n            let shuffled := and(0xffffffff, state) // Number of elements shuffled.\n            let n := shr(224, state) // Length of `$`.\n            let remainder := sub(n, shuffled) // Number of elements left to shuffle.\n            if iszero(remainder) {\n                mstore(0x00, 0x51065f79) // `LazyShuffleFinished()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, randomness) // (Re)hash the randomness so that we don't\n            mstore(0x20, shuffled) // need to expect guarantees on its distribution.\n            let index := add(mod(keccak256(0x00, 0x40), remainder), shuffled)\n            chosen := _get(gt(n, 0xfffe), state, index)\n            _set(gt(n, 0xfffe), state, index, _get(gt(n, 0xfffe), state, shuffled))\n            _set(gt(n, 0xfffe), state, shuffled, chosen)\n            sstore($.slot, add(1, state)) // Increment the `numShuffled` by 1, and store it.\n        }\n    }",
            "startLine": 442
          },
          {
            "name": "_toUints",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "int256[]"
              }
            ],
            "returnValues": [
              {
                "name": "casted",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toUints(int256[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }",
            "startLine": 483
          },
          {
            "name": "_toUints",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              }
            ],
            "returnValues": [
              {
                "name": "casted",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toUints(address[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // As any address written to memory will have the upper 96 bits\n            // of the word zeroized (as per Solidity spec), we can directly\n            // compare these addresses as if they are whole uint256 words.\n            casted := a\n        }\n    }",
            "startLine": 491
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "InvalidInitialLazyShufflerLength",
            "parameters": [],
            "startLine": 14
          },
          {
            "name": "InvalidNewLazyShufflerLength",
            "parameters": [],
            "startLine": 17
          },
          {
            "name": "LazyShufflerNotInitialized",
            "parameters": [],
            "startLine": 20
          },
          {
            "name": "LazyShufflerAlreadyInitialized",
            "parameters": [],
            "startLine": 23
          },
          {
            "name": "LazyShuffleFinished",
            "parameters": [],
            "startLine": 26
          },
          {
            "name": "LazyShufflerGetOutOfBounds",
            "parameters": [],
            "startLine": 29
          }
        ],
        "structs": [
          {
            "name": "PRNG",
            "members": [
              {
                "name": "state",
                "type": "uint256"
              }
            ],
            "startLine": 43
          },
          {
            "name": "LazyShuffler",
            "members": [
              {
                "name": "_state",
                "type": "uint256"
              }
            ],
            "startLine": 48
          }
        ],
        "stateVariables": [
          {
            "name": "WAD",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 36
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibRLP",
        "filePath": "utils/LibRLP.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "computeAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "deployer",
                "type": "address"
              },
              {
                "name": "nonce",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "deployed",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function computeAddress(address deployer, uint256 nonce)\n        internal\n        pure\n        returns (address deployed)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                // The integer zero is treated as an empty byte string,\n                // and as a result it only has a length prefix, 0x80,\n                // computed via `0x80 + 0`.\n\n                // A one-byte integer in the [0x00, 0x7f] range uses its\n                // own value as a length prefix,\n                // there is no additional `0x80 + length` prefix that precedes it.\n                if iszero(gt(nonce, 0x7f)) {\n                    mstore(0x00, deployer)\n                    // Using `mstore8` instead of `or` naturally cleans\n                    // any dirty upper bits of `deployer`.\n                    mstore8(0x0b, 0x94)\n                    mstore8(0x0a, 0xd6)\n                    // `shl` 7 is equivalent to multiplying by 0x80.\n                    mstore8(0x20, or(shl(7, iszero(nonce)), nonce))\n                    deployed := keccak256(0x0a, 0x17)\n                    break\n                }\n                let i := 8\n                // Just use a loop to generalize all the way with minimal bytecode size.\n                for {} shr(i, nonce) { i := add(i, 8) } {}\n                // `shr` 3 is equivalent to dividing by 8.\n                i := shr(3, i)\n                // Store in descending slot sequence to overlap the values correctly.\n                mstore(i, nonce)\n                mstore(0x00, shl(8, deployer))\n                mstore8(0x1f, add(0x80, i))\n                mstore8(0x0a, 0x94)\n                mstore8(0x09, add(0xd6, i))\n                deployed := keccak256(0x09, add(0x17, i))\n                break\n            }\n        }\n    }",
            "startLine": 46
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function p() internal pure returns (List memory result) {}",
            "startLine": 101
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(uint256 x) internal pure returns (List memory result) {\n        p(result, x);\n    }",
            "startLine": 104
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(address x) internal pure returns (List memory result) {\n        p(result, x);\n    }",
            "startLine": 109
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(bool x) internal pure returns (List memory result) {\n        p(result, x);\n    }",
            "startLine": 114
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(bytes memory x) internal pure returns (List memory result) {\n        p(result, x);\n    }",
            "startLine": 119
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "List"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(List memory x) internal pure returns (List memory result) {\n        p(result, x);\n    }",
            "startLine": 124
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "list",
                "type": "List"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "_updateTail",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(List memory list, uint256 x) internal pure returns (List memory result) {\n        result._data = x << 48;\n        _updateTail(list, result);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If `x` is too big, we cannot pack it inline with the node.\n            // We'll have to allocate a new slot for `x` and store the pointer to it in the node.\n            if shr(208, x) {\n                let m := mload(0x40)\n                mstore(m, x)\n                mstore(0x40, add(m, 0x20))\n                mstore(result, shl(40, or(1, shl(8, m))))\n            }\n        }\n        result = list;\n    }",
            "startLine": 129
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "list",
                "type": "List"
              },
              {
                "name": "x",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "_updateTail",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(List memory list, address x) internal pure returns (List memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, shl(40, or(4, shl(8, x))))\n        }\n        _updateTail(list, result);\n        result = list;\n    }",
            "startLine": 147
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "list",
                "type": "List"
              },
              {
                "name": "x",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "_updateTail",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(List memory list, bool x) internal pure returns (List memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, shl(48, iszero(iszero(x))))\n        }\n        _updateTail(list, result);\n        result = list;\n    }",
            "startLine": 157
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "list",
                "type": "List"
              },
              {
                "name": "x",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "_updateTail",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(List memory list, bytes memory x) internal pure returns (List memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, shl(40, or(2, shl(8, x))))\n        }\n        _updateTail(list, result);\n        result = list;\n    }",
            "startLine": 167
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "list",
                "type": "List"
              },
              {
                "name": "x",
                "type": "List"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "_updateTail",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(List memory list, List memory x) internal pure returns (List memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, shl(40, or(3, shl(8, x))))\n        }\n        _updateTail(list, result);\n        result = list;\n    }",
            "startLine": 177
          },
          {
            "name": "encode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "list",
                "type": "List"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function encode(List memory list) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function encodeUint(x_, o_) -> _o {\n                _o := add(o_, 1)\n                if iszero(gt(x_, 0x7f)) {\n                    mstore8(o_, or(shl(7, iszero(x_)), x_)) // Copy `x_`.\n                    leave\n                }\n                let r_ := shl(7, lt(0xffffffffffffffffffffffffffffffff, x_))\n                r_ := or(r_, shl(6, lt(0xffffffffffffffff, shr(r_, x_))))\n                r_ := or(r_, shl(5, lt(0xffffffff, shr(r_, x_))))\n                r_ := or(r_, shl(4, lt(0xffff, shr(r_, x_))))\n                r_ := or(shr(3, r_), lt(0xff, shr(r_, x_)))\n                mstore8(o_, add(r_, 0x81)) // Store the prefix.\n                mstore(0x00, x_)\n                mstore(_o, mload(xor(31, r_))) // Copy `x_`.\n                _o := add(add(1, r_), _o)\n            }\n            function encodeAddress(x_, o_) -> _o {\n                _o := add(o_, 0x15)\n                mstore(o_, shl(88, x_))\n                mstore8(o_, 0x94)\n            }\n            function encodeBytes(x_, o_, c_) -> _o {\n                _o := add(o_, 1)\n                let n_ := mload(x_)\n                if iszero(gt(n_, 55)) {\n                    let f_ := mload(add(0x20, x_))\n                    if iszero(and(eq(1, n_), lt(byte(0, f_), 0x80))) {\n                        mstore8(o_, add(n_, c_)) // Store the prefix.\n                        mstore(add(0x21, o_), mload(add(0x40, x_)))\n                        mstore(_o, f_)\n                        _o := add(n_, _o)\n                        leave\n                    }\n                    mstore(o_, f_) // Copy `x_`.\n                    leave\n                }\n                returndatacopy(returndatasize(), returndatasize(), shr(32, n_))\n                let r_ := add(1, add(lt(0xff, n_), add(lt(0xffff, n_), lt(0xffffff, n_))))\n                mstore(o_, shl(248, add(r_, add(c_, 55)))) // Store the prefix.\n                // Copy `x`.\n                let i_ := add(r_, _o)\n                _o := add(i_, n_)\n                for { let d_ := sub(add(0x20, x_), i_) } 1 {} {\n                    mstore(i_, mload(add(d_, i_)))\n                    i_ := add(i_, 0x20)\n                    if iszero(lt(i_, _o)) { break }\n                }\n                mstore(o_, or(mload(o_), shl(sub(248, shl(3, r_)), n_))) // Store the prefix.\n            }\n            function encodeList(l_, o_) -> _o {\n                if iszero(mload(l_)) {\n                    mstore8(o_, 0xc0)\n                    _o := add(o_, 1)\n                    leave\n                }\n                let j_ := add(o_, 0x20)\n                for { let h_ := l_ } 1 {} {\n                    h_ := and(mload(h_), 0xffffffffff)\n                    if iszero(h_) { break }\n                    let t_ := byte(26, mload(h_))\n                    if iszero(gt(t_, 1)) {\n                        if iszero(t_) {\n                            j_ := encodeUint(shr(48, mload(h_)), j_)\n                            continue\n                        }\n                        j_ := encodeUint(mload(shr(48, mload(h_))), j_)\n                        continue\n                    }\n                    if eq(t_, 2) {\n                        j_ := encodeBytes(shr(48, mload(h_)), j_, 0x80)\n                        continue\n                    }\n                    if eq(t_, 3) {\n                        j_ := encodeList(shr(48, mload(h_)), j_)\n                        continue\n                    }\n                    j_ := encodeAddress(shr(48, mload(h_)), j_)\n                }\n                let n_ := sub(j_, add(o_, 0x20))\n                if iszero(gt(n_, 55)) {\n                    mstore8(o_, add(n_, 0xc0)) // Store the prefix.\n                    mstore(add(0x01, o_), mload(add(0x20, o_)))\n                    mstore(add(0x21, o_), mload(add(0x40, o_)))\n                    _o := add(n_, add(0x01, o_))\n                    leave\n                }\n                mstore(o_, n_)\n                _o := encodeBytes(o_, o_, 0xc0)\n            }\n            result := mload(0x40)\n            let begin := add(result, 0x20)\n            let end := encodeList(list, begin)\n            mstore(result, sub(end, begin)) // Store the length of `result`.\n            mstore(end, 0) // Zeroize the slot after `result`.\n            mstore(0x40, add(end, 0x20)) // Allocate memory for `result`.\n        }\n    }",
            "startLine": 187
          },
          {
            "name": "encode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function encode(uint256 x) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := mload(0x40)\n                if iszero(gt(x, 0x7f)) {\n                    mstore(result, 1) // Store the length of `result`.\n                    mstore(add(result, 0x20), shl(248, or(shl(7, iszero(x)), x))) // Copy `x`.\n                    mstore(0x40, add(result, 0x40)) // Allocate memory for `result`.\n                    break\n                }\n                let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n                r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n                r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n                r := or(r, shl(4, lt(0xffff, shr(r, x))))\n                r := add(2, or(shr(3, r), lt(0xff, shr(r, x))))\n                mstore(add(r, result), x) // Copy `x`.\n                mstore(add(result, 1), add(r, 0x7f)) // Store the prefix.\n                mstore(result, r) // Store the length of `result`.\n                mstore(add(r, add(result, 0x20)), 0) // Zeroize the slot after `result`.\n                mstore(0x40, add(result, 0x60)) // Allocate memory for `result`.\n                break\n            }\n        }\n    }",
            "startLine": 289
          },
          {
            "name": "encode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function encode(address x) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(result, 0x15)\n            let o := add(0x20, result)\n            mstore(o, shl(88, x))\n            mstore8(o, 0x94)\n            mstore(0x40, add(0x20, o))\n        }\n    }",
            "startLine": 316
          },
          {
            "name": "encode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function encode(bool x) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(result, 1)\n            mstore(add(0x20, result), shl(add(0xf8, mul(7, iszero(x))), 0x01))\n            mstore(0x40, add(0x40, result))\n        }\n    }",
            "startLine": 329
          },
          {
            "name": "encode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function encode(bytes memory x) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := x\n\n            for {} iszero(and(eq(1, mload(x)), lt(byte(0, mload(add(x, 0x20))), 0x80))) {} {\n                result := mload(0x40)\n                let n := mload(x) // Length of `x`.\n                if iszero(gt(n, 55)) {\n                    mstore(0x40, add(result, 0x60))\n                    mstore(add(0x41, result), mload(add(0x40, x)))\n                    mstore(add(0x21, result), mload(add(0x20, x)))\n                    mstore(add(1, result), add(n, 0x80)) // Store the prefix.\n                    mstore(result, add(1, n)) // Store the length of `result`.\n                    mstore(add(add(result, 0x21), n), 0) // Zeroize the slot after `result`.\n                    break\n                }\n                returndatacopy(returndatasize(), returndatasize(), shr(32, n))\n                let r := add(2, add(lt(0xff, n), add(lt(0xffff, n), lt(0xffffff, n))))\n                // Copy `x`.\n                let i := add(r, add(0x20, result))\n                let end := add(i, n)\n                for { let d := sub(add(0x20, x), i) } 1 {} {\n                    mstore(i, mload(add(d, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, end)) { break }\n                }\n                mstore(add(r, result), n) // Store the prefix.\n                mstore(add(1, result), add(r, 0xb6)) // Store the prefix.\n                mstore(result, add(r, n)) // Store the length of `result`.\n                mstore(end, 0) // Zeroize the slot after `result`.\n                mstore(0x40, add(end, 0x20)) // Allocate memory.\n                break\n            }\n        }\n    }",
            "startLine": 340
          },
          {
            "name": "_updateTail",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "list",
                "type": "List"
              },
              {
                "name": "result",
                "type": "List"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _updateTail(List memory list, List memory result) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let v := or(shr(mload(list), result), mload(list))\n            let tail := shr(40, v)\n            mstore(list, xor(shl(40, xor(tail, result)), v)) // Update the tail.\n            mstore(tail, or(mload(tail), result)) // Make the previous tail point to `result`.\n        }\n    }",
            "startLine": 382
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "List",
            "members": [
              {
                "name": "_data",
                "type": "uint256"
              }
            ],
            "startLine": 13
          }
        ],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibSort",
        "filePath": "utils/LibSort.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "insertionSort",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function insertionSort(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a) // Length of `a`.\n            mstore(a, 0) // For insertion sort's inner loop to terminate.\n            let h := add(a, shl(5, n)) // High slot.\n            let w := not(0x1f)\n            for { let i := add(a, 0x20) } 1 {} {\n                i := add(i, 0x20)\n                if gt(i, h) { break }\n                let k := mload(i) // Key.\n                let j := add(i, w) // The slot before the current slot.\n                let v := mload(j) // The value of `j`.\n                if iszero(gt(v, k)) { continue }\n                for {} 1 {} {\n                    mstore(add(j, 0x20), v)\n                    j := add(j, w) // `sub(j, 0x20)`.\n                    v := mload(j)\n                    if iszero(gt(v, k)) { break }\n                }\n                mstore(add(j, 0x20), k)\n            }\n            mstore(a, n) // Restore the length of `a`.\n        }\n    }",
            "startLine": 17
          },
          {
            "name": "insertionSort",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "int256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_flipSign",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "insertionSort",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function insertionSort(int256[] memory a) internal pure {\n        _flipSign(a);\n        insertionSort(_toUints(a));\n        _flipSign(a);\n    }",
            "startLine": 44
          },
          {
            "name": "insertionSort",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "insertionSort",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function insertionSort(address[] memory a) internal pure {\n        insertionSort(_toUints(a));\n    }",
            "startLine": 51
          },
          {
            "name": "insertionSort",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "insertionSort",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function insertionSort(bytes32[] memory a) internal pure {\n        insertionSort(_toUints(a));\n    }",
            "startLine": 56
          },
          {
            "name": "sort",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function sort(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function swap(a_, b_) -> _a, _b {\n                _b := a_\n                _a := b_\n            }\n            function mswap(i_, j_) {\n                let t_ := mload(i_)\n                mstore(i_, mload(j_))\n                mstore(j_, t_)\n            }\n            function sortInner(w_, l_, h_) {\n                // Do insertion sort if `h_ - l_ <= 0x20 * 12`.\n                // Threshold is fine-tuned via trial and error.\n                if iszero(gt(sub(h_, l_), 0x180)) {\n                    // Hardcode sort the first 2 elements.\n                    let i_ := add(l_, 0x20)\n                    if iszero(lt(mload(l_), mload(i_))) { mswap(i_, l_) }\n                    for {} 1 {} {\n                        i_ := add(i_, 0x20)\n                        if gt(i_, h_) { break }\n                        let k_ := mload(i_) // Key.\n                        let j_ := add(i_, w_) // The slot before the current slot.\n                        let v_ := mload(j_) // The value of `j_`.\n                        if iszero(gt(v_, k_)) { continue }\n                        for {} 1 {} {\n                            mstore(add(j_, 0x20), v_)\n                            j_ := add(j_, w_)\n                            v_ := mload(j_)\n                            if iszero(gt(v_, k_)) { break }\n                        }\n                        mstore(add(j_, 0x20), k_)\n                    }\n                    leave\n                }\n                // Pivot slot is the average of `l_` and `h_`.\n                let p_ := add(shl(5, shr(6, add(l_, h_))), and(31, l_))\n                // Median of 3 with sorting.\n                {\n                    let e0_ := mload(l_)\n                    let e1_ := mload(p_)\n                    if iszero(lt(e0_, e1_)) { e0_, e1_ := swap(e0_, e1_) }\n                    let e2_ := mload(h_)\n                    if iszero(lt(e1_, e2_)) {\n                        e1_, e2_ := swap(e1_, e2_)\n                        if iszero(lt(e0_, e1_)) { e0_, e1_ := swap(e0_, e1_) }\n                    }\n                    mstore(h_, e2_)\n                    mstore(p_, e1_)\n                    mstore(l_, e0_)\n                }\n                // Hoare's partition.\n                {\n                    // The value of the pivot slot.\n                    let x_ := mload(p_)\n                    p_ := h_\n                    for { let i_ := l_ } 1 {} {\n                        for {} 1 {} {\n                            i_ := add(0x20, i_)\n                            if iszero(gt(x_, mload(i_))) { break }\n                        }\n                        let j_ := p_\n                        for {} 1 {} {\n                            j_ := add(w_, j_)\n                            if iszero(lt(x_, mload(j_))) { break }\n                        }\n                        p_ := j_\n                        if iszero(lt(i_, p_)) { break }\n                        mswap(i_, p_)\n                    }\n                }\n                if iszero(eq(add(p_, 0x20), h_)) { sortInner(w_, add(p_, 0x20), h_) }\n                if iszero(eq(p_, l_)) { sortInner(w_, l_, p_) }\n            }\n\n            for { let n := mload(a) } iszero(lt(n, 2)) {} {\n                let w := not(0x1f) // `-0x20`.\n                let l := add(a, 0x20) // Low slot.\n                let h := add(a, shl(5, n)) // High slot.\n                let j := h\n                // While `mload(j - 0x20) <= mload(j): j -= 0x20`.\n                for {} iszero(gt(mload(add(w, j)), mload(j))) {} { j := add(w, j) }\n                // If the array is already sorted, break.\n                if iszero(gt(j, l)) { break }\n                // While `mload(j - 0x20) >= mload(j): j -= 0x20`.\n                for { j := h } iszero(lt(mload(add(w, j)), mload(j))) {} { j := add(w, j) }\n                // If the array is reversed sorted.\n                if iszero(gt(j, l)) {\n                    for {} 1 {} {\n                        let t := mload(l)\n                        mstore(l, mload(h))\n                        mstore(h, t)\n                        h := add(w, h)\n                        l := add(l, 0x20)\n                        if iszero(lt(l, h)) { break }\n                    }\n                    break\n                }\n                mstore(a, 0) // For insertion sort's inner loop to terminate.\n                sortInner(w, l, h)\n                mstore(a, n) // Restore the length of `a`.\n                break\n            }\n        }\n    }",
            "startLine": 69
          },
          {
            "name": "sort",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "int256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_flipSign",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "sort",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function sort(int256[] memory a) internal pure {\n        _flipSign(a);\n        sort(_toUints(a));\n        _flipSign(a);\n    }",
            "startLine": 177
          },
          {
            "name": "sort",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "sort",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function sort(address[] memory a) internal pure {\n        sort(_toUints(a));\n    }",
            "startLine": 184
          },
          {
            "name": "sort",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "sort",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function sort(bytes32[] memory a) internal pure {\n        sort(_toUints(a));\n    }",
            "startLine": 189
          },
          {
            "name": "uniquifySorted",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function uniquifySorted(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the length of `a` is greater than 1.\n            if iszero(lt(mload(a), 2)) {\n                let x := add(a, 0x20)\n                let y := add(a, 0x40)\n                let end := add(a, shl(5, add(mload(a), 1)))\n                for {} 1 {} {\n                    if iszero(eq(mload(x), mload(y))) {\n                        x := add(x, 0x20)\n                        mstore(x, mload(y))\n                    }\n                    y := add(y, 0x20)\n                    if eq(y, end) { break }\n                }\n                mstore(a, shr(5, sub(x, a)))\n            }\n        }\n    }",
            "startLine": 201
          },
          {
            "name": "uniquifySorted",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "int256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "uniquifySorted",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function uniquifySorted(int256[] memory a) internal pure {\n        uniquifySorted(_toUints(a));\n    }",
            "startLine": 223
          },
          {
            "name": "uniquifySorted",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "uniquifySorted",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function uniquifySorted(address[] memory a) internal pure {\n        uniquifySorted(_toUints(a));\n    }",
            "startLine": 228
          },
          {
            "name": "uniquifySorted",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "uniquifySorted",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function uniquifySorted(bytes32[] memory a) internal pure {\n        uniquifySorted(_toUints(a));\n    }",
            "startLine": 233
          },
          {
            "name": "searchSorted",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "needle",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function searchSorted(uint256[] memory a, uint256 needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(a, needle, 0);\n    }",
            "startLine": 239
          },
          {
            "name": "searchSorted",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "int256[]"
              },
              {
                "name": "needle",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function searchSorted(int256[] memory a, int256 needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(_toUints(a), uint256(needle), 1 << 255);\n    }",
            "startLine": 249
          },
          {
            "name": "searchSorted",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              },
              {
                "name": "needle",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function searchSorted(address[] memory a, address needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(_toUints(a), uint160(needle), 0);\n    }",
            "startLine": 259
          },
          {
            "name": "searchSorted",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              },
              {
                "name": "needle",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function searchSorted(bytes32[] memory a, bytes32 needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(_toUints(a), uint256(needle), 0);\n    }",
            "startLine": 269
          },
          {
            "name": "inSorted",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "needle",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "searchSorted",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function inSorted(uint256[] memory a, uint256 needle) internal pure returns (bool found) {\n        (found,) = searchSorted(a, needle);\n    }",
            "startLine": 278
          },
          {
            "name": "inSorted",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "int256[]"
              },
              {
                "name": "needle",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "searchSorted",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function inSorted(int256[] memory a, int256 needle) internal pure returns (bool found) {\n        (found,) = searchSorted(a, needle);\n    }",
            "startLine": 283
          },
          {
            "name": "inSorted",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              },
              {
                "name": "needle",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "searchSorted",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function inSorted(address[] memory a, address needle) internal pure returns (bool found) {\n        (found,) = searchSorted(a, needle);\n    }",
            "startLine": 288
          },
          {
            "name": "inSorted",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              },
              {
                "name": "needle",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "searchSorted",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function inSorted(bytes32[] memory a, bytes32 needle) internal pure returns (bool found) {\n        (found,) = searchSorted(a, needle);\n    }",
            "startLine": 293
          },
          {
            "name": "reverse",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function reverse(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(mload(a), 2)) {\n                let s := 0x20\n                let w := not(0x1f)\n                let h := add(a, shl(5, mload(a)))\n                for { a := add(a, s) } 1 {} {\n                    let t := mload(a)\n                    mstore(a, mload(h))\n                    mstore(h, t)\n                    h := add(h, w)\n                    a := add(a, s)\n                    if iszero(lt(a, h)) { break }\n                }\n            }\n        }\n    }",
            "startLine": 298
          },
          {
            "name": "reverse",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "int256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "reverse",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function reverse(int256[] memory a) internal pure {\n        reverse(_toUints(a));\n    }",
            "startLine": 318
          },
          {
            "name": "reverse",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "reverse",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function reverse(address[] memory a) internal pure {\n        reverse(_toUints(a));\n    }",
            "startLine": 323
          },
          {
            "name": "reverse",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "reverse",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function reverse(bytes32[] memory a) internal pure {\n        reverse(_toUints(a));\n    }",
            "startLine": 328
          },
          {
            "name": "copy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function copy(uint256[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let end := add(add(result, 0x20), shl(5, mload(a)))\n            let o := result\n            for { let d := sub(a, result) } 1 {} {\n                mstore(o, mload(add(o, d)))\n                o := add(0x20, o)\n                if eq(o, end) { break }\n            }\n            mstore(0x40, o)\n        }\n    }",
            "startLine": 333
          },
          {
            "name": "copy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "int256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "int256[]"
              }
            ],
            "calls": [
              {
                "target": "_toInts",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "copy",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function copy(int256[] memory a) internal pure returns (int256[] memory result) {\n        result = _toInts(copy(_toUints(a)));\n    }",
            "startLine": 349
          },
          {
            "name": "copy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address[]"
              }
            ],
            "calls": [
              {
                "target": "_toAddresses",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "copy",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function copy(address[] memory a) internal pure returns (address[] memory result) {\n        result = _toAddresses(copy(_toUints(a)));\n    }",
            "startLine": 354
          },
          {
            "name": "copy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32[]"
              }
            ],
            "calls": [
              {
                "target": "_toBytes32s",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "copy",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function copy(bytes32[] memory a) internal pure returns (bytes32[] memory result) {\n        result = _toBytes32s(copy(_toUints(a)));\n    }",
            "startLine": 359
          },
          {
            "name": "isSorted",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isSorted(uint256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := iszero(gt(p, mload(a)))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }",
            "startLine": 364
          },
          {
            "name": "isSorted",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "int256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isSorted(int256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := iszero(sgt(p, mload(a)))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }",
            "startLine": 381
          },
          {
            "name": "isSorted",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "isSorted",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function isSorted(address[] memory a) internal pure returns (bool result) {\n        result = isSorted(_toUints(a));\n    }",
            "startLine": 398
          },
          {
            "name": "isSorted",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "isSorted",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function isSorted(bytes32[] memory a) internal pure returns (bool result) {\n        result = isSorted(_toUints(a));\n    }",
            "startLine": 403
          },
          {
            "name": "isSortedAndUniquified",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isSortedAndUniquified(uint256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := lt(p, mload(a))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }",
            "startLine": 408
          },
          {
            "name": "isSortedAndUniquified",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "int256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isSortedAndUniquified(int256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := slt(p, mload(a))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }",
            "startLine": 425
          },
          {
            "name": "isSortedAndUniquified",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "isSortedAndUniquified",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function isSortedAndUniquified(address[] memory a) internal pure returns (bool result) {\n        result = isSortedAndUniquified(_toUints(a));\n    }",
            "startLine": 442
          },
          {
            "name": "isSortedAndUniquified",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "isSortedAndUniquified",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function isSortedAndUniquified(bytes32[] memory a) internal pure returns (bool result) {\n        result = isSortedAndUniquified(_toUints(a));\n    }",
            "startLine": 447
          },
          {
            "name": "difference",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "b",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "_difference",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function difference(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _difference(a, b, 0);\n    }",
            "startLine": 453
          },
          {
            "name": "difference",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "int256[]"
              },
              {
                "name": "b",
                "type": "int256[]"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "int256[]"
              }
            ],
            "calls": [
              {
                "target": "_toInts",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_difference",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function difference(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_difference(_toUints(a), _toUints(b), 1 << 255));\n    }",
            "startLine": 463
          },
          {
            "name": "difference",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              },
              {
                "name": "b",
                "type": "address[]"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "address[]"
              }
            ],
            "calls": [
              {
                "target": "_toAddresses",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_difference",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function difference(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_difference(_toUints(a), _toUints(b), 0));\n    }",
            "startLine": 473
          },
          {
            "name": "difference",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              },
              {
                "name": "b",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "bytes32[]"
              }
            ],
            "calls": [
              {
                "target": "_toBytes32s",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_difference",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function difference(bytes32[] memory a, bytes32[] memory b)\n        internal\n        pure\n        returns (bytes32[] memory c)\n    {\n        c = _toBytes32s(_difference(_toUints(a), _toUints(b), 0));\n    }",
            "startLine": 483
          },
          {
            "name": "intersection",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "b",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "_intersection",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function intersection(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _intersection(a, b, 0);\n    }",
            "startLine": 493
          },
          {
            "name": "intersection",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "int256[]"
              },
              {
                "name": "b",
                "type": "int256[]"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "int256[]"
              }
            ],
            "calls": [
              {
                "target": "_toInts",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_intersection",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function intersection(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_intersection(_toUints(a), _toUints(b), 1 << 255));\n    }",
            "startLine": 503
          },
          {
            "name": "intersection",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              },
              {
                "name": "b",
                "type": "address[]"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "address[]"
              }
            ],
            "calls": [
              {
                "target": "_toAddresses",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_intersection",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function intersection(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_intersection(_toUints(a), _toUints(b), 0));\n    }",
            "startLine": 513
          },
          {
            "name": "intersection",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              },
              {
                "name": "b",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "bytes32[]"
              }
            ],
            "calls": [
              {
                "target": "_toBytes32s",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_intersection",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function intersection(bytes32[] memory a, bytes32[] memory b)\n        internal\n        pure\n        returns (bytes32[] memory c)\n    {\n        c = _toBytes32s(_intersection(_toUints(a), _toUints(b), 0));\n    }",
            "startLine": 523
          },
          {
            "name": "union",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "b",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "_union",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function union(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _union(a, b, 0);\n    }",
            "startLine": 533
          },
          {
            "name": "union",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "int256[]"
              },
              {
                "name": "b",
                "type": "int256[]"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "int256[]"
              }
            ],
            "calls": [
              {
                "target": "_toInts",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_union",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function union(int256[] memory a, int256[] memory b) internal pure returns (int256[] memory c) {\n        c = _toInts(_union(_toUints(a), _toUints(b), 1 << 255));\n    }",
            "startLine": 543
          },
          {
            "name": "union",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              },
              {
                "name": "b",
                "type": "address[]"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "address[]"
              }
            ],
            "calls": [
              {
                "target": "_toAddresses",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_union",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function union(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_union(_toUints(a), _toUints(b), 0));\n    }",
            "startLine": 549
          },
          {
            "name": "union",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              },
              {
                "name": "b",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "bytes32[]"
              }
            ],
            "calls": [
              {
                "target": "_toBytes32s",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_union",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function union(bytes32[] memory a, bytes32[] memory b)\n        internal\n        pure\n        returns (bytes32[] memory c)\n    {\n        c = _toBytes32s(_union(_toUints(a), _toUints(b), 0));\n    }",
            "startLine": 559
          },
          {
            "name": "clean",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clean(address[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let addressMask := shr(96, not(0))\n            for { let end := add(a, shl(5, mload(a))) } iszero(eq(a, end)) {} {\n                a := add(a, 0x20)\n                mstore(a, and(mload(a), addressMask))\n            }\n        }\n    }",
            "startLine": 569
          },
          {
            "name": "groupSum",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "keys",
                "type": "uint256[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function groupSum(uint256[] memory keys, uint256[] memory values) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function mswap(i_, j_) {\n                let t_ := mload(i_)\n                mstore(i_, mload(j_))\n                mstore(j_, t_)\n            }\n            function sortInner(l_, h_, d_) {\n                let p_ := mload(l_)\n                let j_ := l_\n                for { let i_ := add(l_, 0x20) } 1 {} {\n                    if lt(mload(i_), p_) {\n                        j_ := add(j_, 0x20)\n                        mswap(i_, j_)\n                        mswap(add(i_, d_), add(j_, d_))\n                    }\n                    i_ := add(0x20, i_)\n                    if iszero(lt(i_, h_)) { break }\n                }\n                mswap(l_, j_)\n                mswap(add(l_, d_), add(j_, d_))\n                if iszero(gt(add(0x40, l_), j_)) { sortInner(l_, j_, d_) }\n                if iszero(gt(add(0x60, j_), h_)) { sortInner(add(j_, 0x20), h_, d_) }\n            }\n            let n := mload(values)\n            if iszero(eq(mload(keys), n)) {\n                mstore(0x00, 0x4e487b71)\n                mstore(0x20, 0x32) // Array out of bounds panic if the arrays lengths differ.\n                revert(0x1c, 0x24)\n            }\n            if iszero(lt(n, 2)) {\n                let d := sub(values, keys)\n                let x := add(keys, 0x20)\n                let end := add(x, shl(5, n))\n                sortInner(x, end, d)\n                let s := mload(add(x, d))\n                for { let y := add(keys, 0x40) } 1 {} {\n                    if iszero(eq(mload(x), mload(y))) {\n                        mstore(add(x, d), s) // Write sum.\n                        s := 0\n                        x := add(x, 0x20)\n                        mstore(x, mload(y))\n                    }\n                    s := add(s, mload(add(y, d)))\n                    if lt(s, mload(add(y, d))) {\n                        mstore(0x00, 0x4e487b71)\n                        mstore(0x20, 0x11) // Overflow panic if the addition overflows.\n                        revert(0x1c, 0x24)\n                    }\n                    y := add(y, 0x20)\n                    if eq(y, end) { break }\n                }\n                mstore(add(x, d), s) // Write sum.\n                mstore(keys, shr(5, sub(x, keys))) // Truncate.\n                mstore(values, mload(keys)) // Truncate.\n            }\n        }\n    }",
            "startLine": 581
          },
          {
            "name": "groupSum",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "keys",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "groupSum",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function groupSum(address[] memory keys, uint256[] memory values) internal pure {\n        groupSum(_toUints(keys), values);\n    }",
            "startLine": 642
          },
          {
            "name": "groupSum",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "keys",
                "type": "bytes32[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "groupSum",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function groupSum(bytes32[] memory keys, uint256[] memory values) internal pure {\n        groupSum(_toUints(keys), values);\n    }",
            "startLine": 647
          },
          {
            "name": "groupSum",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "keys",
                "type": "int256[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "groupSum",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function groupSum(int256[] memory keys, uint256[] memory values) internal pure {\n        groupSum(_toUints(keys), values);\n    }",
            "startLine": 652
          },
          {
            "name": "hasDuplicate",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hasDuplicate(uint256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function p(i_, x_) -> _y {\n                _y := or(shr(i_, x_), x_)\n            }\n            let n := mload(a)\n            if iszero(lt(n, 2)) {\n                let m := mload(0x40) // Use free memory temporarily for hashmap.\n                let w := not(0x1f) // `-0x20`.\n                let c := and(w, p(16, p(8, p(4, p(2, p(1, mul(0x30, n)))))))\n                calldatacopy(m, calldatasize(), add(0x20, c)) // Zeroize hashmap.\n                for { let i := add(a, shl(5, n)) } 1 {} {\n                    // See LibPRNG for explanation of this formula.\n                    let r := mulmod(mload(i), 0x100000000000000000000000000000051, not(0xbc))\n                    // Linear probing.\n                    for {} 1 { r := add(0x20, r) } {\n                        let o := add(m, and(r, c)) // Non-zero pointer into hashmap.\n                        if iszero(mload(o)) {\n                            mstore(o, i) // Store non-zero pointer into hashmap.\n                            break\n                        }\n                        if eq(mload(mload(o)), mload(i)) {\n                            result := 1\n                            i := a // To break the outer loop.\n                            break\n                        }\n                    }\n                    i := add(i, w) // Iterate `a` backwards.\n                    if iszero(lt(a, i)) { break }\n                }\n                if shr(31, n) { invalid() } // Just in case.\n            }\n        }\n    }",
            "startLine": 657
          },
          {
            "name": "hasDuplicate",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "hasDuplicate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function hasDuplicate(address[] memory a) internal pure returns (bool) {\n        return hasDuplicate(_toUints(a));\n    }",
            "startLine": 694
          },
          {
            "name": "hasDuplicate",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "hasDuplicate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function hasDuplicate(bytes32[] memory a) internal pure returns (bool) {\n        return hasDuplicate(_toUints(a));\n    }",
            "startLine": 699
          },
          {
            "name": "hasDuplicate",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "int256[]"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "hasDuplicate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function hasDuplicate(int256[] memory a) internal pure returns (bool) {\n        return hasDuplicate(_toUints(a));\n    }",
            "startLine": 704
          },
          {
            "name": "_toUints",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "int256[]"
              }
            ],
            "returnValues": [
              {
                "name": "casted",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toUints(int256[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }",
            "startLine": 713
          },
          {
            "name": "_toUints",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              }
            ],
            "returnValues": [
              {
                "name": "casted",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toUints(address[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // As any address written to memory will have the upper 96 bits\n            // of the word zeroized (as per Solidity spec), we can directly\n            // compare these addresses as if they are whole uint256 words.\n            casted := a\n        }\n    }",
            "startLine": 721
          },
          {
            "name": "_toUints",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "casted",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toUints(bytes32[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }",
            "startLine": 732
          },
          {
            "name": "_toInts",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "casted",
                "type": "int256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toInts(uint256[] memory a) private pure returns (int256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }",
            "startLine": 740
          },
          {
            "name": "_toAddresses",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "casted",
                "type": "address[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toAddresses(uint256[] memory a) private pure returns (address[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }",
            "startLine": 748
          },
          {
            "name": "_toBytes32s",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "casted",
                "type": "bytes32[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toBytes32s(uint256[] memory a) private pure returns (bytes32[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }",
            "startLine": 756
          },
          {
            "name": "_flipSign",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "int256[]"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _flipSign(int256[] memory a) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let q := shl(255, 1)\n            for { let i := add(a, shl(5, mload(a))) } iszero(eq(a, i)) {} {\n                mstore(i, add(mload(i), q))\n                i := sub(i, 0x20)\n            }\n        }\n    }",
            "startLine": 765
          },
          {
            "name": "_searchSorted",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "needle",
                "type": "uint256"
              },
              {
                "name": "signed",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _searchSorted(uint256[] memory a, uint256 needle, uint256 signed)\n        private\n        pure\n        returns (bool found, uint256 index)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0)\n            let l := 1\n            let h := mload(a)\n            let t := 0\n            for { needle := add(signed, needle) } 1 {} {\n                index := shr(1, add(l, h))\n                t := add(signed, mload(add(a, shl(5, index))))\n                if or(gt(l, h), eq(t, needle)) { break }\n                // Decide whether to search the left or right half.\n                if iszero(gt(needle, t)) {\n                    h := add(index, w)\n                    continue\n                }\n                l := add(index, 1)\n            }\n            // `index` will be zero in the case of an empty array,\n            // or when the value is less than the smallest value in the array.\n            found := eq(t, needle)\n            t := iszero(iszero(index))\n            index := mul(add(index, w), t)\n            found := and(found, t)\n        }\n    }",
            "startLine": 778
          },
          {
            "name": "_difference",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "b",
                "type": "uint256[]"
              },
              {
                "name": "signed",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _difference(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    b := add(b, s)\n                    continue\n                }\n                k := add(k, s)\n                mstore(k, u)\n                a := add(a, s)\n            }\n            for {} iszero(gt(a, aEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(a))\n                a := add(a, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }",
            "startLine": 811
          },
          {
            "name": "_intersection",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "b",
                "type": "uint256[]"
              },
              {
                "name": "signed",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _intersection(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    k := add(k, s)\n                    mstore(k, u)\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    b := add(b, s)\n                    continue\n                }\n                a := add(a, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }",
            "startLine": 853
          },
          {
            "name": "_union",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "b",
                "type": "uint256[]"
              },
              {
                "name": "signed",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _union(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    k := add(k, s)\n                    mstore(k, u)\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    k := add(k, s)\n                    mstore(k, v)\n                    b := add(b, s)\n                    continue\n                }\n                k := add(k, s)\n                mstore(k, u)\n                a := add(a, s)\n            }\n            for {} iszero(gt(a, aEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(a))\n                a := add(a, s)\n            }\n            for {} iszero(gt(b, bEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(b))\n                b := add(b, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }",
            "startLine": 890
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibStorage",
        "filePath": "utils/LibStorage.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "slot",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "b",
                "type": "Bump"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function slot(Bump storage b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1f, sload(b.slot))\n            mstore(0x04, _BUMPED_STORAGE_REF_SLOT_SEED)\n            mstore(0x00, b.slot)\n            result := keccak256(0x00, 0x3f)\n        }\n    }",
            "startLine": 37
          },
          {
            "name": "invalidate",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "b",
                "type": "Bump"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function invalidate(Bump storage b) internal {\n        unchecked {\n            ++b._current;\n        }\n    }",
            "startLine": 48
          },
          {
            "name": "bump",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "sSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "$",
                "type": "Bump"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function bump(bytes32 sSlot) internal pure returns (Bump storage $) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            $.slot := sSlot\n        }\n    }",
            "startLine": 55
          },
          {
            "name": "bump",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "sSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "$",
                "type": "Bump"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function bump(uint256 sSlot) internal pure returns (Bump storage $) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            $.slot := sSlot\n        }\n    }",
            "startLine": 63
          },
          {
            "name": "ref",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "sSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "$",
                "type": "Ref"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function ref(bytes32 sSlot) internal pure returns (Ref storage $) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            $.slot := sSlot\n        }\n    }",
            "startLine": 71
          },
          {
            "name": "ref",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "sSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "$",
                "type": "Ref"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function ref(uint256 sSlot) internal pure returns (Ref storage $) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            $.slot := sSlot\n        }\n    }",
            "startLine": 79
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "Bump",
            "members": [
              {
                "name": "_current",
                "type": "uint256"
              }
            ],
            "startLine": 20
          },
          {
            "name": "Ref",
            "members": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "startLine": 27
          }
        ],
        "stateVariables": [
          {
            "name": "_BUMPED_STORAGE_REF_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 13
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibString",
        "filePath": "utils/LibString.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "StringStorage"
              },
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "LibBytes.set",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "bytesStorage",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(StringStorage storage $, string memory s) internal {\n        LibBytes.set(bytesStorage($), bytes(s));\n    }",
            "startLine": 82
          },
          {
            "name": "setCalldata",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "StringStorage"
              },
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "LibBytes.setCalldata",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "bytesStorage",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function setCalldata(StringStorage storage $, string calldata s) internal {\n        LibBytes.setCalldata(bytesStorage($), bytes(s));\n    }",
            "startLine": 87
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "StringStorage"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clear(StringStorage storage $) internal {\n        delete $._spacer;\n    }",
            "startLine": 92
          },
          {
            "name": "isEmpty",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "StringStorage"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isEmpty(StringStorage storage $) internal view returns (bool) {\n        return uint256($._spacer) & 0xff == uint256(0);\n    }",
            "startLine": 97
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "StringStorage"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.length",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "bytesStorage",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(StringStorage storage $) internal view returns (uint256) {\n        return LibBytes.length(bytesStorage($));\n    }",
            "startLine": 102
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "StringStorage"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.get",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "bytesStorage",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(StringStorage storage $) internal view returns (string memory) {\n        return string(LibBytes.get(bytesStorage($)));\n    }",
            "startLine": 107
          },
          {
            "name": "uint8At",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "StringStorage"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.uint8At",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "bytesStorage",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function uint8At(StringStorage storage $, uint256 i) internal view returns (uint8) {\n        return LibBytes.uint8At(bytesStorage($), i);\n    }",
            "startLine": 112
          },
          {
            "name": "bytesStorage",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "$",
                "type": "StringStorage"
              }
            ],
            "returnValues": [
              {
                "name": "casted",
                "type": "LibBytes.BytesStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function bytesStorage(StringStorage storage $)\n        internal\n        pure\n        returns (LibBytes.BytesStorage storage casted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted.slot := $.slot\n        }\n    }",
            "startLine": 117
          },
          {
            "name": "toString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toString(uint256 value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            result := add(mload(0x40), 0x80)\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end of the memory to calculate the length later.\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                result := add(result, w) // `sub(result, 1)`.\n                // Store the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(result, add(48, mod(temp, 10)))\n                temp := div(temp, 10) // Keep dividing `temp` until zero.\n                if iszero(temp) { break }\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20) // Move the pointer 32 bytes back to make room for the length.\n            mstore(result, n) // Store the length.\n        }\n    }",
            "startLine": 133
          },
          {
            "name": "toString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toString",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function toString(int256 value) internal pure returns (string memory result) {\n        if (value >= 0) return toString(uint256(value));\n        unchecked {\n            result = toString(~uint256(value) + 1);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let n := mload(result) // Load the string length.\n            mstore(result, 0x2d) // Store the '-' character.\n            result := sub(result, 1) // Move back the string pointer by a byte.\n            mstore(result, add(n, 1)) // Update the string length.\n        }\n    }",
            "startLine": 163
          },
          {
            "name": "toHexString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "byteCount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toHexStringNoPrefix",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function toHexString(uint256 value, uint256 byteCount)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = toHexStringNoPrefix(value, byteCount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }",
            "startLine": 188
          },
          {
            "name": "toHexStringNoPrefix",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "byteCount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toHexStringNoPrefix(uint256 value, uint256 byteCount)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `byteCount * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            result := add(mload(0x40), and(add(shl(1, byteCount), 0x42), not(0x1f)))\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end to calculate the length later.\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(result, add(byteCount, byteCount))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                result := add(result, w) // `sub(result, 2)`.\n                mstore8(add(result, 1), mload(and(temp, 15)))\n                mstore8(result, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(result, start)) { break }\n            }\n            if temp {\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\n                revert(0x1c, 0x04)\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20)\n            mstore(result, n) // Store the length.\n        }\n    }",
            "startLine": 208
          },
          {
            "name": "toHexString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toHexStringNoPrefix",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function toHexString(uint256 value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }",
            "startLine": 253
          },
          {
            "name": "toMinimalHexString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toHexStringNoPrefix",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function toMinimalHexString(uint256 value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(add(result, o), 0x3078) // Store the \"0x\" prefix, accounting for leading zero.\n            result := sub(add(result, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.\n        }\n    }",
            "startLine": 268
          },
          {
            "name": "toMinimalHexStringNoPrefix",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toHexStringNoPrefix",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function toMinimalHexStringNoPrefix(uint256 value)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.\n            let n := mload(result) // Get the length.\n            result := add(result, o) // Move the pointer, accounting for leading zero.\n            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.\n        }\n    }",
            "startLine": 283
          },
          {
            "name": "toHexStringNoPrefix",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toHexStringNoPrefix(uint256 value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            result := add(mload(0x40), 0x80)\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end to calculate the length later.\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                result := add(result, w) // `sub(result, 2)`.\n                mstore8(add(result, 1), mload(and(temp, 15)))\n                mstore8(result, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20)\n            mstore(result, n) // Store the length.\n        }\n    }",
            "startLine": 302
          },
          {
            "name": "toHexStringChecksummed",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toHexString",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function toHexStringChecksummed(address value) internal pure returns (string memory result) {\n        result = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(result, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }",
            "startLine": 335
          },
          {
            "name": "toHexString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toHexStringNoPrefix",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function toHexString(address value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }",
            "startLine": 356
          },
          {
            "name": "toHexStringNoPrefix",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toHexStringNoPrefix(address value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            // Allocate memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(result, 0x80))\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n\n            result := add(result, 2)\n            mstore(result, 40) // Store the length.\n            let o := add(result, 0x20)\n            mstore(add(o, 40), 0) // Zeroize the slot after the string.\n            value := shl(96, value)\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }",
            "startLine": 369
          },
          {
            "name": "toHexString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "raw",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toHexStringNoPrefix",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function toHexString(bytes memory raw) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }",
            "startLine": 400
          },
          {
            "name": "toHexStringNoPrefix",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "raw",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(raw)\n            result := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(result, add(n, n)) // Store the length of the output.\n\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n            let o := add(result, 0x20)\n            let end := add(raw, n)\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }",
            "startLine": 413
          },
          {
            "name": "runeCount",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }",
            "startLine": 439
          },
          {
            "name": "is7BitASCII",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            let mask := shl(7, div(not(0), 255))\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }",
            "startLine": 457
          },
          {
            "name": "is7BitASCII",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              },
              {
                "name": "allowed",
                "type": "uint128"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function is7BitASCII(string memory s, uint128 allowed) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if mload(s) {\n                let allowed_ := shr(128, shl(128, allowed))\n                let o := add(s, 0x20)\n                for { let end := add(o, mload(s)) } 1 {} {\n                    result := and(result, shr(byte(0, mload(o)), allowed_))\n                    o := add(o, 1)\n                    if iszero(and(result, lt(o, end))) { break }\n                }\n            }\n        }\n    }",
            "startLine": 484
          },
          {
            "name": "to7BitASCIIAllowedLookup",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint128"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function to7BitASCIIAllowedLookup(string memory s) internal pure returns (uint128 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                let o := add(s, 0x20)\n                for { let end := add(o, mload(s)) } 1 {} {\n                    result := or(result, shl(byte(0, mload(o)), 1))\n                    o := add(o, 1)\n                    if iszero(lt(o, end)) { break }\n                }\n                if shr(128, result) {\n                    mstore(0x00, 0xc9807e0d) // `StringNot7BitASCII()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 503
          },
          {
            "name": "replace",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "needle",
                "type": "string"
              },
              {
                "name": "replacement",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.replace",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function replace(string memory subject, string memory needle, string memory replacement)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string(LibBytes.replace(bytes(subject), bytes(needle), bytes(replacement)));\n    }",
            "startLine": 531
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "needle",
                "type": "string"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.indexOf",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(string memory subject, string memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.indexOf(bytes(subject), bytes(needle), from);\n    }",
            "startLine": 542
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "needle",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.indexOf",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(string memory subject, string memory needle) internal pure returns (uint256) {\n        return LibBytes.indexOf(bytes(subject), bytes(needle), 0);\n    }",
            "startLine": 553
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "needle",
                "type": "string"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.lastIndexOf",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(string memory subject, string memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.lastIndexOf(bytes(subject), bytes(needle), from);\n    }",
            "startLine": 560
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "needle",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.lastIndexOf",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(string memory subject, string memory needle)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.lastIndexOf(bytes(subject), bytes(needle), type(uint256).max);\n    }",
            "startLine": 571
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "needle",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.contains(bytes(subject), bytes(needle));\n    }",
            "startLine": 580
          },
          {
            "name": "startsWith",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "needle",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.startsWith",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function startsWith(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.startsWith(bytes(subject), bytes(needle));\n    }",
            "startLine": 585
          },
          {
            "name": "endsWith",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "needle",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.endsWith",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function endsWith(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.endsWith(bytes(subject), bytes(needle));\n    }",
            "startLine": 590
          },
          {
            "name": "repeat",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "times",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.repeat",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function repeat(string memory subject, uint256 times) internal pure returns (string memory) {\n        return string(LibBytes.repeat(bytes(subject), times));\n    }",
            "startLine": 595
          },
          {
            "name": "slice",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.slice",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string(LibBytes.slice(bytes(subject), start, end));\n    }",
            "startLine": 601
          },
          {
            "name": "slice",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.slice",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function slice(string memory subject, uint256 start) internal pure returns (string memory) {\n        return string(LibBytes.slice(bytes(subject), start, type(uint256).max));\n    }",
            "startLine": 611
          },
          {
            "name": "indicesOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "needle",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.indicesOf",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indicesOf(string memory subject, string memory needle)\n        internal\n        pure\n        returns (uint256[] memory)\n    {\n        return LibBytes.indicesOf(bytes(subject), bytes(needle));\n    }",
            "startLine": 617
          },
          {
            "name": "split",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "delimiter",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string[]"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.split",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        bytes[] memory a = LibBytes.split(bytes(subject), bytes(delimiter));\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "startLine": 626
          },
          {
            "name": "concat",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "string"
              },
              {
                "name": "b",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.concat",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function concat(string memory a, string memory b) internal pure returns (string memory) {\n        return string(LibBytes.concat(bytes(a), bytes(b)));\n    }",
            "startLine": 640
          },
          {
            "name": "toCase",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "toUpper",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(subject)\n            if n {\n                result := mload(0x40)\n                let o := add(result, 0x20)\n                let d := sub(subject, result)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                for { let end := add(o, n) } 1 {} {\n                    let b := byte(0, mload(add(d, o)))\n                    mstore8(o, xor(and(shr(b, flags), 0x20), b))\n                    o := add(o, 1)\n                    if eq(o, end) { break }\n                }\n                mstore(result, n) // Store the length.\n                mstore(o, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n            }\n        }\n    }",
            "startLine": 646
          },
          {
            "name": "fromSmallString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function fromSmallString(bytes32 s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := 0\n            for {} // Scan for '\\0'.\n             byte(n, s) { n := add(n, 1) } {}\n            mstore(result, n) // Store the length.\n            let o := add(result, 0x20)\n            mstore(o, s) // Store the bytes of the string.\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\n            mstore(0x40, add(result, 0x40)) // Allocate memory.\n        }\n    }",
            "startLine": 674
          },
          {
            "name": "normalizeSmallString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} // Scan for '\\0'.\n             byte(result, s) { result := add(result, 1) } {}\n            mstore(0x00, s)\n            mstore(result, 0x00)\n            result := mload(0x00)\n        }\n    }",
            "startLine": 690
          },
          {
            "name": "toSmallString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toSmallString(string memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(s)\n            if iszero(lt(result, 33)) {\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\n                revert(0x1c, 0x04)\n            }\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\n        }\n    }",
            "startLine": 702
          },
          {
            "name": "lower",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toCase",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }",
            "startLine": 716
          },
          {
            "name": "upper",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toCase",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }",
            "startLine": 722
          },
          {
            "name": "escapeHTML",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let end := add(s, mload(s))\n            let o := add(result, 0x20)\n            // Store the bytes of the packed offsets and strides into the scratch space.\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n            mstore(0x1f, 0x900094)\n            mstore(0x08, 0xc0000000a6ab)\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(o, c)\n                    o := add(o, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(o, mload(and(t, 0x1f)))\n                o := add(o, shr(5, t))\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }",
            "startLine": 727
          },
          {
            "name": "escapeJSON",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              },
              {
                "name": "addDoubleQuotes",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function escapeJSON(string memory s, bool addDoubleQuotes)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            if addDoubleQuotes {\n                mstore8(o, 34)\n                o := add(1, o)\n            }\n            // Store \"\\\\u0000\" in scratch space.\n            // Store \"0123456789abcdef\" in scratch space.\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n            // into the scratch space.\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\n            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(o, c)\n                        o := add(o, 1)\n                        continue\n                    }\n                    mstore8(o, 0x5c) // \"\\\\\".\n                    mstore8(add(o, 1), c)\n                    o := add(o, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(o, mload(0x19)) // \"\\\\u00XX\".\n                    o := add(o, 6)\n                    continue\n                }\n                mstore8(o, 0x5c) // \"\\\\\".\n                mstore8(add(o, 1), mload(add(c, 8)))\n                o := add(o, 2)\n            }\n            if addDoubleQuotes {\n                mstore8(o, 34)\n                o := add(1, o)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }",
            "startLine": 760
          },
          {
            "name": "escapeJSON",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "escapeJSON",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function escapeJSON(string memory s) internal pure returns (string memory result) {\n        result = escapeJSON(s, false);\n    }",
            "startLine": 818
          },
          {
            "name": "encodeURIComponent",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function encodeURIComponent(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            // Store \"0123456789ABCDEF\" in scratch space.\n            // Uppercased to be consistent with JavaScript's implementation.\n            mstore(0x0f, 0x30313233343536373839414243444546)\n            let o := add(result, 0x20)\n            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // If not in `[0-9A-Z-a-z-_.!~*'()]`.\n                if iszero(and(1, shr(c, 0x47fffffe87fffffe03ff678200000000))) {\n                    mstore8(o, 0x25) // '%'.\n                    mstore8(add(o, 1), mload(and(shr(4, c), 15)))\n                    mstore8(add(o, 2), mload(and(c, 15)))\n                    o := add(o, 3)\n                    continue\n                }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }",
            "startLine": 827
          },
          {
            "name": "eq",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "string"
              },
              {
                "name": "b",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function eq(string memory a, string memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }",
            "startLine": 856
          },
          {
            "name": "eqs",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "string"
              },
              {
                "name": "b",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }",
            "startLine": 864
          },
          {
            "name": "cmp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "string"
              },
              {
                "name": "b",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.cmp",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function cmp(string memory a, string memory b) internal pure returns (int256) {\n        return LibBytes.cmp(bytes(a), bytes(b));\n    }",
            "startLine": 883
          },
          {
            "name": "packOne",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result := mul(\n                // Load the length and the bytes.\n                mload(add(a, 0x1f)),\n                // `length != 0 && length < 32`. Abuses underflow.\n                // Assumes that the length is valid and within the block gas limit.\n                lt(sub(mload(a), 1), 0x1f)\n            )\n        }\n    }",
            "startLine": 889
          },
          {
            "name": "unpackOne",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "packed",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer.\n            mstore(0x40, add(result, 0x40)) // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(result, 0) // Zeroize the length slot.\n            mstore(add(result, 0x1f), packed) // Store the length and bytes.\n            mstore(add(add(result, 0x20), mload(result)), 0) // Right pad with zeroes.\n        }\n    }",
            "startLine": 907
          },
          {
            "name": "packTwo",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "string"
              },
              {
                "name": "b",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLen := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result := mul(\n                or( // Load the length and the bytes of `a` and `b`.\n                    shl(shl(3, sub(0x1f, aLen)), mload(add(a, aLen))),\n                    shr(shl(3, add(aLen, 1)), mload(add(b, 0x1f)))\n                ),\n                // `totalLen != 0 && totalLen < 31`. Abuses underflow.\n                // Assumes that the lengths are valid and within the block gas limit.\n                lt(sub(add(aLen, mload(b)), 1), 0x1e)\n            )\n        }\n    }",
            "startLine": 920
          },
          {
            "name": "unpackTwo",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "packed",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "resultA",
                "type": "string"
              },
              {
                "name": "resultB",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            resultA := mload(0x40) // Grab the free memory pointer.\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }",
            "startLine": 941
          },
          {
            "name": "directReturn",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function directReturn(string memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the string.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }",
            "startLine": 965
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "HexLengthInsufficient",
            "parameters": [],
            "startLine": 32
          },
          {
            "name": "TooBigForSmallString",
            "parameters": [],
            "startLine": 35
          },
          {
            "name": "StringNot7BitASCII",
            "parameters": [],
            "startLine": 38
          }
        ],
        "structs": [
          {
            "name": "StringStorage",
            "members": [
              {
                "name": "_spacer",
                "type": "bytes32"
              }
            ],
            "startLine": 23
          }
        ],
        "stateVariables": [
          {
            "name": "NOT_FOUND",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 45
          },
          {
            "name": "ALPHANUMERIC_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 48
          },
          {
            "name": "LETTERS_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 51
          },
          {
            "name": "LOWERCASE_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 54
          },
          {
            "name": "UPPERCASE_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 57
          },
          {
            "name": "DIGITS_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 60
          },
          {
            "name": "HEXDIGITS_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 63
          },
          {
            "name": "OCTDIGITS_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 66
          },
          {
            "name": "PRINTABLE_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 69
          },
          {
            "name": "PUNCTUATION_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 72
          },
          {
            "name": "WHITESPACE_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 75
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./LibBytes.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "LibTransient",
        "filePath": "utils/LibTransient.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "tUint256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tUint256(bytes32 tSlot) internal pure returns (TUint256 storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 81
          },
          {
            "name": "tUint256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tUint256(uint256 tSlot) internal pure returns (TUint256 storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 89
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(TUint256 storage ptr) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := tload(ptr.slot)\n        }\n    }",
            "startLine": 97
          },
          {
            "name": "getCompat",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function getCompat(TUint256 storage ptr) internal view returns (uint256 result) {\n        result = block.chainid == 1 ? get(ptr) : _compat(ptr)._spacer;\n    }",
            "startLine": 105
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(TUint256 storage ptr, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, value)\n        }\n    }",
            "startLine": 110
          },
          {
            "name": "setCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function setCompat(TUint256 storage ptr, uint256 value) internal {\n        if (block.chainid == 1) return set(ptr, value);\n        _compat(ptr)._spacer = value;\n    }",
            "startLine": 118
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clear(TUint256 storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, 0)\n        }\n    }",
            "startLine": 124
          },
          {
            "name": "clearCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "clear",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clearCompat(TUint256 storage ptr) internal {\n        if (block.chainid == 1) return clear(ptr);\n        _compat(ptr)._spacer = 0;\n    }",
            "startLine": 132
          },
          {
            "name": "inc",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function inc(TUint256 storage ptr) internal returns (uint256 newValue) {\n        set(ptr, newValue = get(ptr) + 1);\n    }",
            "startLine": 138
          },
          {
            "name": "incCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "setCompat",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "getCompat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function incCompat(TUint256 storage ptr) internal returns (uint256 newValue) {\n        setCompat(ptr, newValue = getCompat(ptr) + 1);\n    }",
            "startLine": 143
          },
          {
            "name": "inc",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "delta",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function inc(TUint256 storage ptr, uint256 delta) internal returns (uint256 newValue) {\n        set(ptr, newValue = get(ptr) + delta);\n    }",
            "startLine": 148
          },
          {
            "name": "incCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "delta",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "setCompat",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "getCompat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function incCompat(TUint256 storage ptr, uint256 delta) internal returns (uint256 newValue) {\n        setCompat(ptr, newValue = getCompat(ptr) + delta);\n    }",
            "startLine": 153
          },
          {
            "name": "dec",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function dec(TUint256 storage ptr) internal returns (uint256 newValue) {\n        set(ptr, newValue = get(ptr) - 1);\n    }",
            "startLine": 158
          },
          {
            "name": "decCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "setCompat",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "getCompat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function decCompat(TUint256 storage ptr) internal returns (uint256 newValue) {\n        setCompat(ptr, newValue = getCompat(ptr) - 1);\n    }",
            "startLine": 163
          },
          {
            "name": "dec",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "delta",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function dec(TUint256 storage ptr, uint256 delta) internal returns (uint256 newValue) {\n        set(ptr, newValue = get(ptr) - delta);\n    }",
            "startLine": 168
          },
          {
            "name": "decCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "delta",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "setCompat",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "getCompat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function decCompat(TUint256 storage ptr, uint256 delta) internal returns (uint256 newValue) {\n        setCompat(ptr, newValue = getCompat(ptr) - delta);\n    }",
            "startLine": 173
          },
          {
            "name": "incSigned",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "delta",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function incSigned(TUint256 storage ptr, int256 delta) internal returns (uint256 newValue) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let currentValue := tload(ptr.slot)\n            newValue := add(currentValue, delta)\n            if iszero(eq(lt(newValue, currentValue), slt(delta, 0))) {\n                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.\n                mstore(0x20, 0x11) // Underflow or overflow panic.\n                revert(0x1c, 0x24)\n            }\n            tstore(ptr.slot, newValue)\n        }\n    }",
            "startLine": 178
          },
          {
            "name": "incSignedCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "delta",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "incSigned",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function incSignedCompat(TUint256 storage ptr, int256 delta)\n        internal\n        returns (uint256 newValue)\n    {\n        if (block.chainid == 1) return incSigned(ptr, delta);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let currentValue := sload(ptr.slot)\n            newValue := add(currentValue, delta)\n            if iszero(eq(lt(newValue, currentValue), slt(delta, 0))) {\n                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.\n                mstore(0x20, 0x11) // Underflow or overflow panic.\n                revert(0x1c, 0x24)\n            }\n            sstore(ptr.slot, newValue)\n        }\n    }",
            "startLine": 193
          },
          {
            "name": "decSigned",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "delta",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function decSigned(TUint256 storage ptr, int256 delta) internal returns (uint256 newValue) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let currentValue := tload(ptr.slot)\n            newValue := sub(currentValue, delta)\n            if iszero(eq(lt(newValue, currentValue), sgt(delta, 0))) {\n                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.\n                mstore(0x20, 0x11) // Underflow or overflow panic.\n                revert(0x1c, 0x24)\n            }\n            tstore(ptr.slot, newValue)\n        }\n    }",
            "startLine": 213
          },
          {
            "name": "decSignedCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "delta",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "decSigned",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function decSignedCompat(TUint256 storage ptr, int256 delta)\n        internal\n        returns (uint256 newValue)\n    {\n        if (block.chainid == 1) return decSigned(ptr, delta);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let currentValue := sload(ptr.slot)\n            newValue := sub(currentValue, delta)\n            if iszero(eq(lt(newValue, currentValue), sgt(delta, 0))) {\n                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.\n                mstore(0x20, 0x11) // Underflow or overflow panic.\n                revert(0x1c, 0x24)\n            }\n            sstore(ptr.slot, newValue)\n        }\n    }",
            "startLine": 228
          },
          {
            "name": "tInt256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tInt256(bytes32 tSlot) internal pure returns (TInt256 storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 252
          },
          {
            "name": "tInt256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tInt256(uint256 tSlot) internal pure returns (TInt256 storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 260
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(TInt256 storage ptr) internal view returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := tload(ptr.slot)\n        }\n    }",
            "startLine": 268
          },
          {
            "name": "getCompat",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function getCompat(TInt256 storage ptr) internal view returns (int256 result) {\n        result = block.chainid == 1 ? get(ptr) : int256(_compat(ptr)._spacer);\n    }",
            "startLine": 276
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              },
              {
                "name": "value",
                "type": "int256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(TInt256 storage ptr, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, value)\n        }\n    }",
            "startLine": 281
          },
          {
            "name": "setCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              },
              {
                "name": "value",
                "type": "int256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function setCompat(TInt256 storage ptr, int256 value) internal {\n        if (block.chainid == 1) return set(ptr, value);\n        _compat(ptr)._spacer = uint256(value);\n    }",
            "startLine": 289
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clear(TInt256 storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, 0)\n        }\n    }",
            "startLine": 295
          },
          {
            "name": "clearCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "clear",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clearCompat(TInt256 storage ptr) internal {\n        if (block.chainid == 1) return clear(ptr);\n        _compat(ptr)._spacer = 0;\n    }",
            "startLine": 303
          },
          {
            "name": "inc",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function inc(TInt256 storage ptr) internal returns (int256 newValue) {\n        set(ptr, newValue = get(ptr) + 1);\n    }",
            "startLine": 309
          },
          {
            "name": "incCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "setCompat",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "getCompat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function incCompat(TInt256 storage ptr) internal returns (int256 newValue) {\n        setCompat(ptr, newValue = getCompat(ptr) + 1);\n    }",
            "startLine": 314
          },
          {
            "name": "inc",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              },
              {
                "name": "delta",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function inc(TInt256 storage ptr, int256 delta) internal returns (int256 newValue) {\n        set(ptr, newValue = get(ptr) + delta);\n    }",
            "startLine": 319
          },
          {
            "name": "incCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              },
              {
                "name": "delta",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "setCompat",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "getCompat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function incCompat(TInt256 storage ptr, int256 delta) internal returns (int256 newValue) {\n        setCompat(ptr, newValue = getCompat(ptr) + delta);\n    }",
            "startLine": 324
          },
          {
            "name": "dec",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function dec(TInt256 storage ptr) internal returns (int256 newValue) {\n        set(ptr, newValue = get(ptr) - 1);\n    }",
            "startLine": 329
          },
          {
            "name": "decCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "setCompat",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "getCompat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function decCompat(TInt256 storage ptr) internal returns (int256 newValue) {\n        setCompat(ptr, newValue = getCompat(ptr) - 1);\n    }",
            "startLine": 334
          },
          {
            "name": "dec",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              },
              {
                "name": "delta",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function dec(TInt256 storage ptr, int256 delta) internal returns (int256 newValue) {\n        set(ptr, newValue = get(ptr) - delta);\n    }",
            "startLine": 339
          },
          {
            "name": "decCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              },
              {
                "name": "delta",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "setCompat",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "getCompat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function decCompat(TInt256 storage ptr, int256 delta) internal returns (int256 newValue) {\n        setCompat(ptr, newValue = getCompat(ptr) - delta);\n    }",
            "startLine": 344
          },
          {
            "name": "tBytes32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TBytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tBytes32(bytes32 tSlot) internal pure returns (TBytes32 storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 353
          },
          {
            "name": "tBytes32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TBytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tBytes32(uint256 tSlot) internal pure returns (TBytes32 storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 361
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(TBytes32 storage ptr) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := tload(ptr.slot)\n        }\n    }",
            "startLine": 369
          },
          {
            "name": "getCompat",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function getCompat(TBytes32 storage ptr) internal view returns (bytes32 result) {\n        result = block.chainid == 1 ? get(ptr) : bytes32(_compat(ptr)._spacer);\n    }",
            "startLine": 377
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes32"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(TBytes32 storage ptr, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, value)\n        }\n    }",
            "startLine": 382
          },
          {
            "name": "setCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes32"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function setCompat(TBytes32 storage ptr, bytes32 value) internal {\n        if (block.chainid == 1) return set(ptr, value);\n        _compat(ptr)._spacer = uint256(value);\n    }",
            "startLine": 390
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clear(TBytes32 storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, 0)\n        }\n    }",
            "startLine": 396
          },
          {
            "name": "clearCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "clear",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clearCompat(TBytes32 storage ptr) internal {\n        if (block.chainid == 1) return clear(ptr);\n        _compat(ptr)._spacer = 0;\n    }",
            "startLine": 404
          },
          {
            "name": "tAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TAddress"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tAddress(bytes32 tSlot) internal pure returns (TAddress storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 414
          },
          {
            "name": "tAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TAddress"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tAddress(uint256 tSlot) internal pure returns (TAddress storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 422
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TAddress"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(TAddress storage ptr) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := tload(ptr.slot)\n        }\n    }",
            "startLine": 430
          },
          {
            "name": "getCompat",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TAddress"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function getCompat(TAddress storage ptr) internal view returns (address result) {\n        result = block.chainid == 1 ? get(ptr) : address(uint160(_compat(ptr)._spacer));\n    }",
            "startLine": 438
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TAddress"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(TAddress storage ptr, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, shr(96, shl(96, value)))\n        }\n    }",
            "startLine": 443
          },
          {
            "name": "setCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TAddress"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function setCompat(TAddress storage ptr, address value) internal {\n        if (block.chainid == 1) return set(ptr, value);\n        _compat(ptr)._spacer = uint160(value);\n    }",
            "startLine": 451
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TAddress"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clear(TAddress storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, 0)\n        }\n    }",
            "startLine": 457
          },
          {
            "name": "clearCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TAddress"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "clear",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clearCompat(TAddress storage ptr) internal {\n        if (block.chainid == 1) return clear(ptr);\n        _compat(ptr)._spacer = 0;\n    }",
            "startLine": 465
          },
          {
            "name": "tBool",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TBool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tBool(bytes32 tSlot) internal pure returns (TBool storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 475
          },
          {
            "name": "tBool",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TBool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tBool(uint256 tSlot) internal pure returns (TBool storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 483
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(TBool storage ptr) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := tload(ptr.slot)\n        }\n    }",
            "startLine": 491
          },
          {
            "name": "getCompat",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function getCompat(TBool storage ptr) internal view returns (bool result) {\n        result = block.chainid == 1 ? get(ptr) : _compat(ptr)._spacer != 0;\n    }",
            "startLine": 499
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBool"
              },
              {
                "name": "value",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(TBool storage ptr, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, iszero(iszero(value)))\n        }\n    }",
            "startLine": 504
          },
          {
            "name": "setCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBool"
              },
              {
                "name": "value",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function setCompat(TBool storage ptr, bool value) internal {\n        if (block.chainid == 1) return set(ptr, value);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(ptr.slot, iszero(iszero(value)))\n        }\n    }",
            "startLine": 512
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clear(TBool storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, 0)\n        }\n    }",
            "startLine": 522
          },
          {
            "name": "clearCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "clear",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clearCompat(TBool storage ptr) internal {\n        if (block.chainid == 1) return clear(ptr);\n        _compat(ptr)._spacer = 0;\n    }",
            "startLine": 530
          },
          {
            "name": "tBytes",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TBytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tBytes(bytes32 tSlot) internal pure returns (TBytes storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 540
          },
          {
            "name": "tBytes",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TBytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tBytes(uint256 tSlot) internal pure returns (TBytes storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 548
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function length(TBytes storage ptr) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(224, tload(ptr.slot))\n        }\n    }",
            "startLine": 556
          },
          {
            "name": "lengthCompat",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lengthCompat(TBytes storage ptr) internal view returns (uint256 result) {\n        if (block.chainid == 1) return length(ptr);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(224, sload(ptr.slot))\n        }\n    }",
            "startLine": 564
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(TBytes storage ptr) internal view returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(result, 0x00)\n            mstore(add(result, 0x1c), tload(ptr.slot)) // Length and first `0x1c` bytes.\n            let n := mload(result)\n            let e := add(add(result, 0x20), n)\n            if iszero(lt(n, 0x1d)) {\n                mstore(0x00, ptr.slot)\n                let d := sub(keccak256(0x00, 0x20), result)\n                for { let o := add(result, 0x3c) } 1 {} {\n                    mstore(o, tload(add(o, d)))\n                    o := add(o, 0x20)\n                    if iszero(lt(o, e)) { break }\n                }\n            }\n            mstore(e, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(0x20, e)) // Allocate memory.\n        }\n    }",
            "startLine": 574
          },
          {
            "name": "getCompat",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function getCompat(TBytes storage ptr) internal view returns (bytes memory result) {\n        if (block.chainid == 1) return get(ptr);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(result, 0x00)\n            mstore(add(result, 0x1c), sload(ptr.slot)) // Length and first `0x1c` bytes.\n            let n := mload(result)\n            let e := add(add(result, 0x20), n)\n            if iszero(lt(n, 0x1d)) {\n                mstore(0x00, ptr.slot)\n                let d := sub(keccak256(0x00, 0x20), result)\n                for { let o := add(result, 0x3c) } 1 {} {\n                    mstore(o, sload(add(o, d)))\n                    o := add(o, 0x20)\n                    if iszero(lt(o, e)) { break }\n                }\n            }\n            mstore(e, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(0x20, e)) // Allocate memory.\n        }\n    }",
            "startLine": 597
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              },
              {
                "name": "value",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(TBytes storage ptr, bytes memory value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, mload(add(value, 0x1c)))\n            if iszero(lt(mload(value), 0x1d)) {\n                mstore(0x00, ptr.slot)\n                let e := add(add(value, 0x20), mload(value))\n                let d := sub(keccak256(0x00, or(0x20, sub(0, shr(32, mload(value))))), value)\n                for { let o := add(value, 0x3c) } 1 {} {\n                    tstore(add(o, d), mload(o))\n                    o := add(o, 0x20)\n                    if iszero(lt(o, e)) { break }\n                }\n            }\n        }\n    }",
            "startLine": 622
          },
          {
            "name": "setCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              },
              {
                "name": "value",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function setCompat(TBytes storage ptr, bytes memory value) internal {\n        if (block.chainid == 1) return set(ptr, value);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(ptr.slot, mload(add(value, 0x1c)))\n            if iszero(lt(mload(value), 0x1d)) {\n                mstore(0x00, ptr.slot)\n                let e := add(add(value, 0x20), mload(value))\n                let d := sub(keccak256(0x00, or(0x20, sub(0, shr(32, mload(value))))), value)\n                for { let o := add(value, 0x3c) } 1 {} {\n                    sstore(add(o, d), mload(o))\n                    o := add(o, 0x20)\n                    if iszero(lt(o, e)) { break }\n                }\n            }\n        }\n    }",
            "startLine": 640
          },
          {
            "name": "setCalldata",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              },
              {
                "name": "value",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function setCalldata(TBytes storage ptr, bytes calldata value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, or(shl(224, value.length), shr(32, calldataload(value.offset))))\n            if iszero(lt(value.length, 0x1d)) {\n                mstore(0x00, ptr.slot)\n                let e := add(value.offset, value.length)\n                // forgefmt: disable-next-item\n                let d := add(sub(keccak256(0x00, or(0x20, sub(0, shr(32, value.length)))),\n                    value.offset), 0x20)\n                for { let o := add(value.offset, 0x1c) } 1 {} {\n                    tstore(add(o, d), calldataload(o))\n                    o := add(o, 0x20)\n                    if iszero(lt(o, e)) { break }\n                }\n            }\n        }\n    }",
            "startLine": 660
          },
          {
            "name": "setCalldataCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              },
              {
                "name": "value",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "setCalldata",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function setCalldataCompat(TBytes storage ptr, bytes calldata value) internal {\n        if (block.chainid == 1) return setCalldata(ptr, value);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(ptr.slot, or(shl(224, value.length), shr(32, calldataload(value.offset))))\n            if iszero(lt(value.length, 0x1d)) {\n                mstore(0x00, ptr.slot)\n                let e := add(value.offset, value.length)\n                // forgefmt: disable-next-item\n                let d := add(sub(keccak256(0x00, or(0x20, sub(0, shr(32, value.length)))),\n                    value.offset), 0x20)\n                for { let o := add(value.offset, 0x1c) } 1 {} {\n                    sstore(add(o, d), calldataload(o))\n                    o := add(o, 0x20)\n                    if iszero(lt(o, e)) { break }\n                }\n            }\n        }\n    }",
            "startLine": 680
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clear(TBytes storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, 0)\n        }\n    }",
            "startLine": 702
          },
          {
            "name": "clearCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "clear",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clearCompat(TBytes storage ptr) internal {\n        if (block.chainid == 1) return clear(ptr);\n        _compat(ptr)._spacer = 0;\n    }",
            "startLine": 710
          },
          {
            "name": "tStack",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TStack"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tStack(bytes32 tSlot) internal pure returns (TStack storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 720
          },
          {
            "name": "tStack",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TStack"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tStack(uint256 tSlot) internal pure returns (TStack storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 728
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TStack"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function length(TStack storage ptr) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(160, shl(128, tload(ptr.slot))) // Removes the base offset and stride.\n        }\n    }",
            "startLine": 736
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TStack"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clear(TStack storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clears the length and increments the base pointer by `1 << 128`.\n            tstore(ptr.slot, shl(128, add(1, shr(128, tload(ptr.slot)))))\n        }\n    }",
            "startLine": 745
          },
          {
            "name": "place",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TStack"
              }
            ],
            "returnValues": [
              {
                "name": "topPtr",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function place(TStack storage ptr) internal returns (bytes32 topPtr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            topPtr := add(0x100000000, tload(ptr.slot)) // Increments by a stride.\n            tstore(ptr.slot, topPtr)\n            topPtr := add(mul(_STACK_BASE_SALT, ptr.slot), topPtr)\n        }\n    }",
            "startLine": 756
          },
          {
            "name": "peek",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TStack"
              }
            ],
            "returnValues": [
              {
                "name": "topPtr",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function peek(TStack storage ptr) internal view returns (bytes32 topPtr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let t := tload(ptr.slot)\n            topPtr := mul(iszero(iszero(shl(128, t))), add(mul(_STACK_BASE_SALT, ptr.slot), t))\n        }\n    }",
            "startLine": 768
          },
          {
            "name": "top",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TStack"
              }
            ],
            "returnValues": [
              {
                "name": "topPtr",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function top(TStack storage ptr) internal view returns (bytes32 topPtr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            topPtr := tload(ptr.slot)\n            if iszero(topPtr) {\n                mstore(0x00, 0xbb704e21) // `StackIsEmpty()`.\n                revert(0x1c, 0x04)\n            }\n            topPtr := add(mul(_STACK_BASE_SALT, ptr.slot), topPtr)\n        }\n    }",
            "startLine": 777
          },
          {
            "name": "pop",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TStack"
              }
            ],
            "returnValues": [
              {
                "name": "lastTopPtr",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function pop(TStack storage ptr) internal returns (bytes32 lastTopPtr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            lastTopPtr := tload(ptr.slot)\n            if iszero(lastTopPtr) {\n                mstore(0x00, 0xbb704e21) // `StackIsEmpty()`.\n                revert(0x1c, 0x04)\n            }\n            tstore(ptr.slot, sub(lastTopPtr, 0x100000000)) // Decrements by a stride.\n            lastTopPtr := add(mul(_STACK_BASE_SALT, ptr.slot), lastTopPtr)\n        }\n    }",
            "startLine": 792
          },
          {
            "name": "registrySet",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function registrySet(bytes32 key, bytes memory value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0xaac438c0) // `set(bytes32,bytes)`.\n            mstore(add(m, 0x20), key)\n            mstore(add(m, 0x40), 0x40)\n            let n := mload(value)\n            mstore(add(m, 0x60), n)\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x80), i), mload(add(add(value, 0x20), i)))\n            }\n            if iszero(\n                mul(\n                    returndatasize(),\n                    call(gas(), REGISTRY, 0, add(m, 0x1c), add(n, 0x64), 0x00, 0x20)\n                )\n            ) { revert(0x00, returndatasize()) }\n        }\n    }",
            "startLine": 814
          },
          {
            "name": "registryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function registryGet(bytes32 key) internal view returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(0x00, 0x8eaa6ac0) // `get(bytes32)`.\n            mstore(0x20, key)\n            if iszero(mul(returndatasize(), staticcall(gas(), REGISTRY, 0x1c, 0x24, 0x00, 0x20))) {\n                revert(0x00, returndatasize())\n            }\n            // We can safely assume that the bytes will be containing the 0x20 offset.\n            returndatacopy(result, 0x20, sub(returndatasize(), 0x20))\n            mstore(0x40, add(result, returndatasize())) // Allocate memory.\n        }\n    }",
            "startLine": 838
          },
          {
            "name": "registryClear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function registryClear(bytes32 key) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x97040a45) // `clear(bytes32)`.\n            mstore(0x20, key)\n            if iszero(mul(returndatasize(), call(gas(), REGISTRY, 0, 0x1c, 0x24, 0x00, 0x20))) {\n                revert(0x00, returndatasize())\n            }\n        }\n    }",
            "startLine": 856
          },
          {
            "name": "registryAdminOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function registryAdminOf(bytes32 key) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0xc5344411) // `adminOf(bytes32)`.\n            mstore(0x20, key)\n            if iszero(mul(returndatasize(), staticcall(gas(), REGISTRY, 0x1c, 0x24, 0x00, 0x20))) {\n                revert(0x00, returndatasize())\n            }\n            result := mload(0x00)\n        }\n    }",
            "startLine": 870
          },
          {
            "name": "registryChangeAdmin",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "newAdmin",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function registryChangeAdmin(bytes32 key, address newAdmin) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, 0x053b1ca3) // `changeAdmin(bytes32,address)`.\n            mstore(0x20, key)\n            mstore(0x40, shr(96, shl(96, newAdmin)))\n            if iszero(mul(returndatasize(), call(gas(), REGISTRY, 0, 0x1c, 0x44, 0x00, 0x20))) {\n                revert(0x00, returndatasize())\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 886
          },
          {
            "name": "_compat",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "TUint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _compat(TUint256 storage ptr) private pure returns (TUint256 storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)\n            mstore(0x00, ptr.slot)\n            c.slot := keccak256(0x00, 0x24)\n        }\n    }",
            "startLine": 905
          },
          {
            "name": "_compat",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "TInt256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _compat(TInt256 storage ptr) private pure returns (TInt256 storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)\n            mstore(0x00, ptr.slot)\n            c.slot := keccak256(0x00, 0x24)\n        }\n    }",
            "startLine": 915
          },
          {
            "name": "_compat",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes32"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "TBytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _compat(TBytes32 storage ptr) private pure returns (TBytes32 storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)\n            mstore(0x00, ptr.slot)\n            c.slot := keccak256(0x00, 0x24)\n        }\n    }",
            "startLine": 925
          },
          {
            "name": "_compat",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "ptr",
                "type": "TAddress"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "TAddress"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _compat(TAddress storage ptr) private pure returns (TAddress storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)\n            mstore(0x00, ptr.slot)\n            c.slot := keccak256(0x00, 0x24)\n        }\n    }",
            "startLine": 935
          },
          {
            "name": "_compat",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBool"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "TBool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _compat(TBool storage ptr) private pure returns (TBool storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)\n            mstore(0x00, ptr.slot)\n            c.slot := keccak256(0x00, 0x24)\n        }\n    }",
            "startLine": 945
          },
          {
            "name": "_compat",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "TBytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _compat(TBytes storage ptr) private pure returns (TBytes storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)\n            mstore(0x00, ptr.slot)\n            c.slot := keccak256(0x00, 0x24)\n        }\n    }",
            "startLine": 955
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "StackIsEmpty",
            "parameters": [],
            "startLine": 58
          }
        ],
        "structs": [
          {
            "name": "TUint256",
            "members": [
              {
                "name": "_spacer",
                "type": "uint256"
              }
            ],
            "startLine": 17
          },
          {
            "name": "TInt256",
            "members": [
              {
                "name": "_spacer",
                "type": "uint256"
              }
            ],
            "startLine": 22
          },
          {
            "name": "TBytes32",
            "members": [
              {
                "name": "_spacer",
                "type": "uint256"
              }
            ],
            "startLine": 27
          },
          {
            "name": "TAddress",
            "members": [
              {
                "name": "_spacer",
                "type": "uint256"
              }
            ],
            "startLine": 32
          },
          {
            "name": "TBool",
            "members": [
              {
                "name": "_spacer",
                "type": "uint256"
              }
            ],
            "startLine": 37
          },
          {
            "name": "TBytes",
            "members": [
              {
                "name": "_spacer",
                "type": "uint256"
              }
            ],
            "startLine": 42
          },
          {
            "name": "TStack",
            "members": [
              {
                "name": "_spacer",
                "type": "uint256"
              }
            ],
            "startLine": 49
          }
        ],
        "stateVariables": [
          {
            "name": "_LIB_TRANSIENT_COMPAT_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 66
          },
          {
            "name": "_STACK_BASE_SALT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 70
          },
          {
            "name": "REGISTRY",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 74
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibZip",
        "filePath": "utils/LibZip.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "flzCompress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function flzCompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function ms8(d_, v_) -> _d {\n                mstore8(d_, v_)\n                _d := add(d_, 1)\n            }\n            function u24(p_) -> _u {\n                _u := mload(p_)\n                _u := or(shl(16, byte(2, _u)), or(shl(8, byte(1, _u)), byte(0, _u)))\n            }\n            function cmp(p_, q_, e_) -> _l {\n                for { e_ := sub(e_, q_) } lt(_l, e_) { _l := add(_l, 1) } {\n                    e_ := mul(iszero(byte(0, xor(mload(add(p_, _l)), mload(add(q_, _l))))), e_)\n                }\n            }\n            function literals(runs_, src_, dest_) -> _o {\n                for { _o := dest_ } iszero(lt(runs_, 0x20)) { runs_ := sub(runs_, 0x20) } {\n                    mstore(ms8(_o, 31), mload(src_))\n                    _o := add(_o, 0x21)\n                    src_ := add(src_, 0x20)\n                }\n                if iszero(runs_) { leave }\n                mstore(ms8(_o, sub(runs_, 1)), mload(src_))\n                _o := add(1, add(_o, runs_))\n            }\n            function mt(l_, d_, o_) -> _o {\n                for { d_ := sub(d_, 1) } iszero(lt(l_, 263)) { l_ := sub(l_, 262) } {\n                    o_ := ms8(ms8(ms8(o_, add(224, shr(8, d_))), 253), and(0xff, d_))\n                }\n                if iszero(lt(l_, 7)) {\n                    _o := ms8(ms8(ms8(o_, add(224, shr(8, d_))), sub(l_, 7)), and(0xff, d_))\n                    leave\n                }\n                _o := ms8(ms8(o_, add(shl(5, l_), shr(8, d_))), and(0xff, d_))\n            }\n            function setHash(i_, v_) {\n                let p_ := add(mload(0x40), shl(2, i_))\n                mstore(p_, xor(mload(p_), shl(224, xor(shr(224, mload(p_)), v_))))\n            }\n            function getHash(i_) -> _h {\n                _h := shr(224, mload(add(mload(0x40), shl(2, i_))))\n            }\n            function hash(v_) -> _r {\n                _r := and(shr(19, mul(2654435769, v_)), 0x1fff)\n            }\n            function setNextHash(ip_, ipStart_) -> _ip {\n                setHash(hash(u24(ip_)), sub(ip_, ipStart_))\n                _ip := add(ip_, 1)\n            }\n            result := mload(0x40)\n            calldatacopy(result, calldatasize(), 0x8000) // Zeroize the hashmap.\n            let op := add(result, 0x8000)\n            let a := add(data, 0x20)\n            let ipStart := a\n            let ipLimit := sub(add(ipStart, mload(data)), 13)\n            for { let ip := add(2, a) } lt(ip, ipLimit) {} {\n                let r := 0\n                let d := 0\n                for {} 1 {} {\n                    let s := u24(ip)\n                    let h := hash(s)\n                    r := add(ipStart, getHash(h))\n                    setHash(h, sub(ip, ipStart))\n                    d := sub(ip, r)\n                    if iszero(lt(ip, ipLimit)) { break }\n                    ip := add(ip, 1)\n                    if iszero(gt(d, 0x1fff)) { if eq(s, u24(r)) { break } }\n                }\n                if iszero(lt(ip, ipLimit)) { break }\n                ip := sub(ip, 1)\n                if gt(ip, a) { op := literals(sub(ip, a), a, op) }\n                let l := cmp(add(r, 3), add(ip, 3), add(ipLimit, 9))\n                op := mt(l, d, op)\n                ip := setNextHash(setNextHash(add(ip, l), ipStart), ipStart)\n                a := ip\n            }\n            // Copy the result to compact the memory, overwriting the hashmap.\n            let end := sub(literals(sub(add(ipStart, mload(data)), a), a, op), 0x7fe0)\n            let o := add(result, 0x20)\n            mstore(result, sub(end, o)) // Store the length.\n            for {} iszero(gt(o, end)) { o := add(o, 0x20) } { mstore(o, mload(add(o, 0x7fe0))) }\n            mstore(end, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(end, 0x20)) // Allocate the memory.\n        }\n    }",
            "startLine": 23
          },
          {
            "name": "flzDecompress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function flzDecompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let op := add(result, 0x20)\n            let end := add(add(data, 0x20), mload(data))\n            for { data := add(data, 0x20) } lt(data, end) {} {\n                let w := mload(data)\n                let c := byte(0, w)\n                let t := shr(5, c)\n                if iszero(t) {\n                    mstore(op, mload(add(data, 1)))\n                    data := add(data, add(2, c))\n                    op := add(op, add(1, c))\n                    continue\n                }\n                for {\n                    let g := eq(t, 7)\n                    let l := add(2, xor(t, mul(g, xor(t, add(7, byte(1, w)))))) // M\n                    let s := add(add(shl(8, and(0x1f, c)), byte(add(1, g), w)), 1) // R\n                    let r := sub(op, s)\n                    let f := xor(s, mul(gt(s, 0x20), xor(s, 0x20)))\n                    let j := 0\n                } 1 {} {\n                    mstore(add(op, j), mload(add(r, j)))\n                    j := add(j, f)\n                    if lt(j, l) { continue }\n                    data := add(data, add(2, g))\n                    op := add(op, l)\n                    break\n                }\n            }\n            mstore(result, sub(op, add(result, 0x20))) // Store the length.\n            mstore(op, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(op, 0x20)) // Allocate the memory.\n        }\n    }",
            "startLine": 111
          },
          {
            "name": "cdCompress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function cdCompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function countLeadingZeroBytes(x_) -> _r {\n                _r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x_))\n                _r := or(_r, shl(6, lt(0xffffffffffffffff, shr(_r, x_))))\n                _r := or(_r, shl(5, lt(0xffffffff, shr(_r, x_))))\n                _r := or(_r, shl(4, lt(0xffff, shr(_r, x_))))\n                _r := xor(31, or(shr(3, _r), lt(0xff, shr(_r, x_))))\n            }\n            function min(x_, y_) -> _z {\n                _z := xor(x_, mul(xor(x_, y_), lt(y_, x_)))\n            }\n            result := mload(0x40)\n            let end := add(data, mload(data))\n            let m := 0x7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f\n            let o := add(result, 0x20)\n            for { let i := data } iszero(eq(i, end)) {} {\n                i := add(i, 1)\n                let c := byte(31, mload(i))\n                if iszero(c) {\n                    for {} 1 {} {\n                        let x := mload(add(i, 0x20))\n                        if iszero(x) {\n                            let r := min(sub(end, i), 0x20)\n                            r := min(sub(0x7f, c), r)\n                            i := add(i, r)\n                            c := add(c, r)\n                            if iszero(gt(r, 0x1f)) { break }\n                            continue\n                        }\n                        let r := countLeadingZeroBytes(x)\n                        r := min(sub(end, i), r)\n                        i := add(i, r)\n                        c := add(c, r)\n                        break\n                    }\n                    mstore(o, shl(240, c))\n                    o := add(o, 2)\n                    continue\n                }\n                if eq(c, 0xff) {\n                    let r := 0x20\n                    let x := not(mload(add(i, r)))\n                    if x { r := countLeadingZeroBytes(x) }\n                    r := min(min(sub(end, i), r), 0x1f)\n                    i := add(i, r)\n                    mstore(o, shl(240, or(r, 0x80)))\n                    o := add(o, 2)\n                    continue\n                }\n                mstore8(o, c)\n                o := add(o, 1)\n                c := mload(add(i, 0x20))\n                mstore(o, c)\n                // `.each(b => b == 0x00 || b == 0xff ? 0x80 : 0x00)`.\n                c := not(or(and(or(add(and(c, m), m), c), or(add(and(not(c), m), m), not(c))), m))\n                let r := shl(7, lt(0x8421084210842108cc6318c6db6d54be, c)) // Save bytecode.\n                r := or(shl(6, lt(0xffffffffffffffff, shr(r, c))), r)\n                // forgefmt: disable-next-item\n                r := add(iszero(c), shr(3, xor(byte(and(0x1f, shr(byte(24,\n                    mul(0x02040810204081, shr(r, c))), 0x8421084210842108cc6318c6db6d54be)),\n                    0xc0c8c8d0c8e8d0d8c8e8e0e8d0d8e0f0c8d0e8d0e0e0d8f0d0d0e0d8f8f8f8f8), r)))\n                r := min(sub(end, i), r)\n                o := add(o, r)\n                i := add(i, r)\n            }\n            // Bitwise negate the first 4 bytes.\n            mstore(add(result, 4), not(mload(add(result, 4))))\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }",
            "startLine": 167
          },
          {
            "name": "cdDecompress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function cdDecompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(data) {\n                result := mload(0x40)\n                let s := add(data, 4)\n                let v := mload(s)\n                let end := add(add(0x20, data), mload(data))\n                let m := 0x7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f\n                let o := add(result, 0x20)\n                mstore(s, not(v)) // Bitwise negate the first 4 bytes.\n                for { let i := add(0x20, data) } 1 {} {\n                    let c := mload(i)\n                    if iszero(byte(0, c)) {\n                        c := add(1, byte(1, c))\n                        if iszero(gt(c, 0x80)) {\n                            i := add(i, 2)\n                            calldatacopy(o, calldatasize(), c) // Fill with 0x00.\n                            o := add(o, c)\n                            if iszero(lt(i, end)) { break }\n                            continue\n                        }\n                        i := add(i, 2)\n                        mstore(o, not(0)) // Fill with 0xff.\n                        o := add(o, sub(c, 0x80))\n                        if iszero(lt(i, end)) { break }\n                        continue\n                    }\n                    mstore(o, c)\n                    c := not(or(or(add(and(c, m), m), c), m)) // `.each(b => b == 0x00 ? 0x80 : 0x00)`.\n                    let r := shl(7, lt(0x8421084210842108cc6318c6db6d54be, c)) // Save bytecode.\n                    r := or(shl(6, lt(0xffffffffffffffff, shr(r, c))), r)\n                    // forgefmt: disable-next-item\n                    c := add(iszero(c), shr(3, xor(byte(and(0x1f, shr(byte(24,\n                        mul(0x02040810204081, shr(r, c))), 0x8421084210842108cc6318c6db6d54be)),\n                        0xc0c8c8d0c8e8d0d8c8e8e0e8d0d8e0f0c8d0e8d0e0e0d8f0d0d0e0d8f8f8f8f8), r)))\n                    o := add(o, c)\n                    i := add(i, c)\n                    if lt(i, end) { continue }\n                    if gt(i, end) { o := sub(o, sub(i, end)) }\n                    break\n                }\n                mstore(s, v) // Restore the first 4 bytes.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n                mstore(o, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x20)) // Allocate the memory.\n            }\n        }\n    }",
            "startLine": 243
          },
          {
            "name": "cdFallback",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function cdFallback() internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(calldatasize()) { return(calldatasize(), calldatasize()) }\n            let o := 0\n            let f := not(3) // For negating the first 4 bytes.\n            for { let i := 0 } lt(i, calldatasize()) {} {\n                let c := byte(0, xor(add(i, f), calldataload(i)))\n                i := add(i, 1)\n                if iszero(c) {\n                    let d := byte(0, xor(add(i, f), calldataload(i)))\n                    i := add(i, 1)\n                    // Fill with either 0xff or 0x00.\n                    mstore(o, not(0))\n                    if iszero(gt(d, 0x7f)) { calldatacopy(o, calldatasize(), add(d, 1)) }\n                    o := add(o, add(and(d, 0x7f), 1))\n                    continue\n                }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            let success := delegatecall(gas(), address(), 0x00, o, codesize(), 0x00)\n            returndatacopy(0x00, 0x00, returndatasize())\n            if iszero(success) { revert(0x00, returndatasize()) }\n            return(0x00, returndatasize())\n        }\n    }",
            "startLine": 300
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "Lifebuoy",
        "filePath": "utils/Lifebuoy.sol",
        "kind": "contract",
        "inherits": [],
        "implements": [],
        "category": "utils",
        "externalFunctions": [
          {
            "name": "rescueETH",
            "signature": "rescueETH(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function rescueETH(address to, uint256 amount)\n        public\n        payable\n        virtual\n        onlyRescuer(_LIFEBUOY_RESCUE_ETH_LOCK)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0x7ec62e76) // `RescueTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 133
          },
          {
            "name": "rescueERC20",
            "signature": "rescueERC20(address,address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function rescueERC20(address token, address to, uint256 amount)\n        public\n        payable\n        virtual\n        onlyRescuer(_LIFEBUOY_RESCUE_ERC20_LOCK)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            // `RescueTransferFailed()` and `transfer(address,uint256)`.\n            mstore(0x00, shl(96, 0x7ec62e76a9059cbb))\n            if iszero(call(gas(), token, callvalue(), 0x10, 0x44, codesize(), 0x00)) {\n                revert(0x0c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }",
            "startLine": 150
          },
          {
            "name": "rescueERC721",
            "signature": "rescueERC721(address,address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function rescueERC721(address token, address to, uint256 id)\n        public\n        payable\n        virtual\n        onlyRescuer(_LIFEBUOY_RESCUE_ERC721_LOCK)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, id) // Store the `id` argument.\n            mstore(0x40, shr(96, shl(96, to))) // Store the `to` argument.\n            mstore(0x20, address()) // Store the `from` argument.\n            // `RescueTransferFailed()` and `transferFrom(address,address,uint256)`.\n            mstore(0x00, 0x7ec62e7623b872dd)\n            if iszero(call(gas(), token, callvalue(), 0x1c, 0x64, codesize(), 0x00)) {\n                revert(0x18, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 171
          },
          {
            "name": "rescueERC1155",
            "signature": "rescueERC1155(address,address,uint256,uint256,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function rescueERC1155(\n        address token,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public payable virtual onlyRescuer(_LIFEBUOY_RESCUE_ERC1155_LOCK) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            // `RescueTransferFailed()` and `safeTransferFrom(address,address,uint256,uint256,bytes)`.\n            mstore(m, 0x7ec62e76f242432a)\n            mstore(add(0x20, m), address()) // Store the `from` argument.\n            mstore(add(0x40, m), shr(96, shl(96, to))) // Store the `to` argument.\n            mstore(add(0x60, m), id) // Store the `id` argument.\n            mstore(add(0x80, m), amount) // Store the `amount` argument.\n            mstore(add(0xa0, m), 0xa0) // Store the offset to `data`.\n            mstore(add(0xc0, m), data.length)\n            calldatacopy(add(m, 0xe0), data.offset, data.length)\n            // forgefmt: disable-next-item\n            if iszero(\n                call(gas(), token, callvalue(), add(m, 0x1c), add(0xc4, data.length), codesize(), 0x00)\n            ) { revert(add(m, 0x18), 0x04) }\n        }\n    }",
            "startLine": 195
          },
          {
            "name": "rescueERC6909",
            "signature": "rescueERC6909(address,address,uint256,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function rescueERC6909(address token, address to, uint256 id, uint256 amount)\n        public\n        payable\n        virtual\n        onlyRescuer(_LIFEBUOY_RESCUE_ERC6909_LOCK)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, id) // Store the `id` argument.\n            mstore(0x54, amount) // Store the `amount` argument.\n            // `RescueTransferFailed()` and `transfer(address,uint256,uint256)`.\n            mstore(0x00, shl(96, 0x7ec62e76095bcdb6))\n            if iszero(call(gas(), token, callvalue(), 0x10, 0x64, codesize(), 0x00)) {\n                revert(0x0c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 223
          },
          {
            "name": "rescueLocked",
            "signature": "rescueLocked()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "locks",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function rescueLocked() public view virtual returns (uint256 locks) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            locks := sload(_RESCUE_LOCKED_FLAGS_SLOT)\n        }\n    }",
            "startLine": 251
          },
          {
            "name": "lockRescue",
            "signature": "lockRescue(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "locksToSet",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_lockRescue",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function lockRescue(uint256 locksToSet)\n        public\n        payable\n        virtual\n        onlyRescuer(_LIFEBUOY_LOCK_RESCUE_LOCK)\n    {\n        _lockRescue(locksToSet);\n    }",
            "startLine": 259
          }
        ],
        "internalFunctions": [
          {
            "name": "constructor",
            "visibility": "default",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_lifebuoyDefaultDeployer",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "constructor() payable {\n        bytes32 hash;\n        uint256 deployer = uint160(_lifebuoyDefaultDeployer());\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, address())\n            mstore(0x20, deployer)\n            hash := keccak256(0x00, 0x40)\n        }\n        _lifebuoyDeployerHash = hash;\n    }",
            "startLine": 105
          },
          {
            "name": "_lifebuoyDefaultDeployer",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _lifebuoyDefaultDeployer() internal view virtual returns (address) {\n        // I know about EIP7645, and I will stop it if it gets traction.\n        // Worse case, I will add an `ecrecover` method. But not today.\n        return tx.origin;\n    }",
            "startLine": 121
          },
          {
            "name": "_lockRescue",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "locksToSet",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _lockRescue(uint256 locksToSet) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := _RESCUE_LOCKED_FLAGS_SLOT\n            sstore(s, or(sload(s), locksToSet))\n        }\n    }",
            "startLine": 269
          },
          {
            "name": "_checkRescuer",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "modeLock",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "rescueLocked",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkRescuer(uint256 modeLock) internal view virtual {\n        uint256 locks = rescueLocked();\n        bytes32 h = _lifebuoyDeployerHash;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                // If the `modeLock` flag is true, set all bits in `locks` to true.\n                locks := or(sub(0, iszero(iszero(and(modeLock, locks)))), locks)\n                // Caller is the deployer\n                // AND the contract is not a proxy\n                // AND `locks & _LIFEBUOY_DEPLOYER_ACCESS_LOCK` is false.\n                mstore(0x20, caller())\n                mstore(and(locks, _LIFEBUOY_DEPLOYER_ACCESS_LOCK), address())\n                if eq(keccak256(0x00, 0x40), h) { break }\n                // If the caller is `owner()`\n                // AND `locks & _LIFEBUOY_OWNER_ACCESS_LOCK` is false.\n                mstore(0x08, 0x8da5cb5b0a0362e0) // `owner()` and `RescueUnauthorizedOrLocked()`.\n                if and( // The arguments of `and` are evaluated from right to left.\n                    lt(\n                        and(locks, _LIFEBUOY_OWNER_ACCESS_LOCK),\n                        and(gt(returndatasize(), 0x1f), eq(mload(0x00), caller()))\n                    ),\n                    staticcall(gas(), address(), 0x20, 0x04, 0x00, 0x20)\n                ) { break }\n                revert(0x24, 0x04)\n            }\n        }\n    }",
            "startLine": 282
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "RescueUnauthorizedOrLocked",
            "parameters": [],
            "startLine": 43
          },
          {
            "name": "RescueTransferFailed",
            "parameters": [],
            "startLine": 46
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_LIFEBUOY_DEPLOYER_ACCESS_LOCK",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 56
          },
          {
            "name": "_LIFEBUOY_OWNER_ACCESS_LOCK",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 59
          },
          {
            "name": "_LIFEBUOY_LOCK_RESCUE_LOCK",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 62
          },
          {
            "name": "_LIFEBUOY_RESCUE_ETH_LOCK",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 65
          },
          {
            "name": "_LIFEBUOY_RESCUE_ERC20_LOCK",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 68
          },
          {
            "name": "_LIFEBUOY_RESCUE_ERC721_LOCK",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 71
          },
          {
            "name": "_LIFEBUOY_RESCUE_ERC1155_LOCK",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 74
          },
          {
            "name": "_LIFEBUOY_RESCUE_ERC6909_LOCK",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 77
          },
          {
            "name": "_lifebuoyDeployerHash",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": false,
            "isImmutable": true,
            "startLine": 86
          },
          {
            "name": "_RESCUE_LOCKED_FLAGS_SLOT",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 98
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "MerkleProofLib",
        "filePath": "utils/MerkleProofLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "verify",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "proof",
                "type": "bytes32[]"
              },
              {
                "name": "root",
                "type": "bytes32"
              },
              {
                "name": "leaf",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)\n        internal\n        pure\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(proof) {\n                // Initialize `offset` to the offset of `proof` elements in memory.\n                let offset := add(proof, 0x20)\n                // Left shift by 5 is equivalent to multiplying by 0x20.\n                let end := add(offset, shl(5, mload(proof)))\n                // Iterate over proof elements to compute root hash.\n                for {} 1 {} {\n                    // Slot of `leaf` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(leaf, mload(offset)))\n                    // Store elements to hash contiguously in scratch space.\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\n                    mstore(scratch, leaf)\n                    mstore(xor(scratch, 0x20), mload(offset))\n                    // Reuse `leaf` to store the hash to reduce stack operations.\n                    leaf := keccak256(0x00, 0x40)\n                    offset := add(offset, 0x20)\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n            isValid := eq(leaf, root)\n        }\n    }",
            "startLine": 14
          },
          {
            "name": "verifyCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "proof",
                "type": "bytes32[]"
              },
              {
                "name": "root",
                "type": "bytes32"
              },
              {
                "name": "leaf",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf)\n        internal\n        pure\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if proof.length {\n                // Left shift by 5 is equivalent to multiplying by 0x20.\n                let end := add(proof.offset, shl(5, proof.length))\n                // Initialize `offset` to the offset of `proof` in the calldata.\n                let offset := proof.offset\n                // Iterate over proof elements to compute root hash.\n                for {} 1 {} {\n                    // Slot of `leaf` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(leaf, calldataload(offset)))\n                    // Store elements to hash contiguously in scratch space.\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\n                    mstore(scratch, leaf)\n                    mstore(xor(scratch, 0x20), calldataload(offset))\n                    // Reuse `leaf` to store the hash to reduce stack operations.\n                    leaf := keccak256(0x00, 0x40)\n                    offset := add(offset, 0x20)\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n            isValid := eq(leaf, root)\n        }\n    }",
            "startLine": 46
          },
          {
            "name": "verifyMultiProof",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "proof",
                "type": "bytes32[]"
              },
              {
                "name": "root",
                "type": "bytes32"
              },
              {
                "name": "leaves",
                "type": "bytes32[]"
              },
              {
                "name": "flags",
                "type": "bool[]"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function verifyMultiProof(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32[] memory leaves,\n        bool[] memory flags\n    ) internal pure returns (bool isValid) {\n        // Rebuilds the root by consuming and producing values on a queue.\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\n        // After the process, the last element on the queue is verified\n        // to be equal to the `root`.\n        //\n        // The `flags` array denotes whether the sibling\n        // should be popped from the queue (`flag == true`), or\n        // should be popped from the `proof` (`flag == false`).\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cache the lengths of the arrays.\n            let leavesLength := mload(leaves)\n            let proofLength := mload(proof)\n            let flagsLength := mload(flags)\n\n            // Advance the pointers of the arrays to point to the data.\n            leaves := add(0x20, leaves)\n            proof := add(0x20, proof)\n            flags := add(0x20, flags)\n\n            // If the number of flags is correct.\n            for {} eq(add(leavesLength, proofLength), add(flagsLength, 1)) {} {\n                // For the case where `proof.length + leaves.length == 1`.\n                if iszero(flagsLength) {\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\n                    isValid := eq(mload(xor(leaves, mul(xor(proof, leaves), proofLength))), root)\n                    break\n                }\n\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\n                let proofEnd := add(proof, shl(5, proofLength))\n                // We can use the free memory space for the queue.\n                // We don't need to allocate, since the queue is temporary.\n                let hashesFront := mload(0x40)\n                // Copy the leaves into the hashes.\n                // Sometimes, a little memory expansion costs less than branching.\n                // Should cost less, even with a high free memory offset of 0x7d00.\n                leavesLength := shl(5, leavesLength)\n                for { let i := 0 } iszero(eq(i, leavesLength)) { i := add(i, 0x20) } {\n                    mstore(add(hashesFront, i), mload(add(leaves, i)))\n                }\n                // Compute the back of the hashes.\n                let hashesBack := add(hashesFront, leavesLength)\n                // This is the end of the memory for the queue.\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\n                flagsLength := add(hashesBack, shl(5, flagsLength))\n\n                for {} 1 {} {\n                    // Pop from `hashes`.\n                    let a := mload(hashesFront)\n                    // Pop from `hashes`.\n                    let b := mload(add(hashesFront, 0x20))\n                    hashesFront := add(hashesFront, 0x40)\n\n                    // If the flag is false, load the next proof,\n                    // else, pops from the queue.\n                    if iszero(mload(flags)) {\n                        // Loads the next proof.\n                        b := mload(proof)\n                        proof := add(proof, 0x20)\n                        // Unpop from `hashes`.\n                        hashesFront := sub(hashesFront, 0x20)\n                    }\n\n                    // Advance to the next flag.\n                    flags := add(flags, 0x20)\n\n                    // Slot of `a` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(a, b))\n                    // Hash the scratch space and push the result onto the queue.\n                    mstore(scratch, a)\n                    mstore(xor(scratch, 0x20), b)\n                    mstore(hashesBack, keccak256(0x00, 0x40))\n                    hashesBack := add(hashesBack, 0x20)\n                    if iszero(lt(hashesBack, flagsLength)) { break }\n                }\n                isValid := and(\n                    // Checks if the last value in the queue is same as the root.\n                    eq(mload(sub(hashesBack, 0x20)), root),\n                    // And whether all the proofs are used, if required.\n                    eq(proofEnd, proof)\n                )\n                break\n            }\n        }\n    }",
            "startLine": 87
          },
          {
            "name": "verifyMultiProofCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "proof",
                "type": "bytes32[]"
              },
              {
                "name": "root",
                "type": "bytes32"
              },
              {
                "name": "leaves",
                "type": "bytes32[]"
              },
              {
                "name": "flags",
                "type": "bool[]"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function verifyMultiProofCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32[] calldata leaves,\n        bool[] calldata flags\n    ) internal pure returns (bool isValid) {\n        // Rebuilds the root by consuming and producing values on a queue.\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\n        // After the process, the last element on the queue is verified\n        // to be equal to the `root`.\n        //\n        // The `flags` array denotes whether the sibling\n        // should be popped from the queue (`flag == true`), or\n        // should be popped from the `proof` (`flag == false`).\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the number of flags is correct.\n            for {} eq(add(leaves.length, proof.length), add(flags.length, 1)) {} {\n                // For the case where `proof.length + leaves.length == 1`.\n                if iszero(\n                    flags.length\n                ) {\n\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\n                    // forgefmt: disable-next-item\n                    isValid := eq(\n                        calldataload(\n                            xor(leaves.offset, mul(xor(proof.offset, leaves.offset), proof.length))\n                        ),\n                        root\n                    )\n                    break\n                }\n\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\n                let proofEnd := add(proof.offset, shl(5, proof.length))\n                // We can use the free memory space for the queue.\n                // We don't need to allocate, since the queue is temporary.\n                let hashesFront := mload(0x40)\n                // Copy the leaves into the hashes.\n                // Sometimes, a little memory expansion costs less than branching.\n                // Should cost less, even with a high free memory offset of 0x7d00.\n                calldatacopy(hashesFront, leaves.offset, shl(5, leaves.length))\n                // Compute the back of the hashes.\n                let hashesBack := add(hashesFront, shl(5, leaves.length))\n                // This is the end of the memory for the queue.\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\n                flags.length := add(hashesBack, shl(5, flags.length))\n\n                // We don't need to make a copy of `proof.offset` or `flags.offset`,\n                // as they are pass-by-value (this trick may not always save gas).\n\n                for {} 1 {} {\n                    // Pop from `hashes`.\n                    let a := mload(hashesFront)\n                    // Pop from `hashes`.\n                    let b := mload(add(hashesFront, 0x20))\n                    hashesFront := add(hashesFront, 0x40)\n\n                    // If the flag is false, load the next proof,\n                    // else, pops from the queue.\n                    if iszero(calldataload(flags.offset)) {\n                        // Loads the next proof.\n                        b := calldataload(proof.offset)\n                        proof.offset := add(proof.offset, 0x20)\n                        // Unpop from `hashes`.\n                        hashesFront := sub(hashesFront, 0x20)\n                    }\n\n                    // Advance to the next flag offset.\n                    flags.offset := add(flags.offset, 0x20)\n\n                    // Slot of `a` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(a, b))\n                    // Hash the scratch space and push the result onto the queue.\n                    mstore(scratch, a)\n                    mstore(xor(scratch, 0x20), b)\n                    mstore(hashesBack, keccak256(0x00, 0x40))\n                    hashesBack := add(hashesBack, 0x20)\n                    if iszero(lt(hashesBack, flags.length)) { break }\n                }\n                isValid := and(\n                    // Checks if the last value in the queue is same as the root.\n                    eq(mload(sub(hashesBack, 0x20)), root),\n                    // And whether all the proofs are used, if required.\n                    eq(proofEnd, proof.offset)\n                )\n                break\n            }\n        }\n    }",
            "startLine": 190
          },
          {
            "name": "emptyProof",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "proof",
                "type": "bytes32[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function emptyProof() internal pure returns (bytes32[] calldata proof) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            proof.length := 0\n        }\n    }",
            "startLine": 288
          },
          {
            "name": "emptyLeaves",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "leaves",
                "type": "bytes32[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function emptyLeaves() internal pure returns (bytes32[] calldata leaves) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            leaves.length := 0\n        }\n    }",
            "startLine": 296
          },
          {
            "name": "emptyFlags",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "flags",
                "type": "bool[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function emptyFlags() internal pure returns (bool[] calldata flags) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            flags.length := 0\n        }\n    }",
            "startLine": 304
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "MerkleTreeLib",
        "filePath": "utils/MerkleTreeLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "build",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "leaves",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "tree",
                "type": "bytes32[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function build(bytes32[] memory leaves) internal pure returns (bytes32[] memory tree) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tree := mload(0x40) // `nodes`.\n            let l := mload(leaves)\n            if iszero(l) {\n                mstore(0x00, 0xe7171dc4) // `MerkleTreeLeavesEmpty()`.\n                revert(0x1c, 0x04)\n            }\n            let n := sub(add(l, l), 1)\n            mstore(tree, n) // `.length`.\n            let nodes := add(tree, 0x20)\n            let f := add(nodes, shl(5, n))\n            mstore(0x40, f) // Allocate memory.\n            let e := add(0x20, shl(5, l))\n            for { let i := 0x20 } 1 {} {\n                mstore(sub(f, i), mload(add(leaves, i)))\n                i := add(i, 0x20)\n                if eq(i, e) { break }\n            }\n            if iszero(lt(l, 2)) {\n                for { let i := shl(5, sub(l, 2)) } 1 {} {\n                    let left := mload(add(nodes, add(add(i, i), 0x20)))\n                    let right := mload(add(nodes, add(add(i, i), 0x40)))\n                    let c := shl(5, lt(left, right))\n                    mstore(c, right)\n                    mstore(xor(c, 0x20), left)\n                    mstore(add(nodes, i), keccak256(0x00, 0x40))\n                    if iszero(i) { break }\n                    i := sub(i, 0x20)\n                }\n            }\n        }\n    }",
            "startLine": 38
          },
          {
            "name": "root",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tree",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function root(bytes32[] memory tree) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(0x20, tree))\n            if iszero(mload(tree)) {\n                mstore(0x00, 0x7a856a38) // `MerkleTreeOutOfBoundsAccess()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 74
          },
          {
            "name": "numLeaves",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tree",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function numLeaves(bytes32[] memory tree) internal pure returns (uint256) {\n        unchecked {\n            return tree.length - (tree.length >> 1);\n        }\n    }",
            "startLine": 86
          },
          {
            "name": "numInternalNodes",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tree",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function numInternalNodes(bytes32[] memory tree) internal pure returns (uint256) {\n        return tree.length >> 1;\n    }",
            "startLine": 93
          },
          {
            "name": "leaf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tree",
                "type": "bytes32[]"
              },
              {
                "name": "leafIndex",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function leaf(bytes32[] memory tree, uint256 leafIndex) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(tree)\n            if iszero(lt(leafIndex, sub(n, shr(1, n)))) {\n                mstore(0x00, 0x7a856a38) // `MerkleTreeOutOfBoundsAccess()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(add(tree, shl(5, sub(n, leafIndex))))\n        }\n    }",
            "startLine": 98
          },
          {
            "name": "gatherLeaves",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tree",
                "type": "bytes32[]"
              },
              {
                "name": "leafIndices",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function gatherLeaves(bytes32[] memory tree, uint256[] memory leafIndices)\n        internal\n        pure\n        returns (bytes32[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let l := mload(leafIndices)\n            mstore(result, l) // `.length`.\n            let d := sub(leafIndices, result)\n            let n := mload(tree)\n            let o := add(result, 0x20)\n            for { let i := 0 } iszero(eq(i, l)) { i := add(i, 1) } {\n                let j := add(o, shl(5, i))\n                let leafIndex := mload(add(j, d))\n                if iszero(lt(leafIndex, sub(n, shr(1, n)))) {\n                    mstore(0x00, 0x7a856a38) // `MerkleTreeOutOfBoundsAccess()`.\n                    revert(0x1c, 0x04)\n                }\n                mstore(j, mload(add(tree, shl(5, sub(n, leafIndex)))))\n            }\n            mstore(0x40, add(o, shl(5, l))) // Allocate memory.\n        }\n    }",
            "startLine": 111
          },
          {
            "name": "leafProof",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tree",
                "type": "bytes32[]"
              },
              {
                "name": "leafIndex",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32[]"
              }
            ],
            "calls": [
              {
                "target": "nodeProof",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function leafProof(bytes32[] memory tree, uint256 leafIndex)\n        internal\n        pure\n        returns (bytes32[] memory result)\n    {\n        uint256 nodeIndex;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(tree)\n            nodeIndex := sub(n, add(1, leafIndex))\n            if iszero(lt(leafIndex, sub(n, shr(1, n)))) { nodeIndex := not(0) }\n        }\n        result = nodeProof(tree, nodeIndex);\n    }",
            "startLine": 138
          },
          {
            "name": "nodeProof",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tree",
                "type": "bytes32[]"
              },
              {
                "name": "nodeIndex",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function nodeProof(bytes32[] memory tree, uint256 nodeIndex)\n        internal\n        pure\n        returns (bytes32[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            if iszero(lt(nodeIndex, mload(tree))) {\n                mstore(0x00, 0x7a856a38) // `MerkleTreeOutOfBoundsAccess()`.\n                revert(0x1c, 0x04)\n            }\n            let o := add(result, 0x20)\n            for { let i := nodeIndex } i { i := shr(1, sub(i, 1)) } {\n                mstore(o, mload(add(tree, shl(5, add(i, shl(1, and(1, i)))))))\n                o := add(o, 0x20)\n            }\n            mstore(0x40, o) // Allocate memory.\n            mstore(result, shr(5, sub(o, add(result, 0x20)))) // Store length.\n        }\n    }",
            "startLine": 155
          },
          {
            "name": "multiProofForLeaves",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tree",
                "type": "bytes32[]"
              },
              {
                "name": "leafIndices",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "proof",
                "type": "bytes32[]"
              },
              {
                "name": "flags",
                "type": "bool[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function multiProofForLeaves(bytes32[] memory tree, uint256[] memory leafIndices)\n        internal\n        pure\n        returns (bytes32[] memory proof, bool[] memory flags)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function gen(leafIndices_, t_, proof_, flags_) -> _flagsLen, _proofLen {\n                let q_ := mload(0x40) // Circular buffer.\n                let c_ := mload(leafIndices_) // Capacity of circular buffer.\n                let e_ := c_ // End index of circular buffer.\n                let b_ := 0 // Start index of circular buffer.\n                for {\n                    let n_ := mload(t_) // Num nodes.\n                    let l_ := sub(n_, shr(1, n_)) // Num leaves.\n                    let p_ := not(0)\n                    let i_ := 0\n                } 1 {} {\n                    let j_ := mload(add(add(leafIndices_, 0x20), shl(5, i_))) // Leaf index.\n                    if flags_ {\n                        if iszero(lt(j_, l_)) {\n                            mstore(0x00, 0x7a856a38) // `MerkleTreeOutOfBoundsAccess()`.\n                            revert(0x1c, 0x04)\n                        }\n                        if iszero(sgt(j_, p_)) {\n                            mstore(0x00, 0xe9729976) // `MerkleTreeInvalidLeafIndices()`.\n                            revert(0x1c, 0x04)\n                        }\n                        p_ := j_\n                    }\n                    mstore(add(q_, shl(5, i_)), sub(n_, add(1, j_)))\n                    i_ := add(i_, 1)\n                    if eq(i_, e_) { break }\n                }\n                for {} 1 {} {\n                    if iszero(lt(b_, e_)) { break }\n                    let j_ := mload(add(q_, shl(5, mod(b_, c_)))) // Current.\n                    if iszero(j_) { break }\n                    b_ := add(b_, 1)\n                    let s_ := add(j_, shl(1, and(j_, 1))) // Sibling (+1).\n                    _flagsLen := add(_flagsLen, 0x20)\n                    let f_ := and(eq(s_, add(1, mload(add(q_, shl(5, mod(b_, c_)))))), lt(b_, e_))\n                    b_ := add(b_, f_)\n                    _proofLen := add(_proofLen, shl(5, iszero(f_)))\n                    if flags_ {\n                        mstore(add(flags_, _flagsLen), f_)\n                        mstore(mul(iszero(f_), add(proof_, _proofLen)), mload(add(t_, shl(5, s_))))\n                    }\n                    mstore(add(q_, shl(5, mod(e_, c_))), shr(1, sub(j_, 1)))\n                    e_ := add(e_, 1)\n                }\n                _proofLen := shr(5, _proofLen)\n                _flagsLen := shr(5, _flagsLen)\n            }\n            if iszero(mload(leafIndices)) {\n                mstore(0x00, 0xe9729976) // `MerkleTreeInvalidLeafIndices()`.\n                revert(0x1c, 0x04)\n            }\n            let flagsLen, proofLen := gen(leafIndices, tree, 0x00, 0x00)\n            proof := mload(0x40)\n            mstore(proof, proofLen)\n            flags := add(add(proof, 0x20), shl(5, proofLen))\n            mstore(flags, flagsLen)\n            mstore(0x40, add(add(flags, 0x20), shl(5, flagsLen))) // Allocate memory.\n            flagsLen, proofLen := gen(leafIndices, tree, proof, flags)\n        }\n    }",
            "startLine": 179
          },
          {
            "name": "pad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "leaves",
                "type": "bytes32[]"
              },
              {
                "name": "defaultFill",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function pad(bytes32[] memory leaves, bytes32 defaultFill)\n        internal\n        pure\n        returns (bytes32[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let l := mload(leaves)\n            let p := sub(l, 1)\n            if iszero(lt(p, 0xffffffff)) {\n                mstore(0x00, 0xe7171dc4) // `MerkleTreeLeavesEmpty()`.\n                revert(0x1c, mul(iszero(l), 0x04)) // If `p > 2**32 - 1`, revert with empty.\n            }\n            p := or(shr(1, p), p)\n            p := or(shr(2, p), p)\n            p := or(shr(4, p), p)\n            p := or(shr(8, p), p)\n            p := add(1, or(shr(16, p), p)) // Supports up to `2**32 - 1`.\n            mstore(result, p) // Store length.\n            mstore(0x40, add(result, add(0x20, shl(5, p)))) // Allocate memory.\n            let d := sub(result, leaves)\n            let copyEnd := add(add(leaves, 0x20), shl(5, l))\n            let end := add(add(leaves, 0x20), shl(5, p))\n            mstore(0x00, defaultFill)\n            for { let i := add(leaves, 0x20) } 1 {} {\n                mstore(add(i, d), mload(mul(i, lt(i, copyEnd))))\n                i := add(i, 0x20)\n                if eq(i, end) { break }\n            }\n        }\n    }",
            "startLine": 248
          },
          {
            "name": "pad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "leaves",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32[]"
              }
            ],
            "calls": [
              {
                "target": "pad",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pad(bytes32[] memory leaves) internal pure returns (bytes32[] memory result) {\n        result = pad(leaves, bytes32(0));\n    }",
            "startLine": 282
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "MerkleTreeLeavesEmpty",
            "parameters": [],
            "startLine": 23
          },
          {
            "name": "MerkleTreeOutOfBoundsAccess",
            "parameters": [],
            "startLine": 27
          },
          {
            "name": "MerkleTreeInvalidLeafIndices",
            "parameters": [],
            "startLine": 30
          }
        ],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "MetadataReaderLib",
        "filePath": "utils/MetadataReaderLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "readName",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_string",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_ptr",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function readName(address target) internal view returns (string memory) {\n        return _string(target, _ptr(0x06fdde03), STRING_LIMIT_DEFAULT, GAS_STIPEND_NO_GRIEF);\n    }",
            "startLine": 35
          },
          {
            "name": "readName",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "limit",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_string",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_ptr",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function readName(address target, uint256 limit) internal view returns (string memory) {\n        return _string(target, _ptr(0x06fdde03), limit, GAS_STIPEND_NO_GRIEF);\n    }",
            "startLine": 40
          },
          {
            "name": "readName",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "limit",
                "type": "uint256"
              },
              {
                "name": "gasStipend",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_string",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_ptr",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function readName(address target, uint256 limit, uint256 gasStipend)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(0x06fdde03), limit, gasStipend);\n    }",
            "startLine": 45
          },
          {
            "name": "readSymbol",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_string",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_ptr",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function readSymbol(address target) internal view returns (string memory) {\n        return _string(target, _ptr(0x95d89b41), STRING_LIMIT_DEFAULT, GAS_STIPEND_NO_GRIEF);\n    }",
            "startLine": 54
          },
          {
            "name": "readSymbol",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "limit",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_string",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_ptr",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function readSymbol(address target, uint256 limit) internal view returns (string memory) {\n        return _string(target, _ptr(0x95d89b41), limit, GAS_STIPEND_NO_GRIEF);\n    }",
            "startLine": 59
          },
          {
            "name": "readSymbol",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "limit",
                "type": "uint256"
              },
              {
                "name": "gasStipend",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_string",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_ptr",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function readSymbol(address target, uint256 limit, uint256 gasStipend)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(0x95d89b41), limit, gasStipend);\n    }",
            "startLine": 64
          },
          {
            "name": "readString",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_string",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_ptr",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function readString(address target, bytes memory data) internal view returns (string memory) {\n        return _string(target, _ptr(data), STRING_LIMIT_DEFAULT, GAS_STIPEND_NO_GRIEF);\n    }",
            "startLine": 74
          },
          {
            "name": "readString",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "limit",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_string",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_ptr",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function readString(address target, bytes memory data, uint256 limit)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(data), limit, GAS_STIPEND_NO_GRIEF);\n    }",
            "startLine": 80
          },
          {
            "name": "readString",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "limit",
                "type": "uint256"
              },
              {
                "name": "gasStipend",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_string",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_ptr",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function readString(address target, bytes memory data, uint256 limit, uint256 gasStipend)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(data), limit, gasStipend);\n    }",
            "startLine": 90
          },
          {
            "name": "readDecimals",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [
              {
                "target": "_uint",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_ptr",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function readDecimals(address target) internal view returns (uint8) {\n        return uint8(_uint(target, _ptr(0x313ce567), GAS_STIPEND_NO_GRIEF));\n    }",
            "startLine": 111
          },
          {
            "name": "readDecimals",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "gasStipend",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [
              {
                "target": "_uint",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_ptr",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function readDecimals(address target, uint256 gasStipend) internal view returns (uint8) {\n        return uint8(_uint(target, _ptr(0x313ce567), gasStipend));\n    }",
            "startLine": 116
          },
          {
            "name": "readUint",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_uint",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_ptr",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function readUint(address target, bytes memory data) internal view returns (uint256) {\n        return _uint(target, _ptr(data), GAS_STIPEND_NO_GRIEF);\n    }",
            "startLine": 121
          },
          {
            "name": "readUint",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "gasStipend",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_uint",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_ptr",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function readUint(address target, bytes memory data, uint256 gasStipend)\n        internal\n        view\n        returns (uint256)\n    {\n        return _uint(target, _ptr(data), gasStipend);\n    }",
            "startLine": 126
          },
          {
            "name": "_string",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "ptr",
                "type": "bytes32"
              },
              {
                "name": "limit",
                "type": "uint256"
              },
              {
                "name": "gasStipend",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _string(address target, bytes32 ptr, uint256 limit, uint256 gasStipend)\n        private\n        view\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function min(x_, y_) -> _z {\n                _z := xor(x_, mul(xor(x_, y_), lt(y_, x_)))\n            }\n            for {} staticcall(gasStipend, target, add(ptr, 0x20), mload(ptr), 0x00, 0x20) {} {\n                let m := mload(0x40) // Grab the free memory pointer.\n                let s := add(0x20, m) // Start of the string's bytes in memory.\n                // Attempt to `abi.decode` if the returndatasize is greater or equal to 64.\n                if iszero(lt(returndatasize(), 0x40)) {\n                    let o := mload(0x00) // Load the string's offset in the returndata.\n                    // If the string's offset is within bounds.\n                    if iszero(gt(o, sub(returndatasize(), 0x20))) {\n                        returndatacopy(m, o, 0x20) // Copy the string's length.\n                        // If the full string's end is within bounds.\n                        // Note: If the full string doesn't fit, the `abi.decode` must be aborted\n                        // for compliance purposes, regardless if the truncated string can fit.\n                        if iszero(gt(mload(m), sub(returndatasize(), add(o, 0x20)))) {\n                            let n := min(mload(m), limit) // Truncate if needed.\n                            mstore(m, n) // Overwrite the length.\n                            returndatacopy(s, add(o, 0x20), n) // Copy the string's bytes.\n                            mstore(add(s, n), 0) // Zeroize the slot after the string.\n                            mstore(0x40, add(0x20, add(s, n))) // Allocate memory for the string.\n                            result := m\n                            break\n                        }\n                    }\n                }\n                // Try interpreting as a null-terminated string.\n                let n := min(returndatasize(), limit) // Truncate if needed.\n                returndatacopy(s, 0, n) // Copy the string's bytes.\n                mstore8(add(s, n), 0) // Place a '\\0' at the end.\n                let i := s // Pointer to the next byte to scan.\n                for {} // Scan for '\\0'.\n                 byte(0, mload(i)) { i := add(i, 1) } {}\n                mstore(m, sub(i, s)) // Store the string's length.\n                mstore(i, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(0x20, i)) // Allocate memory for the string.\n                result := m\n                break\n            }\n        }\n    }",
            "startLine": 139
          },
          {
            "name": "_uint",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "ptr",
                "type": "bytes32"
              },
              {
                "name": "gasStipend",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _uint(address target, bytes32 ptr, uint256 gasStipend)\n        private\n        view\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mul(\n                mload(0x20),\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gasStipend, target, add(ptr, 0x20), mload(ptr), 0x20, 0x20)\n                )\n            )\n        }\n    }",
            "startLine": 189
          },
          {
            "name": "_ptr",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _ptr(uint256 s) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Layout the calldata in the scratch space for temporary usage.\n            mstore(0x04, s) // Store the function selector.\n            mstore(result, 4) // Store the length.\n        }\n    }",
            "startLine": 207
          },
          {
            "name": "_ptr",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _ptr(bytes memory data) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := data\n        }\n    }",
            "startLine": 217
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "GAS_STIPEND_NO_GRIEF",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 13
          },
          {
            "name": "STRING_LIMIT_DEFAULT",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 16
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "MinHeapLib",
        "filePath": "utils/MinHeapLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "root",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "heap",
                "type": "Heap"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function root(Heap storage heap) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(sload(heap.slot)) {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, heap.slot)\n            result := sload(keccak256(0x00, 0x20))\n        }\n    }",
            "startLine": 40
          },
          {
            "name": "root",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function root(MemHeap memory heap) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(heap)\n            if iszero(mload(result)) {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(add(0x20, result))\n        }\n    }",
            "startLine": 54
          },
          {
            "name": "reserve",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              },
              {
                "name": "minimum",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function reserve(MemHeap memory heap, uint256 minimum) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let prime := 204053801631428327883786711931463459222251954273621\n            let cap := not(mload(add(mload(heap), w)))\n            if gt(minimum, mul(iszero(mod(cap, prime)), div(cap, prime))) {\n                let data := mload(heap)\n                let n := mload(data)\n                let newCap := and(add(minimum, 0x1f), w) // Round up to multiple of 32.\n                mstore(mload(0x40), not(mul(newCap, prime)))\n                let m := add(mload(0x40), 0x20)\n                mstore(m, n) // Store the length.\n                mstore(0x40, add(add(m, 0x20), shl(5, newCap))) // Allocate `heap.data` memory.\n                mstore(heap, m) // Update `heap.data`.\n                if n {\n                    for { let i := shl(5, n) } 1 {} {\n                        mstore(add(m, i), mload(add(data, i)))\n                        i := add(i, w)\n                        if iszero(i) { break }\n                    }\n                }\n            }\n        }\n    }",
            "startLine": 68
          },
          {
            "name": "smallest",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "heap",
                "type": "Heap"
              },
              {
                "name": "k",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function smallest(Heap storage heap, uint256 k) internal view returns (uint256[] memory a) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function pIndex(h_, p_) -> _i {\n                _i := mload(add(0x20, add(h_, shl(6, p_))))\n            }\n            function pValue(h_, p_) -> _v {\n                _v := mload(add(h_, shl(6, p_)))\n            }\n            function pSet(h_, p_, i_, v_) {\n                mstore(add(h_, shl(6, p_)), v_)\n                mstore(add(0x20, add(h_, shl(6, p_))), i_)\n            }\n            function pSiftdown(h_, p_, i_, v_) {\n                for {} 1 {} {\n                    let u_ := shr(1, sub(p_, 1))\n                    if iszero(mul(p_, lt(v_, pValue(h_, u_)))) { break }\n                    pSet(h_, p_, pIndex(h_, u_), pValue(h_, u_))\n                    p_ := u_\n                }\n                pSet(h_, p_, i_, v_)\n            }\n            function pSiftup(h_, e_, i_, v_) {\n                let p_ := 0\n                for { let c_ := 1 } lt(c_, e_) { c_ := add(1, shl(1, p_)) } {\n                    c_ := add(c_, gt(pValue(h_, c_), pValue(h_, add(c_, lt(add(c_, 1), e_)))))\n                    pSet(h_, p_, pIndex(h_, c_), pValue(h_, c_))\n                    p_ := c_\n                }\n                pSiftdown(h_, p_, i_, v_)\n            }\n            a := mload(0x40)\n            mstore(0x00, heap.slot)\n            let sOffset := keccak256(0x00, 0x20)\n            let o := add(a, 0x20) // Offset into `a`.\n            let n := sload(heap.slot) // The number of items in the heap.\n            let m := xor(n, mul(xor(n, k), lt(k, n))) // `min(k, n)`.\n            let h := add(o, shl(5, m)) // Priority queue.\n            pSet(h, 0, 0, sload(sOffset)) // Store the root into the priority queue.\n            for { let e := iszero(eq(o, h)) } e {} {\n                mstore(o, pValue(h, 0))\n                o := add(0x20, o)\n                if eq(o, h) { break }\n                let childPos := add(shl(1, pIndex(h, 0)), 1)\n                if iszero(lt(childPos, n)) {\n                    e := sub(e, 1)\n                    pSiftup(h, e, pIndex(h, e), pValue(h, e))\n                    continue\n                }\n                pSiftup(h, e, childPos, sload(add(sOffset, childPos)))\n                childPos := add(1, childPos)\n                if iszero(eq(childPos, n)) {\n                    pSiftdown(h, e, childPos, sload(add(sOffset, childPos)))\n                    e := add(e, 1)\n                }\n            }\n            mstore(a, shr(5, sub(o, add(a, 0x20)))) // Store the length.\n            mstore(0x40, o) // Allocate memory.\n        }\n    }",
            "startLine": 97
          },
          {
            "name": "smallest",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              },
              {
                "name": "k",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function smallest(MemHeap memory heap, uint256 k) internal pure returns (uint256[] memory a) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function pIndex(h_, p_) -> _i {\n                _i := mload(add(0x20, add(h_, shl(6, p_))))\n            }\n            function pValue(h_, p_) -> _v {\n                _v := mload(add(h_, shl(6, p_)))\n            }\n            function pSet(h_, p_, i_, v_) {\n                mstore(add(h_, shl(6, p_)), v_)\n                mstore(add(0x20, add(h_, shl(6, p_))), i_)\n            }\n            function pSiftdown(h_, p_, i_, v_) {\n                for {} 1 {} {\n                    let u_ := shr(1, sub(p_, 1))\n                    if iszero(mul(p_, lt(v_, pValue(h_, u_)))) { break }\n                    pSet(h_, p_, pIndex(h_, u_), pValue(h_, u_))\n                    p_ := u_\n                }\n                pSet(h_, p_, i_, v_)\n            }\n            function pSiftup(h_, e_, i_, v_) {\n                let p_ := 0\n                for { let c_ := 1 } lt(c_, e_) { c_ := add(1, shl(1, p_)) } {\n                    c_ := add(c_, gt(pValue(h_, c_), pValue(h_, add(c_, lt(add(c_, 1), e_)))))\n                    pSet(h_, p_, pIndex(h_, c_), pValue(h_, c_))\n                    p_ := c_\n                }\n                pSiftdown(h_, p_, i_, v_)\n            }\n            a := mload(0x40)\n            let sOffset := add(mload(heap), 0x20)\n            let o := add(a, 0x20) // Offset into `a`.\n            let n := mload(mload(heap)) // The number of items in the heap.\n            let m := xor(n, mul(xor(n, k), lt(k, n))) // `min(k, n)`.\n            let h := add(o, shl(5, m)) // Priority queue.\n            pSet(h, 0, 0, mload(sOffset)) // Store the root into the priority queue.\n            for { let e := iszero(eq(o, h)) } e {} {\n                mstore(o, pValue(h, 0))\n                o := add(0x20, o)\n                if eq(o, h) { break }\n                let childPos := add(shl(1, pIndex(h, 0)), 1)\n                if iszero(lt(childPos, n)) {\n                    e := sub(e, 1)\n                    pSiftup(h, e, pIndex(h, e), pValue(h, e))\n                    continue\n                }\n                pSiftup(h, e, childPos, mload(add(sOffset, shl(5, childPos))))\n                childPos := add(1, childPos)\n                if iszero(eq(childPos, n)) {\n                    pSiftdown(h, e, childPos, mload(add(sOffset, shl(5, childPos))))\n                    e := add(e, 1)\n                }\n            }\n            mstore(a, shr(5, sub(o, add(a, 0x20)))) // Store the length.\n            mstore(0x40, o) // Allocate memory.\n        }\n    }",
            "startLine": 161
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "heap",
                "type": "Heap"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function length(Heap storage heap) internal view returns (uint256) {\n        return heap.data.length;\n    }",
            "startLine": 222
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function length(MemHeap memory heap) internal pure returns (uint256) {\n        return heap.data.length;\n    }",
            "startLine": 227
          },
          {
            "name": "push",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "heap",
                "type": "Heap"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function push(Heap storage heap, uint256 value) internal {\n        _set(heap, value, 0, 3);\n    }",
            "startLine": 232
          },
          {
            "name": "push",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function push(MemHeap memory heap, uint256 value) internal pure {\n        _set(heap, value, 0, 3);\n    }",
            "startLine": 237
          },
          {
            "name": "pop",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "heap",
                "type": "Heap"
              }
            ],
            "returnValues": [
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pop(Heap storage heap) internal returns (uint256 popped) {\n        (, popped) = _set(heap, 0, 0, 2);\n    }",
            "startLine": 243
          },
          {
            "name": "pop",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              }
            ],
            "returnValues": [
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pop(MemHeap memory heap) internal pure returns (uint256 popped) {\n        (, popped) = _set(heap, 0, 0, 2);\n    }",
            "startLine": 249
          },
          {
            "name": "pushPop",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "heap",
                "type": "Heap"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pushPop(Heap storage heap, uint256 value) internal returns (uint256 popped) {\n        (, popped) = _set(heap, value, 0, 4);\n    }",
            "startLine": 254
          },
          {
            "name": "pushPop",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pushPop(MemHeap memory heap, uint256 value) internal pure returns (uint256 popped) {\n        (, popped) = _set(heap, value, 0, 4);\n    }",
            "startLine": 259
          },
          {
            "name": "replace",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "heap",
                "type": "Heap"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function replace(Heap storage heap, uint256 value) internal returns (uint256 popped) {\n        (, popped) = _set(heap, value, 0, 1);\n    }",
            "startLine": 265
          },
          {
            "name": "replace",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function replace(MemHeap memory heap, uint256 value) internal pure returns (uint256 popped) {\n        (, popped) = _set(heap, value, 0, 1);\n    }",
            "startLine": 271
          },
          {
            "name": "enqueue",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "heap",
                "type": "Heap"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "maxLength",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "success",
                "type": "bool"
              },
              {
                "name": "hasPopped",
                "type": "bool"
              },
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function enqueue(Heap storage heap, uint256 value, uint256 maxLength)\n        internal\n        returns (bool success, bool hasPopped, uint256 popped)\n    {\n        (value, popped) = _set(heap, value, maxLength, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            hasPopped := eq(3, value)\n            success := value\n        }\n    }",
            "startLine": 296
          },
          {
            "name": "enqueue",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "maxLength",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "success",
                "type": "bool"
              },
              {
                "name": "hasPopped",
                "type": "bool"
              },
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function enqueue(MemHeap memory heap, uint256 value, uint256 maxLength)\n        internal\n        pure\n        returns (bool success, bool hasPopped, uint256 popped)\n    {\n        (value, popped) = _set(heap, value, maxLength, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            hasPopped := eq(3, value)\n            success := value\n        }\n    }",
            "startLine": 321
          },
          {
            "name": "bumpFreeMemoryPointer",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function bumpFreeMemoryPointer() internal pure {\n        uint256 zero;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, zero)\n            mstore(0x40, add(m, 0x20))\n        }\n    }",
            "startLine": 340
          },
          {
            "name": "_set",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "heap",
                "type": "Heap"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "maxLength",
                "type": "uint256"
              },
              {
                "name": "mode",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "status",
                "type": "uint256"
              },
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _set(Heap storage heap, uint256 value, uint256 maxLength, uint256 mode)\n        private\n        returns (uint256 status, uint256 popped)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := sload(heap.slot)\n            mstore(0x00, heap.slot)\n            let sOffset := keccak256(0x00, 0x20) // Array storage slot offset.\n            let pos := 0\n            let childPos := not(0)\n            // Operations are ordered from most likely usage to least likely usage.\n            for {} 1 {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            } {\n                // Mode: `enqueue`.\n                if iszero(mode) {\n                    if iszero(maxLength) { continue }\n                    // If queue is full.\n                    if iszero(lt(n, maxLength)) {\n                        let r := sload(sOffset)\n                        if iszero(lt(r, value)) { break }\n                        status := 3\n                        childPos := 1\n                        popped := r\n                        break\n                    }\n                    status := 1\n                    pos := n\n                    // Increment and update the length.\n                    sstore(heap.slot, add(pos, 1))\n                    childPos := sOffset\n                    break\n                }\n                if iszero(gt(mode, 2)) {\n                    if iszero(n) { continue }\n                    // Mode: `pop`.\n                    if eq(mode, 2) {\n                        // Decrement and update the length.\n                        n := sub(n, 1)\n                        sstore(heap.slot, n)\n                        // Set the `value` to the last item.\n                        value := sload(add(sOffset, n))\n                        popped := value\n                        if iszero(n) { break }\n                    }\n                    // Mode: `replace`.\n                    popped := sload(sOffset)\n                    childPos := 1\n                    break\n                }\n                // Mode: `push`.\n                if eq(mode, 3) {\n                    // Increment and update the length.\n                    pos := n\n                    sstore(heap.slot, add(pos, 1))\n                    // `sOffset` is used as a value that is `>= n` and `< not(0)`.\n                    childPos := sOffset\n                    break\n                }\n                // Mode: `pushPop`.\n                popped := value\n                if iszero(n) { break }\n                let r := sload(sOffset)\n                if iszero(lt(r, value)) { break }\n                popped := r\n                childPos := 1\n                break\n            }\n            // Siftup.\n            for {} lt(childPos, n) {} {\n                let child := sload(add(sOffset, childPos))\n                let rightPos := add(childPos, 1)\n                let right := sload(add(sOffset, rightPos))\n                if iszero(gt(lt(rightPos, n), lt(child, right))) {\n                    right := child\n                    rightPos := childPos\n                }\n                sstore(add(sOffset, pos), right)\n                pos := rightPos\n                childPos := add(shl(1, pos), 1)\n            }\n            // Siftdown.\n            for {} pos {} {\n                let parentPos := shr(1, sub(pos, 1))\n                let parent := sload(add(sOffset, parentPos))\n                if iszero(lt(value, parent)) { break }\n                sstore(add(sOffset, pos), parent)\n                pos := parentPos\n            }\n            // If `childPos` has been changed from `not(0)`.\n            if add(childPos, 1) { sstore(add(sOffset, pos), value) }\n        }\n    }",
            "startLine": 356
          },
          {
            "name": "_set",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "maxLength",
                "type": "uint256"
              },
              {
                "name": "mode",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "status",
                "type": "uint256"
              },
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _set(MemHeap memory heap, uint256 value, uint256 maxLength, uint256 mode)\n        private\n        pure\n        returns (uint256 status, uint256 popped)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let data := mload(heap)\n            let n := mload(data)\n            // Allocation / reallocation.\n            for {\n                let cap := not(mload(sub(data, 0x20)))\n                let prime := 204053801631428327883786711931463459222251954273621\n                cap := mul(iszero(mod(cap, prime)), div(cap, prime))\n            } iszero(lt(n, cap)) {} {\n                let newCap := add(add(cap, cap), shl(5, iszero(cap)))\n                if iszero(or(cap, iszero(n))) {\n                    for { cap := n } iszero(gt(newCap, n)) {} { newCap := add(newCap, newCap) }\n                }\n                mstore(mload(0x40), not(mul(newCap, prime))) // Update `heap.capacity`.\n                let m := add(mload(0x40), 0x20)\n                mstore(m, n) // Store the length.\n                mstore(0x40, add(add(m, 0x20), shl(5, newCap))) // Allocate `heap.data` memory.\n                if cap {\n                    let w := not(0x1f)\n                    for { let i := shl(5, cap) } 1 {} {\n                        mstore(add(m, i), mload(add(data, i)))\n                        i := add(i, w)\n                        if iszero(i) { break }\n                    }\n                }\n                mstore(heap, m) // Update `heap.data`.\n                data := m\n                break\n            }\n            let sOffset := add(data, 0x20) // Array memory offset.\n            let pos := 0\n            let childPos := not(0)\n            // Operations are ordered from most likely usage to least likely usage.\n            for {} 1 {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            } {\n                // Mode: `enqueue`.\n                if iszero(mode) {\n                    if iszero(maxLength) { continue }\n                    // If the queue is full.\n                    if iszero(lt(n, maxLength)) {\n                        if iszero(lt(mload(sOffset), value)) { break }\n                        status := 3\n                        childPos := 1\n                        popped := mload(sOffset)\n                        break\n                    }\n                    status := 1\n                    pos := n\n                    // Increment and update the length.\n                    mstore(data, add(pos, 1))\n                    childPos := 0xff0000000000000000\n                    break\n                }\n                if iszero(gt(mode, 2)) {\n                    if iszero(n) { continue }\n                    // Mode: `pop`.\n                    if eq(mode, 2) {\n                        // Decrement and update the length.\n                        n := sub(n, 1)\n                        mstore(data, n)\n                        // Set the `value` to the last item.\n                        value := mload(add(sOffset, shl(5, n)))\n                        popped := value\n                        if iszero(n) { break }\n                    }\n                    // Mode: `replace`.\n                    popped := mload(sOffset)\n                    childPos := 1\n                    break\n                }\n                // Mode: `push`.\n                if eq(mode, 3) {\n                    // Increment and update the length.\n                    pos := n\n                    mstore(data, add(pos, 1))\n                    childPos := 0xff0000000000000000\n                    break\n                }\n                // Mode: `pushPop`.\n                if iszero(mul(n, lt(mload(sOffset), value))) {\n                    popped := value\n                    break\n                }\n                popped := mload(sOffset)\n                childPos := 1\n                break\n            }\n            // Siftup.\n            for {} lt(childPos, n) {} {\n                let child := mload(add(sOffset, shl(5, childPos)))\n                let rightPos := add(childPos, 1)\n                let right := mload(add(sOffset, shl(5, rightPos)))\n                if iszero(gt(lt(rightPos, n), lt(child, right))) {\n                    mstore(add(sOffset, shl(5, pos)), child)\n                    pos := childPos\n                    childPos := add(shl(1, pos), 1)\n                    continue\n                }\n                mstore(add(sOffset, shl(5, pos)), right)\n                pos := rightPos\n                childPos := add(shl(1, pos), 1)\n            }\n            // Siftdown.\n            for {} pos {} {\n                let parentPos := shr(1, sub(pos, 1))\n                let parent := mload(add(sOffset, shl(5, parentPos)))\n                if iszero(lt(value, parent)) { break }\n                mstore(add(sOffset, shl(5, pos)), parent)\n                pos := parentPos\n            }\n            // If `childPos` has been changed from `not(0)`.\n            if iszero(shr(128, childPos)) { mstore(add(sOffset, shl(5, pos)), value) }\n        }\n    }",
            "startLine": 454
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "HeapIsEmpty",
            "parameters": [],
            "startLine": 12
          }
        ],
        "structs": [
          {
            "name": "Heap",
            "members": [
              {
                "name": "data",
                "type": "uint256[]"
              }
            ],
            "startLine": 19
          },
          {
            "name": "MemHeap",
            "members": [
              {
                "name": "data",
                "type": "uint256[]"
              }
            ],
            "startLine": 24
          }
        ],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "Multicallable",
        "filePath": "utils/Multicallable.sol",
        "kind": "abstract",
        "inherits": [],
        "implements": [],
        "category": "utils",
        "externalFunctions": [
          {
            "name": "multicall",
            "signature": "multicall(bytes[])",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "data",
                "type": "bytes[]"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes[]"
              }
            ],
            "calls": [
              {
                "target": "_multicallDirectReturn",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_multicall",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function multicall(bytes[] calldata data) public payable virtual returns (bytes[] memory) {\n        // Revert if `msg.value` is non-zero by default to guard against double-spending.\n        // (See: https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong)\n        //\n        // If you really need to pass in a `msg.value`, then you will have to\n        // override this function and add in any relevant before and after checks.\n        if (msg.value != 0) revert();\n        // `_multicallDirectReturn` returns the results directly and terminates the call context.\n        _multicallDirectReturn(_multicall(data));\n    }",
            "startLine": 28
          }
        ],
        "internalFunctions": [
          {
            "name": "_multicall",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "data",
                "type": "bytes[]"
              }
            ],
            "returnValues": [
              {
                "name": "results",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _multicall(bytes[] calldata data) internal virtual returns (bytes32 results) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            results := mload(0x40)\n            mstore(results, 0x20)\n            mstore(add(0x20, results), data.length)\n            let c := add(0x40, results)\n            let s := c\n            let end := shl(5, data.length)\n            calldatacopy(c, data.offset, end)\n            end := add(c, end)\n            let m := end\n            if data.length {\n                for {} 1 {} {\n                    let o := add(data.offset, mload(c))\n                    calldatacopy(m, add(o, 0x20), calldataload(o))\n                    // forgefmt: disable-next-item\n                    if iszero(delegatecall(gas(), address(), m, calldataload(o), codesize(), 0x00)) {\n                        // Bubble up the revert if the delegatecall reverts.\n                        returndatacopy(results, 0x00, returndatasize())\n                        revert(results, returndatasize())\n                    }\n                    mstore(c, sub(m, s))\n                    c := add(0x20, c)\n                    // Append the `returndatasize()`, and the return data.\n                    mstore(m, returndatasize())\n                    let b := add(m, 0x20)\n                    returndatacopy(b, 0x00, returndatasize())\n                    // Advance `m` by `returndatasize() + 0x20`,\n                    // rounded up to the next multiple of 32.\n                    m := and(add(add(b, returndatasize()), 0x1f), 0xffffffffffffffe0)\n                    mstore(add(b, returndatasize()), 0) // Zeroize the slot after the returndata.\n                    if iszero(lt(c, end)) { break }\n                }\n            }\n            mstore(0x40, m) // Allocate memory.\n            results := or(shl(64, sub(m, results)), results) // Pack the bytes length into `results`.\n        }\n    }",
            "startLine": 42
          },
          {
            "name": "_multicallResultsToBytesArray",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "results",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "decoded",
                "type": "bytes[]"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _multicallResultsToBytesArray(bytes32 results)\n        internal\n        pure\n        virtual\n        returns (bytes[] memory decoded)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            decoded := mload(0x40)\n            let c := and(0xffffffffffffffff, results) // Extract the offset.\n            mstore(decoded, mload(add(c, 0x20))) // Store the length.\n            let o := add(decoded, 0x20) // Start of elements in `decoded`.\n            let end := add(o, shl(5, mload(decoded)))\n            mstore(0x40, end) // Allocate memory.\n            let s := add(c, 0x40) // Start of elements in `results`.\n            let d := sub(s, o) // Difference between input and output pointers.\n            for {} iszero(eq(o, end)) { o := add(o, 0x20) } { mstore(o, add(mload(add(d, o)), s)) }\n        }\n    }",
            "startLine": 84
          },
          {
            "name": "_multicallDirectReturn",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "results",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _multicallDirectReturn(bytes32 results) internal pure virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            return(and(0xffffffffffffffff, results), shr(64, results))\n        }\n    }",
            "startLine": 106
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "P256",
        "filePath": "utils/P256.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "verifySignatureAllowMalleability",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              },
              {
                "name": "x",
                "type": "bytes32"
              },
              {
                "name": "y",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function verifySignatureAllowMalleability(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 s,\n        bytes32 x,\n        bytes32 y\n    ) internal view returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, hash)\n            mstore(add(m, 0x20), r)\n            mstore(add(m, 0x40), s)\n            mstore(add(m, 0x60), x)\n            mstore(add(m, 0x80), y)\n            mstore(0x00, 0) // Zeroize the return slot before the staticcalls.\n            pop(staticcall(gas(), RIP_PRECOMPILE, m, 0xa0, 0x00, 0x20))\n            // RIP-7212 dictates that success returns `uint256(1)`.\n            // But failure returns zero returndata, which is ambiguous.\n            if iszero(returndatasize()) {\n                if iszero(extcodesize(CANARY)) {\n                    // The verifier will never revert when given sufficient gas.\n                    // The `invalid` upon `staticcall` failure is solely for gas estimation.\n                    if iszero(staticcall(gas(), VERIFIER, m, 0xa0, 0x00, 0x20)) { invalid() }\n                }\n                // Unlike RIP-7212, the verifier returns `uint256(0)` on failure.\n                // We shall not revert even if the verifier does not exist,\n                // to allow for workflows where reverting can cause trouble.\n            }\n            isValid := eq(1, mload(0x00))\n        }\n    }",
            "startLine": 46
          },
          {
            "name": "verifySignature",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              },
              {
                "name": "x",
                "type": "bytes32"
              },
              {
                "name": "y",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function verifySignature(bytes32 hash, bytes32 r, bytes32 s, bytes32 x, bytes32 y)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, hash)\n            mstore(add(m, 0x20), r)\n            mstore(add(m, 0x40), s)\n            mstore(add(m, 0x60), x)\n            mstore(add(m, 0x80), y)\n            mstore(0x00, 0) // Zeroize the return slot before the staticcalls.\n            pop(staticcall(gas(), RIP_PRECOMPILE, m, 0xa0, 0x00, 0x20))\n            // RIP-7212 dictates that success returns `uint256(1)`.\n            // But failure returns zero returndata, which is ambiguous.\n            if iszero(returndatasize()) {\n                if iszero(extcodesize(CANARY)) {\n                    // The verifier will never revert when given sufficient gas.\n                    // The `invalid` upon `staticcall` failure is solely for gas estimation.\n                    if iszero(staticcall(gas(), VERIFIER, m, 0xa0, 0x00, 0x20)) { invalid() }\n                }\n                // Unlike RIP-7212, the verifier returns `uint256(0)` on failure.\n                // We shall not revert even if the verifier does not exist,\n                // to allow for workflows where reverting can cause trouble.\n            }\n            // Optimize for happy path. Users are unlikely to pass in malleable signatures.\n            isValid := lt(gt(s, _HALF_N), eq(1, mload(0x00)))\n        }\n    }",
            "startLine": 81
          },
          {
            "name": "hasPrecompile",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hasPrecompile() internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            // These values are taken from the standard Wycheproof test vectors.\n            // https://github.com/C2SP/wycheproof/blob/aca47066256c167f0ce04d611d718cc85654341e/testvectors/ecdsa_webcrypto_test.json#L1197\n            mstore(m, 0x532eaabd9574880dbf76b9b8cc00832c20a6ec113d682299550d7a6e0f345e25) // `hash`.\n            mstore(add(m, 0x20), 0x5) // `r`.\n            mstore(add(m, 0x40), 0x1) // `s`.\n            mstore(add(m, 0x60), 0x4a03ef9f92eb268cafa601072489a56380fa0dc43171d7712813b3a19a1eb5e5) // `x`.\n            mstore(add(m, 0x80), 0x3e213e28a608ce9a2f4a17fd830c6654018a79b3e0263d91a8ba90622df6f2f0) // `y`.\n            // The `invalid` upon `staticcall` failure is solely for gas estimation.\n            if iszero(staticcall(gas(), RIP_PRECOMPILE, m, 0xa0, m, 0x20)) { invalid() }\n            result := eq(1, mload(m))\n        }\n    }",
            "startLine": 114
          },
          {
            "name": "hasPrecompileOrVerifier",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "hasPrecompile",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function hasPrecompileOrVerifier() internal view returns (bool result) {\n        result = hasPrecompile();\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(iszero(or(result, extcodesize(VERIFIER))))\n        }\n    }",
            "startLine": 135
          },
          {
            "name": "normalized",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function normalized(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := xor(s, mul(xor(sub(N, s), s), gt(s, _HALF_N)))\n        }\n    }",
            "startLine": 148
          },
          {
            "name": "tryDecodePoint",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "encoded",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "x",
                "type": "bytes32"
              },
              {
                "name": "y",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tryDecodePoint(bytes memory encoded) internal pure returns (bytes32 x, bytes32 y) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let t := gt(mload(encoded), 0x3f)\n            x := mul(mload(add(encoded, 0x20)), t)\n            y := mul(mload(add(encoded, 0x40)), t)\n        }\n    }",
            "startLine": 157
          },
          {
            "name": "tryDecodePointCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "encoded",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "x",
                "type": "bytes32"
              },
              {
                "name": "y",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tryDecodePointCalldata(bytes calldata encoded)\n        internal\n        pure\n        returns (bytes32 x, bytes32 y)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let t := gt(encoded.length, 0x3f)\n            x := mul(calldataload(encoded.offset), t)\n            y := mul(calldataload(add(encoded.offset, 0x20)), t)\n        }\n    }",
            "startLine": 168
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "VERIFIER",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 18
          },
          {
            "name": "CANARY",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 25
          },
          {
            "name": "RIP_PRECOMPILE",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 30
          },
          {
            "name": "N",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 33
          },
          {
            "name": "_HALF_N",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 37
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "RedBlackTreeLib",
        "filePath": "utils/RedBlackTreeLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "size",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_nodes",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function size(Tree storage tree) internal view returns (uint256 result) {\n        uint256 nodes = _nodes(tree);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(sload(nodes), _BITMASK_KEY)\n        }\n    }",
            "startLine": 99
          },
          {
            "name": "values",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "_nodes",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function values(Tree storage tree) internal view returns (uint256[] memory result) {\n        uint256 nodes = _nodes(tree);\n        /// @solidity memory-safe-assembly\n        assembly {\n            function visit(current_) {\n                if iszero(current_) { leave } // If the current node is null, leave.\n                current_ := or(mload(0x00), current_) // Current node's storage slot.\n                let packed_ := sload(current_)\n                visit(and(packed_, _BITMASK_KEY)) // Visit left child.\n                let value_ := shr(_BITPOS_PACKED_VALUE, packed_) // Current value.\n                if iszero(value_) { value_ := sload(or(current_, _BIT_FULL_VALUE_SLOT)) }\n                mstore(mload(0x20), value_) // Append the value to `results`.\n                mstore(0x20, add(0x20, mload(0x20))) // Advance the offset into `results`.\n                visit(and(shr(_BITPOS_RIGHT, packed_), _BITMASK_KEY)) // Visit right child.\n            }\n            result := mload(0x40)\n            let rootPacked := sload(nodes)\n            mstore(result, and(rootPacked, _BITMASK_KEY)) // Length of `result`.\n            mstore(0x00, nodes) // Cache the nodes pointer in scratch space.\n            mstore(0x20, add(result, 0x20)) // Cache the offset into `results` in scratch space.\n            mstore(0x40, add(mload(0x20), shl(5, mload(result)))) // Allocate memory.\n            visit(shr(128, rootPacked)) // Start the tree traversal from the root node.\n        }\n    }",
            "startLine": 110
          },
          {
            "name": "find",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_find",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_pack",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function find(Tree storage tree, uint256 x) internal view returns (bytes32 result) {\n        (uint256 nodes,, uint256 key) = _find(tree, x);\n        result = _pack(nodes, key);\n    }",
            "startLine": 137
          },
          {
            "name": "nearest",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_find",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_pack",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "value",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "prev",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "next",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function nearest(Tree storage tree, uint256 x) internal view returns (bytes32 result) {\n        (uint256 nodes, uint256 cursor, uint256 key) = _find(tree, x);\n        unchecked {\n            if (cursor == uint256(0)) return result; // Nothing found -- empty tree.\n            if (key != uint256(0)) return _pack(nodes, key); // Exact match.\n            bytes32 a = _pack(nodes, cursor);\n            uint256 aValue = value(a);\n            bytes32 b = x < aValue ? prev(a) : next(a);\n            if (b == bytes32(0)) return a; // Only node found.\n            uint256 bValue = value(b);\n            uint256 aDist = x < aValue ? aValue - x : x - aValue;\n            uint256 bDist = x < bValue ? bValue - x : x - bValue;\n            return (aDist == bDist ? aValue < bValue : aDist < bDist) ? a : b;\n        }\n    }",
            "startLine": 145
          },
          {
            "name": "nearestBefore",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_find",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_pack",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "value",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "prev",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function nearestBefore(Tree storage tree, uint256 x) internal view returns (bytes32 result) {\n        (uint256 nodes, uint256 cursor, uint256 key) = _find(tree, x);\n        if (cursor == uint256(0)) return result; // Nothing found -- empty tree.\n        if (key != uint256(0)) return _pack(nodes, key); // Exact match.\n        bytes32 a = _pack(nodes, cursor);\n        return value(a) < x ? a : prev(a);\n    }",
            "startLine": 163
          },
          {
            "name": "nearestAfter",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_find",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_pack",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "value",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "next",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function nearestAfter(Tree storage tree, uint256 x) internal view returns (bytes32 result) {\n        (uint256 nodes, uint256 cursor, uint256 key) = _find(tree, x);\n        if (cursor == uint256(0)) return result; // Nothing found -- empty tree.\n        if (key != uint256(0)) return _pack(nodes, key); // Exact match.\n        bytes32 a = _pack(nodes, cursor);\n        return value(a) > x ? a : next(a);\n    }",
            "startLine": 173
          },
          {
            "name": "exists",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_find",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function exists(Tree storage tree, uint256 x) internal view returns (bool result) {\n        (,, uint256 key) = _find(tree, x);\n        result = key != 0;\n    }",
            "startLine": 182
          },
          {
            "name": "insert",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "tryInsert",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_revert",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function insert(Tree storage tree, uint256 x) internal {\n        uint256 err = tryInsert(tree, x);\n        if (err != 0) _revert(err);\n    }",
            "startLine": 189
          },
          {
            "name": "tryInsert",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "err",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_find",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_update",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryInsert(Tree storage tree, uint256 x) internal returns (uint256 err) {\n        (uint256 nodes, uint256 cursor, uint256 key) = _find(tree, x);\n        err = _update(nodes, cursor, key, x, 0);\n    }",
            "startLine": 197
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "tryRemove",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_revert",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Tree storage tree, uint256 x) internal {\n        uint256 err = tryRemove(tree, x);\n        if (err != 0) _revert(err);\n    }",
            "startLine": 204
          },
          {
            "name": "tryRemove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "err",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_find",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_update",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryRemove(Tree storage tree, uint256 x) internal returns (uint256 err) {\n        (uint256 nodes,, uint256 key) = _find(tree, x);\n        err = _update(nodes, 0, key, 0, 1);\n    }",
            "startLine": 212
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "tryRemove",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_revert",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(bytes32 ptr) internal {\n        uint256 err = tryRemove(ptr);\n        if (err != 0) _revert(err);\n    }",
            "startLine": 222
          },
          {
            "name": "tryRemove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "err",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_unpack",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_update",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryRemove(bytes32 ptr) internal returns (uint256 err) {\n        (uint256 nodes, uint256 key) = _unpack(ptr);\n        err = _update(nodes, 0, key, 0, 1);\n    }",
            "startLine": 229
          },
          {
            "name": "value",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function value(bytes32 ptr) internal view returns (uint256 result) {\n        if (ptr == bytes32(0)) return result;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := sload(ptr)\n            result := shr(_BITPOS_PACKED_VALUE, packed)\n            if iszero(result) { result := sload(or(ptr, _BIT_FULL_VALUE_SLOT)) }\n        }\n    }",
            "startLine": 236
          },
          {
            "name": "first",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_end",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function first(Tree storage tree) internal view returns (bytes32 result) {\n        result = _end(tree, _BITPOS_LEFT);\n    }",
            "startLine": 248
          },
          {
            "name": "last",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_end",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function last(Tree storage tree) internal view returns (bytes32 result) {\n        result = _end(tree, _BITPOS_RIGHT);\n    }",
            "startLine": 254
          },
          {
            "name": "next",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_step",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function next(bytes32 ptr) internal view returns (bytes32 result) {\n        result = _step(ptr, _BITPOS_LEFT, _BITPOS_RIGHT);\n    }",
            "startLine": 261
          },
          {
            "name": "prev",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_step",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function prev(bytes32 ptr) internal view returns (bytes32 result) {\n        result = _step(ptr, _BITPOS_RIGHT, _BITPOS_LEFT);\n    }",
            "startLine": 268
          },
          {
            "name": "isEmpty",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "ptr",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isEmpty(bytes32 ptr) internal pure returns (bool result) {\n        result = ptr == bytes32(0);\n    }",
            "startLine": 273
          },
          {
            "name": "_unpack",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "ptr",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "nodes",
                "type": "uint256"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _unpack(bytes32 ptr) private pure returns (uint256 nodes, uint256 key) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            nodes := shl(_NODES_SLOT_SHIFT, shr(_NODES_SLOT_SHIFT, ptr))\n            key := and(_BITMASK_KEY, ptr)\n        }\n    }",
            "startLine": 282
          },
          {
            "name": "_pack",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "nodes",
                "type": "uint256"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _pack(uint256 nodes, uint256 key) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mul(or(nodes, key), iszero(iszero(key)))\n        }\n    }",
            "startLine": 291
          },
          {
            "name": "_end",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "L",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_nodes",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_pack",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _end(Tree storage tree, uint256 L) private view returns (bytes32 result) {\n        uint256 nodes = _nodes(tree);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(128, sload(nodes))\n            if result {\n                for {} 1 {} {\n                    let packed := sload(or(nodes, result))\n                    let left := and(shr(L, packed), _BITMASK_KEY)\n                    if iszero(left) { break }\n                    result := left\n                }\n            }\n        }\n        result = _pack(nodes, uint256(result));\n    }",
            "startLine": 299
          },
          {
            "name": "_step",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "bytes32"
              },
              {
                "name": "L",
                "type": "uint256"
              },
              {
                "name": "R",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_unpack",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_pack",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _step(bytes32 ptr, uint256 L, uint256 R) private view returns (bytes32 result) {\n        if (ptr == bytes32(0)) return ptr;\n        (uint256 nodes, uint256 target) = _unpack(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := sload(ptr)\n            for { result := and(shr(R, packed), _BITMASK_KEY) } 1 {} {\n                if iszero(result) {\n                    result := and(shr(_BITPOS_PARENT, packed), _BITMASK_KEY)\n                    for {} 1 {} {\n                        if iszero(result) { break }\n                        packed := sload(or(nodes, result))\n                        if iszero(eq(target, and(shr(R, packed), _BITMASK_KEY))) {\n                            break\n                        }\n                        target := result\n                        result := and(shr(_BITPOS_PARENT, packed), _BITMASK_KEY)\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    packed := sload(or(nodes, result))\n                    let left := and(shr(L, packed), _BITMASK_KEY)\n                    if iszero(left) { break }\n                    result := left\n                }\n                break\n            }\n        }\n        result = _pack(nodes, uint256(result));\n    }",
            "startLine": 317
          },
          {
            "name": "_update",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "nodes",
                "type": "uint256"
              },
              {
                "name": "cursor",
                "type": "uint256"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "mode",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "err",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _update(uint256 nodes, uint256 cursor, uint256 key, uint256 x, uint256 mode)\n        private\n        returns (uint256 err)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function getKey(packed_, bitpos_) -> index_ {\n                index_ := and(_BITMASK_KEY, shr(bitpos_, packed_))\n            }\n\n            function setKey(packed_, bitpos_, key_) -> result_ {\n                result_ := or(and(not(shl(bitpos_, _BITMASK_KEY)), packed_), shl(bitpos_, key_))\n            }\n\n            function rotate(nodes_, key_, L, R) {\n                let packed_ := sload(or(nodes_, key_))\n                let cursor_ := getKey(packed_, R)\n                let parent_ := getKey(packed_, _BITPOS_PARENT)\n                let cursorPacked_ := sload(or(nodes_, cursor_))\n                let cursorLeft_ := getKey(cursorPacked_, L)\n\n                if cursorLeft_ {\n                    let s_ := or(nodes_, cursorLeft_)\n                    sstore(s_, setKey(sload(s_), _BITPOS_PARENT, key_))\n                }\n\n                for {} 1 {} {\n                    if iszero(parent_) {\n                        mstore(0x00, cursor_)\n                        break\n                    }\n                    let s_ := or(nodes_, parent_)\n                    let parentPacked_ := sload(s_)\n                    if eq(key_, getKey(parentPacked_, L)) {\n                        sstore(s_, setKey(parentPacked_, L, cursor_))\n                        break\n                    }\n                    sstore(s_, setKey(parentPacked_, R, cursor_))\n                    break\n                }\n                packed_ := setKey(packed_, R, cursorLeft_)\n                sstore(or(nodes_, key_), setKey(packed_, _BITPOS_PARENT, cursor_))\n                cursorPacked_ := setKey(cursorPacked_, _BITPOS_PARENT, parent_)\n                sstore(or(nodes_, cursor_), setKey(cursorPacked_, L, key_))\n            }\n\n            function insert(nodes_, cursor_, key_, x_) -> err_ {\n                if key_ {\n                    err_ := ERROR_VALUE_ALREADY_EXISTS\n                    leave\n                }\n\n                let totalNodes_ := add(shr(128, mload(0x20)), 1)\n                if gt(totalNodes_, _BITMASK_KEY) {\n                    err_ := ERROR_TREE_IS_FULL\n                    leave\n                }\n\n                mstore(0x20, shl(128, totalNodes_))\n\n                {\n                    let packed_ := or(_BITMASK_RED, shl(_BITPOS_PARENT, cursor_))\n                    let nodePointer_ := or(nodes_, totalNodes_)\n\n                    for {} 1 {} {\n                        if iszero(gt(x_, _BITMASK_PACKED_VALUE)) {\n                            packed_ := or(shl(_BITPOS_PACKED_VALUE, x_), packed_)\n                            break\n                        }\n                        sstore(or(nodePointer_, _BIT_FULL_VALUE_SLOT), x_)\n                        break\n                    }\n                    sstore(nodePointer_, packed_)\n\n                    for {} 1 {} {\n                        if iszero(cursor_) {\n                            mstore(0x00, totalNodes_)\n                            break\n                        }\n                        let s_ := or(nodes_, cursor_)\n                        let cPacked_ := sload(s_)\n                        let cValue_ := shr(_BITPOS_PACKED_VALUE, cPacked_)\n                        if iszero(cValue_) {\n                            cValue_ := sload(or(s_, _BIT_FULL_VALUE_SLOT))\n                        }\n                        if iszero(lt(x_, cValue_)) {\n                            sstore(s_, setKey(cPacked_, _BITPOS_RIGHT, totalNodes_))\n                            break\n                        }\n                        sstore(s_, setKey(cPacked_, _BITPOS_LEFT, totalNodes_))\n                        break\n                    }\n                }\n\n                // Insert fixup workflow:\n\n                key_ := totalNodes_\n                let BR := _BITMASK_RED\n                for {} iszero(eq(key_, mload(0x00))) {} {\n                    let packed_ := sload(or(nodes_, key_))\n                    let parent_ := getKey(packed_, _BITPOS_PARENT)\n                    let parentPacked_ := sload(or(nodes_, parent_))\n                    if iszero(and(BR, parentPacked_)) { break }\n\n                    let grandParent_ := getKey(parentPacked_, _BITPOS_PARENT)\n                    let grandParentPacked_ := sload(or(nodes_, grandParent_))\n\n                    let R := mul(eq(parent_, getKey(grandParentPacked_, 0)), _BITPOS_RIGHT)\n                    let L := xor(R, _BITPOS_RIGHT)\n\n                    let c_ := getKey(grandParentPacked_, R)\n                    let cPacked_ := sload(or(nodes_, c_))\n                    if iszero(and(BR, cPacked_)) {\n                        if eq(key_, getKey(parentPacked_, R)) {\n                            key_ := parent_\n                            rotate(nodes_, key_, L, R)\n                            parent_ := getKey(sload(or(nodes_, key_)), _BITPOS_PARENT)\n                            parentPacked_ := sload(or(nodes_, parent_))\n                        }\n                        sstore(or(nodes_, parent_), and(parentPacked_, not(BR)))\n                        let s_ := or(nodes_, grandParent_)\n                        sstore(s_, or(sload(s_), BR))\n                        rotate(nodes_, grandParent_, R, L)\n                        break\n                    }\n                    sstore(or(nodes_, parent_), and(parentPacked_, not(BR)))\n                    sstore(or(nodes_, c_), and(cPacked_, not(BR)))\n                    sstore(or(nodes_, grandParent_), or(grandParentPacked_, BR))\n                    key_ := grandParent_\n                }\n                let root_ := or(nodes_, mload(0x00))\n                sstore(root_, and(sload(root_), not(BR)))\n            }\n\n            function removeFixup(nodes_, key_) {\n                let BR := _BITMASK_RED\n                for {} iszero(eq(key_, mload(0x00))) {} {\n                    let packed_ := sload(or(nodes_, key_))\n                    if and(BR, packed_) { break }\n\n                    let parent_ := getKey(packed_, _BITPOS_PARENT)\n                    let parentPacked_ := sload(or(nodes_, parent_))\n\n                    let R := mul(eq(key_, getKey(parentPacked_, 0)), _BITPOS_RIGHT)\n                    let L := xor(R, _BITPOS_RIGHT)\n\n                    let cursor_ := getKey(parentPacked_, R)\n                    let cursorPacked_ := sload(or(nodes_, cursor_))\n\n                    if and(BR, cursorPacked_) {\n                        sstore(or(nodes_, cursor_), and(cursorPacked_, not(BR)))\n                        sstore(or(nodes_, parent_), or(parentPacked_, BR))\n                        rotate(nodes_, parent_, L, R)\n                        cursor_ := getKey(sload(or(nodes_, parent_)), R)\n                        cursorPacked_ := sload(or(nodes_, cursor_))\n                    }\n\n                    let cursorLeft_ := getKey(cursorPacked_, L)\n                    let cursorLeftPacked_ := sload(or(nodes_, cursorLeft_))\n                    let cursorRight_ := getKey(cursorPacked_, R)\n                    let cursorRightPacked_ := sload(or(nodes_, cursorRight_))\n\n                    if iszero(and(BR, or(cursorLeftPacked_, cursorRightPacked_))) {\n                        sstore(or(nodes_, cursor_), or(cursorPacked_, BR))\n                        key_ := parent_\n                        continue\n                    }\n\n                    if iszero(and(BR, cursorRightPacked_)) {\n                        sstore(or(nodes_, cursorLeft_), and(cursorLeftPacked_, not(BR)))\n                        sstore(or(nodes_, cursor_), or(cursorPacked_, BR))\n                        rotate(nodes_, cursor_, R, L)\n                        cursor_ := getKey(sload(or(nodes_, parent_)), R)\n                        cursorPacked_ := sload(or(nodes_, cursor_))\n                        cursorRight_ := getKey(cursorPacked_, R)\n                        cursorRightPacked_ := sload(or(nodes_, cursorRight_))\n                    }\n\n                    parentPacked_ := sload(or(nodes_, parent_))\n                    // forgefmt: disable-next-item\n                    sstore(or(nodes_, cursor_), xor(cursorPacked_, and(BR, xor(cursorPacked_, parentPacked_))))\n                    sstore(or(nodes_, parent_), and(parentPacked_, not(BR)))\n                    sstore(or(nodes_, cursorRight_), and(cursorRightPacked_, not(BR)))\n                    rotate(nodes_, parent_, L, R)\n                    break\n                }\n                sstore(or(nodes_, key_), and(sload(or(nodes_, key_)), not(BR)))\n            }\n\n            function replaceParent(nodes_, parent_, a_, b_) {\n                if iszero(parent_) {\n                    mstore(0x00, a_)\n                    leave\n                }\n                let s_ := or(nodes_, parent_)\n                let p_ := sload(s_)\n                let t_ := iszero(eq(b_, getKey(p_, _BITPOS_LEFT)))\n                sstore(s_, setKey(p_, mul(t_, _BITPOS_RIGHT), a_))\n            }\n\n            // In `remove`, the parent of the null value (index 0) may be temporarily set\n            // to a non-zero value. This is an optimization that unifies the removal cases.\n            function remove(nodes_, key_) -> err_ {\n                if gt(key_, shr(128, mload(0x20))) {\n                    err_ := ERROR_POINTER_OUT_OF_BOUNDS\n                    leave\n                }\n                if iszero(key_) {\n                    err_ := ERROR_VALUE_DOES_NOT_EXISTS\n                    leave\n                }\n\n                let cursor_ := key_\n                {\n                    let packed_ := sload(or(nodes_, key_))\n                    let left_ := getKey(packed_, _BITPOS_LEFT)\n                    let right_ := getKey(packed_, _BITPOS_RIGHT)\n                    if mul(left_, right_) {\n                        for { cursor_ := right_ } 1 {} {\n                            let cursorLeft_ := getKey(sload(or(nodes_, cursor_)), _BITPOS_LEFT)\n                            if iszero(cursorLeft_) { break }\n                            cursor_ := cursorLeft_\n                        }\n                    }\n                }\n\n                let cursorPacked_ := sload(or(nodes_, cursor_))\n                let probe_ := getKey(cursorPacked_, _BITPOS_LEFT)\n                probe_ := getKey(cursorPacked_, mul(iszero(probe_), _BITPOS_RIGHT))\n\n                let yParent_ := getKey(cursorPacked_, _BITPOS_PARENT)\n                let probeSlot_ := or(nodes_, probe_)\n                sstore(probeSlot_, setKey(sload(probeSlot_), _BITPOS_PARENT, yParent_))\n                replaceParent(nodes_, yParent_, probe_, cursor_)\n\n                if iszero(eq(cursor_, key_)) {\n                    let packed_ := sload(or(nodes_, key_))\n                    replaceParent(nodes_, getKey(packed_, _BITPOS_PARENT), cursor_, key_)\n\n                    let leftSlot_ := or(nodes_, getKey(packed_, _BITPOS_LEFT))\n                    sstore(leftSlot_, setKey(sload(leftSlot_), _BITPOS_PARENT, cursor_))\n\n                    let rightSlot_ := or(nodes_, getKey(packed_, _BITPOS_RIGHT))\n                    sstore(rightSlot_, setKey(sload(rightSlot_), _BITPOS_PARENT, cursor_))\n\n                    // Copy `left`, `right`, `red` from `key_` to `cursor_`.\n                    // forgefmt: disable-next-item\n                    sstore(or(nodes_, cursor_), xor(cursorPacked_,\n                        and(xor(packed_, cursorPacked_), sub(shl(_BITPOS_PACKED_VALUE, 1), 1))))\n\n                    let t_ := cursor_\n                    cursor_ := key_\n                    key_ := t_\n                }\n\n                if iszero(and(_BITMASK_RED, cursorPacked_)) {\n                    removeFixup(nodes_, probe_)\n                }\n\n                // Remove last workflow:\n\n                let last_ := shr(128, mload(0x20))\n                let lastPacked_ := sload(or(nodes_, last_))\n                let lastValue_ := shr(_BITPOS_PACKED_VALUE, lastPacked_)\n                let lastFullValue_ := 0\n                if iszero(lastValue_) {\n                    lastValue_ := sload(or(_BIT_FULL_VALUE_SLOT, or(nodes_, last_)))\n                    lastFullValue_ := lastValue_\n                }\n\n                let cursorValue_ := shr(_BITPOS_PACKED_VALUE, sload(or(nodes_, cursor_)))\n                let cursorFullValue_ := 0\n                if iszero(cursorValue_) {\n                    cursorValue_ := sload(or(_BIT_FULL_VALUE_SLOT, or(nodes_, cursor_)))\n                    cursorFullValue_ := cursorValue_\n                }\n\n                if iszero(eq(lastValue_, cursorValue_)) {\n                    sstore(or(nodes_, cursor_), lastPacked_)\n                    if iszero(eq(lastFullValue_, cursorFullValue_)) {\n                        sstore(or(_BIT_FULL_VALUE_SLOT, or(nodes_, cursor_)), lastFullValue_)\n                    }\n                    for { let lastParent_ := getKey(lastPacked_, _BITPOS_PARENT) } 1 {} {\n                        if iszero(lastParent_) {\n                            mstore(0x00, cursor_)\n                            break\n                        }\n                        let s_ := or(nodes_, lastParent_)\n                        let p_ := sload(s_)\n                        let t_ := iszero(eq(last_, getKey(p_, _BITPOS_LEFT)))\n                        sstore(s_, setKey(p_, mul(t_, _BITPOS_RIGHT), cursor_))\n                        break\n                    }\n                    let lastRight_ := getKey(lastPacked_, _BITPOS_RIGHT)\n                    if lastRight_ {\n                        let s_ := or(nodes_, lastRight_)\n                        sstore(s_, setKey(sload(s_), _BITPOS_PARENT, cursor_))\n                    }\n                    let lastLeft_ := getKey(lastPacked_, _BITPOS_LEFT)\n                    if lastLeft_ {\n                        let s_ := or(nodes_, lastLeft_)\n                        sstore(s_, setKey(sload(s_), _BITPOS_PARENT, cursor_))\n                    }\n                }\n                sstore(or(nodes_, last_), 0)\n                if lastFullValue_ { sstore(or(_BIT_FULL_VALUE_SLOT, or(nodes_, last_)), 0) }\n\n                mstore(0x20, shl(128, sub(last_, 1)))\n            }\n\n            mstore(0x00, codesize()) // Zeroize the first 0x10 bytes.\n            mstore(0x10, sload(nodes))\n\n            for {} 1 {} {\n                if iszero(mode) {\n                    err := insert(nodes, cursor, key, x)\n                    break\n                }\n                err := remove(nodes, key)\n                break\n            }\n\n            sstore(nodes, mload(0x10))\n        }\n    }",
            "startLine": 350
          },
          {
            "name": "_nodes",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              }
            ],
            "returnValues": [
              {
                "name": "nodes",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _nodes(Tree storage tree) private pure returns (uint256 nodes) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, tree.slot)\n            mstore(0x00, _NODES_SLOT_SEED)\n            nodes := shl(_NODES_SLOT_SHIFT, keccak256(0x00, 0x40))\n        }\n    }",
            "startLine": 677
          },
          {
            "name": "_find",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "nodes",
                "type": "uint256"
              },
              {
                "name": "cursor",
                "type": "uint256"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_revert",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _find(Tree storage tree, uint256 x)\n        private\n        view\n        returns (uint256 nodes, uint256 cursor, uint256 key)\n    {\n        if (x == uint256(0)) _revert(0xc94f1877); // `ValueIsEmpty()`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, tree.slot)\n            mstore(0x00, _NODES_SLOT_SEED)\n            nodes := shl(_NODES_SLOT_SHIFT, keccak256(0x00, 0x40))\n            // Layout scratch space so that `mload(0x00) == 0`, `mload(0x01) == _BITPOS_RIGHT`.\n            mstore(0x01, _BITPOS_RIGHT) // `_BITPOS_RIGHT` is 31.\n            for { let probe := shr(128, sload(nodes)) } probe {} {\n                cursor := probe\n                let nodePacked := sload(or(nodes, probe))\n                let nodeValue := shr(_BITPOS_PACKED_VALUE, nodePacked)\n                if iszero(nodeValue) {\n                    nodeValue := sload(or(or(nodes, probe), _BIT_FULL_VALUE_SLOT))\n                }\n                if eq(nodeValue, x) {\n                    key := cursor\n                    break\n                }\n                probe := and(shr(mload(gt(x, nodeValue)), nodePacked), _BITMASK_KEY)\n            }\n        }\n    }",
            "startLine": 687
          },
          {
            "name": "_revert",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "err",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _revert(uint256 err) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, err)\n            revert(0x1c, 0x04)\n        }\n    }",
            "startLine": 717
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ValueIsEmpty",
            "parameters": [],
            "startLine": 15
          },
          {
            "name": "ValueAlreadyExists",
            "parameters": [],
            "startLine": 18
          },
          {
            "name": "ValueDoesNotExist",
            "parameters": [],
            "startLine": 21
          },
          {
            "name": "PointerOutOfBounds",
            "parameters": [],
            "startLine": 24
          },
          {
            "name": "TreeIsFull",
            "parameters": [],
            "startLine": 27
          }
        ],
        "structs": [
          {
            "name": "Tree",
            "members": [
              {
                "name": "_spacer",
                "type": "uint256"
              }
            ],
            "startLine": 46
          }
        ],
        "stateVariables": [
          {
            "name": "ERROR_VALUE_ALREADY_EXISTS",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 30
          },
          {
            "name": "ERROR_VALUE_DOES_NOT_EXISTS",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 33
          },
          {
            "name": "ERROR_POINTER_OUT_OF_BOUNDS",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 36
          },
          {
            "name": "ERROR_TREE_IS_FULL",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 39
          },
          {
            "name": "_NODES_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 82
          },
          {
            "name": "_NODES_SLOT_SHIFT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 83
          },
          {
            "name": "_BITMASK_KEY",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 84
          },
          {
            "name": "_BITPOS_LEFT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 85
          },
          {
            "name": "_BITPOS_RIGHT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 86
          },
          {
            "name": "_BITPOS_PARENT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 87
          },
          {
            "name": "_BITPOS_RED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 88
          },
          {
            "name": "_BITMASK_RED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 89
          },
          {
            "name": "_BITPOS_PACKED_VALUE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 90
          },
          {
            "name": "_BITMASK_PACKED_VALUE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 91
          },
          {
            "name": "_BIT_FULL_VALUE_SLOT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 92
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "ReentrancyGuard",
        "filePath": "utils/ReentrancyGuard.sol",
        "kind": "abstract",
        "inherits": [],
        "implements": [],
        "category": "utils",
        "externalFunctions": [],
        "internalFunctions": [],
        "events": [],
        "errors": [
          {
            "name": "Reentrancy",
            "parameters": [],
            "startLine": 12
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_REENTRANCY_GUARD_SLOT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 21
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "ReentrancyGuardTransient",
        "filePath": "utils/ReentrancyGuardTransient.sol",
        "kind": "abstract",
        "inherits": [],
        "implements": [],
        "category": "utils",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "_useTransientReentrancyGuardOnlyOnMainnet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _useTransientReentrancyGuardOnlyOnMainnet() internal view virtual returns (bool) {\n        return true;\n    }",
            "startLine": 120
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "Reentrancy",
            "parameters": [],
            "startLine": 15
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_REENTRANCY_GUARD_SLOT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 24
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "SSTORE2",
        "filePath": "utils/SSTORE2.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "write",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "pointer",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function write(bytes memory data) internal returns (address pointer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data) // Let `l` be `n + 1`. +1 as we prefix a STOP opcode.\n            /**\n             * ---------------------------------------------------+\n             * Opcode | Mnemonic       | Stack     | Memory       |\n             * ---------------------------------------------------|\n             * 61 l   | PUSH2 l        | l         |              |\n             * 80     | DUP1           | l l       |              |\n             * 60 0xa | PUSH1 0xa      | 0xa l l   |              |\n             * 3D     | RETURNDATASIZE | 0 0xa l l |              |\n             * 39     | CODECOPY       | l         | [0..l): code |\n             * 3D     | RETURNDATASIZE | 0 l       | [0..l): code |\n             * F3     | RETURN         |           | [0..l): code |\n             * 00     | STOP           |           |              |\n             * ---------------------------------------------------+\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\n             */\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            mstore(add(data, gt(n, 0xfffe)), add(0xfe61000180600a3d393df300, shl(0x40, n)))\n            // Deploy a new contract with the generated creation code.\n            pointer := create(0, add(data, 0x15), add(n, 0xb))\n            if iszero(pointer) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }",
            "startLine": 35
          },
          {
            "name": "writeCounterfactual",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "pointer",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function writeCounterfactual(bytes memory data, bytes32 salt)\n        internal\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            mstore(add(data, gt(n, 0xfffe)), add(0xfe61000180600a3d393df300, shl(0x40, n)))\n            // Deploy a new contract with the generated creation code.\n            pointer := create2(0, add(data, 0x15), add(n, 0xb), salt)\n            if iszero(pointer) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }",
            "startLine": 69
          },
          {
            "name": "writeDeterministic",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "pointer",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function writeDeterministic(bytes memory data, bytes32 salt)\n        internal\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            mstore(0x00, _CREATE3_PROXY_INITCODE) // Store the `_PROXY_INITCODE`.\n            let proxy := create2(0, 0x10, 0x10, salt)\n            if iszero(proxy) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, proxy) // Store the proxy's address.\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            mstore8(0x34, 0x01) // Nonce of the proxy contract (1).\n            pointer := keccak256(0x1e, 0x17)\n\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            mstore(add(data, gt(n, 0xfffe)), add(0xfe61000180600a3d393df300, shl(0x40, n)))\n            if iszero(\n                mul( // The arguments of `mul` are evaluated last to first.\n                    extcodesize(pointer),\n                    call(gas(), proxy, 0, add(data, 0x15), add(n, 0xb), codesize(), 0x00)\n                )\n            ) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }",
            "startLine": 91
          },
          {
            "name": "initCodeHash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "hash",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeHash(bytes memory data) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xfffe))\n            mstore(data, add(0x61000180600a3d393df300, shl(0x40, n)))\n            hash := keccak256(add(data, 0x15), add(n, 0xb))\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }",
            "startLine": 132
          },
          {
            "name": "predictCounterfactualAddress",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "pointer",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "predictCounterfactualAddress",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function predictCounterfactualAddress(bytes memory data, bytes32 salt)\n        internal\n        view\n        returns (address pointer)\n    {\n        pointer = predictCounterfactualAddress(data, salt, address(this));\n    }",
            "startLine": 145
          },
          {
            "name": "predictCounterfactualAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "deployer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "initCodeHash",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function predictCounterfactualAddress(bytes memory data, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(data);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }",
            "startLine": 156
          },
          {
            "name": "predictDeterministicAddress",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "pointer",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "predictDeterministicAddress",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddress(bytes32 salt) internal view returns (address pointer) {\n        pointer = predictDeterministicAddress(salt, address(this));\n    }",
            "startLine": 176
          },
          {
            "name": "predictDeterministicAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "deployer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "pointer",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddress(bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, deployer) // Store `deployer`.\n            mstore8(0x0b, 0xff) // Store the prefix.\n            mstore(0x20, salt) // Store the salt.\n            mstore(0x40, CREATE3_PROXY_INITCODE_HASH) // Store the bytecode hash.\n\n            mstore(0x14, keccak256(0x0b, 0x55)) // Store the proxy's address.\n            mstore(0x40, m) // Restore the free memory pointer.\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            mstore8(0x34, 0x01) // Nonce of the proxy contract (1).\n            pointer := keccak256(0x1e, 0x17)\n        }\n    }",
            "startLine": 181
          },
          {
            "name": "read",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "pointer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function read(address pointer) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(pointer), 0x01))\n            extcodecopy(pointer, add(data, 0x1f), 0x00, add(n, 0x21))\n            mstore(data, n) // Store the length.\n            mstore(0x40, add(n, add(data, 0x40))) // Allocate memory.\n        }\n    }",
            "startLine": 209
          },
          {
            "name": "read",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "pointer",
                "type": "address"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function read(address pointer, uint256 start) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(pointer), 0x01))\n            let l := sub(n, and(0xffffff, mul(lt(start, n), start)))\n            extcodecopy(pointer, add(data, 0x1f), start, add(l, 0x21))\n            mstore(data, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(data, add(0x40, mload(data)))) // Allocate memory.\n        }\n    }",
            "startLine": 221
          },
          {
            "name": "read",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "pointer",
                "type": "address"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function read(address pointer, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(pointer, add(data, 0x1f), start, add(d, 0x01))\n            if iszero(and(0xff, mload(add(data, d)))) {\n                let n := sub(extcodesize(pointer), 0x01)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(data, d) // Store the length.\n            mstore(add(add(data, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(data, 0x40), d)) // Allocate memory.\n        }\n    }",
            "startLine": 238
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "DeploymentFailed",
            "parameters": [],
            "startLine": 28
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_CREATE3_PROXY_INITCODE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 16
          },
          {
            "name": "CREATE3_PROXY_INITCODE_HASH",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 20
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "SafeCastLib",
        "filePath": "utils/SafeCastLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "toUint8",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint8(uint256 x) internal pure returns (uint8) {\n        if (x >= 1 << 8) _revertOverflow();\n        return uint8(x);\n    }",
            "startLine": 21
          },
          {
            "name": "toUint16",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint16"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint16(uint256 x) internal pure returns (uint16) {\n        if (x >= 1 << 16) _revertOverflow();\n        return uint16(x);\n    }",
            "startLine": 27
          },
          {
            "name": "toUint24",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint24"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint24(uint256 x) internal pure returns (uint24) {\n        if (x >= 1 << 24) _revertOverflow();\n        return uint24(x);\n    }",
            "startLine": 33
          },
          {
            "name": "toUint32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint32(uint256 x) internal pure returns (uint32) {\n        if (x >= 1 << 32) _revertOverflow();\n        return uint32(x);\n    }",
            "startLine": 39
          },
          {
            "name": "toUint40",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint40"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint40(uint256 x) internal pure returns (uint40) {\n        if (x >= 1 << 40) _revertOverflow();\n        return uint40(x);\n    }",
            "startLine": 45
          },
          {
            "name": "toUint48",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint48"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint48(uint256 x) internal pure returns (uint48) {\n        if (x >= 1 << 48) _revertOverflow();\n        return uint48(x);\n    }",
            "startLine": 51
          },
          {
            "name": "toUint56",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint56"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint56(uint256 x) internal pure returns (uint56) {\n        if (x >= 1 << 56) _revertOverflow();\n        return uint56(x);\n    }",
            "startLine": 57
          },
          {
            "name": "toUint64",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint64(uint256 x) internal pure returns (uint64) {\n        if (x >= 1 << 64) _revertOverflow();\n        return uint64(x);\n    }",
            "startLine": 63
          },
          {
            "name": "toUint72",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint72"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint72(uint256 x) internal pure returns (uint72) {\n        if (x >= 1 << 72) _revertOverflow();\n        return uint72(x);\n    }",
            "startLine": 69
          },
          {
            "name": "toUint80",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint80"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint80(uint256 x) internal pure returns (uint80) {\n        if (x >= 1 << 80) _revertOverflow();\n        return uint80(x);\n    }",
            "startLine": 75
          },
          {
            "name": "toUint88",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint88"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint88(uint256 x) internal pure returns (uint88) {\n        if (x >= 1 << 88) _revertOverflow();\n        return uint88(x);\n    }",
            "startLine": 81
          },
          {
            "name": "toUint96",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint96"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint96(uint256 x) internal pure returns (uint96) {\n        if (x >= 1 << 96) _revertOverflow();\n        return uint96(x);\n    }",
            "startLine": 87
          },
          {
            "name": "toUint104",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint104"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint104(uint256 x) internal pure returns (uint104) {\n        if (x >= 1 << 104) _revertOverflow();\n        return uint104(x);\n    }",
            "startLine": 93
          },
          {
            "name": "toUint112",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint112"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint112(uint256 x) internal pure returns (uint112) {\n        if (x >= 1 << 112) _revertOverflow();\n        return uint112(x);\n    }",
            "startLine": 99
          },
          {
            "name": "toUint120",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint120"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint120(uint256 x) internal pure returns (uint120) {\n        if (x >= 1 << 120) _revertOverflow();\n        return uint120(x);\n    }",
            "startLine": 105
          },
          {
            "name": "toUint128",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint128"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint128(uint256 x) internal pure returns (uint128) {\n        if (x >= 1 << 128) _revertOverflow();\n        return uint128(x);\n    }",
            "startLine": 111
          },
          {
            "name": "toUint136",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint136"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint136(uint256 x) internal pure returns (uint136) {\n        if (x >= 1 << 136) _revertOverflow();\n        return uint136(x);\n    }",
            "startLine": 117
          },
          {
            "name": "toUint144",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint144"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint144(uint256 x) internal pure returns (uint144) {\n        if (x >= 1 << 144) _revertOverflow();\n        return uint144(x);\n    }",
            "startLine": 123
          },
          {
            "name": "toUint152",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint152"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint152(uint256 x) internal pure returns (uint152) {\n        if (x >= 1 << 152) _revertOverflow();\n        return uint152(x);\n    }",
            "startLine": 129
          },
          {
            "name": "toUint160",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint160"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint160(uint256 x) internal pure returns (uint160) {\n        if (x >= 1 << 160) _revertOverflow();\n        return uint160(x);\n    }",
            "startLine": 135
          },
          {
            "name": "toUint168",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint168"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint168(uint256 x) internal pure returns (uint168) {\n        if (x >= 1 << 168) _revertOverflow();\n        return uint168(x);\n    }",
            "startLine": 141
          },
          {
            "name": "toUint176",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint176"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint176(uint256 x) internal pure returns (uint176) {\n        if (x >= 1 << 176) _revertOverflow();\n        return uint176(x);\n    }",
            "startLine": 147
          },
          {
            "name": "toUint184",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint184"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint184(uint256 x) internal pure returns (uint184) {\n        if (x >= 1 << 184) _revertOverflow();\n        return uint184(x);\n    }",
            "startLine": 153
          },
          {
            "name": "toUint192",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint192"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint192(uint256 x) internal pure returns (uint192) {\n        if (x >= 1 << 192) _revertOverflow();\n        return uint192(x);\n    }",
            "startLine": 159
          },
          {
            "name": "toUint200",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint200"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint200(uint256 x) internal pure returns (uint200) {\n        if (x >= 1 << 200) _revertOverflow();\n        return uint200(x);\n    }",
            "startLine": 165
          },
          {
            "name": "toUint208",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint208"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint208(uint256 x) internal pure returns (uint208) {\n        if (x >= 1 << 208) _revertOverflow();\n        return uint208(x);\n    }",
            "startLine": 171
          },
          {
            "name": "toUint216",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint216"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint216(uint256 x) internal pure returns (uint216) {\n        if (x >= 1 << 216) _revertOverflow();\n        return uint216(x);\n    }",
            "startLine": 177
          },
          {
            "name": "toUint224",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint224"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint224(uint256 x) internal pure returns (uint224) {\n        if (x >= 1 << 224) _revertOverflow();\n        return uint224(x);\n    }",
            "startLine": 183
          },
          {
            "name": "toUint232",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint232"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint232(uint256 x) internal pure returns (uint232) {\n        if (x >= 1 << 232) _revertOverflow();\n        return uint232(x);\n    }",
            "startLine": 189
          },
          {
            "name": "toUint240",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint240"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint240(uint256 x) internal pure returns (uint240) {\n        if (x >= 1 << 240) _revertOverflow();\n        return uint240(x);\n    }",
            "startLine": 195
          },
          {
            "name": "toUint248",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint248"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint248(uint256 x) internal pure returns (uint248) {\n        if (x >= 1 << 248) _revertOverflow();\n        return uint248(x);\n    }",
            "startLine": 201
          },
          {
            "name": "toInt8",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int8"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt8(int256 x) internal pure returns (int8) {\n        unchecked {\n            if (((1 << 7) + uint256(x)) >> 8 == uint256(0)) return int8(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 211
          },
          {
            "name": "toInt16",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int16"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt16(int256 x) internal pure returns (int16) {\n        unchecked {\n            if (((1 << 15) + uint256(x)) >> 16 == uint256(0)) return int16(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 219
          },
          {
            "name": "toInt24",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int24"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt24(int256 x) internal pure returns (int24) {\n        unchecked {\n            if (((1 << 23) + uint256(x)) >> 24 == uint256(0)) return int24(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 227
          },
          {
            "name": "toInt32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt32(int256 x) internal pure returns (int32) {\n        unchecked {\n            if (((1 << 31) + uint256(x)) >> 32 == uint256(0)) return int32(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 235
          },
          {
            "name": "toInt40",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int40"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt40(int256 x) internal pure returns (int40) {\n        unchecked {\n            if (((1 << 39) + uint256(x)) >> 40 == uint256(0)) return int40(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 243
          },
          {
            "name": "toInt48",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int48"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt48(int256 x) internal pure returns (int48) {\n        unchecked {\n            if (((1 << 47) + uint256(x)) >> 48 == uint256(0)) return int48(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 251
          },
          {
            "name": "toInt56",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int56"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt56(int256 x) internal pure returns (int56) {\n        unchecked {\n            if (((1 << 55) + uint256(x)) >> 56 == uint256(0)) return int56(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 259
          },
          {
            "name": "toInt64",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int64"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt64(int256 x) internal pure returns (int64) {\n        unchecked {\n            if (((1 << 63) + uint256(x)) >> 64 == uint256(0)) return int64(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 267
          },
          {
            "name": "toInt72",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int72"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt72(int256 x) internal pure returns (int72) {\n        unchecked {\n            if (((1 << 71) + uint256(x)) >> 72 == uint256(0)) return int72(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 275
          },
          {
            "name": "toInt80",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int80"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt80(int256 x) internal pure returns (int80) {\n        unchecked {\n            if (((1 << 79) + uint256(x)) >> 80 == uint256(0)) return int80(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 283
          },
          {
            "name": "toInt88",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int88"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt88(int256 x) internal pure returns (int88) {\n        unchecked {\n            if (((1 << 87) + uint256(x)) >> 88 == uint256(0)) return int88(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 291
          },
          {
            "name": "toInt96",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int96"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt96(int256 x) internal pure returns (int96) {\n        unchecked {\n            if (((1 << 95) + uint256(x)) >> 96 == uint256(0)) return int96(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 299
          },
          {
            "name": "toInt104",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int104"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt104(int256 x) internal pure returns (int104) {\n        unchecked {\n            if (((1 << 103) + uint256(x)) >> 104 == uint256(0)) return int104(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 307
          },
          {
            "name": "toInt112",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int112"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt112(int256 x) internal pure returns (int112) {\n        unchecked {\n            if (((1 << 111) + uint256(x)) >> 112 == uint256(0)) return int112(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 315
          },
          {
            "name": "toInt120",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int120"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt120(int256 x) internal pure returns (int120) {\n        unchecked {\n            if (((1 << 119) + uint256(x)) >> 120 == uint256(0)) return int120(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 323
          },
          {
            "name": "toInt128",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int128"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt128(int256 x) internal pure returns (int128) {\n        unchecked {\n            if (((1 << 127) + uint256(x)) >> 128 == uint256(0)) return int128(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 331
          },
          {
            "name": "toInt136",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int136"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt136(int256 x) internal pure returns (int136) {\n        unchecked {\n            if (((1 << 135) + uint256(x)) >> 136 == uint256(0)) return int136(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 339
          },
          {
            "name": "toInt144",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int144"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt144(int256 x) internal pure returns (int144) {\n        unchecked {\n            if (((1 << 143) + uint256(x)) >> 144 == uint256(0)) return int144(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 347
          },
          {
            "name": "toInt152",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int152"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt152(int256 x) internal pure returns (int152) {\n        unchecked {\n            if (((1 << 151) + uint256(x)) >> 152 == uint256(0)) return int152(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 355
          },
          {
            "name": "toInt160",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int160"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt160(int256 x) internal pure returns (int160) {\n        unchecked {\n            if (((1 << 159) + uint256(x)) >> 160 == uint256(0)) return int160(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 363
          },
          {
            "name": "toInt168",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int168"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt168(int256 x) internal pure returns (int168) {\n        unchecked {\n            if (((1 << 167) + uint256(x)) >> 168 == uint256(0)) return int168(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 371
          },
          {
            "name": "toInt176",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int176"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt176(int256 x) internal pure returns (int176) {\n        unchecked {\n            if (((1 << 175) + uint256(x)) >> 176 == uint256(0)) return int176(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 379
          },
          {
            "name": "toInt184",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int184"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt184(int256 x) internal pure returns (int184) {\n        unchecked {\n            if (((1 << 183) + uint256(x)) >> 184 == uint256(0)) return int184(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 387
          },
          {
            "name": "toInt192",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int192"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt192(int256 x) internal pure returns (int192) {\n        unchecked {\n            if (((1 << 191) + uint256(x)) >> 192 == uint256(0)) return int192(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 395
          },
          {
            "name": "toInt200",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int200"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt200(int256 x) internal pure returns (int200) {\n        unchecked {\n            if (((1 << 199) + uint256(x)) >> 200 == uint256(0)) return int200(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 403
          },
          {
            "name": "toInt208",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int208"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt208(int256 x) internal pure returns (int208) {\n        unchecked {\n            if (((1 << 207) + uint256(x)) >> 208 == uint256(0)) return int208(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 411
          },
          {
            "name": "toInt216",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int216"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt216(int256 x) internal pure returns (int216) {\n        unchecked {\n            if (((1 << 215) + uint256(x)) >> 216 == uint256(0)) return int216(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 419
          },
          {
            "name": "toInt224",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int224"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt224(int256 x) internal pure returns (int224) {\n        unchecked {\n            if (((1 << 223) + uint256(x)) >> 224 == uint256(0)) return int224(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 427
          },
          {
            "name": "toInt232",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int232"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt232(int256 x) internal pure returns (int232) {\n        unchecked {\n            if (((1 << 231) + uint256(x)) >> 232 == uint256(0)) return int232(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 435
          },
          {
            "name": "toInt240",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int240"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt240(int256 x) internal pure returns (int240) {\n        unchecked {\n            if (((1 << 239) + uint256(x)) >> 240 == uint256(0)) return int240(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 443
          },
          {
            "name": "toInt248",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int248"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt248(int256 x) internal pure returns (int248) {\n        unchecked {\n            if (((1 << 247) + uint256(x)) >> 248 == uint256(0)) return int248(x);\n            _revertOverflow();\n        }\n    }",
            "startLine": 451
          },
          {
            "name": "toInt8",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int8"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt8(uint256 x) internal pure returns (int8) {\n        if (x >= 1 << 7) _revertOverflow();\n        return int8(int256(x));\n    }",
            "startLine": 463
          },
          {
            "name": "toInt16",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int16"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt16(uint256 x) internal pure returns (int16) {\n        if (x >= 1 << 15) _revertOverflow();\n        return int16(int256(x));\n    }",
            "startLine": 469
          },
          {
            "name": "toInt24",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int24"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt24(uint256 x) internal pure returns (int24) {\n        if (x >= 1 << 23) _revertOverflow();\n        return int24(int256(x));\n    }",
            "startLine": 475
          },
          {
            "name": "toInt32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt32(uint256 x) internal pure returns (int32) {\n        if (x >= 1 << 31) _revertOverflow();\n        return int32(int256(x));\n    }",
            "startLine": 481
          },
          {
            "name": "toInt40",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int40"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt40(uint256 x) internal pure returns (int40) {\n        if (x >= 1 << 39) _revertOverflow();\n        return int40(int256(x));\n    }",
            "startLine": 487
          },
          {
            "name": "toInt48",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int48"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt48(uint256 x) internal pure returns (int48) {\n        if (x >= 1 << 47) _revertOverflow();\n        return int48(int256(x));\n    }",
            "startLine": 493
          },
          {
            "name": "toInt56",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int56"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt56(uint256 x) internal pure returns (int56) {\n        if (x >= 1 << 55) _revertOverflow();\n        return int56(int256(x));\n    }",
            "startLine": 499
          },
          {
            "name": "toInt64",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int64"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt64(uint256 x) internal pure returns (int64) {\n        if (x >= 1 << 63) _revertOverflow();\n        return int64(int256(x));\n    }",
            "startLine": 505
          },
          {
            "name": "toInt72",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int72"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt72(uint256 x) internal pure returns (int72) {\n        if (x >= 1 << 71) _revertOverflow();\n        return int72(int256(x));\n    }",
            "startLine": 511
          },
          {
            "name": "toInt80",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int80"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt80(uint256 x) internal pure returns (int80) {\n        if (x >= 1 << 79) _revertOverflow();\n        return int80(int256(x));\n    }",
            "startLine": 517
          },
          {
            "name": "toInt88",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int88"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt88(uint256 x) internal pure returns (int88) {\n        if (x >= 1 << 87) _revertOverflow();\n        return int88(int256(x));\n    }",
            "startLine": 523
          },
          {
            "name": "toInt96",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int96"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt96(uint256 x) internal pure returns (int96) {\n        if (x >= 1 << 95) _revertOverflow();\n        return int96(int256(x));\n    }",
            "startLine": 529
          },
          {
            "name": "toInt104",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int104"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt104(uint256 x) internal pure returns (int104) {\n        if (x >= 1 << 103) _revertOverflow();\n        return int104(int256(x));\n    }",
            "startLine": 535
          },
          {
            "name": "toInt112",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int112"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt112(uint256 x) internal pure returns (int112) {\n        if (x >= 1 << 111) _revertOverflow();\n        return int112(int256(x));\n    }",
            "startLine": 541
          },
          {
            "name": "toInt120",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int120"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt120(uint256 x) internal pure returns (int120) {\n        if (x >= 1 << 119) _revertOverflow();\n        return int120(int256(x));\n    }",
            "startLine": 547
          },
          {
            "name": "toInt128",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int128"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt128(uint256 x) internal pure returns (int128) {\n        if (x >= 1 << 127) _revertOverflow();\n        return int128(int256(x));\n    }",
            "startLine": 553
          },
          {
            "name": "toInt136",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int136"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt136(uint256 x) internal pure returns (int136) {\n        if (x >= 1 << 135) _revertOverflow();\n        return int136(int256(x));\n    }",
            "startLine": 559
          },
          {
            "name": "toInt144",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int144"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt144(uint256 x) internal pure returns (int144) {\n        if (x >= 1 << 143) _revertOverflow();\n        return int144(int256(x));\n    }",
            "startLine": 565
          },
          {
            "name": "toInt152",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int152"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt152(uint256 x) internal pure returns (int152) {\n        if (x >= 1 << 151) _revertOverflow();\n        return int152(int256(x));\n    }",
            "startLine": 571
          },
          {
            "name": "toInt160",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int160"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt160(uint256 x) internal pure returns (int160) {\n        if (x >= 1 << 159) _revertOverflow();\n        return int160(int256(x));\n    }",
            "startLine": 577
          },
          {
            "name": "toInt168",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int168"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt168(uint256 x) internal pure returns (int168) {\n        if (x >= 1 << 167) _revertOverflow();\n        return int168(int256(x));\n    }",
            "startLine": 583
          },
          {
            "name": "toInt176",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int176"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt176(uint256 x) internal pure returns (int176) {\n        if (x >= 1 << 175) _revertOverflow();\n        return int176(int256(x));\n    }",
            "startLine": 589
          },
          {
            "name": "toInt184",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int184"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt184(uint256 x) internal pure returns (int184) {\n        if (x >= 1 << 183) _revertOverflow();\n        return int184(int256(x));\n    }",
            "startLine": 595
          },
          {
            "name": "toInt192",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int192"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt192(uint256 x) internal pure returns (int192) {\n        if (x >= 1 << 191) _revertOverflow();\n        return int192(int256(x));\n    }",
            "startLine": 601
          },
          {
            "name": "toInt200",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int200"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt200(uint256 x) internal pure returns (int200) {\n        if (x >= 1 << 199) _revertOverflow();\n        return int200(int256(x));\n    }",
            "startLine": 607
          },
          {
            "name": "toInt208",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int208"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt208(uint256 x) internal pure returns (int208) {\n        if (x >= 1 << 207) _revertOverflow();\n        return int208(int256(x));\n    }",
            "startLine": 613
          },
          {
            "name": "toInt216",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int216"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt216(uint256 x) internal pure returns (int216) {\n        if (x >= 1 << 215) _revertOverflow();\n        return int216(int256(x));\n    }",
            "startLine": 619
          },
          {
            "name": "toInt224",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int224"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt224(uint256 x) internal pure returns (int224) {\n        if (x >= 1 << 223) _revertOverflow();\n        return int224(int256(x));\n    }",
            "startLine": 625
          },
          {
            "name": "toInt232",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int232"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt232(uint256 x) internal pure returns (int232) {\n        if (x >= 1 << 231) _revertOverflow();\n        return int232(int256(x));\n    }",
            "startLine": 631
          },
          {
            "name": "toInt240",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int240"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt240(uint256 x) internal pure returns (int240) {\n        if (x >= 1 << 239) _revertOverflow();\n        return int240(int256(x));\n    }",
            "startLine": 637
          },
          {
            "name": "toInt248",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int248"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt248(uint256 x) internal pure returns (int248) {\n        if (x >= 1 << 247) _revertOverflow();\n        return int248(int256(x));\n    }",
            "startLine": 643
          },
          {
            "name": "toInt256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toInt256(uint256 x) internal pure returns (int256) {\n        if (int256(x) >= 0) return int256(x);\n        _revertOverflow();\n    }",
            "startLine": 649
          },
          {
            "name": "toUint256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint256(int256 x) internal pure returns (uint256) {\n        if (x >= 0) return uint256(x);\n        _revertOverflow();\n    }",
            "startLine": 655
          },
          {
            "name": "_revertOverflow",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _revertOverflow() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the function selector of `Overflow()`.\n            mstore(0x00, 0x35278d12)\n            // Revert with (offset, size).\n            revert(0x1c, 0x04)\n        }\n    }",
            "startLine": 664
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "Overflow",
            "parameters": [],
            "startLine": 14
          }
        ],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "SafeTransferLib",
        "filePath": "utils/SafeTransferLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "safeTransferETH",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 95
          },
          {
            "name": "safeTransferAllETH",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 106
          },
          {
            "name": "forceSafeTransferETH",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "gasStipend",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }",
            "startLine": 118
          },
          {
            "name": "forceSafeTransferAllETH",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "gasStipend",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) {\n                    revert(codesize(), codesize())\n                } // For gas estimation.\n            }\n        }\n    }",
            "startLine": 135
          },
          {
            "name": "forceSafeTransferETH",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }",
            "startLine": 150
          },
          {
            "name": "forceSafeTransferAllETH",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }",
            "startLine": 167
          },
          {
            "name": "trySafeTransferETH",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "gasStipend",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "success",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }",
            "startLine": 182
          },
          {
            "name": "trySafeTransferAllETH",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "gasStipend",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "success",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function trySafeTransferAllETH(address to, uint256 gasStipend) internal returns (bool success) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }",
            "startLine": 193
          },
          {
            "name": "safeMoveETH",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "vault",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function safeMoveETH(address to, uint256 amount) internal returns (address vault) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            to := shr(96, shl(96, to)) // Clean upper 96 bits.\n            for { let mover := ETH_MOVER } iszero(eq(to, address())) {} {\n                let selfBalanceBefore := selfbalance()\n                if or(lt(selfBalanceBefore, amount), eq(to, mover)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                if extcodesize(mover) {\n                    let balanceBefore := balance(to) // Check via delta, in case `SELFDESTRUCT` is bricked.\n                    mstore(0x00, to)\n                    pop(call(gas(), mover, amount, 0x00, 0x20, codesize(), 0x00))\n                    // If `address(to).balance >= amount + balanceBefore`, skip vault workflow.\n                    if iszero(lt(balance(to), add(amount, balanceBefore))) { break }\n                    // Just in case `SELFDESTRUCT` is changed to not revert and do nothing.\n                    if lt(selfBalanceBefore, selfbalance()) { invalid() }\n                }\n                let m := mload(0x40)\n                // If the mover is missing or bricked, deploy a minimal vault\n                // that withdraws all ETH to `to` when being called only by `to`.\n                // forgefmt: disable-next-item\n                mstore(add(m, 0x20), 0x33146025575b600160005260206000f35b3d3d3d3d47335af1601a5760003dfd)\n                mstore(m, or(to, shl(160, 0x6035600b3d3960353df3fe73)))\n                // Compute and store the bytecode hash.\n                mstore8(0x00, 0xff) // Write the prefix.\n                mstore(0x35, keccak256(m, 0x40))\n                mstore(0x01, shl(96, address())) // Deployer.\n                mstore(0x15, 0) // Salt.\n                vault := keccak256(0x00, 0x55)\n                pop(call(gas(), vault, amount, codesize(), 0x00, codesize(), 0x00))\n                // The vault returns a single word on success. Failure reverts with empty data.\n                if iszero(returndatasize()) {\n                    if iszero(create2(0, m, 0x40, 0)) { revert(codesize(), codesize()) } // For gas estimation.\n                }\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }",
            "startLine": 203
          },
          {
            "name": "safeTransferFrom",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 254
          },
          {
            "name": "trySafeTransferFrom",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "success",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                success := lt(or(iszero(extcodesize(token)), returndatasize()), success)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 277
          },
          {
            "name": "safeTransferAllFrom",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 301
          },
          {
            "name": "safeTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }",
            "startLine": 338
          },
          {
            "name": "safeTransferAll",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }",
            "startLine": 358
          },
          {
            "name": "safeApprove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }",
            "startLine": 390
          },
          {
            "name": "safeApproveWithRetry",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x34, 0) // Store 0 for the `amount`.\n                    mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                    pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                    mstore(0x34, amount) // Store back the original `amount`.\n                    // Retry the approval, reverting upon failure.\n                    success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    if iszero(and(eq(mload(0x00), 1), success)) {\n                        // Check the `extcodesize` again just in case the token selfdestructs lol.\n                        if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                            mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                            revert(0x1c, 0x04)\n                        }\n                    }\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }",
            "startLine": 411
          },
          {
            "name": "balanceOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount := mul( // The arguments of `mul` are evaluated from right to left.\n                mload(0x20),\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                )\n            )\n        }\n    }",
            "startLine": 442
          },
          {
            "name": "checkBalanceOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "implemented",
                "type": "bool"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function checkBalanceOf(address token, address account)\n        internal\n        view\n        returns (bool implemented, uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            implemented := and( // The arguments of `and` are evaluated from right to left.\n                gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n            )\n            amount := mul(mload(0x20), implemented)\n        }\n    }",
            "startLine": 460
          },
          {
            "name": "totalSupply",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function totalSupply(address token) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x18160ddd) // `totalSupply()`.\n            if iszero(\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), token, 0x1c, 0x04, 0x00, 0x20))\n            ) {\n                mstore(0x00, 0x54cd9435) // `TotalSupplyQueryFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }",
            "startLine": 479
          },
          {
            "name": "safeTransferFrom2",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "trySafeTransferFrom",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "permit2TransferFrom",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }",
            "startLine": 498
          },
          {
            "name": "permit2TransferFrom",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function permit2TransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := PERMIT2\n            let exists := eq(chainid(), 1)\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\n            if iszero(\n                and(\n                    call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00),\n                    lt(iszero(extcodesize(token)), exists) // Token has code and Permit2 exists.\n                )\n            ) {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\n            }\n        }\n    }",
            "startLine": 506
          },
          {
            "name": "permit2",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "deadline",
                "type": "uint256"
              },
              {
                "name": "v",
                "type": "uint8"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "simplePermit2",
                "type": "internal",
                "argCount": 8
              }
            ],
            "isVirtual": false,
            "sourceCode": "function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                // After here, we can be sure that token is a contract.\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(\n                        add(m, 0x94),\n                        lt(iszero(amount), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\n                    )\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `amount != 0` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }",
            "startLine": 534
          },
          {
            "name": "simplePermit2",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "deadline",
                "type": "uint256"
              },
              {
                "name": "v",
                "type": "uint8"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero( // Revert if token does not have code, or if the call fails.\n                mul(extcodesize(token), call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00))\n            ) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 591
          },
          {
            "name": "permit2Approve",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint160"
              },
              {
                "name": "expiration",
                "type": "uint48"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function permit2Approve(address token, address spender, uint160 amount, uint48 expiration)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let addressMask := shr(96, not(0))\n            let m := mload(0x40)\n            mstore(m, 0x87517c45) // `approve(address,address,uint160,uint48)`.\n            mstore(add(m, 0x20), and(addressMask, token))\n            mstore(add(m, 0x40), and(addressMask, spender))\n            mstore(add(m, 0x60), and(addressMask, amount))\n            mstore(add(m, 0x80), and(0xffffffffffff, expiration))\n            if iszero(call(gas(), PERMIT2, 0, add(m, 0x1c), 0xa0, codesize(), 0x00)) {\n                mstore(0x00, 0x324f14ae) // `Permit2ApproveFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 645
          },
          {
            "name": "permit2Lockdown",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function permit2Lockdown(address token, address spender) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0xcc53287f) // `Permit2.lockdown`.\n            mstore(add(m, 0x20), 0x20) // Offset of the `approvals`.\n            mstore(add(m, 0x40), 1) // `approvals.length`.\n            mstore(add(m, 0x60), shr(96, shl(96, token)))\n            mstore(add(m, 0x80), shr(96, shl(96, spender)))\n            if iszero(call(gas(), PERMIT2, 0, add(m, 0x1c), 0xa0, codesize(), 0x00)) {\n                mstore(0x00, 0x96b3de23) // `Permit2LockdownFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 665
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ETHTransferFailed",
            "parameters": [],
            "startLine": 17
          },
          {
            "name": "TransferFromFailed",
            "parameters": [],
            "startLine": 20
          },
          {
            "name": "TransferFailed",
            "parameters": [],
            "startLine": 23
          },
          {
            "name": "ApproveFailed",
            "parameters": [],
            "startLine": 26
          },
          {
            "name": "TotalSupplyQueryFailed",
            "parameters": [],
            "startLine": 29
          },
          {
            "name": "Permit2Failed",
            "parameters": [],
            "startLine": 32
          },
          {
            "name": "Permit2AmountOverflow",
            "parameters": [],
            "startLine": 35
          },
          {
            "name": "Permit2ApproveFailed",
            "parameters": [],
            "startLine": 38
          },
          {
            "name": "Permit2LockdownFailed",
            "parameters": [],
            "startLine": 41
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "GAS_STIPEND_NO_STORAGE_WRITES",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 48
          },
          {
            "name": "GAS_STIPEND_NO_GRIEF",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 52
          },
          {
            "name": "DAI_DOMAIN_SEPARATOR",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 55
          },
          {
            "name": "WETH9",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 59
          },
          {
            "name": "PERMIT2",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 64
          },
          {
            "name": "ETH_MOVER",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 69
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "SemVerLib",
        "filePath": "utils/SemVerLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "cmp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32"
              },
              {
                "name": "b",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function cmp(bytes32 a, bytes32 b) internal pure returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function mmp(i_, a_) -> _r, _o {\n                for { _o := i_ } iszero(gt(sub(byte(_o, a_), 48), 9)) { _o := add(1, _o) } {\n                    _r := add(mul(10, _r), sub(byte(_o, a_), 48))\n                }\n            }\n            function pre(i_, a_) -> hasNonDigit_, _r, _o {\n                mstore(0x00, 0)\n                for { _o := i_ } 1 { _o := add(1, _o) } {\n                    let c_ := byte(_o, a_)\n                    if and(1, shr(c_, 0x480000000001)) { break } // '\\x00', '.', '+'\n                    let digit_ := sub(c_, 48)\n                    hasNonDigit_ := or(hasNonDigit_, gt(digit_, 9))\n                    _r := add(mul(10, _r), digit_)\n                    mstore8(sub(_o, i_), c_)\n                }\n                mstore(shl(5, hasNonDigit_), _r) // Overwrite if it's numeric.\n                _r := mload(0x00)\n            }\n            let x, i := mmp(eq(118, or(32, byte(0, a))), a) // 'v', 'V'\n            let y, j := mmp(eq(118, or(32, byte(0, b))), b) // 'v', 'V'\n            result := sub(gt(x, y), lt(x, y))\n            for {} 1 {} {\n                let u := eq(byte(i, a), 46) // `.`\n                let v := eq(byte(j, b), 46) // `.`\n                if iszero(lt(result, or(u, v))) { break }\n                if u { u, i := mmp(add(i, 1), a)} // `.`\n                if v { v, j := mmp(add(j, 1), b)} // `.`\n                result := sub(gt(u, v), lt(u, v))\n            }\n            if iszero(result) {\n                let u := eq(byte(i, a), 45) // `-`\n                let v := eq(byte(j, b), 45) // `-`\n                result := sub(lt(u, v), gt(u, v))\n                for {} lt(result, u) {} {\n                    u, x, i := pre(add(i, 1), a)\n                    v, y, j := pre(add(j, 1), b)\n                    result := sub(gt(u, v), lt(u, v))\n                    if result { break }\n                    result := sub(gt(x, y), lt(x, y))\n                    if result { break }\n                    u := eq(byte(i, a), 46) // `.`\n                    v := eq(byte(j, b), 46) // `.`\n                    result := sub(gt(u, v), lt(u, v))\n                }\n            }\n        }\n    }",
            "startLine": 17
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "SignatureCheckerLib",
        "filePath": "utils/SignatureCheckerLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "isValidSignatureNow",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    switch mload(signature)\n                    case 64 {\n                        let vs := mload(add(signature, 0x40))\n                        mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                        mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    }\n                    case 65 {\n                        mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                        mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                    }\n                    default { break }\n                    mstore(0x00, hash)\n                    mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                // Copy the `signature` over.\n                let n := add(0x20, mload(signature))\n                let copied := staticcall(gas(), 4, signature, n, add(m, 0x44), n)\n                isValid := staticcall(gas(), signer, m, add(returndatasize(), 0x44), d, 0x20)\n                isValid := and(eq(mload(d), f), and(isValid, copied))\n                break\n            }\n        }\n    }",
            "startLine": 32
          },
          {
            "name": "isValidSignatureNowCalldata",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    switch signature.length\n                    case 64 {\n                        let vs := calldataload(add(signature.offset, 0x20))\n                        mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                        mstore(0x40, calldataload(signature.offset)) // `r`.\n                        mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    }\n                    case 65 {\n                        mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                        calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.\n                    }\n                    default { break }\n                    mstore(0x00, hash)\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), signature.length)\n                // Copy the `signature` over.\n                calldatacopy(add(m, 0x64), signature.offset, signature.length)\n                isValid := staticcall(gas(), signer, m, add(signature.length, 0x64), d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n                break\n            }\n        }\n    }",
            "startLine": 80
          },
          {
            "name": "isValidSignatureNow",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "vs",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    mstore(0x00, hash)\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, r) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\n                mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\n                isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n                break\n            }\n        }\n    }",
            "startLine": 128
          },
          {
            "name": "isValidSignatureNow",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "v",
                "type": "uint8"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    mstore(0x00, hash)\n                    mstore(0x20, and(v, 0xff)) // `v`.\n                    mstore(0x40, r) // `r`.\n                    mstore(0x60, s) // `s`.\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), s) // `s`.\n                mstore8(add(m, 0xa4), v) // `v`.\n                isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n                break\n            }\n        }\n    }",
            "startLine": 168
          },
          {
            "name": "isValidERC1271SignatureNow",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            // Copy the `signature` over.\n            let n := add(0x20, mload(signature))\n            let copied := staticcall(gas(), 4, signature, n, add(m, 0x44), n)\n            isValid := staticcall(gas(), signer, m, add(returndatasize(), 0x44), d, 0x20)\n            isValid := and(eq(mload(d), f), and(isValid, copied))\n        }\n    }",
            "startLine": 212
          },
          {
            "name": "isValidERC1271SignatureNowCalldata",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isValidERC1271SignatureNowCalldata(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), signature.length)\n            // Copy the `signature` over.\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\n            isValid := staticcall(gas(), signer, m, add(signature.length, 0x64), d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }",
            "startLine": 234
          },
          {
            "name": "isValidERC1271SignatureNow",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "vs",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\n            mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\n            isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }",
            "startLine": 257
          },
          {
            "name": "isValidERC1271SignatureNow",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "v",
                "type": "uint8"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), s) // `s`.\n            mstore8(add(m, 0xa4), v) // `v`.\n            isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }",
            "startLine": 281
          },
          {
            "name": "isValidERC6492SignatureNowAllowSideEffects",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isValidERC6492SignatureNowAllowSideEffects(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function callIsValidSignature(signer_, hash_, signature_) -> _isValid {\n                let m_ := mload(0x40)\n                let f_ := shl(224, 0x1626ba7e)\n                mstore(m_, f_) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m_, 0x04), hash_)\n                let d_ := add(m_, 0x24)\n                mstore(d_, 0x40) // The offset of the `signature` in the calldata.\n                let n_ := add(0x20, mload(signature_))\n                let copied_ := staticcall(gas(), 4, signature_, n_, add(m_, 0x44), n_)\n                _isValid := staticcall(gas(), signer_, m_, add(returndatasize(), 0x44), d_, 0x20)\n                _isValid := and(eq(mload(d_), f_), and(_isValid, copied_))\n            }\n            let noCode := iszero(extcodesize(signer))\n            let n := mload(signature)\n            for {} 1 {} {\n                if iszero(eq(mload(add(signature, n)), mul(0x6492, div(not(isValid), 0xffff)))) {\n                    if iszero(noCode) { isValid := callIsValidSignature(signer, hash, signature) }\n                    break\n                }\n                if iszero(noCode) {\n                    let o := add(signature, 0x20) // Signature bytes.\n                    isValid := callIsValidSignature(signer, hash, add(o, mload(add(o, 0x40))))\n                    if isValid { break }\n                }\n                let m := mload(0x40)\n                mstore(m, signer)\n                mstore(add(m, 0x20), hash)\n                pop(\n                    call(\n                        gas(), // Remaining gas.\n                        0x0000bc370E4DC924F427d84e2f4B9Ec81626ba7E, // Non-reverting verifier.\n                        0, // Send zero ETH.\n                        m, // Start of memory.\n                        add(returndatasize(), 0x40), // Length of calldata in memory.\n                        staticcall(gas(), 4, add(signature, 0x20), n, add(m, 0x40), n), // 1.\n                        0x00 // Length of returndata to write.\n                    )\n                )\n                isValid := returndatasize()\n                break\n            }\n            // Do `ecrecover` fallback if `noCode && !isValid`.\n            for {} gt(noCode, isValid) {} {\n                switch n\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { break }\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }",
            "startLine": 319
          },
          {
            "name": "isValidERC6492SignatureNow",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isValidERC6492SignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function callIsValidSignature(signer_, hash_, signature_) -> _isValid {\n                let m_ := mload(0x40)\n                let f_ := shl(224, 0x1626ba7e)\n                mstore(m_, f_) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m_, 0x04), hash_)\n                let d_ := add(m_, 0x24)\n                mstore(d_, 0x40) // The offset of the `signature` in the calldata.\n                let n_ := add(0x20, mload(signature_))\n                let copied_ := staticcall(gas(), 4, signature_, n_, add(m_, 0x44), n_)\n                _isValid := staticcall(gas(), signer_, m_, add(returndatasize(), 0x44), d_, 0x20)\n                _isValid := and(eq(mload(d_), f_), and(_isValid, copied_))\n            }\n            let noCode := iszero(extcodesize(signer))\n            let n := mload(signature)\n            for {} 1 {} {\n                if iszero(eq(mload(add(signature, n)), mul(0x6492, div(not(isValid), 0xffff)))) {\n                    if iszero(noCode) { isValid := callIsValidSignature(signer, hash, signature) }\n                    break\n                }\n                if iszero(noCode) {\n                    let o := add(signature, 0x20) // Signature bytes.\n                    isValid := callIsValidSignature(signer, hash, add(o, mload(add(o, 0x40))))\n                    if isValid { break }\n                }\n                let m := mload(0x40)\n                mstore(m, signer)\n                mstore(add(m, 0x20), hash)\n                let willBeZeroIfRevertingVerifierExists :=\n                    call(\n                        gas(), // Remaining gas.\n                        0x00007bd799e4A591FeA53f8A8a3E9f931626Ba7e, // Reverting verifier.\n                        0, // Send zero ETH.\n                        m, // Start of memory.\n                        add(returndatasize(), 0x40), // Length of calldata in memory.\n                        staticcall(gas(), 4, add(signature, 0x20), n, add(m, 0x40), n), // 1.\n                        0x00 // Length of returndata to write.\n                    )\n                isValid := gt(returndatasize(), willBeZeroIfRevertingVerifierExists)\n                break\n            }\n            // Do `ecrecover` fallback if `noCode && !isValid`.\n            for {} gt(noCode, isValid) {} {\n                switch n\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { break }\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }",
            "startLine": 400
          },
          {
            "name": "toEthSignedMessageHash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }",
            "startLine": 479
          },
          {
            "name": "toEthSignedMessageHash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }",
            "startLine": 493
          },
          {
            "name": "emptySignature",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }",
            "startLine": 521
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "UUPSUpgradeable",
        "filePath": "utils/UUPSUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "CallContextChecker"
        ],
        "implements": [],
        "category": "utils",
        "externalFunctions": [
          {
            "name": "proxiableUUID",
            "signature": "proxiableUUID()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proxiableUUID() public view virtual notDelegated returns (bytes32) {\n        // This function must always return `_ERC1967_IMPLEMENTATION_SLOT` to comply with ERC1967.\n        return _ERC1967_IMPLEMENTATION_SLOT;\n    }",
            "startLine": 60
          },
          {
            "name": "upgradeToAndCall",
            "signature": "upgradeToAndCall(address,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "newImplementation",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_authorizeUpgrade",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function upgradeToAndCall(address newImplementation, bytes calldata data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _authorizeUpgrade(newImplementation);\n        /// @solidity memory-safe-assembly\n        assembly {\n            newImplementation := shr(96, shl(96, newImplementation)) // Clears upper 96 bits.\n            mstore(0x00, returndatasize())\n            mstore(0x01, 0x52d1902d) // `proxiableUUID()`.\n            let s := _ERC1967_IMPLEMENTATION_SLOT\n            // Check if `newImplementation` implements `proxiableUUID` correctly.\n            if iszero(eq(mload(staticcall(gas(), newImplementation, 0x1d, 0x04, 0x01, 0x20)), s)) {\n                mstore(0x01, 0x55299b49) // `UpgradeFailed()`.\n                revert(0x1d, 0x04)\n            }\n            // Emit the {Upgraded} event.\n            log2(codesize(), 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)\n            sstore(s, newImplementation) // Updates the implementation.\n\n            // Perform a delegatecall to `newImplementation` if `data` is non-empty.\n            if data.length {\n                // Forwards the `data` to `newImplementation` via delegatecall.\n                let m := mload(0x40)\n                calldatacopy(m, data.offset, data.length)\n                if iszero(\n                    delegatecall(gas(), newImplementation, m, data.length, codesize(), 0x00)\n                ) {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n        }\n    }",
            "startLine": 69
          }
        ],
        "internalFunctions": [
          {
            "name": "_authorizeUpgrade",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newImplementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _authorizeUpgrade(address newImplementation) internal virtual;",
            "startLine": 53
          }
        ],
        "events": [
          {
            "name": "Upgraded",
            "parameters": [
              {
                "name": "implementation",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 29
          }
        ],
        "errors": [
          {
            "name": "UpgradeFailed",
            "parameters": [],
            "startLine": 22
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_UPGRADED_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 32
          },
          {
            "name": "_ERC1967_IMPLEMENTATION_SLOT",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 41
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./CallContextChecker.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "UpgradeableBeacon",
        "filePath": "utils/UpgradeableBeacon.sol",
        "kind": "contract",
        "inherits": [],
        "implements": [],
        "category": "utils",
        "externalFunctions": [
          {
            "name": "implementation",
            "signature": "implementation()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function implementation() public view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_UPGRADEABLE_BEACON_IMPLEMENTATION_SLOT)\n        }\n    }",
            "startLine": 132
          },
          {
            "name": "owner",
            "signature": "owner()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function owner() public view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_UPGRADEABLE_BEACON_OWNER_SLOT)\n        }\n    }",
            "startLine": 140
          },
          {
            "name": "upgradeTo",
            "signature": "upgradeTo(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newImplementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setImplementation",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n    }",
            "startLine": 148
          },
          {
            "name": "transferOwnership",
            "signature": "transferOwnership(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setOwner",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }",
            "startLine": 153
          },
          {
            "name": "renounceOwnership",
            "signature": "renounceOwnership()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_setOwner",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }",
            "startLine": 165
          }
        ],
        "internalFunctions": [
          {
            "name": "constructor",
            "visibility": "default",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              },
              {
                "name": "initialImplementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_constructUpgradeableBeacon",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "constructor(address initialOwner, address initialImplementation) payable {\n        _constructUpgradeableBeacon(initialOwner, initialImplementation);\n    }",
            "startLine": 75
          },
          {
            "name": "_constructUpgradeableBeacon",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              },
              {
                "name": "initialImplementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initializeUpgradeableBeacon",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _constructUpgradeableBeacon(address initialOwner, address initialImplementation)\n        internal\n        virtual\n    {\n        _initializeUpgradeableBeacon(initialOwner, initialImplementation);\n    }",
            "startLine": 80
          },
          {
            "name": "_initializeUpgradeableBeacon",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              },
              {
                "name": "initialImplementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setOwner",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_setImplementation",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _initializeUpgradeableBeacon(address initialOwner, address initialImplementation)\n        internal\n        virtual\n    {\n        // We don't need to check if `initialOwner` is the zero address here,\n        // as some use cases may not want the beacon to be owned.\n        _setOwner(initialOwner);\n        _setImplementation(initialImplementation);\n    }",
            "startLine": 93
          },
          {
            "name": "_setImplementation",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newImplementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _setImplementation(address newImplementation) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            newImplementation := shr(96, shl(96, newImplementation)) // Clean the upper 96 bits.\n            if iszero(extcodesize(newImplementation)) {\n                mstore(0x00, 0x6d3e283b) // `NewImplementationHasNoCode()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(_UPGRADEABLE_BEACON_IMPLEMENTATION_SLOT, newImplementation) // Store the implementation.\n            // Emit the {Upgraded} event.\n            log2(codesize(), 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)\n        }\n    }",
            "startLine": 104
          },
          {
            "name": "_setOwner",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _setOwner(address newOwner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            newOwner := shr(96, shl(96, newOwner)) // Clean the upper 96 bits.\n            let oldOwner := sload(_UPGRADEABLE_BEACON_OWNER_SLOT)\n            sstore(_UPGRADEABLE_BEACON_OWNER_SLOT, newOwner) // Store the owner.\n            // Emit the {OwnershipTransferred} event.\n            log3(codesize(), 0x00, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, oldOwner, newOwner)\n        }\n    }",
            "startLine": 119
          },
          {
            "name": "_checkOwner",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_UPGRADEABLE_BEACON_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 170
          }
        ],
        "events": [
          {
            "name": "Upgraded",
            "parameters": [
              {
                "name": "implementation",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 43
          },
          {
            "name": "OwnershipTransferred",
            "parameters": [
              {
                "name": "oldOwner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "newOwner",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 49
          }
        ],
        "errors": [
          {
            "name": "NewImplementationHasNoCode",
            "parameters": [],
            "startLine": 30
          },
          {
            "name": "Unauthorized",
            "parameters": [],
            "startLine": 33
          },
          {
            "name": "NewOwnerIsZeroAddress",
            "parameters": [],
            "startLine": 36
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_UPGRADED_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 52
          },
          {
            "name": "_OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 56
          },
          {
            "name": "_UPGRADEABLE_BEACON_IMPLEMENTATION_SLOT",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 65
          },
          {
            "name": "_UPGRADEABLE_BEACON_OWNER_SLOT",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 69
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "WebAuthn",
        "filePath": "utils/WebAuthn.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "verify",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "challenge",
                "type": "bytes"
              },
              {
                "name": "requireUserVerification",
                "type": "bool"
              },
              {
                "name": "auth",
                "type": "WebAuthnAuth"
              },
              {
                "name": "x",
                "type": "bytes32"
              },
              {
                "name": "y",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "Base64.encode",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "P256.verifySignature",
                "type": "library",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function verify(\n        bytes memory challenge,\n        bool requireUserVerification,\n        WebAuthnAuth memory auth,\n        bytes32 x,\n        bytes32 y\n    ) internal view returns (bool result) {\n        bytes32 messageHash;\n        string memory encoded = Base64.encode(challenge, true, true);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let clientDataJSON := mload(add(auth, 0x20))\n            let n := mload(clientDataJSON) // `clientDataJSON`'s length.\n            let o := add(clientDataJSON, 0x20) // Start of `clientData`'s bytes.\n            {\n                let c := mload(add(auth, 0x40)) // Challenge index in `clientDataJSON`.\n                let t := mload(add(auth, 0x60)) // Type index in `clientDataJSON`.\n                let l := mload(encoded) // Cache `encoded`'s length.\n                let q := add(l, 0x0d) // Length of `encoded` prefixed with '\"challenge\":\"'.\n                mstore(encoded, shr(152, '\"challenge\":\"')) // Temp prefix with '\"challenge\":\"'.\n                result := and(\n                    // 11. Verify JSON's type. Also checks for possible addition overflows.\n                    and(\n                        eq(shr(88, mload(add(o, t))), shr(88, '\"type\":\"webauthn.get\"')),\n                        lt(shr(128, or(t, c)), lt(add(0x14, t), n))\n                    ),\n                    // 12. Verify JSON's challenge. Includes a check for the closing '\"'.\n                    and(\n                        eq(keccak256(add(o, c), q), keccak256(add(encoded, 0x13), q)),\n                        and(eq(byte(0, mload(add(add(o, c), q))), 34), lt(add(q, c), n))\n                    )\n                )\n                mstore(encoded, l) // Restore `encoded`'s length, in case of string interning.\n            }\n            // Skip 13., 14., 15.\n            let l := mload(mload(auth)) // Length of `authenticatorData`.\n            // 16. Verify that the \"User Present\" flag is set (bit 0).\n            // 17. Verify that the \"User Verified\" flag is set (bit 2), if required.\n            // See: https://www.w3.org/TR/webauthn-2/#flags.\n            let u := or(1, shl(2, iszero(iszero(requireUserVerification))))\n            result := and(and(result, gt(l, 0x20)), eq(and(mload(add(mload(auth), 0x21)), u), u))\n            if result {\n                let p := add(mload(auth), 0x20) // Start of `authenticatorData`'s bytes.\n                let e := add(p, l) // Location of the word after `authenticatorData`.\n                let w := mload(e) // Cache the word after `authenticatorData`.\n                // 19. Compute `sha256(clientDataJSON)`.\n                // 20. Compute `sha256(authenticatorData  sha256(clientDataJSON))`.\n                // forgefmt: disable-next-item\n                messageHash := mload(staticcall(gas(),\n                    shl(1, staticcall(gas(), 2, o, n, e, 0x20)), p, add(l, 0x20), 0x01, 0x20))\n                mstore(e, w) // Restore the word after `authenticatorData`, in case of reuse.\n                // `returndatasize()` is `0x20` on `sha256` success, and `0x00` otherwise.\n                if iszero(returndatasize()) { invalid() }\n            }\n        }\n        // `P256.verifySignature` returns false if `s > N/2` due to the malleability check.\n        if (result) result = P256.verifySignature(messageHash, auth.r, auth.s, x, y);\n    }",
            "startLine": 86
          },
          {
            "name": "verify",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "challenge",
                "type": "bytes"
              },
              {
                "name": "requireUserVerification",
                "type": "bool"
              },
              {
                "name": "authenticatorData",
                "type": "bytes"
              },
              {
                "name": "clientDataJSON",
                "type": "string"
              },
              {
                "name": "challengeIndex",
                "type": "uint256"
              },
              {
                "name": "typeIndex",
                "type": "uint256"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              },
              {
                "name": "x",
                "type": "bytes32"
              },
              {
                "name": "y",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "verify",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "WebAuthnAuth",
                "type": "external",
                "argCount": 6
              }
            ],
            "isVirtual": false,
            "sourceCode": "function verify(\n        bytes memory challenge,\n        bool requireUserVerification,\n        bytes memory authenticatorData,\n        string memory clientDataJSON,\n        uint256 challengeIndex,\n        uint256 typeIndex,\n        bytes32 r,\n        bytes32 s,\n        bytes32 x,\n        bytes32 y\n    ) internal view returns (bool) {\n        return verify(\n            challenge,\n            requireUserVerification,\n            WebAuthnAuth(authenticatorData, clientDataJSON, challengeIndex, typeIndex, r, s),\n            x,\n            y\n        );\n    }",
            "startLine": 146
          },
          {
            "name": "encodeAuth",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "auth",
                "type": "WebAuthnAuth"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function encodeAuth(WebAuthnAuth memory auth) internal pure returns (bytes memory) {\n        return abi.encode(auth);\n    }",
            "startLine": 172
          },
          {
            "name": "tryDecodeAuth",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "encodedAuth",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "decoded",
                "type": "WebAuthnAuth"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tryDecodeAuth(bytes memory encodedAuth)\n        internal\n        pure\n        returns (WebAuthnAuth memory decoded)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let n := mload(encodedAuth) } iszero(lt(n, 0xc0)) {} {\n                let o := add(encodedAuth, 0x20) // Start of `encodedAuth`'s bytes.\n                let e := add(o, n) // End of `encodedAuth` in memory.\n                let p := add(mload(o), o) // Start of `encodedAuth`.\n                if or(gt(add(p, 0xc0), e), lt(p, o)) { break }\n                let authenticatorData := add(mload(p), p)\n                let clientDataJSON := add(mload(add(p, 0x20)), p)\n                if or(\n                    or(gt(authenticatorData, e), lt(authenticatorData, p)),\n                    or(gt(clientDataJSON, e), lt(clientDataJSON, p))\n                ) { break }\n                if or(\n                    gt(add(add(authenticatorData, 0x20), mload(authenticatorData)), e),\n                    gt(add(add(clientDataJSON, 0x20), mload(clientDataJSON)), e)\n                ) { break }\n                mstore(decoded, authenticatorData) // `authenticatorData`.\n                mstore(add(decoded, 0x20), clientDataJSON) // `clientDataJSON`.\n                mstore(add(decoded, 0x40), mload(add(p, 0x40))) // `challengeIndex`.\n                mstore(add(decoded, 0x60), mload(add(p, 0x60))) // `typeIndex`.\n                mstore(add(decoded, 0x80), mload(add(p, 0x80))) // `r`.\n                mstore(add(decoded, 0xa0), mload(add(p, 0xa0))) // `s`.\n                break\n            }\n        }\n    }",
            "startLine": 179
          },
          {
            "name": "tryEncodeAuthCompact",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "auth",
                "type": "WebAuthnAuth"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tryEncodeAuthCompact(WebAuthnAuth memory auth)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function copyBytes(o_, s_, c_) -> _e {\n                mstore(o_, shl(240, mload(s_)))\n                o_ := add(o_, c_)\n                _e := add(o_, mload(s_)) // The end of the bytes.\n                for { let d_ := sub(add(0x20, s_), o_) } 1 {} {\n                    mstore(o_, mload(add(d_, o_)))\n                    o_ := add(o_, 0x20)\n                    if iszero(lt(o_, _e)) { break }\n                }\n            }\n            let clientDataJSON := mload(add(0x20, auth))\n            let c := mload(add(0x40, auth)) // `challengeIndex`.\n            let t := mload(add(0x60, auth)) // `typeIndex`.\n            // If none of the lengths are more than `0xffff`.\n            if iszero(shr(16, or(or(t, c), or(mload(mload(auth)), mload(clientDataJSON))))) {\n                result := mload(0x40)\n                // `authenticatorData`, `clientDataJSON`.\n                let o := copyBytes(copyBytes(add(result, 0x20), mload(auth), 2), clientDataJSON, 0)\n                mstore(o, or(shl(240, c), shl(224, t))) // `challengeIndex`, `typeIndex`.\n                mstore(add(o, 0x04), mload(add(0x80, auth))) // `r`.\n                mstore(add(o, 0x24), mload(add(0xa0, auth))) // `s`.\n                mstore(result, sub(add(o, 0x24), result)) // Store the length.\n                mstore(add(o, 0x44), 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x64)) // Allocate memory .\n            }\n        }\n    }",
            "startLine": 225
          },
          {
            "name": "tryDecodeAuthCompact",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "encodedAuth",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "decoded",
                "type": "WebAuthnAuth"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tryDecodeAuthCompact(bytes memory encodedAuth)\n        internal\n        pure\n        returns (WebAuthnAuth memory decoded)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function extractBytes(o_, l_) -> _m {\n                _m := mload(0x40) // Grab the free memory pointer.\n                let s_ := add(_m, 0x20)\n                for { let i_ := 0 } 1 {} {\n                    mstore(add(s_, i_), mload(add(o_, i_)))\n                    i_ := add(i_, 0x20)\n                    if iszero(lt(i_, l_)) { break }\n                }\n                mstore(_m, l_) // Store the length.\n                mstore(add(l_, s_), 0) // Zeroize the slot after the string.\n                mstore(0x40, add(0x20, add(l_, s_))) // Allocate memory.\n            }\n            let n := mload(encodedAuth)\n            if iszero(lt(n, 0x46)) {\n                let o := add(encodedAuth, 0x20) // Start of `encodedAuth`'s bytes.\n                let e := add(o, n) // End of `encodedAuth` in memory.\n                n := shr(240, mload(o)) // Length of `authenticatorData`.\n                let a := add(o, 0x02) // Start of `authenticatorData`.\n                let c := add(a, n) // Start of `clientDataJSON`.\n                let j := sub(e, 0x44) // Start of `challengeIndex`.\n                if iszero(gt(c, j)) {\n                    mstore(decoded, extractBytes(a, n)) // `authenticatorData`.\n                    mstore(add(decoded, 0x20), extractBytes(c, sub(j, c))) // `clientDataJSON`.\n                    mstore(add(decoded, 0x40), shr(240, mload(j))) // `challengeIndex`.\n                    mstore(add(decoded, 0x60), shr(240, mload(add(j, 0x02)))) // `typeIndex`.\n                    mstore(add(decoded, 0x80), mload(add(j, 0x04))) // `r`.\n                    mstore(add(decoded, 0xa0), mload(add(j, 0x24))) // `s`.\n                }\n            }\n        }\n    }",
            "startLine": 263
          },
          {
            "name": "tryDecodeAuthCompactCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "encodedAuth",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "decoded",
                "type": "WebAuthnAuth"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tryDecodeAuthCompactCalldata(bytes calldata encodedAuth)\n        internal\n        pure\n        returns (WebAuthnAuth memory decoded)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function extractBytes(o_, l_) -> _m {\n                _m := mload(0x40) // Grab the free memory pointer.\n                let s_ := add(_m, 0x20)\n                calldatacopy(s_, o_, l_)\n                mstore(_m, l_) // Store the length.\n                mstore(add(l_, s_), 0) // Zeroize the slot after the string.\n                mstore(0x40, add(0x20, add(l_, s_))) // Allocate memory.\n            }\n            if iszero(lt(encodedAuth.length, 0x46)) {\n                let e := add(encodedAuth.offset, encodedAuth.length) // End of `encodedAuth`.\n                let n := shr(240, calldataload(encodedAuth.offset)) // Length of `authenticatorData`.\n                let a := add(encodedAuth.offset, 0x02) // Start of `authenticatorData`.\n                let c := add(a, n) // Start of `clientDataJSON`.\n                let j := sub(e, 0x44) // Start of `challengeIndex`.\n                if iszero(gt(c, j)) {\n                    mstore(decoded, extractBytes(a, n)) // `authenticatorData`.\n                    mstore(add(decoded, 0x20), extractBytes(c, sub(j, c))) // `clientDataJSON`.\n                    mstore(add(decoded, 0x40), shr(240, calldataload(j))) // `challengeIndex`.\n                    mstore(add(decoded, 0x60), shr(240, calldataload(add(j, 0x02)))) // `typeIndex`.\n                    mstore(add(decoded, 0x80), calldataload(add(j, 0x04))) // `r`.\n                    mstore(add(decoded, 0xa0), calldataload(add(j, 0x24))) // `s`.\n                }\n            }\n        }\n    }",
            "startLine": 303
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "WebAuthnAuth",
            "members": [
              {
                "name": "authenticatorData",
                "type": "bytes"
              },
              {
                "name": "clientDataJSON",
                "type": "string"
              },
              {
                "name": "challengeIndex",
                "type": "uint256"
              },
              {
                "name": "typeIndex",
                "type": "uint256"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "startLine": 17
          }
        ],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./Base64.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./P256.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "DelegateCheckerLib",
        "filePath": "utils/ext/delegatexyz/DelegateCheckerLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "checkDelegateForAll",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForAll(address to, address from) internal view returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            // `0x60` is already 0.\n            mstore(0x40, from)\n            mstore(0x2c, shl(96, to))\n            mstore(0x0c, 0xe839bd53000000000000000000000000) // `checkDelegateForAll(address,address,bytes32)`.\n            isValid := eq(mload(staticcall(gas(), DELEGATE_REGISTRY_V2, 0x1c, 0x64, 0x01, 0x20)), 1)\n            if iszero(isValid) {\n                mstore(0x01, 0x9c395bc200) // `checkDelegateForAll(address,address)`.\n                isValid := eq(\n                    mload(staticcall(gas(), DELEGATE_REGISTRY_V1, 0x1c, 0x44, 0x01, 0x20)),\n                    1\n                )\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 32
          },
          {
            "name": "checkDelegateForAll",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "rights",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForAll(address to, address from, bytes32 rights)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(0x60, rights)\n            mstore(0x40, from)\n            mstore(0x2c, shl(96, to))\n            mstore(0x0c, 0xe839bd53000000000000000000000000) // `checkDelegateForAll(address,address,bytes32)`.\n            isValid := eq(mload(staticcall(gas(), DELEGATE_REGISTRY_V2, 0x1c, 0x64, 0x01, 0x20)), 1)\n            if iszero(or(rights, isValid)) {\n                mstore(0x01, 0x9c395bc200) // `checkDelegateForAll(address,address)`.\n                isValid := eq(\n                    mload(staticcall(gas(), DELEGATE_REGISTRY_V1, 0x1c, 0x44, 0x01, 0x20)),\n                    1\n                )\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }",
            "startLine": 57
          },
          {
            "name": "checkDelegateForContract",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "contract_",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForContract(address to, address from, address contract_)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(0x80, m), 0)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForContract(address,address,address,bytes32)`.\n            mstore(add(0x0c, m), 0x8988eea9000000000000000000000000)\n            isValid := staticcall(gas(), DELEGATE_REGISTRY_V2, add(m, 0x1c), 0x84, m, 0x20)\n            isValid := and(eq(mload(m), 1), isValid)\n            if iszero(isValid) {\n                mstore(m, 0x90c9a2d0) // `checkDelegateForContract(address,address,address)`.\n                isValid := staticcall(gas(), DELEGATE_REGISTRY_V1, add(m, 0x1c), 0x64, m, 0x20)\n                isValid := and(eq(mload(m), 1), isValid)\n            }\n        }\n    }",
            "startLine": 88
          },
          {
            "name": "checkDelegateForContract",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "contract_",
                "type": "address"
              },
              {
                "name": "rights",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(0x80, m), rights)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForContract(address,address,address,bytes32)`.\n            mstore(add(0x0c, m), 0x8988eea9000000000000000000000000)\n            isValid := staticcall(gas(), DELEGATE_REGISTRY_V2, add(m, 0x1c), 0x84, m, 0x20)\n            isValid := and(eq(mload(m), 1), isValid)\n            if iszero(or(rights, isValid)) {\n                mstore(m, 0x90c9a2d0) // `checkDelegateForContract(address,address,address)`.\n                isValid := staticcall(gas(), DELEGATE_REGISTRY_V1, add(m, 0x1c), 0x64, m, 0x20)\n                isValid := and(eq(mload(m), 1), isValid)\n            }\n        }\n    }",
            "startLine": 118
          },
          {
            "name": "checkDelegateForERC721",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "contract_",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForERC721(address to, address from, address contract_, uint256 id)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(0xa0, m), 0)\n            mstore(add(0x80, m), id)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForERC721(address,address,address,uint256,bytes32)`.\n            mstore(add(0x0c, m), 0xb9f36874000000000000000000000000)\n            isValid := staticcall(gas(), DELEGATE_REGISTRY_V2, add(m, 0x1c), 0xa4, m, 0x20)\n            isValid := and(eq(mload(m), 1), isValid)\n            if iszero(isValid) {\n                mstore(m, 0xaba69cf8) // `checkDelegateForToken(address,address,address,uint256)`.\n                isValid := staticcall(gas(), DELEGATE_REGISTRY_V1, add(m, 0x1c), 0x84, m, 0x20)\n                isValid := and(eq(mload(m), 1), isValid)\n            }\n        }\n    }",
            "startLine": 148
          },
          {
            "name": "checkDelegateForERC721",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "contract_",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "rights",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForERC721(\n        address to,\n        address from,\n        address contract_,\n        uint256 id,\n        bytes32 rights\n    ) internal view returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(0xa0, m), rights)\n            mstore(add(0x80, m), id)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForERC721(address,address,address,uint256,bytes32)`.\n            mstore(add(0x0c, m), 0xb9f36874000000000000000000000000)\n            isValid := staticcall(gas(), DELEGATE_REGISTRY_V2, add(m, 0x1c), 0xa4, m, 0x20)\n            isValid := and(eq(mload(m), 1), isValid)\n            if iszero(or(rights, isValid)) {\n                mstore(m, 0xaba69cf8) // `checkDelegateForToken(address,address,address,uint256)`.\n                isValid := staticcall(gas(), DELEGATE_REGISTRY_V1, add(m, 0x1c), 0x84, m, 0x20)\n                isValid := and(eq(mload(m), 1), isValid)\n            }\n        }\n    }",
            "startLine": 179
          },
          {
            "name": "checkDelegateForERC20",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "contract_",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForERC20(address to, address from, address contract_)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let o := add(0x80, m)\n            mstore(o, 0)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForERC20(address,address,address,bytes32)`.\n            mstore(add(0x0c, m), 0xba63c817000000000000000000000000)\n            amount := staticcall(gas(), DELEGATE_REGISTRY_V2, add(m, 0x1c), 0x84, o, 0x20)\n            amount := mul(mload(o), amount)\n            if not(amount) {\n                mstore(m, 0x90c9a2d0) // `checkDelegateForContract(address,address,address)`.\n                let t := staticcall(gas(), DELEGATE_REGISTRY_V1, add(m, 0x1c), 0x64, m, 0x20)\n                amount := or(sub(0, and(eq(mload(m), 1), t)), amount)\n            }\n        }\n    }",
            "startLine": 215
          },
          {
            "name": "checkDelegateForERC20",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "contract_",
                "type": "address"
              },
              {
                "name": "rights",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(0x00, 0)\n            mstore(add(0x80, m), rights)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForERC20(address,address,address,bytes32)`.\n            mstore(add(0x0c, m), 0xba63c817000000000000000000000000)\n            amount := staticcall(gas(), DELEGATE_REGISTRY_V2, add(m, 0x1c), 0x84, 0x00, 0x20)\n            amount := mul(mload(0x00), amount)\n            if iszero(or(rights, iszero(not(amount)))) {\n                mstore(m, 0x90c9a2d0) // `checkDelegateForContract(address,address,address)`.\n                let t := staticcall(gas(), DELEGATE_REGISTRY_V1, add(m, 0x1c), 0x64, m, 0x20)\n                amount := or(sub(0, and(eq(mload(m), 1), t)), amount)\n            }\n        }\n    }",
            "startLine": 249
          },
          {
            "name": "checkDelegateForERC1155",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "contract_",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForERC1155(address to, address from, address contract_, uint256 id)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let o := add(0xa0, m)\n            mstore(o, 0)\n            mstore(add(0x80, m), id)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForERC1155(address,address,address,uint256,bytes32)`.\n            mstore(add(0x0c, m), 0xb8705875000000000000000000000000)\n            amount := staticcall(gas(), DELEGATE_REGISTRY_V2, add(m, 0x1c), 0xa4, o, 0x20)\n            amount := mul(mload(o), amount)\n            if not(amount) {\n                mstore(m, 0x90c9a2d0) // `checkDelegateForContract(address,address,address)`.\n                let t := staticcall(gas(), DELEGATE_REGISTRY_V1, add(m, 0x1c), 0x64, m, 0x20)\n                amount := or(sub(0, and(eq(mload(m), 1), t)), amount)\n            }\n        }\n    }",
            "startLine": 283
          },
          {
            "name": "checkDelegateForERC1155",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "contract_",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "rights",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForERC1155(\n        address to,\n        address from,\n        address contract_,\n        uint256 id,\n        bytes32 rights\n    ) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(0x00, 0)\n            mstore(add(0xa0, m), rights)\n            mstore(add(0x80, m), id)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForERC1155(address,address,address,uint256,bytes32)`.\n            mstore(add(0x0c, m), 0xb8705875000000000000000000000000)\n            amount := staticcall(gas(), DELEGATE_REGISTRY_V2, add(m, 0x1c), 0xa4, 0x00, 0x20)\n            amount := mul(mload(0x00), amount)\n            if iszero(or(rights, iszero(not(amount)))) {\n                mstore(m, 0x90c9a2d0) // `checkDelegateForContract(address,address,address)`.\n                let t := staticcall(gas(), DELEGATE_REGISTRY_V1, add(m, 0x1c), 0x64, m, 0x20)\n                amount := or(sub(0, and(eq(mload(m), 1), t)), amount)\n            }\n        }\n    }",
            "startLine": 318
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "DELEGATE_REGISTRY_V1",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 13
          },
          {
            "name": "DELEGATE_REGISTRY_V2",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 17
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "BLS",
        "filePath": "utils/ext/ithaca/BLS.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "point0",
                "type": "G1Point"
              },
              {
                "name": "point1",
                "type": "G1Point"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "G1Point"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function add(G1Point memory point0, G1Point memory point1)\n        internal\n        view\n        returns (G1Point memory result)\n    {\n        assembly (\"memory-safe\") {\n            mcopy(result, point0, 0x80)\n            mcopy(add(result, 0x80), point1, 0x80)\n            if iszero(\n                and(\n                    eq(returndatasize(), 0x80),\n                    staticcall(gas(), BLS12_G1ADD, result, 0x100, result, 0x80)\n                )\n            ) {\n                mstore(0x00, 0xd6cc76eb) // `G1AddFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 120
          },
          {
            "name": "msm",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "points",
                "type": "G1Point[]"
              },
              {
                "name": "scalars",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "G1Point"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function msm(G1Point[] memory points, bytes32[] memory scalars)\n        internal\n        view\n        returns (G1Point memory result)\n    {\n        assembly (\"memory-safe\") {\n            let k := mload(points)\n            let d := sub(scalars, points)\n            for { let i := 0 } iszero(eq(i, k)) { i := add(i, 1) } {\n                points := add(points, 0x20)\n                let o := add(result, mul(0xa0, i))\n                mcopy(o, mload(points), 0x80)\n                mstore(add(o, 0x80), mload(add(points, d)))\n            }\n            if iszero(\n                and(\n                    and(eq(k, mload(scalars)), eq(returndatasize(), 0x80)),\n                    staticcall(gas(), BLS12_G1MSM, result, mul(0xa0, k), result, 0x80)\n                )\n            ) {\n                mstore(0x00, 0x5f776986) // `G1MSMFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 141
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "point0",
                "type": "G2Point"
              },
              {
                "name": "point1",
                "type": "G2Point"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "G2Point"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function add(G2Point memory point0, G2Point memory point1)\n        internal\n        view\n        returns (G2Point memory result)\n    {\n        assembly (\"memory-safe\") {\n            mcopy(result, point0, 0x100)\n            mcopy(add(result, 0x100), point1, 0x100)\n            if iszero(\n                and(\n                    eq(returndatasize(), 0x100),\n                    staticcall(gas(), BLS12_G2ADD, result, 0x200, result, 0x100)\n                )\n            ) {\n                mstore(0x00, 0xc55e5e33) // `G2AddFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 168
          },
          {
            "name": "msm",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "points",
                "type": "G2Point[]"
              },
              {
                "name": "scalars",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "G2Point"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function msm(G2Point[] memory points, bytes32[] memory scalars)\n        internal\n        view\n        returns (G2Point memory result)\n    {\n        assembly (\"memory-safe\") {\n            let k := mload(points)\n            let d := sub(scalars, points)\n            for { let i := 0 } iszero(eq(i, k)) { i := add(i, 1) } {\n                points := add(points, 0x20)\n                let o := add(result, mul(0x120, i))\n                mcopy(o, mload(points), 0x100)\n                mstore(add(o, 0x100), mload(add(d, points)))\n            }\n            if iszero(\n                and(\n                    and(eq(k, mload(scalars)), eq(returndatasize(), 0x100)),\n                    staticcall(gas(), BLS12_G2MSM, result, mul(0x120, k), result, 0x100)\n                )\n            ) {\n                mstore(0x00, 0xe3dc5425) // `G2MSMFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 189
          },
          {
            "name": "pairing",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "g1Points",
                "type": "G1Point[]"
              },
              {
                "name": "g2Points",
                "type": "G2Point[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function pairing(G1Point[] memory g1Points, G2Point[] memory g2Points)\n        internal\n        view\n        returns (bool result)\n    {\n        assembly (\"memory-safe\") {\n            let k := mload(g1Points)\n            let m := mload(0x40)\n            let d := sub(g2Points, g1Points)\n            for { let i := 0 } iszero(eq(i, k)) { i := add(i, 1) } {\n                g1Points := add(g1Points, 0x20)\n                let o := add(m, mul(0x180, i))\n                mcopy(o, mload(g1Points), 0x80)\n                mcopy(add(o, 0x80), mload(add(d, g1Points)), 0x100)\n            }\n            if iszero(\n                and(\n                    and(eq(k, mload(g2Points)), eq(returndatasize(), 0x20)),\n                    staticcall(gas(), BLS12_PAIRING_CHECK, m, mul(0x180, k), 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x4df45e2f) // `PairingFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }",
            "startLine": 216
          },
          {
            "name": "toG1",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "element",
                "type": "Fp"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "G1Point"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toG1(Fp memory element) internal view returns (G1Point memory result) {\n        assembly (\"memory-safe\") {\n            if iszero(\n                and(\n                    eq(returndatasize(), 0x80),\n                    staticcall(gas(), BLS12_MAP_FP_TO_G1, element, 0x40, result, 0x80)\n                )\n            ) {\n                mstore(0x00, 0x24a289fc) // `MapFpToG1Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 245
          },
          {
            "name": "toG2",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "element",
                "type": "Fp2"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "G2Point"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toG2(Fp2 memory element) internal view returns (G2Point memory result) {\n        assembly (\"memory-safe\") {\n            if iszero(\n                and(\n                    eq(returndatasize(), 0x100),\n                    staticcall(gas(), BLS12_MAP_FP2_TO_G2, element, 0x80, result, 0x100)\n                )\n            ) {\n                mstore(0x00, 0x89083b91) // `MapFp2ToG2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 260
          },
          {
            "name": "hashToG2",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "message",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "G2Point"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hashToG2(bytes memory message) internal view returns (G2Point memory result) {\n        assembly (\"memory-safe\") {\n            function dstPrime(o_, i_) -> _o {\n                mstore8(o_, i_) // 1.\n                mstore(add(o_, 0x01), \"BLS_SIG_BLS12381G2_XMD:SHA-256_S\") // 32.\n                mstore(add(o_, 0x21), \"SWU_RO_NUL_\\x2b\") // 12.\n                _o := add(0x2d, o_)\n            }\n\n            function sha2(data_, n_) -> _h {\n                if iszero(\n                    and(eq(returndatasize(), 0x20), staticcall(gas(), 2, data_, n_, 0x00, 0x20))\n                ) { revert(calldatasize(), 0x00) }\n                _h := mload(0x00)\n            }\n\n            function modfield(s_, b_) {\n                mcopy(add(s_, 0x60), b_, 0x40)\n                if iszero(\n                    and(eq(returndatasize(), 0x40), staticcall(gas(), 5, s_, 0x100, b_, 0x40))\n                ) {\n                    revert(calldatasize(), 0x00)\n                }\n            }\n\n            function mapToG2(s_, r_) {\n                if iszero(\n                    and(\n                        eq(returndatasize(), 0x100),\n                        staticcall(gas(), BLS12_MAP_FP2_TO_G2, s_, 0x80, r_, 0x100)\n                    )\n                ) {\n                    mstore(0x00, 0x89083b91) // `MapFp2ToG2Failed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            let b := mload(0x40)\n            let s := add(b, 0x100)\n            calldatacopy(s, calldatasize(), 0x40)\n            mcopy(add(0x40, s), add(0x20, message), mload(message))\n            let o := add(add(0x40, s), mload(message))\n            mstore(o, shl(240, 256))\n            let b0 := sha2(s, sub(dstPrime(add(0x02, o), 0), s))\n            mstore(0x20, b0)\n            mstore(s, b0)\n            mstore(b, sha2(s, sub(dstPrime(add(0x20, s), 1), s)))\n            let j := b\n            for { let i := 2 } 1 {} {\n                mstore(s, xor(b0, mload(j)))\n                j := add(j, 0x20)\n                mstore(j, sha2(s, sub(dstPrime(add(0x20, s), i), s)))\n                i := add(i, 1)\n                if eq(i, 9) { break }\n            }\n\n            mstore(add(s, 0x00), 0x40)\n            mstore(add(s, 0x20), 0x20)\n            mstore(add(s, 0x40), 0x40)\n            mstore(add(s, 0xa0), 1)\n            mstore(add(s, 0xc0), 0x000000000000000000000000000000001a0111ea397fe69a4b1ba7b6434bacd7)\n            mstore(add(s, 0xe0), 0x64774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)\n            modfield(s, add(b, 0x00))\n            modfield(s, add(b, 0x40))\n            modfield(s, add(b, 0x80))\n            modfield(s, add(b, 0xc0))\n\n            mapToG2(b, result)\n            mapToG2(add(0x80, b), add(0x100, result))\n\n            if iszero(\n                and(\n                    eq(returndatasize(), 0x100),\n                    staticcall(gas(), BLS12_G2ADD, result, 0x200, result, 0x100)\n                )\n            ) {\n                mstore(0x00, 0xc55e5e33) // `G2AddFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 275
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "G1AddFailed",
            "parameters": [],
            "startLine": 95
          },
          {
            "name": "G1MSMFailed",
            "parameters": [],
            "startLine": 98
          },
          {
            "name": "G2AddFailed",
            "parameters": [],
            "startLine": 101
          },
          {
            "name": "G2MSMFailed",
            "parameters": [],
            "startLine": 104
          },
          {
            "name": "PairingFailed",
            "parameters": [],
            "startLine": 107
          },
          {
            "name": "MapFpToG1Failed",
            "parameters": [],
            "startLine": 110
          },
          {
            "name": "MapFp2ToG2Failed",
            "parameters": [],
            "startLine": 113
          }
        ],
        "structs": [
          {
            "name": "Fp",
            "members": [
              {
                "name": "a",
                "type": "bytes32"
              },
              {
                "name": "b",
                "type": "bytes32"
              }
            ],
            "startLine": 30
          },
          {
            "name": "Fp2",
            "members": [
              {
                "name": "c0_a",
                "type": "bytes32"
              },
              {
                "name": "c0_b",
                "type": "bytes32"
              },
              {
                "name": "c1_a",
                "type": "bytes32"
              },
              {
                "name": "c1_b",
                "type": "bytes32"
              }
            ],
            "startLine": 36
          },
          {
            "name": "G1Point",
            "members": [
              {
                "name": "x_a",
                "type": "bytes32"
              },
              {
                "name": "x_b",
                "type": "bytes32"
              },
              {
                "name": "y_a",
                "type": "bytes32"
              },
              {
                "name": "y_b",
                "type": "bytes32"
              }
            ],
            "startLine": 44
          },
          {
            "name": "G2Point",
            "members": [
              {
                "name": "x_c0_a",
                "type": "bytes32"
              },
              {
                "name": "x_c0_b",
                "type": "bytes32"
              },
              {
                "name": "x_c1_a",
                "type": "bytes32"
              },
              {
                "name": "x_c1_b",
                "type": "bytes32"
              },
              {
                "name": "y_c0_a",
                "type": "bytes32"
              },
              {
                "name": "y_c0_b",
                "type": "bytes32"
              },
              {
                "name": "y_c1_a",
                "type": "bytes32"
              },
              {
                "name": "y_c1_b",
                "type": "bytes32"
              }
            ],
            "startLine": 52
          }
        ],
        "stateVariables": [
          {
            "name": "BLS12_G1ADD",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 68
          },
          {
            "name": "BLS12_G1MSM",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 71
          },
          {
            "name": "BLS12_G2ADD",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 74
          },
          {
            "name": "BLS12_G2MSM",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 77
          },
          {
            "name": "BLS12_PAIRING_CHECK",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 80
          },
          {
            "name": "BLS12_MAP_FP_TO_G1",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 83
          },
          {
            "name": "BLS12_MAP_FP2_TO_G2",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 86
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "ERC1967BeaconProxy",
        "filePath": "utils/ext/zksync/ERC1967BeaconProxy.sol",
        "kind": "contract",
        "inherits": [],
        "implements": [],
        "category": "utils",
        "externalFunctions": [
          {
            "name": "fallback",
            "signature": "fallback()",
            "selector": "",
            "visibility": "external",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "fallback() external payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, 0) // Optimization trick to remove free memory pointer initialization.\n            // For the special case of 1-byte calldata, return the implementation.\n            if eq(calldatasize(), 1) {\n                mstore(0x00, 0x5c60da1b) // `implementation()`.\n                let s := staticcall(gas(), sload(_ERC1967_BEACON_SLOT), 0x1c, 0x04, 0x00, 0x20)\n                if iszero(and(gt(returndatasize(), 0x1f), s)) { revert(0x00, 0x00) }\n                return(0x00, 0x20) // Return the implementation.\n            }\n            // Deployer workflow.\n            if eq(caller(), sload(_ERC1967_BEACON_PROXY_DEPLOYER_SLOT)) {\n                sstore(_ERC1967_BEACON_SLOT, calldataload(0x00))\n                // Emit the {Upgraded} event.\n                log2(0x00, 0x00, _BEACON_UPGRADED_EVENT_SIGNATURE, calldataload(0x00))\n                stop() // End the context.\n            }\n            // Query the beacon.\n            mstore(0x00, 0x5c60da1b) // `implementation()`.\n            let s := staticcall(gas(), sload(_ERC1967_BEACON_SLOT), 0x1c, 0x04, 0x00, 0x20)\n            if iszero(and(gt(returndatasize(), 0x1f), s)) { revert(0x00, 0x00) }\n            let implementation := mload(0x00)\n            // Perform the delegatecall.\n            calldatacopy(0x00, 0x00, calldatasize())\n            s := delegatecall(gas(), implementation, 0x00, calldatasize(), 0x00, 0x00)\n            returndatacopy(0x00, 0x00, returndatasize())\n            if iszero(s) { revert(0x00, returndatasize()) }\n            return(0x00, returndatasize())\n        }\n    }",
            "startLine": 47
          }
        ],
        "internalFunctions": [
          {
            "name": "constructor",
            "visibility": "default",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "constructor() payable {\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(_ERC1967_BEACON_PROXY_DEPLOYER_SLOT, caller())\n        }\n    }",
            "startLine": 36
          }
        ],
        "events": [
          {
            "name": "BeaconUpgraded",
            "parameters": [
              {
                "name": "beacon",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 12
          }
        ],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "_BEACON_UPGRADED_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 15
          },
          {
            "name": "_ERC1967_BEACON_SLOT",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 24
          },
          {
            "name": "_ERC1967_BEACON_PROXY_DEPLOYER_SLOT",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 29
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "ERC1967Factory",
        "filePath": "utils/ext/zksync/ERC1967Factory.sol",
        "kind": "contract",
        "inherits": [],
        "implements": [],
        "category": "utils",
        "externalFunctions": [
          {
            "name": "adminOf",
            "signature": "adminOf(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "admin",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function adminOf(address instance) public view returns (address admin) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            admin := mul(sload(instance), gt(instance, 0xff))\n        }\n    }",
            "startLine": 111
          },
          {
            "name": "changeAdmin",
            "signature": "changeAdmin(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function changeAdmin(address instance, address admin) public {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(sload(instance), caller())) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(instance, admin)\n        }\n        emit AdminChanged(instance, admin);\n    }",
            "startLine": 121
          },
          {
            "name": "upgrade",
            "signature": "upgrade(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "implementation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "upgradeAndCall",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_emptyData",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function upgrade(address instance, address implementation) public payable {\n        upgradeAndCall(instance, implementation, _emptyData());\n    }",
            "startLine": 140
          },
          {
            "name": "upgradeAndCall",
            "signature": "upgradeAndCall(address,address,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function upgradeAndCall(address instance, address implementation, bytes calldata data)\n        public\n        payable\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(sload(instance), caller())) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n            let m := mload(0x40)\n            mstore(m, implementation)\n            calldatacopy(add(m, 0x20), data.offset, data.length)\n            if iszero(call(gas(), instance, callvalue(), m, add(0x20, data.length), 0x00, 0x00)) {\n                if iszero(returndatasize()) {\n                    mstore(0x00, 0x55299b49) // `UpgradeFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n        }\n        emit Upgraded(instance, implementation);\n    }",
            "startLine": 148
          },
          {
            "name": "deployProxy",
            "signature": "deployProxy(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployProxyAndCall",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_emptyData",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function deployProxy(address implementation, address admin) public payable returns (address) {\n        return deployProxyAndCall(implementation, admin, _emptyData());\n    }",
            "startLine": 179
          },
          {
            "name": "deployProxyAndCall",
            "signature": "deployProxyAndCall(address,address,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_deploy",
                "type": "internal",
                "argCount": 6
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function deployProxyAndCall(address implementation, address admin, bytes calldata data)\n        public\n        payable\n        returns (address)\n    {\n        return _deploy(0, uint160(implementation), uint160(admin), \"\", false, data);\n    }",
            "startLine": 186
          },
          {
            "name": "deployProxyDeterministic",
            "signature": "deployProxyDeterministic(address,address,bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployProxyDeterministicAndCall",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_emptyData",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function deployProxyDeterministic(address implementation, address admin, bytes32 salt)\n        public\n        payable\n        returns (address)\n    {\n        return deployProxyDeterministicAndCall(implementation, admin, salt, _emptyData());\n    }",
            "startLine": 197
          },
          {
            "name": "deployProxyDeterministicAndCall",
            "signature": "deployProxyDeterministicAndCall(address,address,bytes32,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_deploy",
                "type": "internal",
                "argCount": 6
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function deployProxyDeterministicAndCall(\n        address implementation,\n        address admin,\n        bytes32 salt,\n        bytes calldata data\n    ) public payable returns (address) {\n        return _deploy(0, uint160(implementation), uint160(admin), salt, true, data);\n    }",
            "startLine": 209
          },
          {
            "name": "deployBeacon",
            "signature": "deployBeacon(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_deploy",
                "type": "internal",
                "argCount": 6
              },
              {
                "target": "_emptyData",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function deployBeacon(address implementation, address admin) public returns (address) {\n        return _deploy(1, uint160(implementation), uint160(admin), \"\", false, _emptyData());\n    }",
            "startLine": 223
          },
          {
            "name": "deployBeaconDeterministic",
            "signature": "deployBeaconDeterministic(address,address,bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "admin",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_deploy",
                "type": "internal",
                "argCount": 6
              },
              {
                "target": "_emptyData",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function deployBeaconDeterministic(address implementation, address admin, bytes32 salt)\n        public\n        payable\n        returns (address)\n    {\n        return _deploy(1, uint160(implementation), uint160(admin), salt, true, _emptyData());\n    }",
            "startLine": 229
          },
          {
            "name": "deployBeaconProxy",
            "signature": "deployBeaconProxy(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployBeaconProxyAndCall",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_emptyData",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function deployBeaconProxy(address beacon) public payable returns (address) {\n        return deployBeaconProxyAndCall(beacon, _emptyData());\n    }",
            "startLine": 243
          },
          {
            "name": "deployBeaconProxyAndCall",
            "signature": "deployBeaconProxyAndCall(address,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_deploy",
                "type": "internal",
                "argCount": 6
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function deployBeaconProxyAndCall(address beacon, bytes calldata data)\n        public\n        payable\n        returns (address)\n    {\n        return _deploy(2, uint160(beacon), 0, \"\", false, data);\n    }",
            "startLine": 250
          },
          {
            "name": "deployBeaconProxyDeterministic",
            "signature": "deployBeaconProxyDeterministic(address,bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "deployBeaconProxyDeterministicAndCall",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_emptyData",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function deployBeaconProxyDeterministic(address beacon, bytes32 salt)\n        public\n        payable\n        returns (address)\n    {\n        return deployBeaconProxyDeterministicAndCall(beacon, salt, _emptyData());\n    }",
            "startLine": 261
          },
          {
            "name": "deployBeaconProxyDeterministicAndCall",
            "signature": "deployBeaconProxyDeterministicAndCall(address,bytes32,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "beacon",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_deploy",
                "type": "internal",
                "argCount": 6
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function deployBeaconProxyDeterministicAndCall(\n        address beacon,\n        bytes32 salt,\n        bytes calldata data\n    ) public payable returns (address) {\n        return _deploy(2, uint160(beacon), 0, salt, true, data);\n    }",
            "startLine": 273
          },
          {
            "name": "predictDeterministicAddress",
            "signature": "predictDeterministicAddress(bytes32,bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instanceHash",
                "type": "bytes32"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_predictDeterministicAddressZKsync",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_predictDeterministicAddressRegularEVM",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddress(bytes32 instanceHash, bytes32 salt)\n        public\n        view\n        returns (address)\n    {\n        if (_useZKsyncCreate2Prediction) {\n            return _predictDeterministicAddressZKsync(instanceHash, salt);\n        }\n        return _predictDeterministicAddressRegularEVM(instanceHash, salt);\n    }",
            "startLine": 287
          },
          {
            "name": "implementationOf",
            "signature": "implementationOf(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_extcodehash",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function implementationOf(address instance) public view returns (address result) {\n        bytes32 h = _extcodehash(instance);\n        if (h == proxyHash || h == beaconProxyHash) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let s := staticcall(gas(), instance, 0x00, 0x01, 0x00, 0x20)\n                if iszero(and(gt(returndatasize(), 0x1f), s)) { revert(0x00, 0x00) }\n                result := mload(0x00)\n            }\n        } else if (h == beaconHash) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(0x00, 0x5c60da1b) // `implementation()`.\n                let s := staticcall(gas(), instance, 0x1c, 0x04, 0x00, 0x20)\n                if iszero(and(gt(returndatasize(), 0x1f), s)) { revert(0x00, 0x00) }\n                result := mload(0x00)\n            }\n        }\n    }",
            "startLine": 300
          }
        ],
        "internalFunctions": [
          {
            "name": "constructor",
            "visibility": "default",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_extcodehash",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_predictDeterministicAddressZKsync",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "constructor() payable {\n        bytes32 proxySalt = keccak256(abi.encode(address(this), bytes32(\"proxySalt\")));\n        address proxyAddress = address(new ERC1967Proxy{salt: proxySalt}());\n\n        proxyHash = _extcodehash(proxyAddress);\n        beaconHash = _extcodehash(address(new UpgradeableBeacon()));\n        beaconProxyHash = _extcodehash(address(new ERC1967BeaconProxy()));\n\n        if (_predictDeterministicAddressZKsync(proxyHash, proxySalt) == proxyAddress) {\n            _useZKsyncCreate2Prediction = true;\n        } else {\n            _initCodeHashes[proxyHash] = keccak256(type(ERC1967Proxy).creationCode);\n            _initCodeHashes[beaconHash] = keccak256(type(UpgradeableBeacon).creationCode);\n            _initCodeHashes[beaconProxyHash] = keccak256(type(ERC1967BeaconProxy).creationCode);\n        }\n    }",
            "startLine": 87
          },
          {
            "name": "_validateSalt",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _validateSalt(bytes32 salt) internal view returns (bytes32) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the salt does not start with the zero address or the caller.\n            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {\n                mstore(0x00, 0x2f634836) // `SaltDoesNotStartWithCaller()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        return salt;\n    }",
            "startLine": 325
          },
          {
            "name": "_deploy",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "codeType",
                "type": "uint256"
              },
              {
                "name": "target",
                "type": "uint256"
              },
              {
                "name": "admin",
                "type": "uint256"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "useSalt",
                "type": "bool"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_validateSalt",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _deploy(\n        uint256 codeType,\n        uint256 target,\n        uint256 admin,\n        bytes32 salt,\n        bool useSalt,\n        bytes calldata data\n    ) internal returns (address instance) {\n        if (codeType == 0) {\n            instance = address(\n                useSalt ? new ERC1967Proxy{salt: _validateSalt(salt)}() : new ERC1967Proxy()\n            );\n            /// @solidity memory-safe-assembly\n            assembly {\n                sstore(instance, admin)\n            }\n            emit ProxyDeployed(instance, address(uint160(target)), address(uint160(admin)));\n        } else if (codeType == 1) {\n            instance = address(\n                useSalt\n                    ? new UpgradeableBeacon{salt: _validateSalt(salt)}()\n                    : new UpgradeableBeacon()\n            );\n            /// @solidity memory-safe-assembly\n            assembly {\n                sstore(instance, admin)\n            }\n            emit BeaconDeployed(instance, address(uint160(target)), address(uint160(admin)));\n        } else {\n            instance = address(\n                useSalt\n                    ? new ERC1967BeaconProxy{salt: _validateSalt(salt)}()\n                    : new ERC1967BeaconProxy()\n            );\n            emit BeaconProxyDeployed(instance, address(uint160(target)));\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the creation fails.\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            // Make the initialization call.\n            let m := mload(0x40)\n            mstore(m, target)\n            calldatacopy(add(m, 0x20), data.offset, data.length)\n            if iszero(call(gas(), instance, callvalue(), m, add(0x20, data.length), 0x00, 0x00)) {\n                // Revert with the `DeploymentFailed` selector if there is no error returndata.\n                if iszero(returndatasize()) {\n                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                // Otherwise, bubble up the returned error.\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n        }\n    }",
            "startLine": 338
          },
          {
            "name": "_extcodehash",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _extcodehash(address instance) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := extcodehash(instance)\n        }\n    }",
            "startLine": 399
          },
          {
            "name": "_emptyData",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _emptyData() internal pure returns (bytes calldata data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data.length := 0\n        }\n    }",
            "startLine": 407
          },
          {
            "name": "_predictDeterministicAddressZKsync",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instanceHash",
                "type": "bytes32"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _predictDeterministicAddressZKsync(bytes32 instanceHash, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        bytes32 prefix = keccak256(\"zksyncCreate2\");\n        bytes32 emptyStringHash = keccak256(\"\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The following is `keccak256(abi.encode(...))`.\n            let m := mload(0x40)\n            mstore(m, prefix)\n            mstore(add(m, 0x20), address())\n            mstore(add(m, 0x40), salt)\n            mstore(add(m, 0x60), instanceHash)\n            mstore(add(m, 0x80), emptyStringHash)\n            predicted := keccak256(m, 0xa0)\n        }\n    }",
            "startLine": 415
          },
          {
            "name": "_predictDeterministicAddressRegularEVM",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instanceHash",
                "type": "bytes32"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _predictDeterministicAddressRegularEVM(bytes32 instanceHash, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        bytes32 initCodeHash = _initCodeHashes[instanceHash];\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(initCodeHash) {\n                mstore(0x00, 0xa3a58d1c) // `NoInitCodeHashFound()`.\n                revert(0x1c, 0x04)\n            }\n            // The following is `keccak256(abi.encodePacked(...))`.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, initCodeHash)\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 436
          }
        ],
        "events": [
          {
            "name": "AdminChanged",
            "parameters": [
              {
                "name": "instance",
                "type": "address",
                "indexed": true
              },
              {
                "name": "admin",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 46
          },
          {
            "name": "Upgraded",
            "parameters": [
              {
                "name": "instance",
                "type": "address",
                "indexed": true
              },
              {
                "name": "implementation",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 49
          },
          {
            "name": "ProxyDeployed",
            "parameters": [
              {
                "name": "proxy",
                "type": "address",
                "indexed": true
              },
              {
                "name": "implementation",
                "type": "address",
                "indexed": true
              },
              {
                "name": "admin",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 52
          },
          {
            "name": "BeaconDeployed",
            "parameters": [
              {
                "name": "beacon",
                "type": "address",
                "indexed": true
              },
              {
                "name": "implementation",
                "type": "address",
                "indexed": true
              },
              {
                "name": "admin",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 57
          },
          {
            "name": "BeaconProxyDeployed",
            "parameters": [
              {
                "name": "beaconProxy",
                "type": "address",
                "indexed": true
              },
              {
                "name": "beacon",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 62
          }
        ],
        "errors": [
          {
            "name": "Unauthorized",
            "parameters": [],
            "startLine": 27
          },
          {
            "name": "DeploymentFailed",
            "parameters": [],
            "startLine": 30
          },
          {
            "name": "UpgradeFailed",
            "parameters": [],
            "startLine": 33
          },
          {
            "name": "SaltDoesNotStartWithCaller",
            "parameters": [],
            "startLine": 36
          },
          {
            "name": "NoInitCodeHashFound",
            "parameters": [],
            "startLine": 39
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "proxyHash",
            "type": "bytes32",
            "visibility": "public",
            "isConstant": false,
            "isImmutable": false,
            "startLine": 69
          },
          {
            "name": "beaconHash",
            "type": "bytes32",
            "visibility": "public",
            "isConstant": false,
            "isImmutable": false,
            "startLine": 72
          },
          {
            "name": "beaconProxyHash",
            "type": "bytes32",
            "visibility": "public",
            "isConstant": false,
            "isImmutable": false,
            "startLine": 75
          },
          {
            "name": "_useZKsyncCreate2Prediction",
            "type": "bool",
            "visibility": "internal",
            "isConstant": false,
            "isImmutable": false,
            "startLine": 78
          },
          {
            "name": "_initCodeHashes",
            "type": "mapping(bytes32 => bytes32)",
            "visibility": "internal",
            "isConstant": false,
            "isImmutable": false,
            "startLine": 81
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./ERC1967Proxy.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./UpgradeableBeacon.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./ERC1967BeaconProxy.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "ERC1967FactoryConstants",
        "filePath": "utils/ext/zksync/ERC1967FactoryConstants.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "ADDRESS",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 8
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "ERC1967Proxy",
        "filePath": "utils/ext/zksync/ERC1967Proxy.sol",
        "kind": "contract",
        "inherits": [],
        "implements": [],
        "category": "utils",
        "externalFunctions": [
          {
            "name": "fallback",
            "signature": "fallback()",
            "selector": "",
            "visibility": "external",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "fallback() external payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, 0) // Optimization trick to remove free memory pointer initialization.\n            // For the special case of 1-byte calldata, return the implementation.\n            if eq(calldatasize(), 1) {\n                mstore(0x00, sload(_ERC1967_IMPLEMENTATION_SLOT))\n                return(0x00, 0x20)\n            }\n            // Deployer workflow.\n            if eq(caller(), sload(_ERC1967_PROXY_DEPLOYER_SLOT)) {\n                let newImplementation := calldataload(0x00)\n                sstore(_ERC1967_IMPLEMENTATION_SLOT, newImplementation)\n                if gt(calldatasize(), 0x20) {\n                    let n := sub(calldatasize(), 0x20)\n                    calldatacopy(0x00, 0x20, n)\n                    if iszero(delegatecall(gas(), newImplementation, 0x00, n, 0x00, 0x00)) {\n                        // Bubble up the revert if the call reverts.\n                        returndatacopy(0x00, 0x00, returndatasize())\n                        revert(0x00, returndatasize())\n                    }\n                }\n                // Emit the {Upgraded} event.\n                log2(0x00, 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)\n                stop() // End the context.\n            }\n            // Perform the delegatecall.\n            let implementation := sload(_ERC1967_IMPLEMENTATION_SLOT)\n            calldatacopy(0x00, 0x00, calldatasize())\n            let s := delegatecall(gas(), implementation, 0x00, calldatasize(), 0x00, 0x00)\n            returndatacopy(0x00, 0x00, returndatasize())\n            if iszero(s) { revert(0x00, returndatasize()) }\n            return(0x00, returndatasize())\n        }\n    }",
            "startLine": 47
          }
        ],
        "internalFunctions": [
          {
            "name": "constructor",
            "visibility": "default",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "constructor() payable {\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(_ERC1967_PROXY_DEPLOYER_SLOT, caller())\n        }\n    }",
            "startLine": 36
          }
        ],
        "events": [
          {
            "name": "Upgraded",
            "parameters": [
              {
                "name": "implementation",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 12
          }
        ],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "_UPGRADED_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 15
          },
          {
            "name": "_ERC1967_IMPLEMENTATION_SLOT",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 24
          },
          {
            "name": "_ERC1967_PROXY_DEPLOYER_SLOT",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 29
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "SafeTransferLib",
        "filePath": "utils/ext/zksync/SafeTransferLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "safeTransferETH",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, 0x00, 0x00, 0x00, 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 67
          },
          {
            "name": "safeTransferAllETH",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), 0x00, 0x00, 0x00, 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 78
          },
          {
            "name": "forceSafeTransferETH",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "gasStipend",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "vault",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (address vault)\n    {\n        if (amount == uint256(0)) return address(0); // Early return if `amount` is zero.\n        uint256 selfBalanceBefore = address(this).balance;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfBalanceBefore, amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            pop(call(gasStipend, to, amount, 0x00, 0x00, 0x00, 0x00))\n        }\n        if (address(this).balance == selfBalanceBefore) {\n            vault = address(new SingleUseETHVault());\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(0x00, shr(96, shl(96, to)))\n                if iszero(call(gas(), vault, amount, 0x00, 0x20, 0x00, 0x00)) {\n                    revert(0x00, 0x00)\n                }\n            }\n            emit SingleUseETHVaultCreated(to, amount, vault);\n        }\n    }",
            "startLine": 91
          },
          {
            "name": "forceSafeTransferAllETH",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "gasStipend",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "vault",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "forceSafeTransferETH",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function forceSafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (address vault)\n    {\n        vault = forceSafeTransferETH(to, address(this).balance, gasStipend);\n    }",
            "startLine": 120
          },
          {
            "name": "forceSafeTransferETH",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "vault",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "forceSafeTransferETH",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function forceSafeTransferETH(address to, uint256 amount) internal returns (address vault) {\n        vault = forceSafeTransferETH(to, amount, GAS_STIPEND_NO_GRIEF);\n    }",
            "startLine": 129
          },
          {
            "name": "forceSafeTransferAllETH",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "vault",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "forceSafeTransferETH",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function forceSafeTransferAllETH(address to) internal returns (address vault) {\n        vault = forceSafeTransferETH(to, address(this).balance, GAS_STIPEND_NO_GRIEF);\n    }",
            "startLine": 135
          },
          {
            "name": "trySafeTransferETH",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "gasStipend",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "success",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, 0x00, 0x00, 0x00, 0x00)\n        }\n    }",
            "startLine": 140
          },
          {
            "name": "trySafeTransferAllETH",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "gasStipend",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "success",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function trySafeTransferAllETH(address to, uint256 gasStipend) internal returns (bool success) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), 0x00, 0x00, 0x00, 0x00)\n        }\n    }",
            "startLine": 151
          },
          {
            "name": "safeTransferFrom",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 167
          },
          {
            "name": "trySafeTransferFrom",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "success",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                success := lt(or(iszero(extcodesize(token)), returndatasize()), success)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 190
          },
          {
            "name": "safeTransferAllFrom",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 214
          },
          {
            "name": "safeTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }",
            "startLine": 251
          },
          {
            "name": "safeTransferAll",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }",
            "startLine": 271
          },
          {
            "name": "safeApprove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }",
            "startLine": 303
          },
          {
            "name": "safeApproveWithRetry",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x34, 0) // Store 0 for the `amount`.\n                    mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                    pop(call(gas(), token, 0, 0x10, 0x44, 0x00, 0x00)) // Reset the approval.\n                    mstore(0x34, amount) // Store back the original `amount`.\n                    // Retry the approval, reverting upon failure.\n                    success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    if iszero(and(eq(mload(0x00), 1), success)) {\n                        // Check the `extcodesize` again just in case the token selfdestructs lol.\n                        if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                            mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                            revert(0x1c, 0x04)\n                        }\n                    }\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }",
            "startLine": 324
          },
          {
            "name": "balanceOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount := mul( // The arguments of `mul` are evaluated from right to left.\n                mload(0x20),\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                )\n            )\n        }\n    }",
            "startLine": 355
          },
          {
            "name": "totalSupply",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function totalSupply(address token) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x18160ddd) // `totalSupply()`.\n            if iszero(\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), token, 0x1c, 0x04, 0x00, 0x20))\n            ) {\n                mstore(0x00, 0x54cd9435) // `TotalSupplyQueryFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }",
            "startLine": 372
          }
        ],
        "events": [
          {
            "name": "SingleUseETHVaultCreated",
            "parameters": [
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "vault",
                "type": "address",
                "indexed": false
              }
            ],
            "startLine": 14
          }
        ],
        "errors": [
          {
            "name": "ETHTransferFailed",
            "parameters": [],
            "startLine": 21
          },
          {
            "name": "TransferFromFailed",
            "parameters": [],
            "startLine": 24
          },
          {
            "name": "TransferFailed",
            "parameters": [],
            "startLine": 27
          },
          {
            "name": "ApproveFailed",
            "parameters": [],
            "startLine": 30
          },
          {
            "name": "TotalSupplyQueryFailed",
            "parameters": [],
            "startLine": 33
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "GAS_STIPEND_NO_GRIEF",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 41
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./SingleUseETHVault.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "SignatureCheckerLib",
        "filePath": "utils/ext/zksync/SignatureCheckerLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "isValidSignatureNow",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function copy(dst_, src_, n_) {\n                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {\n                    mstore(add(dst_, i_), mload(add(src_, i_)))\n                }\n            }\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    switch mload(signature)\n                    case 64 {\n                        let vs := mload(add(signature, 0x40))\n                        mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                        mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    }\n                    case 65 {\n                        mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                        mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                    }\n                    default { break }\n                    mstore(0x00, hash)\n                    mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                // Copy the `signature` over.\n                let n := add(0x20, mload(signature))\n                copy(add(m, 0x44), signature, n)\n                isValid := staticcall(gas(), signer, m, add(n, 0x44), d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n                break\n            }\n        }\n    }",
            "startLine": 30
          },
          {
            "name": "isValidSignatureNowCalldata",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    switch signature.length\n                    case 64 {\n                        let vs := calldataload(add(signature.offset, 0x20))\n                        mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                        mstore(0x40, calldataload(signature.offset)) // `r`.\n                        mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    }\n                    case 65 {\n                        mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                        calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.\n                    }\n                    default { break }\n                    mstore(0x00, hash)\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), signature.length)\n                // Copy the `signature` over.\n                calldatacopy(add(m, 0x64), signature.offset, signature.length)\n                isValid := staticcall(gas(), signer, m, add(signature.length, 0x64), d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n                break\n            }\n        }\n    }",
            "startLine": 83
          },
          {
            "name": "isValidSignatureNow",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "vs",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    mstore(0x00, hash)\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, r) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\n                mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\n                isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n                break\n            }\n        }\n    }",
            "startLine": 131
          },
          {
            "name": "isValidSignatureNow",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "v",
                "type": "uint8"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                if iszero(extcodesize(signer)) {\n                    mstore(0x00, hash)\n                    mstore(0x20, and(v, 0xff)) // `v`.\n                    mstore(0x40, r) // `r`.\n                    mstore(0x60, s) // `s`.\n                    let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                    isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), s) // `s`.\n                mstore8(add(m, 0xa4), v) // `v`.\n                isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n                break\n            }\n        }\n    }",
            "startLine": 171
          },
          {
            "name": "isValidERC1271SignatureNow",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function copy(dst_, src_, n_) {\n                for { let i_ := 0 } lt(i_, n_) { i_ := add(0x20, i_) } {\n                    mstore(add(dst_, i_), mload(add(src_, i_)))\n                }\n            }\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            // Copy the `signature` over.\n            let n := add(0x20, mload(signature))\n            copy(add(m, 0x44), signature, n)\n            isValid := staticcall(gas(), signer, m, add(n, 0x44), d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }",
            "startLine": 215
          },
          {
            "name": "isValidERC1271SignatureNowCalldata",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isValidERC1271SignatureNowCalldata(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), signature.length)\n            // Copy the `signature` over.\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\n            isValid := staticcall(gas(), signer, m, add(signature.length, 0x64), d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }",
            "startLine": 242
          },
          {
            "name": "isValidERC1271SignatureNow",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "vs",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\n            mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\n            isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }",
            "startLine": 265
          },
          {
            "name": "isValidERC1271SignatureNow",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "v",
                "type": "uint8"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), s) // `s`.\n            mstore8(add(m, 0xa4), v) // `v`.\n            isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }",
            "startLine": 289
          },
          {
            "name": "toEthSignedMessageHash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }",
            "startLine": 319
          },
          {
            "name": "toEthSignedMessageHash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }",
            "startLine": 333
          },
          {
            "name": "emptySignature",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }",
            "startLine": 361
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "SingleUseETHVault",
        "filePath": "utils/ext/zksync/SingleUseETHVault.sol",
        "kind": "contract",
        "inherits": [],
        "implements": [],
        "category": "utils",
        "externalFunctions": [
          {
            "name": "fallback",
            "signature": "fallback()",
            "selector": "",
            "visibility": "external",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "fallback() external payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, 0) // Optimization trick to remove free memory pointer initialization.\n            let owner := sload(0)\n            // Initialization.\n            if iszero(owner) {\n                sstore(0, calldataload(0x00)) // Store the owner.\n                return(0x00, 0x00) // Early return.\n            }\n            // Authorization check.\n            if iszero(eq(caller(), owner)) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n            let to := calldataload(0x00)\n            // If the calldata is less than 32 bytes, zero-left-pad it to 32 bytes.\n            // Then use the rightmost 20 bytes of the word as the `to` address.\n            // This allows for the calldata to be `abi.encode(to)` or `abi.encodePacked(to)`.\n            to := shr(mul(lt(calldatasize(), 0x20), shl(3, sub(0x20, calldatasize()))), to)\n            // If `to` is `address(0)`, set it to `msg.sender`.\n            to := xor(mul(xor(to, caller()), iszero(to)), to)\n            // Transfers the whole balance to `to`.\n            if iszero(call(gas(), to, selfbalance(), 0x00, 0x00, 0x00, 0x00)) {\n                mstore(0x00, 0x651aee10) // `WithdrawAllFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 21
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": [
          {
            "name": "WithdrawAllFailed",
            "parameters": [],
            "startLine": 12
          },
          {
            "name": "Unauthorized",
            "parameters": [],
            "startLine": 15
          }
        ],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "UpgradeableBeacon",
        "filePath": "utils/ext/zksync/UpgradeableBeacon.sol",
        "kind": "contract",
        "inherits": [],
        "implements": [],
        "category": "utils",
        "externalFunctions": [
          {
            "name": "implementation",
            "signature": "implementation()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function implementation() public view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(__implementation.slot)\n        }\n    }",
            "startLine": 42
          },
          {
            "name": "fallback",
            "signature": "fallback()",
            "selector": "",
            "visibility": "external",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "fallback() external virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, 0) // Optimization trick to remove free memory pointer initialization.\n            let newImplementation := calldataload(0x00)\n            // Revert if the caller is not the deployer. We will still allow the implementation\n            // to be set to an empty contract for simplicity.\n            if iszero(eq(caller(), sload(__deployer.slot))) { revert(0x00, 0x00) }\n            sstore(__implementation.slot, newImplementation)\n            // Emit the {Upgraded} event.\n            log2(0x00, 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)\n        }\n    }",
            "startLine": 49
          }
        ],
        "internalFunctions": [
          {
            "name": "constructor",
            "visibility": "default",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "constructor() payable {\n        __deployer = uint256(uint160(msg.sender));\n    }",
            "startLine": 32
          }
        ],
        "events": [
          {
            "name": "Upgraded",
            "parameters": [
              {
                "name": "implementation",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 12
          }
        ],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "_UPGRADED_EVENT_SIGNATURE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 15
          },
          {
            "name": "__implementation",
            "type": "uint256",
            "visibility": "private",
            "isConstant": false,
            "isImmutable": false,
            "startLine": 23
          },
          {
            "name": "__deployer",
            "type": "uint256",
            "visibility": "private",
            "isConstant": false,
            "isImmutable": false,
            "startLine": 26
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "DelegateCheckerLib",
        "filePath": "utils/ext/zksync/delegatexyz/DelegateCheckerLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "checkDelegateForAll",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_delegateRegistryV2",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForAll(address to, address from) internal view returns (bool isValid) {\n        address v2 = _delegateRegistryV2();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            // `0x60` is already 0.\n            mstore(0x40, from)\n            mstore(0x2c, shl(96, to))\n            mstore(0x0c, 0xe839bd53000000000000000000000000) // `checkDelegateForAll(address,address,bytes32)`.\n            isValid := eq(mload(staticcall(gas(), v2, 0x1c, 0x64, 0x01, 0x20)), 1)\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 35
          },
          {
            "name": "checkDelegateForAll",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "rights",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_delegateRegistryV2",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForAll(address to, address from, bytes32 rights)\n        internal\n        view\n        returns (bool isValid)\n    {\n        address v2 = _delegateRegistryV2();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(0x60, rights)\n            mstore(0x40, from)\n            mstore(0x2c, shl(96, to))\n            mstore(0x0c, 0xe839bd53000000000000000000000000) // `checkDelegateForAll(address,address,bytes32)`.\n            isValid := eq(mload(staticcall(gas(), v2, 0x1c, 0x64, 0x01, 0x20)), 1)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }",
            "startLine": 53
          },
          {
            "name": "checkDelegateForContract",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "contract_",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_delegateRegistryV2",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForContract(address to, address from, address contract_)\n        internal\n        view\n        returns (bool isValid)\n    {\n        address v2 = _delegateRegistryV2();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(0x80, m), 0)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForContract(address,address,address,bytes32)`.\n            mstore(add(0x0c, m), 0x8988eea9000000000000000000000000)\n            isValid := staticcall(gas(), v2, add(m, 0x1c), 0x84, m, 0x20)\n            isValid := and(eq(mload(m), 1), isValid)\n        }\n    }",
            "startLine": 77
          },
          {
            "name": "checkDelegateForContract",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "contract_",
                "type": "address"
              },
              {
                "name": "rights",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_delegateRegistryV2",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        internal\n        view\n        returns (bool isValid)\n    {\n        address v2 = _delegateRegistryV2();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(0x80, m), rights)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForContract(address,address,address,bytes32)`.\n            mstore(add(0x0c, m), 0x8988eea9000000000000000000000000)\n            isValid := staticcall(gas(), v2, add(m, 0x1c), 0x84, m, 0x20)\n            isValid := and(eq(mload(m), 1), isValid)\n        }\n    }",
            "startLine": 102
          },
          {
            "name": "checkDelegateForERC721",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "contract_",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_delegateRegistryV2",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForERC721(address to, address from, address contract_, uint256 id)\n        internal\n        view\n        returns (bool isValid)\n    {\n        address v2 = _delegateRegistryV2();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(0xa0, m), 0)\n            mstore(add(0x80, m), id)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForERC721(address,address,address,uint256,bytes32)`.\n            mstore(add(0x0c, m), 0xb9f36874000000000000000000000000)\n            isValid := staticcall(gas(), v2, add(m, 0x1c), 0xa4, m, 0x20)\n            isValid := and(eq(mload(m), 1), isValid)\n        }\n    }",
            "startLine": 127
          },
          {
            "name": "checkDelegateForERC721",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "contract_",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "rights",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_delegateRegistryV2",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForERC721(\n        address to,\n        address from,\n        address contract_,\n        uint256 id,\n        bytes32 rights\n    ) internal view returns (bool isValid) {\n        address v2 = _delegateRegistryV2();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(0xa0, m), rights)\n            mstore(add(0x80, m), id)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForERC721(address,address,address,uint256,bytes32)`.\n            mstore(add(0x0c, m), 0xb9f36874000000000000000000000000)\n            isValid := staticcall(gas(), v2, add(m, 0x1c), 0xa4, m, 0x20)\n            isValid := and(eq(mload(m), 1), isValid)\n        }\n    }",
            "startLine": 153
          },
          {
            "name": "checkDelegateForERC20",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "contract_",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_delegateRegistryV2",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForERC20(address to, address from, address contract_)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        address v2 = _delegateRegistryV2();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let o := add(0x80, m)\n            mstore(o, 0)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForERC20(address,address,address,bytes32)`.\n            mstore(add(0x0c, m), 0xba63c817000000000000000000000000)\n            amount := staticcall(gas(), v2, add(m, 0x1c), 0x84, o, 0x20)\n            amount := mul(mload(o), amount)\n        }\n    }",
            "startLine": 182
          },
          {
            "name": "checkDelegateForERC20",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "contract_",
                "type": "address"
              },
              {
                "name": "rights",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_delegateRegistryV2",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        address v2 = _delegateRegistryV2();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(0x00, 0)\n            mstore(add(0x80, m), rights)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForERC20(address,address,address,bytes32)`.\n            mstore(add(0x0c, m), 0xba63c817000000000000000000000000)\n            amount := staticcall(gas(), v2, add(m, 0x1c), 0x84, 0x00, 0x20)\n            amount := mul(mload(0x00), amount)\n        }\n    }",
            "startLine": 209
          },
          {
            "name": "checkDelegateForERC1155",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "contract_",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_delegateRegistryV2",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForERC1155(address to, address from, address contract_, uint256 id)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        address v2 = _delegateRegistryV2();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let o := add(0xa0, m)\n            mstore(o, 0)\n            mstore(add(0x80, m), id)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForERC1155(address,address,address,uint256,bytes32)`.\n            mstore(add(0x0c, m), 0xb8705875000000000000000000000000)\n            amount := staticcall(gas(), v2, add(m, 0x1c), 0xa4, o, 0x20)\n            amount := mul(mload(o), amount)\n        }\n    }",
            "startLine": 236
          },
          {
            "name": "checkDelegateForERC1155",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "contract_",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "rights",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_delegateRegistryV2",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function checkDelegateForERC1155(\n        address to,\n        address from,\n        address contract_,\n        uint256 id,\n        bytes32 rights\n    ) internal view returns (uint256 amount) {\n        address v2 = _delegateRegistryV2();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(0x00, 0)\n            mstore(add(0xa0, m), rights)\n            mstore(add(0x80, m), id)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForERC1155(address,address,address,uint256,bytes32)`.\n            mstore(add(0x0c, m), 0xb8705875000000000000000000000000)\n            amount := staticcall(gas(), v2, add(m, 0x1c), 0xa4, 0x00, 0x20)\n            amount := mul(mload(0x00), amount)\n        }\n    }",
            "startLine": 264
          },
          {
            "name": "_delegateRegistryV2",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _delegateRegistryV2() private view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Don't worry about it, storage read is cheap on ZKsync VM.\n            result := shr(96, shl(96, sload(DELEGATE_REGISTRY_V2_OVERRIDE_SLOT)))\n            result := or(mul(DELEGATE_REGISTRY_V2, iszero(result)), result)\n        }\n    }",
            "startLine": 293
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "DELEGATE_REGISTRY_V2",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 14
          },
          {
            "name": "DELEGATE_REGISTRY_V2_OVERRIDE_SLOT",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 20
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "BlockHashLib",
        "filePath": "utils/g/BlockHashLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "blockHash",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "blockNumber",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function blockHash(uint256 blockNumber) internal view returns (bytes32 result) {\n        unchecked {\n            // If `blockNumber + 256` overflows:\n            // - Typical chain height (`block.number > 255`) -> `staticcall` -> 0.\n            // - Very early chain (`block.number <= 255`) -> `blockhash` -> 0.\n            if (block.number <= blockNumber + 256) return blockhash(blockNumber);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, blockNumber)\n            mstore(0x00, 0)\n            pop(staticcall(gas(), HISTORY_STORAGE_ADDRESS, 0x20, 0x20, 0x00, 0x20))\n            result := mload(0x00)\n        }\n    }",
            "startLine": 50
          },
          {
            "name": "verifyBlock",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "encodedHeader",
                "type": "bytes"
              },
              {
                "name": "blockNumber",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "blockHash",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function verifyBlock(bytes calldata encodedHeader, uint256 blockNumber)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        result = blockHash(blockNumber);\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), encodedHeader.offset, encodedHeader.length)\n            if iszero(eq(result, keccak256(mload(0x40), encodedHeader.length))) {\n                mstore(0x00, 0xe42b5e7e) // `BlockHashMismatch()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 69
          },
          {
            "name": "toShortHeader",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "encodedHeader",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "ShortHeader"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toShortHeader(bytes calldata encodedHeader)\n        internal\n        pure\n        returns (ShortHeader memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, calldataload(add(4, encodedHeader.offset))) // `parentHash`.\n            mstore(add(0x20, result), calldataload(add(91, encodedHeader.offset))) // `stateRoot`.\n            mstore(add(0x40, result), calldataload(add(124, encodedHeader.offset))) // `transactionsRoot`.\n            mstore(add(0x60, result), calldataload(add(157, encodedHeader.offset))) // `receiptsRoot`.\n            calldatacopy(mload(add(0x80, result)), add(192, encodedHeader.offset), 0x100) // `logsBloom`.\n            if iszero( // Just perform some minimal light bounds checking.\n                and(\n                    gt(encodedHeader.length, 447), // `0x100 + 192 - 1`.\n                    eq(byte(0, calldataload(encodedHeader.offset)), 0xf9) // `0xff < len < 0x10000`.\n                )\n            ) {\n                mstore(0x00, 0x1a27c4e4) // `InvalidBlockHeaderEncoding()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 92
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "BlockHashMismatch",
            "parameters": [],
            "startLine": 30
          },
          {
            "name": "InvalidBlockHeaderEncoding",
            "parameters": [],
            "startLine": 33
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "HISTORY_STORAGE_ADDRESS",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 41
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "DynamicArrayLib",
        "filePath": "utils/g/DynamicArrayLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "malloc",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function malloc(uint256 n) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := or(sub(0, shr(32, n)), mload(0x40))\n            mstore(result, n)\n            mstore(0x40, add(add(result, 0x20), shl(5, n)))\n        }\n    }",
            "startLine": 39
          },
          {
            "name": "zeroize",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function zeroize(uint256[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n            calldatacopy(add(result, 0x20), calldatasize(), shl(5, mload(result)))\n        }\n    }",
            "startLine": 49
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(uint256[] memory a, uint256 i) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 58
          },
          {
            "name": "getUint256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getUint256(uint256[] memory a, uint256 i) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 66
          },
          {
            "name": "getAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getAddress(uint256[] memory a, uint256 i) internal pure returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 74
          },
          {
            "name": "getBool",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getBool(uint256[] memory a, uint256 i) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 82
          },
          {
            "name": "getBytes32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getBytes32(uint256[] memory a, uint256 i) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 90
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "i",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(uint256[] memory a, uint256 i, uint256 data)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(result, 0x20), shl(5, i)), data)\n        }\n    }",
            "startLine": 98
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "i",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(uint256[] memory a, uint256 i, address data)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(result, 0x20), shl(5, i)), shr(96, shl(96, data)))\n        }\n    }",
            "startLine": 111
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "i",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(uint256[] memory a, uint256 i, bool data)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(result, 0x20), shl(5, i)), iszero(iszero(data)))\n        }\n    }",
            "startLine": 124
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "i",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(uint256[] memory a, uint256 i, bytes32 data)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(result, 0x20), shl(5, i)), data)\n        }\n    }",
            "startLine": 137
          },
          {
            "name": "asAddressArray",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function asAddressArray(uint256[] memory a) internal pure returns (address[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "startLine": 150
          },
          {
            "name": "asBoolArray",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function asBoolArray(uint256[] memory a) internal pure returns (bool[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "startLine": 158
          },
          {
            "name": "asBytes32Array",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function asBytes32Array(uint256[] memory a) internal pure returns (bytes32[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "startLine": 166
          },
          {
            "name": "toUint256Array",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint256Array(address[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "startLine": 174
          },
          {
            "name": "toUint256Array",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bool[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint256Array(bool[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "startLine": 182
          },
          {
            "name": "toUint256Array",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toUint256Array(bytes32[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "startLine": 190
          },
          {
            "name": "truncate",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function truncate(uint256[] memory a, uint256 n)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n            mstore(mul(lt(n, mload(result)), result), n)\n        }\n    }",
            "startLine": 199
          },
          {
            "name": "free",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function free(uint256[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n            let n := mload(result)\n            mstore(shl(6, lt(iszero(n), eq(add(shl(5, add(1, n)), result), mload(0x40)))), result)\n            mstore(result, 0)\n        }\n    }",
            "startLine": 212
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(uint256[] memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(a, 0x20), shl(5, mload(a)))\n        }\n    }",
            "startLine": 223
          },
          {
            "name": "slice",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function slice(uint256[] memory a, uint256 start, uint256 end)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let arrayLen := mload(a)\n            if iszero(gt(arrayLen, end)) { end := arrayLen }\n            if iszero(gt(arrayLen, start)) { start := arrayLen }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLen := sub(end, start)\n                mstore(result, resultLen)\n                a := add(a, shl(5, start))\n                // Copy the `a` one word at a time, backwards.\n                let o := shl(5, resultLen)\n                mstore(0x40, add(add(result, o), 0x20)) // Allocate memory.\n                for {} 1 {} {\n                    mstore(add(result, o), mload(add(a, o)))\n                    o := sub(o, 0x20)\n                    if iszero(o) { break }\n                }\n            }\n        }\n    }",
            "startLine": 231
          },
          {
            "name": "slice",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "slice",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function slice(uint256[] memory a, uint256 start)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        result = slice(a, start, type(uint256).max);\n    }",
            "startLine": 259
          },
          {
            "name": "copy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function copy(uint256[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let end := add(add(result, 0x20), shl(5, mload(a)))\n            let o := result\n            for { let d := sub(a, result) } 1 {} {\n                mstore(o, mload(add(o, d)))\n                o := add(0x20, o)\n                if eq(o, end) { break }\n            }\n            mstore(0x40, o)\n        }\n    }",
            "startLine": 268
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "needle",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(uint256[] memory a, uint256 needle) internal pure returns (bool) {\n        return ~indexOf(a, needle, 0) != 0;\n    }",
            "startLine": 284
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "needle",
                "type": "uint256"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function indexOf(uint256[] memory a, uint256 needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0)\n            if lt(from, mload(a)) {\n                let o := add(a, shl(5, from))\n                let end := add(shl(5, add(1, mload(a))), a)\n                let c := mload(end) // Cache the word after the array.\n                for { mstore(end, needle) } 1 {} {\n                    o := add(o, 0x20)\n                    if eq(mload(o), needle) { break }\n                }\n                mstore(end, c) // Restore the word after the array.\n                if iszero(eq(o, end)) { result := shr(5, sub(o, add(0x20, a))) }\n            }\n        }\n    }",
            "startLine": 290
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "needle",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(uint256[] memory a, uint256 needle) internal pure returns (uint256 result) {\n        result = indexOf(a, needle, 0);\n    }",
            "startLine": 314
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "needle",
                "type": "uint256"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(uint256[] memory a, uint256 needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0)\n            let n := mload(a)\n            if n {\n                if iszero(lt(from, n)) { from := sub(n, 1) }\n                let o := add(shl(5, add(2, from)), a)\n                for { mstore(a, needle) } 1 {} {\n                    o := sub(o, 0x20)\n                    if eq(mload(o), needle) { break }\n                }\n                mstore(a, n) // Restore the length.\n                if iszero(eq(o, a)) { result := shr(5, sub(o, add(0x20, a))) }\n            }\n        }\n    }",
            "startLine": 320
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "needle",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "lastIndexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(uint256[] memory a, uint256 needle)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(a, needle, NOT_FOUND);\n    }",
            "startLine": 344
          },
          {
            "name": "directReturn",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function directReturn(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let retStart := sub(a, 0x20)\n            mstore(retStart, 0x20)\n            return(retStart, add(0x40, shl(5, mload(a))))\n        }\n    }",
            "startLine": 353
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function length(DynamicArray memory a) internal pure returns (uint256) {\n        return a.data.length;\n    }",
            "startLine": 370
          },
          {
            "name": "wrap",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function wrap(uint256[] memory a) internal pure returns (DynamicArray memory result) {\n        result.data = a;\n    }",
            "startLine": 375
          },
          {
            "name": "wrap",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function wrap(address[] memory a) internal pure returns (DynamicArray memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, a)\n        }\n    }",
            "startLine": 380
          },
          {
            "name": "wrap",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bool[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function wrap(bool[] memory a) internal pure returns (DynamicArray memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, a)\n        }\n    }",
            "startLine": 388
          },
          {
            "name": "wrap",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function wrap(bytes32[] memory a) internal pure returns (DynamicArray memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, a)\n        }\n    }",
            "startLine": 396
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clear(DynamicArray memory a) internal pure returns (DynamicArray memory result) {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(mload(result), 0)\n        }\n    }",
            "startLine": 404
          },
          {
            "name": "free",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function free(DynamicArray memory a) internal pure returns (DynamicArray memory result) {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let arrData := mload(result)\n            if iszero(eq(arrData, 0x60)) {\n                let prime := 8188386068317523\n                let cap := mload(sub(arrData, 0x20))\n                // Extract `cap`, initializing it to zero if it is not a multiple of `prime`.\n                cap := mul(div(cap, prime), iszero(mod(cap, prime)))\n                // If `cap` is non-zero and the memory is contiguous, we can free it.\n                if lt(iszero(cap), eq(mload(0x40), add(arrData, add(0x20, cap)))) {\n                    mstore(0x40, sub(arrData, 0x20))\n                }\n                mstore(result, 0x60)\n            }\n        }\n    }",
            "startLine": 414
          },
          {
            "name": "resize",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "reserve",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function resize(DynamicArray memory a, uint256 n)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        reserve(result, n);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let arrData := mload(result)\n            let arrLen := mload(arrData)\n            if iszero(lt(n, arrLen)) {\n                calldatacopy(\n                    add(arrData, shl(5, add(1, arrLen))),\n                    calldatasize(),\n                    shl(5, sub(n, arrLen))\n                )\n            }\n            mstore(arrData, n)\n        }\n    }",
            "startLine": 435
          },
          {
            "name": "expand",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "reserve",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function expand(DynamicArray memory a, uint256 n)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        if (n >= a.data.length) {\n            reserve(result, n);\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(mload(result), n)\n            }\n        }\n    }",
            "startLine": 461
          },
          {
            "name": "truncate",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function truncate(DynamicArray memory a, uint256 n)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(mul(lt(n, mload(mload(result))), mload(result)), n)\n        }\n    }",
            "startLine": 479
          },
          {
            "name": "reserve",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "minimum",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function reserve(DynamicArray memory a, uint256 minimum)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(minimum, 0xffffffff)) { invalid() } // For extra safety.\n            for { let arrData := mload(a) } 1 {} {\n                // Some random prime number to multiply `cap`, so that\n                // we know that the `cap` is for a dynamic array.\n                // Selected to be larger than any memory pointer realistically.\n                let prime := 8188386068317523\n                // Special case for `arrData` pointing to zero pointer.\n                if eq(arrData, 0x60) {\n                    let newCap := shl(5, add(1, minimum))\n                    let capSlot := mload(0x40)\n                    mstore(capSlot, mul(prime, newCap)) // Store the capacity.\n                    let newArrData := add(0x20, capSlot)\n                    mstore(newArrData, 0) // Store the length.\n                    mstore(0x40, add(newArrData, add(0x20, newCap))) // Allocate memory.\n                    mstore(a, newArrData)\n                    break\n                }\n                let w := not(0x1f)\n                let cap := mload(add(arrData, w)) // `mload(sub(arrData, w))`.\n                // Extract `cap`, initializing it to zero if it is not a multiple of `prime`.\n                cap := mul(div(cap, prime), iszero(mod(cap, prime)))\n                let newCap := shl(5, minimum)\n                // If we don't need to grow the memory.\n                if iszero(and(gt(minimum, mload(arrData)), gt(newCap, cap))) { break }\n                // If the memory is contiguous, we can simply expand it.\n                if eq(mload(0x40), add(arrData, add(0x20, cap))) {\n                    mstore(add(arrData, w), mul(prime, newCap)) // Store the capacity.\n                    mstore(0x40, add(arrData, add(0x20, newCap))) // Expand the memory allocation.\n                    break\n                }\n                let capSlot := mload(0x40)\n                let newArrData := add(capSlot, 0x20)\n                mstore(0x40, add(newArrData, add(0x20, newCap))) // Reallocate the memory.\n                mstore(a, newArrData) // Store the `newArrData`.\n                // Copy `arrData` one word at a time, backwards.\n                for { let o := add(0x20, shl(5, mload(arrData))) } 1 {} {\n                    mstore(add(newArrData, o), mload(add(arrData, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                mstore(capSlot, mul(prime, newCap)) // Store the capacity.\n                mstore(newArrData, mload(arrData)) // Store the length.\n                break\n            }\n        }\n    }",
            "startLine": 493
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "data",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(DynamicArray memory a, uint256 data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let arrData := mload(a)\n            let newArrLen := add(mload(arrData), 1)\n            let newArrBytesLen := shl(5, newArrLen)\n            // Some random prime number to multiply `cap`, so that\n            // we know that the `cap` is for a dynamic array.\n            // Selected to be larger than any memory pointer realistically.\n            let prime := 8188386068317523\n            let cap := mload(sub(arrData, 0x20))\n            // Extract `cap`, initializing it to zero if it is not a multiple of `prime`.\n            cap := mul(div(cap, prime), iszero(mod(cap, prime)))\n\n            // Expand / Reallocate memory if required.\n            // Note that we need to allocate an extra word for the length.\n            for {} iszero(lt(newArrBytesLen, cap)) {} {\n                // Approximately more than double the capacity to ensure more than enough space.\n                let newCap := add(cap, or(cap, newArrBytesLen))\n                // If the memory is contiguous, we can simply expand it.\n                if iszero(or(xor(mload(0x40), add(arrData, add(0x20, cap))), iszero(cap))) {\n                    mstore(sub(arrData, 0x20), mul(prime, newCap)) // Store the capacity.\n                    mstore(0x40, add(arrData, add(0x20, newCap))) // Expand the memory allocation.\n                    break\n                }\n                // Set the `newArrData` to point to the word after `cap`.\n                let newArrData := add(mload(0x40), 0x20)\n                mstore(0x40, add(newArrData, add(0x20, newCap))) // Reallocate the memory.\n                mstore(a, newArrData) // Store the `newArrData`.\n                let w := not(0x1f)\n                // Copy `arrData` one word at a time, backwards.\n                for { let o := newArrBytesLen } 1 {} {\n                    mstore(add(newArrData, o), mload(add(arrData, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                mstore(add(newArrData, w), mul(prime, newCap)) // Store the memory.\n                arrData := newArrData // Assign `newArrData` to `arrData`.\n                break\n            }\n            mstore(add(arrData, newArrBytesLen), data) // Append `data`.\n            mstore(arrData, newArrLen) // Store the length.\n        }\n    }",
            "startLine": 550
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "data",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(DynamicArray memory a, address data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = p(a, uint256(uint160(data)));\n    }",
            "startLine": 602
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "data",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toUint",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(DynamicArray memory a, bool data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = p(a, _toUint(data));\n    }",
            "startLine": 612
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "data",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(DynamicArray memory a, bytes32 data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = p(a, uint256(data));\n    }",
            "startLine": 622
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function p() internal pure returns (DynamicArray memory result) {}",
            "startLine": 632
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(uint256 data) internal pure returns (DynamicArray memory result) {\n        p(result, uint256(data));\n    }",
            "startLine": 635
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(address data) internal pure returns (DynamicArray memory result) {\n        p(result, uint256(uint160(data)));\n    }",
            "startLine": 640
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toUint",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(bool data) internal pure returns (DynamicArray memory result) {\n        p(result, _toUint(data));\n    }",
            "startLine": 645
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(bytes32 data) internal pure returns (DynamicArray memory result) {\n        p(result, uint256(data));\n    }",
            "startLine": 650
          },
          {
            "name": "pop",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function pop(DynamicArray memory a) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := mload(a)\n            let n := mload(o)\n            result := mload(add(o, shl(5, n)))\n            mstore(o, sub(n, iszero(iszero(n))))\n        }\n    }",
            "startLine": 656
          },
          {
            "name": "popUint256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function popUint256(DynamicArray memory a) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := mload(a)\n            let n := mload(o)\n            result := mload(add(o, shl(5, n)))\n            mstore(o, sub(n, iszero(iszero(n))))\n        }\n    }",
            "startLine": 668
          },
          {
            "name": "popAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function popAddress(DynamicArray memory a) internal pure returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := mload(a)\n            let n := mload(o)\n            result := mload(add(o, shl(5, n)))\n            mstore(o, sub(n, iszero(iszero(n))))\n        }\n    }",
            "startLine": 680
          },
          {
            "name": "popBool",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function popBool(DynamicArray memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := mload(a)\n            let n := mload(o)\n            result := mload(add(o, shl(5, n)))\n            mstore(o, sub(n, iszero(iszero(n))))\n        }\n    }",
            "startLine": 692
          },
          {
            "name": "popBytes32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function popBytes32(DynamicArray memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := mload(a)\n            let n := mload(o)\n            result := mload(add(o, shl(5, n)))\n            mstore(o, sub(n, iszero(iszero(n))))\n        }\n    }",
            "startLine": 704
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(DynamicArray memory a, uint256 i) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(mload(a), 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 715
          },
          {
            "name": "getUint256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getUint256(DynamicArray memory a, uint256 i) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(mload(a), 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 723
          },
          {
            "name": "getAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getAddress(DynamicArray memory a, uint256 i) internal pure returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(mload(a), 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 731
          },
          {
            "name": "getBool",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getBool(DynamicArray memory a, uint256 i) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(mload(a), 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 739
          },
          {
            "name": "getBytes32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getBytes32(DynamicArray memory a, uint256 i) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(mload(a), 0x20), shl(5, i)))\n        }\n    }",
            "startLine": 747
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "i",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(DynamicArray memory a, uint256 i, uint256 data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(mload(result), 0x20), shl(5, i)), data)\n        }\n    }",
            "startLine": 755
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "i",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(DynamicArray memory a, uint256 i, address data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(mload(result), 0x20), shl(5, i)), shr(96, shl(96, data)))\n        }\n    }",
            "startLine": 769
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "i",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(DynamicArray memory a, uint256 i, bool data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(mload(result), 0x20), shl(5, i)), iszero(iszero(data)))\n        }\n    }",
            "startLine": 783
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "i",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(DynamicArray memory a, uint256 i, bytes32 data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(mload(result), 0x20), shl(5, i)), data)\n        }\n    }",
            "startLine": 797
          },
          {
            "name": "asUint256Array",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function asUint256Array(DynamicArray memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(a)\n        }\n    }",
            "startLine": 811
          },
          {
            "name": "asAddressArray",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function asAddressArray(DynamicArray memory a) internal pure returns (address[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(a)\n        }\n    }",
            "startLine": 819
          },
          {
            "name": "asBoolArray",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function asBoolArray(DynamicArray memory a) internal pure returns (bool[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(a)\n        }\n    }",
            "startLine": 827
          },
          {
            "name": "asBytes32Array",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function asBytes32Array(DynamicArray memory a) internal pure returns (bytes32[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(a)\n        }\n    }",
            "startLine": 835
          },
          {
            "name": "slice",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "slice",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function slice(DynamicArray memory a, uint256 start, uint256 end)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        result.data = slice(a.data, start, end);\n    }",
            "startLine": 843
          },
          {
            "name": "slice",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "slice",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function slice(DynamicArray memory a, uint256 start)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        result.data = slice(a.data, start, type(uint256).max);\n    }",
            "startLine": 852
          },
          {
            "name": "copy",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "calls": [
              {
                "target": "copy",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function copy(DynamicArray memory a) internal pure returns (DynamicArray memory result) {\n        result.data = copy(a.data);\n    }",
            "startLine": 861
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(DynamicArray memory a, uint256 needle) internal pure returns (bool) {\n        return ~indexOf(a.data, needle, 0) != 0;\n    }",
            "startLine": 866
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(DynamicArray memory a, address needle) internal pure returns (bool) {\n        return ~indexOf(a.data, uint160(needle), 0) != 0;\n    }",
            "startLine": 871
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(DynamicArray memory a, bytes32 needle) internal pure returns (bool) {\n        return ~indexOf(a.data, uint256(needle), 0) != 0;\n    }",
            "startLine": 876
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "uint256"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(DynamicArray memory a, uint256 needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return indexOf(a.data, needle, from);\n    }",
            "startLine": 882
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "address"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(DynamicArray memory a, address needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return indexOf(a.data, uint160(needle), from);\n    }",
            "startLine": 892
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "bytes32"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(DynamicArray memory a, bytes32 needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return indexOf(a.data, uint256(needle), from);\n    }",
            "startLine": 902
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(DynamicArray memory a, uint256 needle) internal pure returns (uint256) {\n        return indexOf(a.data, needle, 0);\n    }",
            "startLine": 912
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(DynamicArray memory a, address needle) internal pure returns (uint256) {\n        return indexOf(a.data, uint160(needle), 0);\n    }",
            "startLine": 918
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(DynamicArray memory a, bytes32 needle) internal pure returns (uint256) {\n        return indexOf(a.data, uint256(needle), 0);\n    }",
            "startLine": 924
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "uint256"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "lastIndexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(DynamicArray memory a, uint256 needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(a.data, needle, from);\n    }",
            "startLine": 930
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "address"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "lastIndexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(DynamicArray memory a, address needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(a.data, uint160(needle), from);\n    }",
            "startLine": 940
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "bytes32"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "lastIndexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(DynamicArray memory a, bytes32 needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(a.data, uint256(needle), from);\n    }",
            "startLine": 950
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "lastIndexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(DynamicArray memory a, uint256 needle) internal pure returns (uint256) {\n        return lastIndexOf(a.data, needle, NOT_FOUND);\n    }",
            "startLine": 960
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "lastIndexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(DynamicArray memory a, address needle) internal pure returns (uint256) {\n        return lastIndexOf(a.data, uint160(needle), NOT_FOUND);\n    }",
            "startLine": 966
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              },
              {
                "name": "needle",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "lastIndexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(DynamicArray memory a, bytes32 needle) internal pure returns (uint256) {\n        return lastIndexOf(a.data, uint256(needle), NOT_FOUND);\n    }",
            "startLine": 972
          },
          {
            "name": "hash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function hash(DynamicArray memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(mload(a), 0x20), shl(5, mload(mload(a))))\n        }\n    }",
            "startLine": 977
          },
          {
            "name": "directReturn",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function directReturn(DynamicArray memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let arrData := mload(a)\n            let retStart := sub(arrData, 0x20)\n            mstore(retStart, 0x20)\n            return(retStart, add(0x40, shl(5, mload(arrData))))\n        }\n    }",
            "startLine": 985
          },
          {
            "name": "_deallocate",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "result",
                "type": "DynamicArray"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _deallocate(DynamicArray memory result) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Deallocate, as we have already allocated.\n        }\n    }",
            "startLine": 1000
          },
          {
            "name": "_toUint",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "b",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toUint(bool b) private pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(iszero(b))\n        }\n    }",
            "startLine": 1008
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "NOT_FOUND",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 27
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "DynamicBufferLib",
        "filePath": "utils/g/DynamicBufferLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function length(DynamicBuffer memory buffer) internal pure returns (uint256) {\n        return buffer.data.length;\n    }",
            "startLine": 31
          },
          {
            "name": "reserve",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "minimum",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function reserve(DynamicBuffer memory buffer, uint256 minimum)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = buffer;\n        uint256 n = buffer.data.length;\n        if (minimum > n) {\n            uint256 i = 0x40;\n            do {} while ((i <<= 1) < minimum);\n            bytes memory data;\n            /// @solidity memory-safe-assembly\n            assembly {\n                data := 0x01\n                mstore(data, sub(i, n))\n            }\n            result = p(result, data);\n        }\n    }",
            "startLine": 36
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clear(DynamicBuffer memory buffer)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(mload(buffer), 0)\n        }\n        result = buffer;\n    }",
            "startLine": 58
          },
          {
            "name": "s",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function s(DynamicBuffer memory buffer) internal pure returns (string memory) {\n        return string(buffer.data);\n    }",
            "startLine": 73
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(DynamicBuffer memory buffer, bytes memory data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = buffer;\n        if (data.length == uint256(0)) return result;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let bufData := mload(buffer)\n            let bufDataLen := mload(bufData)\n            let newBufDataLen := add(mload(data), bufDataLen)\n            // Some random prime number to multiply `cap`, so that\n            // we know that the `cap` is for a dynamic buffer.\n            // Selected to be larger than any memory pointer realistically.\n            let prime := 1621250193422201\n            let cap := mload(add(bufData, w)) // `mload(sub(bufData, 0x20))`.\n            // Extract `cap`, initializing it to zero if it is not a multiple of `prime`.\n            cap := mul(div(cap, prime), iszero(mod(cap, prime)))\n\n            // Expand / Reallocate memory if required.\n            // Note that we need to allocate an extra word for the length, and\n            // and another extra word as a safety word (giving a total of 0x40 bytes).\n            // Without the safety word, the backwards copying can cause a buffer overflow.\n            for {} iszero(lt(newBufDataLen, cap)) {} {\n                // Approximately more than double the capacity to ensure more than enough space.\n                let newCap := and(add(cap, add(or(cap, newBufDataLen), 0x20)), w)\n                // If the memory is contiguous, we can simply expand it.\n                if iszero(or(xor(mload(0x40), add(bufData, add(0x40, cap))), iszero(cap))) {\n                    // Store `cap * prime` in the word before the length.\n                    mstore(add(bufData, w), mul(prime, newCap))\n                    mstore(0x40, add(bufData, add(0x40, newCap))) // Expand the memory allocation.\n                    break\n                }\n                // Set the `newBufData` to point to the word after `cap`.\n                let newBufData := add(mload(0x40), 0x20)\n                mstore(0x40, add(newBufData, add(0x40, newCap))) // Reallocate the memory.\n                mstore(buffer, newBufData) // Store the `newBufData`.\n                // Copy `bufData` one word at a time, backwards.\n                for { let o := and(add(bufDataLen, 0x20), w) } 1 {} {\n                    mstore(add(newBufData, o), mload(add(bufData, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Store `cap * prime` in the word before the length.\n                mstore(add(newBufData, w), mul(prime, newCap))\n                bufData := newBufData // Assign `newBufData` to `bufData`.\n                break\n            }\n            // If it's a reserve operation, set the variables to skip the appending.\n            if eq(data, 0x01) {\n                mstore(data, 0x00)\n                newBufDataLen := bufDataLen\n            }\n            // Copy `data` one word at a time, backwards.\n            for { let o := and(add(mload(data), 0x20), w) } 1 {} {\n                mstore(add(add(bufData, bufDataLen), o), mload(add(data, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            mstore(add(add(bufData, 0x20), newBufDataLen), 0) // Zeroize the word after the buffer.\n            mstore(bufData, newBufDataLen) // Store the length.\n        }\n    }",
            "startLine": 78
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(DynamicBuffer memory buffer, bytes memory data0, bytes memory data1)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(p(buffer, data0), data1);\n    }",
            "startLine": 146
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(buffer, data0), data1), data2);\n    }",
            "startLine": 156
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              },
              {
                "name": "data3",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(p(buffer, data0), data1), data2), data3);\n    }",
            "startLine": 167
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              },
              {
                "name": "data3",
                "type": "bytes"
              },
              {
                "name": "data4",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(p(p(buffer, data0), data1), data2), data3), data4);\n    }",
            "startLine": 179
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              },
              {
                "name": "data3",
                "type": "bytes"
              },
              {
                "name": "data4",
                "type": "bytes"
              },
              {
                "name": "data5",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4,\n        bytes memory data5\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(p(p(p(buffer, data0), data1), data2), data3), data4), data5);\n    }",
            "startLine": 192
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              },
              {
                "name": "data3",
                "type": "bytes"
              },
              {
                "name": "data4",
                "type": "bytes"
              },
              {
                "name": "data5",
                "type": "bytes"
              },
              {
                "name": "data6",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4,\n        bytes memory data5,\n        bytes memory data6\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(p(p(p(p(buffer, data0), data1), data2), data3), data4), data5), data6);\n    }",
            "startLine": 206
          },
          {
            "name": "pBool",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBool(DynamicBuffer memory buffer, bool data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        uint256 casted;\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := iszero(iszero(data))\n        }\n        result = p(buffer, _single(casted, 1));\n    }",
            "startLine": 221
          },
          {
            "name": "pAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pAddress(DynamicBuffer memory buffer, address data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(uint256(uint160(data)), 20));\n    }",
            "startLine": 236
          },
          {
            "name": "pUint8",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint8(DynamicBuffer memory buffer, uint8 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 1));\n    }",
            "startLine": 246
          },
          {
            "name": "pUint16",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint16"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint16(DynamicBuffer memory buffer, uint16 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 2));\n    }",
            "startLine": 256
          },
          {
            "name": "pUint24",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint24"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint24(DynamicBuffer memory buffer, uint24 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 3));\n    }",
            "startLine": 266
          },
          {
            "name": "pUint32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint32(DynamicBuffer memory buffer, uint32 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 4));\n    }",
            "startLine": 276
          },
          {
            "name": "pUint40",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint40"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint40(DynamicBuffer memory buffer, uint40 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 5));\n    }",
            "startLine": 286
          },
          {
            "name": "pUint48",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint48"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint48(DynamicBuffer memory buffer, uint48 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 6));\n    }",
            "startLine": 296
          },
          {
            "name": "pUint56",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint56"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint56(DynamicBuffer memory buffer, uint56 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 7));\n    }",
            "startLine": 306
          },
          {
            "name": "pUint64",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint64(DynamicBuffer memory buffer, uint64 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 8));\n    }",
            "startLine": 316
          },
          {
            "name": "pUint72",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint72"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint72(DynamicBuffer memory buffer, uint72 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 9));\n    }",
            "startLine": 326
          },
          {
            "name": "pUint80",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint80"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint80(DynamicBuffer memory buffer, uint80 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 10));\n    }",
            "startLine": 336
          },
          {
            "name": "pUint88",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint88"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint88(DynamicBuffer memory buffer, uint88 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 11));\n    }",
            "startLine": 346
          },
          {
            "name": "pUint96",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint96"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint96(DynamicBuffer memory buffer, uint96 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 12));\n    }",
            "startLine": 356
          },
          {
            "name": "pUint104",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint104"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint104(DynamicBuffer memory buffer, uint104 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 13));\n    }",
            "startLine": 366
          },
          {
            "name": "pUint112",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint112"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint112(DynamicBuffer memory buffer, uint112 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 14));\n    }",
            "startLine": 376
          },
          {
            "name": "pUint120",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint120"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint120(DynamicBuffer memory buffer, uint120 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 15));\n    }",
            "startLine": 386
          },
          {
            "name": "pUint128",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint128"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint128(DynamicBuffer memory buffer, uint128 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 16));\n    }",
            "startLine": 396
          },
          {
            "name": "pUint136",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint136"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint136(DynamicBuffer memory buffer, uint136 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 17));\n    }",
            "startLine": 406
          },
          {
            "name": "pUint144",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint144"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint144(DynamicBuffer memory buffer, uint144 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 18));\n    }",
            "startLine": 416
          },
          {
            "name": "pUint152",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint152"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint152(DynamicBuffer memory buffer, uint152 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 19));\n    }",
            "startLine": 426
          },
          {
            "name": "pUint160",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint160"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint160(DynamicBuffer memory buffer, uint160 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 20));\n    }",
            "startLine": 436
          },
          {
            "name": "pUint168",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint168"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint168(DynamicBuffer memory buffer, uint168 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 21));\n    }",
            "startLine": 446
          },
          {
            "name": "pUint176",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint176"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint176(DynamicBuffer memory buffer, uint176 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 22));\n    }",
            "startLine": 456
          },
          {
            "name": "pUint184",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint184"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint184(DynamicBuffer memory buffer, uint184 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 23));\n    }",
            "startLine": 466
          },
          {
            "name": "pUint192",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint192"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint192(DynamicBuffer memory buffer, uint192 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 24));\n    }",
            "startLine": 476
          },
          {
            "name": "pUint200",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint200"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint200(DynamicBuffer memory buffer, uint200 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 25));\n    }",
            "startLine": 486
          },
          {
            "name": "pUint208",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint208"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint208(DynamicBuffer memory buffer, uint208 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 26));\n    }",
            "startLine": 496
          },
          {
            "name": "pUint216",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint216"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint216(DynamicBuffer memory buffer, uint216 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 27));\n    }",
            "startLine": 506
          },
          {
            "name": "pUint224",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint224"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint224(DynamicBuffer memory buffer, uint224 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 28));\n    }",
            "startLine": 516
          },
          {
            "name": "pUint232",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint232"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint232(DynamicBuffer memory buffer, uint232 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 29));\n    }",
            "startLine": 526
          },
          {
            "name": "pUint240",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint240"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint240(DynamicBuffer memory buffer, uint240 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 30));\n    }",
            "startLine": 536
          },
          {
            "name": "pUint248",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint248"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint248(DynamicBuffer memory buffer, uint248 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 31));\n    }",
            "startLine": 546
          },
          {
            "name": "pUint256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint256(DynamicBuffer memory buffer, uint256 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 32));\n    }",
            "startLine": 556
          },
          {
            "name": "pBytes1",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes1"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes1(DynamicBuffer memory buffer, bytes1 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 1));\n    }",
            "startLine": 566
          },
          {
            "name": "pBytes2",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes2"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes2(DynamicBuffer memory buffer, bytes2 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 2));\n    }",
            "startLine": 576
          },
          {
            "name": "pBytes3",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes3"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes3(DynamicBuffer memory buffer, bytes3 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 3));\n    }",
            "startLine": 586
          },
          {
            "name": "pBytes4",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes4(DynamicBuffer memory buffer, bytes4 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 4));\n    }",
            "startLine": 596
          },
          {
            "name": "pBytes5",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes5"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes5(DynamicBuffer memory buffer, bytes5 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 5));\n    }",
            "startLine": 606
          },
          {
            "name": "pBytes6",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes6"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes6(DynamicBuffer memory buffer, bytes6 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 6));\n    }",
            "startLine": 616
          },
          {
            "name": "pBytes7",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes7"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes7(DynamicBuffer memory buffer, bytes7 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 7));\n    }",
            "startLine": 626
          },
          {
            "name": "pBytes8",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes8"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes8(DynamicBuffer memory buffer, bytes8 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 8));\n    }",
            "startLine": 636
          },
          {
            "name": "pBytes9",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes9"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes9(DynamicBuffer memory buffer, bytes9 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 9));\n    }",
            "startLine": 646
          },
          {
            "name": "pBytes10",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes10"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes10(DynamicBuffer memory buffer, bytes10 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 10));\n    }",
            "startLine": 656
          },
          {
            "name": "pBytes11",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes11"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes11(DynamicBuffer memory buffer, bytes11 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 11));\n    }",
            "startLine": 666
          },
          {
            "name": "pBytes12",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes12"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes12(DynamicBuffer memory buffer, bytes12 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 12));\n    }",
            "startLine": 676
          },
          {
            "name": "pBytes13",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes13"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes13(DynamicBuffer memory buffer, bytes13 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 13));\n    }",
            "startLine": 686
          },
          {
            "name": "pBytes14",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes14"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes14(DynamicBuffer memory buffer, bytes14 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 14));\n    }",
            "startLine": 696
          },
          {
            "name": "pBytes15",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes15"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes15(DynamicBuffer memory buffer, bytes15 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 15));\n    }",
            "startLine": 706
          },
          {
            "name": "pBytes16",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes16"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes16(DynamicBuffer memory buffer, bytes16 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 16));\n    }",
            "startLine": 716
          },
          {
            "name": "pBytes17",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes17"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes17(DynamicBuffer memory buffer, bytes17 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 17));\n    }",
            "startLine": 726
          },
          {
            "name": "pBytes18",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes18"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes18(DynamicBuffer memory buffer, bytes18 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 18));\n    }",
            "startLine": 736
          },
          {
            "name": "pBytes19",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes19"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes19(DynamicBuffer memory buffer, bytes19 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 19));\n    }",
            "startLine": 746
          },
          {
            "name": "pBytes20",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes20"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes20(DynamicBuffer memory buffer, bytes20 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 20));\n    }",
            "startLine": 756
          },
          {
            "name": "pBytes21",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes21"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes21(DynamicBuffer memory buffer, bytes21 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 21));\n    }",
            "startLine": 766
          },
          {
            "name": "pBytes22",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes22"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes22(DynamicBuffer memory buffer, bytes22 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 22));\n    }",
            "startLine": 776
          },
          {
            "name": "pBytes23",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes23"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes23(DynamicBuffer memory buffer, bytes23 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 23));\n    }",
            "startLine": 786
          },
          {
            "name": "pBytes24",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes24"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes24(DynamicBuffer memory buffer, bytes24 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 24));\n    }",
            "startLine": 796
          },
          {
            "name": "pBytes25",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes25"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes25(DynamicBuffer memory buffer, bytes25 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 25));\n    }",
            "startLine": 806
          },
          {
            "name": "pBytes26",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes26"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes26(DynamicBuffer memory buffer, bytes26 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 26));\n    }",
            "startLine": 816
          },
          {
            "name": "pBytes27",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes27"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes27(DynamicBuffer memory buffer, bytes27 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 27));\n    }",
            "startLine": 826
          },
          {
            "name": "pBytes28",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes28"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes28(DynamicBuffer memory buffer, bytes28 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 28));\n    }",
            "startLine": 836
          },
          {
            "name": "pBytes29",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes29"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes29(DynamicBuffer memory buffer, bytes29 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 29));\n    }",
            "startLine": 846
          },
          {
            "name": "pBytes30",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes30"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes30(DynamicBuffer memory buffer, bytes30 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 30));\n    }",
            "startLine": 856
          },
          {
            "name": "pBytes31",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes31"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes31(DynamicBuffer memory buffer, bytes31 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 31));\n    }",
            "startLine": 866
          },
          {
            "name": "pBytes32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "DynamicBuffer"
              },
              {
                "name": "data",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "_deallocate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_single",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes32(DynamicBuffer memory buffer, bytes32 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 32));\n    }",
            "startLine": 876
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function p() internal pure returns (DynamicBuffer memory result) {}",
            "startLine": 886
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(bytes memory data) internal pure returns (DynamicBuffer memory result) {\n        p(result, data);\n    }",
            "startLine": 889
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(bytes memory data0, bytes memory data1)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        p(p(result, data0), data1);\n    }",
            "startLine": 894
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(bytes memory data0, bytes memory data1, bytes memory data2)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        p(p(p(result, data0), data1), data2);\n    }",
            "startLine": 903
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              },
              {
                "name": "data3",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        p(p(p(p(result, data0), data1), data2), data3);\n    }",
            "startLine": 912
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              },
              {
                "name": "data3",
                "type": "bytes"
              },
              {
                "name": "data4",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4\n    ) internal pure returns (DynamicBuffer memory result) {\n        p(p(p(p(p(result, data0), data1), data2), data3), data4);\n    }",
            "startLine": 921
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              },
              {
                "name": "data3",
                "type": "bytes"
              },
              {
                "name": "data4",
                "type": "bytes"
              },
              {
                "name": "data5",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4,\n        bytes memory data5\n    ) internal pure returns (DynamicBuffer memory result) {\n        p(p(p(p(p(p(result, data0), data1), data2), data3), data4), data5);\n    }",
            "startLine": 932
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data0",
                "type": "bytes"
              },
              {
                "name": "data1",
                "type": "bytes"
              },
              {
                "name": "data2",
                "type": "bytes"
              },
              {
                "name": "data3",
                "type": "bytes"
              },
              {
                "name": "data4",
                "type": "bytes"
              },
              {
                "name": "data5",
                "type": "bytes"
              },
              {
                "name": "data6",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4,\n        bytes memory data5,\n        bytes memory data6\n    ) internal pure returns (DynamicBuffer memory result) {\n        p(p(p(p(p(p(p(result, data0), data1), data2), data3), data4), data5), data6);\n    }",
            "startLine": 944
          },
          {
            "name": "pBool",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBool",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBool(bool data) internal pure returns (DynamicBuffer memory result) {\n        pBool(result, data);\n    }",
            "startLine": 957
          },
          {
            "name": "pAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pAddress",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pAddress(address data) internal pure returns (DynamicBuffer memory result) {\n        pAddress(result, data);\n    }",
            "startLine": 962
          },
          {
            "name": "pUint8",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint8",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint8(uint8 data) internal pure returns (DynamicBuffer memory result) {\n        pUint8(result, data);\n    }",
            "startLine": 967
          },
          {
            "name": "pUint16",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint16"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint16",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint16(uint16 data) internal pure returns (DynamicBuffer memory result) {\n        pUint16(result, data);\n    }",
            "startLine": 972
          },
          {
            "name": "pUint24",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint24"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint24",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint24(uint24 data) internal pure returns (DynamicBuffer memory result) {\n        pUint24(result, data);\n    }",
            "startLine": 977
          },
          {
            "name": "pUint32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint32",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint32(uint32 data) internal pure returns (DynamicBuffer memory result) {\n        pUint32(result, data);\n    }",
            "startLine": 982
          },
          {
            "name": "pUint40",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint40"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint40",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint40(uint40 data) internal pure returns (DynamicBuffer memory result) {\n        pUint40(result, data);\n    }",
            "startLine": 987
          },
          {
            "name": "pUint48",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint48"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint48",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint48(uint48 data) internal pure returns (DynamicBuffer memory result) {\n        pUint48(result, data);\n    }",
            "startLine": 992
          },
          {
            "name": "pUint56",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint56"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint56",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint56(uint56 data) internal pure returns (DynamicBuffer memory result) {\n        pUint56(result, data);\n    }",
            "startLine": 997
          },
          {
            "name": "pUint64",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint64",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint64(uint64 data) internal pure returns (DynamicBuffer memory result) {\n        pUint64(result, data);\n    }",
            "startLine": 1002
          },
          {
            "name": "pUint72",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint72"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint72",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint72(uint72 data) internal pure returns (DynamicBuffer memory result) {\n        pUint72(result, data);\n    }",
            "startLine": 1007
          },
          {
            "name": "pUint80",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint80"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint80",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint80(uint80 data) internal pure returns (DynamicBuffer memory result) {\n        pUint80(result, data);\n    }",
            "startLine": 1012
          },
          {
            "name": "pUint88",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint88"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint88",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint88(uint88 data) internal pure returns (DynamicBuffer memory result) {\n        pUint88(result, data);\n    }",
            "startLine": 1017
          },
          {
            "name": "pUint96",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint96"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint96",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint96(uint96 data) internal pure returns (DynamicBuffer memory result) {\n        pUint96(result, data);\n    }",
            "startLine": 1022
          },
          {
            "name": "pUint104",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint104"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint104",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint104(uint104 data) internal pure returns (DynamicBuffer memory result) {\n        pUint104(result, data);\n    }",
            "startLine": 1027
          },
          {
            "name": "pUint112",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint112"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint112",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint112(uint112 data) internal pure returns (DynamicBuffer memory result) {\n        pUint112(result, data);\n    }",
            "startLine": 1032
          },
          {
            "name": "pUint120",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint120"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint120",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint120(uint120 data) internal pure returns (DynamicBuffer memory result) {\n        pUint120(result, data);\n    }",
            "startLine": 1037
          },
          {
            "name": "pUint128",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint128"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint128",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint128(uint128 data) internal pure returns (DynamicBuffer memory result) {\n        pUint128(result, data);\n    }",
            "startLine": 1042
          },
          {
            "name": "pUint136",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint136"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint136",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint136(uint136 data) internal pure returns (DynamicBuffer memory result) {\n        pUint136(result, data);\n    }",
            "startLine": 1047
          },
          {
            "name": "pUint144",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint144"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint144",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint144(uint144 data) internal pure returns (DynamicBuffer memory result) {\n        pUint144(result, data);\n    }",
            "startLine": 1052
          },
          {
            "name": "pUint152",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint152"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint152",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint152(uint152 data) internal pure returns (DynamicBuffer memory result) {\n        pUint152(result, data);\n    }",
            "startLine": 1057
          },
          {
            "name": "pUint160",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint160"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint160",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint160(uint160 data) internal pure returns (DynamicBuffer memory result) {\n        pUint160(result, data);\n    }",
            "startLine": 1062
          },
          {
            "name": "pUint168",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint168"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint168",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint168(uint168 data) internal pure returns (DynamicBuffer memory result) {\n        pUint168(result, data);\n    }",
            "startLine": 1067
          },
          {
            "name": "pUint176",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint176"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint176",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint176(uint176 data) internal pure returns (DynamicBuffer memory result) {\n        pUint176(result, data);\n    }",
            "startLine": 1072
          },
          {
            "name": "pUint184",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint184"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint184",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint184(uint184 data) internal pure returns (DynamicBuffer memory result) {\n        pUint184(result, data);\n    }",
            "startLine": 1077
          },
          {
            "name": "pUint192",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint192"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint192",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint192(uint192 data) internal pure returns (DynamicBuffer memory result) {\n        pUint192(result, data);\n    }",
            "startLine": 1082
          },
          {
            "name": "pUint200",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint200"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint200",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint200(uint200 data) internal pure returns (DynamicBuffer memory result) {\n        pUint200(result, data);\n    }",
            "startLine": 1087
          },
          {
            "name": "pUint208",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint208"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint208",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint208(uint208 data) internal pure returns (DynamicBuffer memory result) {\n        pUint208(result, data);\n    }",
            "startLine": 1092
          },
          {
            "name": "pUint216",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint216"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint216",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint216(uint216 data) internal pure returns (DynamicBuffer memory result) {\n        pUint216(result, data);\n    }",
            "startLine": 1097
          },
          {
            "name": "pUint224",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint224"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint224",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint224(uint224 data) internal pure returns (DynamicBuffer memory result) {\n        pUint224(result, data);\n    }",
            "startLine": 1102
          },
          {
            "name": "pUint232",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint232"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint232",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint232(uint232 data) internal pure returns (DynamicBuffer memory result) {\n        pUint232(result, data);\n    }",
            "startLine": 1107
          },
          {
            "name": "pUint240",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint240"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint240",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint240(uint240 data) internal pure returns (DynamicBuffer memory result) {\n        pUint240(result, data);\n    }",
            "startLine": 1112
          },
          {
            "name": "pUint248",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint248"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint248",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint248(uint248 data) internal pure returns (DynamicBuffer memory result) {\n        pUint248(result, data);\n    }",
            "startLine": 1117
          },
          {
            "name": "pUint256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pUint256",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pUint256(uint256 data) internal pure returns (DynamicBuffer memory result) {\n        pUint256(result, data);\n    }",
            "startLine": 1122
          },
          {
            "name": "pBytes1",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes1"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes1",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes1(bytes1 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes1(result, data);\n    }",
            "startLine": 1127
          },
          {
            "name": "pBytes2",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes2"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes2",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes2(bytes2 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes2(result, data);\n    }",
            "startLine": 1132
          },
          {
            "name": "pBytes3",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes3"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes3",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes3(bytes3 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes3(result, data);\n    }",
            "startLine": 1137
          },
          {
            "name": "pBytes4",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes4",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes4(bytes4 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes4(result, data);\n    }",
            "startLine": 1142
          },
          {
            "name": "pBytes5",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes5"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes5",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes5(bytes5 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes5(result, data);\n    }",
            "startLine": 1147
          },
          {
            "name": "pBytes6",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes6"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes6",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes6(bytes6 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes6(result, data);\n    }",
            "startLine": 1152
          },
          {
            "name": "pBytes7",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes7"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes7",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes7(bytes7 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes7(result, data);\n    }",
            "startLine": 1157
          },
          {
            "name": "pBytes8",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes8"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes8",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes8(bytes8 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes8(result, data);\n    }",
            "startLine": 1162
          },
          {
            "name": "pBytes9",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes9"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes9",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes9(bytes9 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes9(result, data);\n    }",
            "startLine": 1167
          },
          {
            "name": "pBytes10",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes10"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes10",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes10(bytes10 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes10(result, data);\n    }",
            "startLine": 1172
          },
          {
            "name": "pBytes11",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes11"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes11",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes11(bytes11 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes11(result, data);\n    }",
            "startLine": 1177
          },
          {
            "name": "pBytes12",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes12"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes12",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes12(bytes12 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes12(result, data);\n    }",
            "startLine": 1182
          },
          {
            "name": "pBytes13",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes13"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes13",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes13(bytes13 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes13(result, data);\n    }",
            "startLine": 1187
          },
          {
            "name": "pBytes14",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes14"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes14",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes14(bytes14 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes14(result, data);\n    }",
            "startLine": 1192
          },
          {
            "name": "pBytes15",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes15"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes15",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes15(bytes15 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes15(result, data);\n    }",
            "startLine": 1197
          },
          {
            "name": "pBytes16",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes16"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes16",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes16(bytes16 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes16(result, data);\n    }",
            "startLine": 1202
          },
          {
            "name": "pBytes17",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes17"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes17",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes17(bytes17 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes17(result, data);\n    }",
            "startLine": 1207
          },
          {
            "name": "pBytes18",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes18"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes18",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes18(bytes18 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes18(result, data);\n    }",
            "startLine": 1212
          },
          {
            "name": "pBytes19",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes19"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes19",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes19(bytes19 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes19(result, data);\n    }",
            "startLine": 1217
          },
          {
            "name": "pBytes20",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes20"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes20",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes20(bytes20 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes20(result, data);\n    }",
            "startLine": 1222
          },
          {
            "name": "pBytes21",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes21"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes21",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes21(bytes21 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes21(result, data);\n    }",
            "startLine": 1227
          },
          {
            "name": "pBytes22",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes22"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes22",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes22(bytes22 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes22(result, data);\n    }",
            "startLine": 1232
          },
          {
            "name": "pBytes23",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes23"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes23",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes23(bytes23 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes23(result, data);\n    }",
            "startLine": 1237
          },
          {
            "name": "pBytes24",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes24"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes24",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes24(bytes24 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes24(result, data);\n    }",
            "startLine": 1242
          },
          {
            "name": "pBytes25",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes25"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes25",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes25(bytes25 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes25(result, data);\n    }",
            "startLine": 1247
          },
          {
            "name": "pBytes26",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes26"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes26",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes26(bytes26 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes26(result, data);\n    }",
            "startLine": 1252
          },
          {
            "name": "pBytes27",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes27"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes27",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes27(bytes27 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes27(result, data);\n    }",
            "startLine": 1257
          },
          {
            "name": "pBytes28",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes28"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes28",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes28(bytes28 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes28(result, data);\n    }",
            "startLine": 1262
          },
          {
            "name": "pBytes29",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes29"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes29",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes29(bytes29 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes29(result, data);\n    }",
            "startLine": 1267
          },
          {
            "name": "pBytes30",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes30"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes30",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes30(bytes30 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes30(result, data);\n    }",
            "startLine": 1272
          },
          {
            "name": "pBytes31",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes31"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes31",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes31(bytes31 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes31(result, data);\n    }",
            "startLine": 1277
          },
          {
            "name": "pBytes32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "calls": [
              {
                "target": "pBytes32",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pBytes32(bytes32 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes32(result, data);\n    }",
            "startLine": 1282
          },
          {
            "name": "_deallocate",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "result",
                "type": "DynamicBuffer"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _deallocate(DynamicBuffer memory result) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Deallocate, as we have already allocated.\n        }\n    }",
            "startLine": 1291
          },
          {
            "name": "_single",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "uint256"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _single(uint256 data, uint256 n) private pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 0x00\n            mstore(n, data)\n            mstore(result, n)\n        }\n    }",
            "startLine": 1299
          },
          {
            "name": "_single",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes32"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _single(bytes32 data, uint256 n) private pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 0x00\n            mstore(0x20, data)\n            mstore(result, n)\n        }\n    }",
            "startLine": 1309
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "EnumerableMapLib",
        "filePath": "utils/g/EnumerableMapLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "startLine": 93
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "bytes32"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value, uint256 cap)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key, cap);\n    }",
            "startLine": 104
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.remove",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "startLine": 114
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "bytes32"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        bytes32 value,\n        bool isAdd,\n        uint256 cap\n    ) internal returns (bool) {\n        return isAdd ? set(map, key, value, cap) : remove(map, key);\n    }",
            "startLine": 120
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return EnumerableSetLib.contains(map._keys, key);\n    }",
            "startLine": 131
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.length",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return EnumerableSetLib.length(map._keys);\n    }",
            "startLine": 136
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.at",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Bytes32ToBytes32Map storage map, uint256 i)\n        internal\n        view\n        returns (bytes32 key, bytes32 value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "startLine": 141
          },
          {
            "name": "tryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "exists",
                "type": "bool"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryGet(Bytes32ToBytes32Map storage map, bytes32 key)\n        internal\n        view\n        returns (bool exists, bytes32 value)\n    {\n        exists = (value = map._values[key]) != bytes32(0) || contains(map, key);\n    }",
            "startLine": 150
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(Bytes32ToBytes32Map storage map, bytes32 key)\n        internal\n        view\n        returns (bytes32 value)\n    {\n        if ((value = map._values[key]) == bytes32(0)) {\n            if (!contains(map, key)) _revertNotFound();\n        }\n    }",
            "startLine": 159
          },
          {
            "name": "keys",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToBytes32Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32[]"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.values",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\n        return EnumerableSetLib.values(map._keys);\n    }",
            "startLine": 170
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Bytes32ToUint256Map storage map, bytes32 key, uint256 value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "startLine": 176
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Bytes32ToUint256Map storage map, bytes32 key, uint256 value, uint256 cap)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key, cap);\n    }",
            "startLine": 187
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.remove",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Bytes32ToUint256Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "startLine": 197
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(\n        Bytes32ToUint256Map storage map,\n        bytes32 key,\n        uint256 value,\n        bool isAdd,\n        uint256 cap\n    ) internal returns (bool) {\n        return isAdd ? set(map, key, value, cap) : remove(map, key);\n    }",
            "startLine": 203
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(Bytes32ToUint256Map storage map, bytes32 key) internal view returns (bool) {\n        return EnumerableSetLib.contains(map._keys, key);\n    }",
            "startLine": 214
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.length",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(Bytes32ToUint256Map storage map) internal view returns (uint256) {\n        return EnumerableSetLib.length(map._keys);\n    }",
            "startLine": 219
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.at",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Bytes32ToUint256Map storage map, uint256 i)\n        internal\n        view\n        returns (bytes32 key, uint256 value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "startLine": 224
          },
          {
            "name": "tryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "exists",
                "type": "bool"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryGet(Bytes32ToUint256Map storage map, bytes32 key)\n        internal\n        view\n        returns (bool exists, uint256 value)\n    {\n        exists = (value = map._values[key]) != uint256(0) || contains(map, key);\n    }",
            "startLine": 233
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(Bytes32ToUint256Map storage map, bytes32 key)\n        internal\n        view\n        returns (uint256 value)\n    {\n        if ((value = map._values[key]) == uint256(0)) {\n            if (!contains(map, key)) _revertNotFound();\n        }\n    }",
            "startLine": 242
          },
          {
            "name": "keys",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToUint256Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32[]"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.values",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function keys(Bytes32ToUint256Map storage map) internal view returns (bytes32[] memory) {\n        return EnumerableSetLib.values(map._keys);\n    }",
            "startLine": 253
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              },
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Bytes32ToAddressMap storage map, bytes32 key, address value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "startLine": 259
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              },
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "address"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Bytes32ToAddressMap storage map, bytes32 key, address value, uint256 cap)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key, cap);\n    }",
            "startLine": 270
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.remove",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Bytes32ToAddressMap storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "startLine": 280
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              },
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "address"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(\n        Bytes32ToAddressMap storage map,\n        bytes32 key,\n        address value,\n        bool isAdd,\n        uint256 cap\n    ) internal returns (bool) {\n        return isAdd ? set(map, key, value, cap) : remove(map, key);\n    }",
            "startLine": 286
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (bool) {\n        return EnumerableSetLib.contains(map._keys, key);\n    }",
            "startLine": 297
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.length",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(Bytes32ToAddressMap storage map) internal view returns (uint256) {\n        return EnumerableSetLib.length(map._keys);\n    }",
            "startLine": 302
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.at",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Bytes32ToAddressMap storage map, uint256 i)\n        internal\n        view\n        returns (bytes32 key, address value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "startLine": 307
          },
          {
            "name": "tryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "exists",
                "type": "bool"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryGet(Bytes32ToAddressMap storage map, bytes32 key)\n        internal\n        view\n        returns (bool exists, address value)\n    {\n        exists = (value = map._values[key]) != address(0) || contains(map, key);\n    }",
            "startLine": 316
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              },
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(Bytes32ToAddressMap storage map, bytes32 key)\n        internal\n        view\n        returns (address value)\n    {\n        if ((value = map._values[key]) == address(0)) {\n            if (!contains(map, key)) _revertNotFound();\n        }\n    }",
            "startLine": 325
          },
          {
            "name": "keys",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Bytes32ToAddressMap"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32[]"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.values",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function keys(Bytes32ToAddressMap storage map) internal view returns (bytes32[] memory) {\n        return EnumerableSetLib.values(map._keys);\n    }",
            "startLine": 336
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Uint256ToBytes32Map storage map, uint256 key, bytes32 value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "startLine": 342
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "bytes32"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Uint256ToBytes32Map storage map, uint256 key, bytes32 value, uint256 cap)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key, cap);\n    }",
            "startLine": 353
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.remove",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Uint256ToBytes32Map storage map, uint256 key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "startLine": 363
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "bytes32"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(\n        Uint256ToBytes32Map storage map,\n        uint256 key,\n        bytes32 value,\n        bool isAdd,\n        uint256 cap\n    ) internal returns (bool) {\n        return isAdd ? set(map, key, value, cap) : remove(map, key);\n    }",
            "startLine": 369
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(Uint256ToBytes32Map storage map, uint256 key) internal view returns (bool) {\n        return EnumerableSetLib.contains(map._keys, key);\n    }",
            "startLine": 380
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.length",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(Uint256ToBytes32Map storage map) internal view returns (uint256) {\n        return EnumerableSetLib.length(map._keys);\n    }",
            "startLine": 385
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.at",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Uint256ToBytes32Map storage map, uint256 i)\n        internal\n        view\n        returns (uint256 key, bytes32 value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "startLine": 390
          },
          {
            "name": "tryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "exists",
                "type": "bool"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryGet(Uint256ToBytes32Map storage map, uint256 key)\n        internal\n        view\n        returns (bool exists, bytes32 value)\n    {\n        exists = (value = map._values[key]) != bytes32(0) || contains(map, key);\n    }",
            "startLine": 399
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(Uint256ToBytes32Map storage map, uint256 key)\n        internal\n        view\n        returns (bytes32 value)\n    {\n        if ((value = map._values[key]) == bytes32(0)) {\n            if (!contains(map, key)) _revertNotFound();\n        }\n    }",
            "startLine": 408
          },
          {
            "name": "keys",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToBytes32Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.values",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function keys(Uint256ToBytes32Map storage map) internal view returns (uint256[] memory) {\n        return EnumerableSetLib.values(map._keys);\n    }",
            "startLine": 419
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Uint256ToUint256Map storage map, uint256 key, uint256 value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "startLine": 425
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Uint256ToUint256Map storage map, uint256 key, uint256 value, uint256 cap)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key, cap);\n    }",
            "startLine": 436
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.remove",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Uint256ToUint256Map storage map, uint256 key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "startLine": 446
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(\n        Uint256ToUint256Map storage map,\n        uint256 key,\n        uint256 value,\n        bool isAdd,\n        uint256 cap\n    ) internal returns (bool) {\n        return isAdd ? set(map, key, value, cap) : remove(map, key);\n    }",
            "startLine": 452
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(Uint256ToUint256Map storage map, uint256 key) internal view returns (bool) {\n        return EnumerableSetLib.contains(map._keys, key);\n    }",
            "startLine": 463
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.length",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(Uint256ToUint256Map storage map) internal view returns (uint256) {\n        return EnumerableSetLib.length(map._keys);\n    }",
            "startLine": 468
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.at",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Uint256ToUint256Map storage map, uint256 i)\n        internal\n        view\n        returns (uint256 key, uint256 value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "startLine": 473
          },
          {
            "name": "tryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "exists",
                "type": "bool"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryGet(Uint256ToUint256Map storage map, uint256 key)\n        internal\n        view\n        returns (bool exists, uint256 value)\n    {\n        exists = (value = map._values[key]) != uint256(0) || contains(map, key);\n    }",
            "startLine": 482
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(Uint256ToUint256Map storage map, uint256 key)\n        internal\n        view\n        returns (uint256 value)\n    {\n        if ((value = map._values[key]) == uint256(0)) {\n            if (!contains(map, key)) _revertNotFound();\n        }\n    }",
            "startLine": 491
          },
          {
            "name": "keys",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToUint256Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.values",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function keys(Uint256ToUint256Map storage map) internal view returns (uint256[] memory) {\n        return EnumerableSetLib.values(map._keys);\n    }",
            "startLine": 502
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Uint256ToAddressMap storage map, uint256 key, address value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "startLine": 508
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "address"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(Uint256ToAddressMap storage map, uint256 key, address value, uint256 cap)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key, cap);\n    }",
            "startLine": 519
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.remove",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Uint256ToAddressMap storage map, uint256 key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "startLine": 529
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "address"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(\n        Uint256ToAddressMap storage map,\n        uint256 key,\n        address value,\n        bool isAdd,\n        uint256 cap\n    ) internal returns (bool) {\n        return isAdd ? set(map, key, value, cap) : remove(map, key);\n    }",
            "startLine": 535
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(Uint256ToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return EnumerableSetLib.contains(map._keys, key);\n    }",
            "startLine": 546
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.length",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(Uint256ToAddressMap storage map) internal view returns (uint256) {\n        return EnumerableSetLib.length(map._keys);\n    }",
            "startLine": 551
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.at",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Uint256ToAddressMap storage map, uint256 i)\n        internal\n        view\n        returns (uint256 key, address value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "startLine": 556
          },
          {
            "name": "tryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "exists",
                "type": "bool"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryGet(Uint256ToAddressMap storage map, uint256 key)\n        internal\n        view\n        returns (bool exists, address value)\n    {\n        exists = (value = map._values[key]) != address(0) || contains(map, key);\n    }",
            "startLine": 565
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(Uint256ToAddressMap storage map, uint256 key)\n        internal\n        view\n        returns (address value)\n    {\n        if ((value = map._values[key]) == address(0)) {\n            if (!contains(map, key)) _revertNotFound();\n        }\n    }",
            "startLine": 574
          },
          {
            "name": "keys",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint256ToAddressMap"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.values",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function keys(Uint256ToAddressMap storage map) internal view returns (uint256[] memory) {\n        return EnumerableSetLib.values(map._keys);\n    }",
            "startLine": 585
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              },
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(AddressToBytes32Map storage map, address key, bytes32 value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "startLine": 591
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              },
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "bytes32"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(AddressToBytes32Map storage map, address key, bytes32 value, uint256 cap)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key, cap);\n    }",
            "startLine": 602
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.remove",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(AddressToBytes32Map storage map, address key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "startLine": 612
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              },
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "bytes32"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(\n        AddressToBytes32Map storage map,\n        address key,\n        bytes32 value,\n        bool isAdd,\n        uint256 cap\n    ) internal returns (bool) {\n        return isAdd ? set(map, key, value, cap) : remove(map, key);\n    }",
            "startLine": 618
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(AddressToBytes32Map storage map, address key) internal view returns (bool) {\n        return EnumerableSetLib.contains(map._keys, key);\n    }",
            "startLine": 629
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.length",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(AddressToBytes32Map storage map) internal view returns (uint256) {\n        return EnumerableSetLib.length(map._keys);\n    }",
            "startLine": 634
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.at",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(AddressToBytes32Map storage map, uint256 i)\n        internal\n        view\n        returns (address key, bytes32 value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "startLine": 639
          },
          {
            "name": "tryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "exists",
                "type": "bool"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryGet(AddressToBytes32Map storage map, address key)\n        internal\n        view\n        returns (bool exists, bytes32 value)\n    {\n        exists = (value = map._values[key]) != bytes32(0) || contains(map, key);\n    }",
            "startLine": 648
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(AddressToBytes32Map storage map, address key)\n        internal\n        view\n        returns (bytes32 value)\n    {\n        if ((value = map._values[key]) == bytes32(0)) {\n            if (!contains(map, key)) _revertNotFound();\n        }\n    }",
            "startLine": 657
          },
          {
            "name": "keys",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToBytes32Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address[]"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.values",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function keys(AddressToBytes32Map storage map) internal view returns (address[] memory) {\n        return EnumerableSetLib.values(map._keys);\n    }",
            "startLine": 668
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              },
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(AddressToUint256Map storage map, address key, uint256 value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "startLine": 674
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              },
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(AddressToUint256Map storage map, address key, uint256 value, uint256 cap)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key, cap);\n    }",
            "startLine": 685
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.remove",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(AddressToUint256Map storage map, address key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "startLine": 695
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              },
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(\n        AddressToUint256Map storage map,\n        address key,\n        uint256 value,\n        bool isAdd,\n        uint256 cap\n    ) internal returns (bool) {\n        return isAdd ? set(map, key, value, cap) : remove(map, key);\n    }",
            "startLine": 701
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(AddressToUint256Map storage map, address key) internal view returns (bool) {\n        return EnumerableSetLib.contains(map._keys, key);\n    }",
            "startLine": 712
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.length",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(AddressToUint256Map storage map) internal view returns (uint256) {\n        return EnumerableSetLib.length(map._keys);\n    }",
            "startLine": 717
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.at",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(AddressToUint256Map storage map, uint256 i)\n        internal\n        view\n        returns (address key, uint256 value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "startLine": 722
          },
          {
            "name": "tryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "exists",
                "type": "bool"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryGet(AddressToUint256Map storage map, address key)\n        internal\n        view\n        returns (bool exists, uint256 value)\n    {\n        exists = (value = map._values[key]) != uint256(0) || contains(map, key);\n    }",
            "startLine": 731
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(AddressToUint256Map storage map, address key)\n        internal\n        view\n        returns (uint256 value)\n    {\n        if ((value = map._values[key]) == uint256(0)) {\n            if (!contains(map, key)) _revertNotFound();\n        }\n    }",
            "startLine": 740
          },
          {
            "name": "keys",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToUint256Map"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address[]"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.values",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function keys(AddressToUint256Map storage map) internal view returns (address[] memory) {\n        return EnumerableSetLib.values(map._keys);\n    }",
            "startLine": 751
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              },
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(AddressToAddressMap storage map, address key, address value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "startLine": 757
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              },
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "address"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.add",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(AddressToAddressMap storage map, address key, address value, uint256 cap)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key, cap);\n    }",
            "startLine": 768
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.remove",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(AddressToAddressMap storage map, address key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "startLine": 778
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              },
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "address"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(\n        AddressToAddressMap storage map,\n        address key,\n        address value,\n        bool isAdd,\n        uint256 cap\n    ) internal returns (bool) {\n        return isAdd ? set(map, key, value, cap) : remove(map, key);\n    }",
            "startLine": 784
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(AddressToAddressMap storage map, address key) internal view returns (bool) {\n        return EnumerableSetLib.contains(map._keys, key);\n    }",
            "startLine": 795
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.length",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(AddressToAddressMap storage map) internal view returns (uint256) {\n        return EnumerableSetLib.length(map._keys);\n    }",
            "startLine": 800
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "address"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.at",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(AddressToAddressMap storage map, uint256 i)\n        internal\n        view\n        returns (address key, address value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "startLine": 805
          },
          {
            "name": "tryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "exists",
                "type": "bool"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryGet(AddressToAddressMap storage map, address key)\n        internal\n        view\n        returns (bool exists, address value)\n    {\n        exists = (value = map._values[key]) != address(0) || contains(map, key);\n    }",
            "startLine": 814
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              },
              {
                "name": "key",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(AddressToAddressMap storage map, address key)\n        internal\n        view\n        returns (address value)\n    {\n        if ((value = map._values[key]) == address(0)) {\n            if (!contains(map, key)) _revertNotFound();\n        }\n    }",
            "startLine": 823
          },
          {
            "name": "keys",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "AddressToAddressMap"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address[]"
              }
            ],
            "calls": [
              {
                "target": "EnumerableSetLib.values",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function keys(AddressToAddressMap storage map) internal view returns (address[] memory) {\n        return EnumerableSetLib.values(map._keys);\n    }",
            "startLine": 834
          },
          {
            "name": "_revertNotFound",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _revertNotFound() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x88682bf3) // `EnumerableMapKeyNotFound()`.\n            revert(0x1c, 0x04)\n        }\n    }",
            "startLine": 843
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "EnumerableMapKeyNotFound",
            "parameters": [],
            "startLine": 85
          }
        ],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../EnumerableSetLib.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "EnumerableSetLib",
        "filePath": "utils/g/EnumerableSetLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "AddressSet"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(AddressSet storage set) internal view returns (uint256 result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let rootPacked := sload(rootSlot)\n            let n := shr(160, shl(160, rootPacked))\n            result := shr(1, n)\n            for {} iszero(or(iszero(shr(96, rootPacked)), n)) {} {\n                result := 1\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 2\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 3\n                break\n            }\n        }\n    }",
            "startLine": 113
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Bytes32Set"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(Bytes32Set storage set) internal view returns (uint256 result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := sload(not(rootSlot))\n            result := shr(1, n)\n            for {} iszero(n) {} {\n                result := 0\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 1\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 2\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 3\n                break\n            }\n        }\n    }",
            "startLine": 132
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint256Set"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(Uint256Set storage set) internal view returns (uint256 result) {\n        result = length(_toBytes32Set(set));\n    }",
            "startLine": 152
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Int256Set"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(Int256Set storage set) internal view returns (uint256 result) {\n        result = length(_toBytes32Set(set));\n    }",
            "startLine": 157
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint8Set"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function length(Uint8Set storage set) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let packed := sload(set.slot) } packed { result := add(1, result) } {\n                packed := xor(packed, and(packed, add(1, not(packed))))\n            }\n        }\n    }",
            "startLine": 162
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "AddressSet"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(AddressSet storage set, address value) internal view returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := shr(96, shl(96, value))\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            let rootPacked := sload(rootSlot)\n            for {} 1 {} {\n                if iszero(shr(160, shl(160, rootPacked))) {\n                    result := 1\n                    if eq(shr(96, rootPacked), value) { break }\n                    if eq(shr(96, sload(add(rootSlot, 1))), value) { break }\n                    if eq(shr(96, sload(add(rootSlot, 2))), value) { break }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := iszero(iszero(sload(keccak256(0x00, 0x40))))\n                break\n            }\n        }\n    }",
            "startLine": 172
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Bytes32Set"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for {} 1 {} {\n                if iszero(sload(not(rootSlot))) {\n                    result := 1\n                    if eq(sload(rootSlot), value) { break }\n                    if eq(sload(add(rootSlot, 1)), value) { break }\n                    if eq(sload(add(rootSlot, 2)), value) { break }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := iszero(iszero(sload(keccak256(0x00, 0x40))))\n                break\n            }\n        }\n    }",
            "startLine": 201
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint256Set"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(Uint256Set storage set, uint256 value) internal view returns (bool result) {\n        result = contains(_toBytes32Set(set), bytes32(value));\n    }",
            "startLine": 228
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Int256Set"
              },
              {
                "name": "value",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "contains",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(Int256Set storage set, int256 value) internal view returns (bool result) {\n        result = contains(_toBytes32Set(set), bytes32(uint256(value)));\n    }",
            "startLine": 233
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint8Set"
              },
              {
                "name": "value",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function contains(Uint8Set storage set, uint8 value) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(1, shr(and(0xff, value), sload(set.slot)))\n        }\n    }",
            "startLine": 238
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "AddressSet"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function add(AddressSet storage set, address value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := shr(96, shl(96, value))\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            let rootPacked := sload(rootSlot)\n            for { let n := shr(160, shl(160, rootPacked)) } 1 {} {\n                mstore(0x20, rootSlot)\n                if iszero(n) {\n                    let v0 := shr(96, rootPacked)\n                    if iszero(v0) {\n                        sstore(rootSlot, shl(96, value))\n                        result := 1\n                        break\n                    }\n                    if eq(v0, value) { break }\n                    let v1 := shr(96, sload(add(rootSlot, 1)))\n                    if iszero(v1) {\n                        sstore(add(rootSlot, 1), shl(96, value))\n                        result := 1\n                        break\n                    }\n                    if eq(v1, value) { break }\n                    let v2 := shr(96, sload(add(rootSlot, 2)))\n                    if iszero(v2) {\n                        sstore(add(rootSlot, 2), shl(96, value))\n                        result := 1\n                        break\n                    }\n                    if eq(v2, value) { break }\n                    mstore(0x00, v0)\n                    sstore(keccak256(0x00, 0x40), 1)\n                    mstore(0x00, v1)\n                    sstore(keccak256(0x00, 0x40), 2)\n                    mstore(0x00, v2)\n                    sstore(keccak256(0x00, 0x40), 3)\n                    rootPacked := or(rootPacked, 7)\n                    n := 7\n                }\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                if iszero(sload(p)) {\n                    n := shr(1, n)\n                    result := 1\n                    sstore(p, add(1, n))\n                    if iszero(n) {\n                        sstore(rootSlot, or(3, shl(96, value)))\n                        break\n                    }\n                    sstore(add(rootSlot, n), shl(96, value))\n                    sstore(rootSlot, add(2, rootPacked))\n                    break\n                }\n                break\n            }\n        }\n    }",
            "startLine": 246
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Bytes32Set"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function add(Bytes32Set storage set, bytes32 value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for { let n := sload(not(rootSlot)) } 1 {} {\n                mstore(0x20, rootSlot)\n                if iszero(n) {\n                    let v0 := sload(rootSlot)\n                    if iszero(v0) {\n                        sstore(rootSlot, value)\n                        result := 1\n                        break\n                    }\n                    if eq(v0, value) { break }\n                    let v1 := sload(add(rootSlot, 1))\n                    if iszero(v1) {\n                        sstore(add(rootSlot, 1), value)\n                        result := 1\n                        break\n                    }\n                    if eq(v1, value) { break }\n                    let v2 := sload(add(rootSlot, 2))\n                    if iszero(v2) {\n                        sstore(add(rootSlot, 2), value)\n                        result := 1\n                        break\n                    }\n                    if eq(v2, value) { break }\n                    mstore(0x00, v0)\n                    sstore(keccak256(0x00, 0x40), 1)\n                    mstore(0x00, v1)\n                    sstore(keccak256(0x00, 0x40), 2)\n                    mstore(0x00, v2)\n                    sstore(keccak256(0x00, 0x40), 3)\n                    n := 7\n                }\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                if iszero(sload(p)) {\n                    n := shr(1, n)\n                    sstore(add(rootSlot, n), value)\n                    sstore(p, add(1, n))\n                    sstore(not(rootSlot), or(1, shl(1, add(1, n))))\n                    result := 1\n                    break\n                }\n                break\n            }\n        }\n    }",
            "startLine": 310
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Uint256Set"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function add(Uint256Set storage set, uint256 value) internal returns (bool result) {\n        result = add(_toBytes32Set(set), bytes32(value));\n    }",
            "startLine": 367
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Int256Set"
              },
              {
                "name": "value",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function add(Int256Set storage set, int256 value) internal returns (bool result) {\n        result = add(_toBytes32Set(set), bytes32(uint256(value)));\n    }",
            "startLine": 372
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Uint8Set"
              },
              {
                "name": "value",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function add(Uint8Set storage set, uint8 value) internal returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(set.slot)\n            let mask := shl(and(0xff, value), 1)\n            sstore(set.slot, or(result, mask))\n            result := iszero(and(result, mask))\n        }\n    }",
            "startLine": 377
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "AddressSet"
              },
              {
                "name": "value",
                "type": "address"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function add(AddressSet storage set, address value, uint256 cap)\n        internal\n        returns (bool result)\n    {\n        if (result = add(set, value)) {\n            if (length(set) > cap) revert ExceedsCapacity();\n        }\n    }",
            "startLine": 389
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Bytes32Set"
              },
              {
                "name": "value",
                "type": "bytes32"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function add(Bytes32Set storage set, bytes32 value, uint256 cap)\n        internal\n        returns (bool result)\n    {\n        if (result = add(set, value)) {\n            if (length(set) > cap) revert ExceedsCapacity();\n        }\n    }",
            "startLine": 400
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Uint256Set"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function add(Uint256Set storage set, uint256 value, uint256 cap)\n        internal\n        returns (bool result)\n    {\n        if (result = add(set, value)) {\n            if (length(set) > cap) revert ExceedsCapacity();\n        }\n    }",
            "startLine": 411
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Int256Set"
              },
              {
                "name": "value",
                "type": "int256"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function add(Int256Set storage set, int256 value, uint256 cap) internal returns (bool result) {\n        if (result = add(set, value)) if (length(set) > cap) revert ExceedsCapacity();\n    }",
            "startLine": 422
          },
          {
            "name": "add",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Uint8Set"
              },
              {
                "name": "value",
                "type": "uint8"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function add(Uint8Set storage set, uint8 value, uint256 cap) internal returns (bool result) {\n        if (result = add(set, value)) if (length(set) > cap) revert ExceedsCapacity();\n    }",
            "startLine": 428
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "AddressSet"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(AddressSet storage set, address value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := shr(96, shl(96, value))\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            let rootPacked := sload(rootSlot)\n            for { let n := shr(160, shl(160, rootPacked)) } 1 {} {\n                if iszero(n) {\n                    result := 1\n                    if eq(shr(96, rootPacked), value) {\n                        sstore(rootSlot, sload(add(rootSlot, 1)))\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 1))), value) {\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 2))), value) {\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                let position := sload(p)\n                if iszero(position) { break }\n                n := sub(shr(1, n), 1)\n                if iszero(eq(sub(position, 1), n)) {\n                    let lastValue := shr(96, sload(add(rootSlot, n)))\n                    sstore(add(rootSlot, sub(position, 1)), shl(96, lastValue))\n                    mstore(0x00, lastValue)\n                    sstore(keccak256(0x00, 0x40), position)\n                }\n                sstore(rootSlot, or(shl(96, shr(96, sload(rootSlot))), or(shl(1, n), 1)))\n                sstore(p, 0)\n                result := 1\n                break\n            }\n        }\n    }",
            "startLine": 433
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Bytes32Set"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Bytes32Set storage set, bytes32 value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for { let n := sload(not(rootSlot)) } 1 {} {\n                if iszero(n) {\n                    result := 1\n                    if eq(sload(rootSlot), value) {\n                        sstore(rootSlot, sload(add(rootSlot, 1)))\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 1)), value) {\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 2)), value) {\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                let position := sload(p)\n                if iszero(position) { break }\n                n := sub(shr(1, n), 1)\n                if iszero(eq(sub(position, 1), n)) {\n                    let lastValue := sload(add(rootSlot, n))\n                    sstore(add(rootSlot, sub(position, 1)), lastValue)\n                    mstore(0x00, lastValue)\n                    sstore(keccak256(0x00, 0x40), position)\n                }\n                sstore(not(rootSlot), or(shl(1, n), 1))\n                sstore(p, 0)\n                result := 1\n                break\n            }\n        }\n    }",
            "startLine": 486
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Uint256Set"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Uint256Set storage set, uint256 value) internal returns (bool result) {\n        result = remove(_toBytes32Set(set), bytes32(value));\n    }",
            "startLine": 537
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Int256Set"
              },
              {
                "name": "value",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Int256Set storage set, int256 value) internal returns (bool result) {\n        result = remove(_toBytes32Set(set), bytes32(uint256(value)));\n    }",
            "startLine": 542
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Uint8Set"
              },
              {
                "name": "value",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function remove(Uint8Set storage set, uint8 value) internal returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(set.slot)\n            let mask := shl(and(0xff, value), 1)\n            sstore(set.slot, and(result, not(mask)))\n            result := iszero(iszero(and(result, mask)))\n        }\n    }",
            "startLine": 547
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "AddressSet"
              },
              {
                "name": "value",
                "type": "address"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(AddressSet storage set, address value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }",
            "startLine": 558
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Bytes32Set"
              },
              {
                "name": "value",
                "type": "bytes32"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(Bytes32Set storage set, bytes32 value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }",
            "startLine": 566
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Uint256Set"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(Uint256Set storage set, uint256 value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }",
            "startLine": 574
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Int256Set"
              },
              {
                "name": "value",
                "type": "int256"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(Int256Set storage set, int256 value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }",
            "startLine": 582
          },
          {
            "name": "update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "set",
                "type": "Uint8Set"
              },
              {
                "name": "value",
                "type": "uint8"
              },
              {
                "name": "isAdd",
                "type": "bool"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "add",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "remove",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function update(Uint8Set storage set, uint8 value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }",
            "startLine": 590
          },
          {
            "name": "values",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "AddressSet"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address[]"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function values(AddressSet storage set) internal view returns (address[] memory result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let zs := _ZERO_SENTINEL\n            let rootPacked := sload(rootSlot)\n            let n := shr(160, shl(160, rootPacked))\n            result := mload(0x40)\n            let o := add(0x20, result)\n            let v := shr(96, rootPacked)\n            mstore(o, mul(v, iszero(eq(v, zs))))\n            for {} 1 {} {\n                if iszero(n) {\n                    if v {\n                        n := 1\n                        v := shr(96, sload(add(rootSlot, n)))\n                        if v {\n                            n := 2\n                            mstore(add(o, 0x20), mul(v, iszero(eq(v, zs))))\n                            v := shr(96, sload(add(rootSlot, n)))\n                            if v {\n                                n := 3\n                                mstore(add(o, 0x40), mul(v, iszero(eq(v, zs))))\n                            }\n                        }\n                    }\n                    break\n                }\n                n := shr(1, n)\n                for { let i := 1 } lt(i, n) { i := add(i, 1) } {\n                    v := shr(96, sload(add(rootSlot, i)))\n                    mstore(add(o, shl(5, i)), mul(v, iszero(eq(v, zs))))\n                }\n                break\n            }\n            mstore(result, n)\n            mstore(0x40, add(o, shl(5, n)))\n        }\n    }",
            "startLine": 599
          },
          {
            "name": "values",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Bytes32Set"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32[]"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function values(Bytes32Set storage set) internal view returns (bytes32[] memory result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let zs := _ZERO_SENTINEL\n            let n := sload(not(rootSlot))\n            result := mload(0x40)\n            let o := add(0x20, result)\n            for {} 1 {} {\n                if iszero(n) {\n                    let v := sload(rootSlot)\n                    if v {\n                        n := 1\n                        mstore(o, mul(v, iszero(eq(v, zs))))\n                        v := sload(add(rootSlot, n))\n                        if v {\n                            n := 2\n                            mstore(add(o, 0x20), mul(v, iszero(eq(v, zs))))\n                            v := sload(add(rootSlot, n))\n                            if v {\n                                n := 3\n                                mstore(add(o, 0x40), mul(v, iszero(eq(v, zs))))\n                            }\n                        }\n                    }\n                    break\n                }\n                n := shr(1, n)\n                for { let i := 0 } lt(i, n) { i := add(i, 1) } {\n                    let v := sload(add(rootSlot, i))\n                    mstore(add(o, shl(5, i)), mul(v, iszero(eq(v, zs))))\n                }\n                break\n            }\n            mstore(result, n)\n            mstore(0x40, add(o, shl(5, n)))\n        }\n    }",
            "startLine": 641
          },
          {
            "name": "values",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint256Set"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "values",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function values(Uint256Set storage set) internal view returns (uint256[] memory result) {\n        result = _toUints(values(_toBytes32Set(set)));\n    }",
            "startLine": 682
          },
          {
            "name": "values",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Int256Set"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "int256[]"
              }
            ],
            "calls": [
              {
                "target": "_toInts",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "values",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function values(Int256Set storage set) internal view returns (int256[] memory result) {\n        result = _toInts(values(_toBytes32Set(set)));\n    }",
            "startLine": 688
          },
          {
            "name": "values",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint8Set"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint8[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function values(Uint8Set storage set) internal view returns (uint8[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let ptr := add(result, 0x20)\n            let o := 0\n            for { let packed := sload(set.slot) } packed {} {\n                if iszero(and(packed, 0xffff)) {\n                    o := add(o, 16)\n                    packed := shr(16, packed)\n                    continue\n                }\n                mstore(ptr, o)\n                ptr := add(ptr, shl(5, and(packed, 1)))\n                o := add(o, 1)\n                packed := shr(1, packed)\n            }\n            mstore(result, shr(5, sub(ptr, add(result, 0x20))))\n            mstore(0x40, ptr)\n        }\n    }",
            "startLine": 693
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "AddressSet"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(AddressSet storage set, uint256 i) internal view returns (address result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(96, sload(add(rootSlot, i)))\n            result := mul(result, iszero(eq(result, _ZERO_SENTINEL)))\n        }\n        if (i >= length(set)) revert IndexOutOfBounds();\n    }",
            "startLine": 716
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Bytes32Set"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Bytes32Set storage set, uint256 i) internal view returns (bytes32 result) {\n        result = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(add(result, i))\n            result := mul(result, iszero(eq(result, _ZERO_SENTINEL)))\n        }\n        if (i >= length(set)) revert IndexOutOfBounds();\n    }",
            "startLine": 727
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint256Set"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "at",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Uint256Set storage set, uint256 i) internal view returns (uint256 result) {\n        result = uint256(at(_toBytes32Set(set), i));\n    }",
            "startLine": 738
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Int256Set"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "at",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Int256Set storage set, uint256 i) internal view returns (int256 result) {\n        result = int256(uint256(at(_toBytes32Set(set), i)));\n    }",
            "startLine": 743
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint8Set"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint8"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function at(Uint8Set storage set, uint256 i) internal view returns (uint8 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := sload(set.slot)\n            for {} 1 {\n                mstore(0x00, 0x4e23d035) // `IndexOutOfBounds()`.\n                revert(0x1c, 0x04)\n            } {\n                if iszero(lt(i, 256)) { continue }\n                for { let j := 0 } iszero(eq(i, j)) {} {\n                    packed := xor(packed, and(packed, add(1, not(packed))))\n                    j := add(j, 1)\n                }\n                if iszero(packed) { continue }\n                break\n            }\n            // Find first set subroutine, optimized for smaller bytecode size.\n            let x := and(packed, add(1, not(packed)))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            result := or(r, byte(and(div(0xd76453e0, shr(r, x)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }",
            "startLine": 748
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "AddressSet"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(AddressSet storage set, address value) internal view returns (uint256 result) {\n        result = NOT_FOUND;\n        if (uint160(value) == _ZERO_SENTINEL) return result;\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(value) { value := _ZERO_SENTINEL }\n            result := not(0)\n            let rootPacked := sload(rootSlot)\n            for {} 1 {} {\n                if iszero(shr(160, shl(160, rootPacked))) {\n                    if eq(shr(96, rootPacked), value) {\n                        result := 0\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 1))), value) {\n                        result := 1\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 2))), value) {\n                        result := 2\n                        break\n                    }\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := sub(sload(keccak256(0x00, 0x40)), 1)\n                break\n            }\n        }\n    }",
            "startLine": 777
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Bytes32Set"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_rootSlot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(Bytes32Set storage set, bytes32 value) internal view returns (uint256 result) {\n        result = NOT_FOUND;\n        if (uint256(value) == _ZERO_SENTINEL) return result;\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for {} 1 {} {\n                if iszero(sload(not(rootSlot))) {\n                    if eq(sload(rootSlot), value) {\n                        result := 0\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 1)), value) {\n                        result := 1\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 2)), value) {\n                        result := 2\n                        break\n                    }\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := sub(sload(keccak256(0x00, 0x40)), 1)\n                break\n            }\n        }\n    }",
            "startLine": 811
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint256Set"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(Uint256Set storage set, uint256 i) internal view returns (uint256 result) {\n        result = indexOf(_toBytes32Set(set), bytes32(i));\n    }",
            "startLine": 843
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Int256Set"
              },
              {
                "name": "i",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toBytes32Set",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(Int256Set storage set, int256 i) internal view returns (uint256 result) {\n        result = indexOf(_toBytes32Set(set), bytes32(uint256(i)));\n    }",
            "startLine": 848
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "set",
                "type": "Uint8Set"
              },
              {
                "name": "value",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function indexOf(Uint8Set storage set, uint8 value) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0)\n            let packed := sload(set.slot)\n            let m := shl(and(0xff, value), 1)\n            if and(packed, m) {\n                result := 0\n                for { let p := and(packed, sub(m, 1)) } p {} {\n                    p := xor(p, and(p, add(1, not(p))))\n                    result := add(result, 1)\n                }\n            }\n        }\n    }",
            "startLine": 853
          },
          {
            "name": "_rootSlot",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "AddressSet"
              }
            ],
            "returnValues": [
              {
                "name": "r",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _rootSlot(AddressSet storage s) private pure returns (bytes32 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ENUMERABLE_ADDRESS_SET_SLOT_SEED)\n            mstore(0x00, s.slot)\n            r := keccak256(0x00, 0x24)\n        }\n    }",
            "startLine": 874
          },
          {
            "name": "_rootSlot",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "Bytes32Set"
              }
            ],
            "returnValues": [
              {
                "name": "r",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _rootSlot(Bytes32Set storage s) private pure returns (bytes32 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ENUMERABLE_WORD_SET_SLOT_SEED)\n            mstore(0x00, s.slot)\n            r := keccak256(0x00, 0x24)\n        }\n    }",
            "startLine": 884
          },
          {
            "name": "_toBytes32Set",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "Uint256Set"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "Bytes32Set"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toBytes32Set(Uint256Set storage s) private pure returns (Bytes32Set storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c.slot := s.slot\n        }\n    }",
            "startLine": 894
          },
          {
            "name": "_toBytes32Set",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "Int256Set"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "Bytes32Set"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toBytes32Set(Int256Set storage s) private pure returns (Bytes32Set storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c.slot := s.slot\n        }\n    }",
            "startLine": 902
          },
          {
            "name": "_toUints",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toUints(bytes32[] memory a) private pure returns (uint256[] memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := a\n        }\n    }",
            "startLine": 910
          },
          {
            "name": "_toInts",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes32[]"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "int256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toInts(bytes32[] memory a) private pure returns (int256[] memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := a\n        }\n    }",
            "startLine": 918
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "IndexOutOfBounds",
            "parameters": [],
            "startLine": 60
          },
          {
            "name": "ValueIsZeroSentinel",
            "parameters": [],
            "startLine": 63
          },
          {
            "name": "ExceedsCapacity",
            "parameters": [],
            "startLine": 66
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "NOT_FOUND",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 73
          },
          {
            "name": "_ZERO_SENTINEL",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 78
          },
          {
            "name": "_ENUMERABLE_ADDRESS_SET_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 92
          },
          {
            "name": "_ENUMERABLE_WORD_SET_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 106
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "JSONParserLib",
        "filePath": "utils/g/JSONParserLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "parse",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "Item"
              }
            ],
            "calls": [
              {
                "target": "_query",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toInput",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function parse(string memory s) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // We will use our own allocation instead.\n        }\n        bytes32 r = _query(_toInput(s), 255);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }",
            "startLine": 86
          },
          {
            "name": "value",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_query",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toInput",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function value(Item memory item) internal pure returns (string memory result) {\n        bytes32 r = _query(_toInput(item), 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }",
            "startLine": 120
          },
          {
            "name": "index",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function index(Item memory item) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if and(mload(item), _PARENT_IS_ARRAY) {\n                result := and(_BITMASK_POINTER, shr(_BITPOS_KEY, mload(item)))\n            }\n        }\n    }",
            "startLine": 130
          },
          {
            "name": "key",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_query",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toInput",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function key(Item memory item) internal pure returns (string memory result) {\n        if (item._data & _PARENT_IS_OBJECT != 0) {\n            bytes32 r = _query(_toInput(item), 1);\n            /// @solidity memory-safe-assembly\n            assembly {\n                result := r\n            }\n        }\n    }",
            "startLine": 145
          },
          {
            "name": "children",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "Item[]"
              }
            ],
            "calls": [
              {
                "target": "_query",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toInput",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function children(Item memory item) internal pure returns (Item[] memory result) {\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }",
            "startLine": 160
          },
          {
            "name": "size",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_query",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toInput",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function size(Item memory item) internal pure returns (uint256 result) {\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(r)\n        }\n    }",
            "startLine": 170
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "Item"
              }
            ],
            "calls": [
              {
                "target": "_query",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toInput",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Item memory item, uint256 i) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\n        }\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(r, 0x20), shl(5, i)))\n            if iszero(and(lt(i, mload(r)), eq(and(mload(item), _BITMASK_TYPE), TYPE_ARRAY))) {\n                result := 0x60 // Reset to the zero pointer.\n            }\n        }\n    }",
            "startLine": 181
          },
          {
            "name": "at",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              },
              {
                "name": "k",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "Item"
              }
            ],
            "calls": [
              {
                "target": "isObject",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "children",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "key",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function at(Item memory item, string memory k) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\n            result := 0x60 // Initialize to the zero pointer.\n        }\n        if (isObject(item)) {\n            bytes32 kHash = keccak256(bytes(k));\n            Item[] memory r = children(item);\n            // We'll just do a linear search. The alternatives are very bloated.\n            for (uint256 i = r.length << 5; i != 0;) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    item := mload(add(r, i))\n                    i := sub(i, 0x20)\n                }\n                if (keccak256(bytes(key(item))) != kHash) continue;\n                result = item;\n                break;\n            }\n        }\n    }",
            "startLine": 203
          },
          {
            "name": "getType",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint8"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function getType(Item memory item) internal pure returns (uint8 result) {\n        result = uint8(item._data & _BITMASK_TYPE);\n    }",
            "startLine": 227
          },
          {
            "name": "isUndefined",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isUndefined(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_UNDEFINED;\n    }",
            "startLine": 234
          },
          {
            "name": "isArray",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isArray(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_ARRAY;\n    }",
            "startLine": 239
          },
          {
            "name": "isObject",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isObject(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_OBJECT;\n    }",
            "startLine": 244
          },
          {
            "name": "isNumber",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isNumber(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_NUMBER;\n    }",
            "startLine": 249
          },
          {
            "name": "isString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isString(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_STRING;\n    }",
            "startLine": 254
          },
          {
            "name": "isBoolean",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isBoolean(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_BOOLEAN;\n    }",
            "startLine": 259
          },
          {
            "name": "isNull",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isNull(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_NULL;\n    }",
            "startLine": 264
          },
          {
            "name": "parent",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "item",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "Item"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function parent(Item memory item) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We've already allocated.\n            result := and(shr(_BITPOS_SIBLING_OR_PARENT, mload(item)), _BITMASK_POINTER)\n            if iszero(result) { result := 0x60 } // Reset to the zero pointer.\n        }\n    }",
            "startLine": 270
          },
          {
            "name": "parseUint",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function parseUint(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            let preMulOverflowThres := div(not(0), 10)\n            for { let i := 0 } 1 {} {\n                i := add(i, 1)\n                let digit := sub(and(mload(add(s, i)), 0xff), 48)\n                let mulOverflowed := gt(result, preMulOverflowThres)\n                let product := mul(10, result)\n                result := add(product, digit)\n                n := mul(n, iszero(or(or(mulOverflowed, lt(result, product)), gt(digit, 9))))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 286
          },
          {
            "name": "parseInt",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "parseUint",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function parseInt(string memory s) internal pure returns (int256 result) {\n        uint256 n = bytes(s).length;\n        uint256 sign;\n        uint256 isNegative;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if n {\n                let c := and(mload(add(s, 1)), 0xff)\n                isNegative := eq(c, 45)\n                if or(eq(c, 43), isNegative) {\n                    sign := c\n                    s := add(s, 1)\n                    mstore(s, sub(n, 1))\n                }\n                if iszero(or(sign, lt(sub(c, 48), 10))) { s := 0x60 }\n            }\n        }\n        uint256 x = parseUint(s);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, add(shl(255, 1), isNegative))) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if sign {\n                mstore(s, sign)\n                s := sub(s, 1)\n                mstore(s, n)\n            }\n            result := xor(x, mul(xor(x, add(not(x), 1)), isNegative))\n        }\n    }",
            "startLine": 310
          },
          {
            "name": "parseUintFromHex",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function parseUintFromHex(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            // Skip two if starts with '0x' or '0X'.\n            let i := shl(1, and(eq(0x3078, or(shr(240, mload(add(s, 0x20))), 0x20)), gt(n, 1)))\n            for {} 1 {} {\n                i := add(i, 1)\n                let c :=\n                    byte(\n                        and(0x1f, shr(and(mload(add(s, i)), 0xff), 0x3e4088843e41bac000000000000)),\n                        0x3010a071000000b0104040208000c05090d060e0f\n                    )\n                n := mul(n, iszero(or(iszero(c), shr(252, result))))\n                result := add(shl(4, result), sub(c, 1))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 346
          },
          {
            "name": "decodeString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function decodeString(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function fail() {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            function decodeUnicodeEscapeSequence(pIn_, end_) -> _unicode, _pOut {\n                _pOut := add(pIn_, 4)\n                let b_ := iszero(gt(_pOut, end_))\n                let t_ := mload(pIn_) // Load the whole word.\n                for { let i_ := 0 } iszero(eq(i_, 4)) { i_ := add(i_, 1) } {\n                    let c_ := sub(byte(i_, t_), 48)\n                    if iszero(and(shr(c_, 0x7e0000007e03ff), b_)) { fail() } // Not hexadecimal.\n                    c_ := sub(c_, add(mul(gt(c_, 16), 7), shl(5, gt(c_, 48))))\n                    _unicode := add(shl(4, _unicode), c_)\n                }\n            }\n\n            function decodeUnicodeCodePoint(pIn_, end_) -> _unicode, _pOut {\n                _unicode, _pOut := decodeUnicodeEscapeSequence(pIn_, end_)\n                if iszero(or(lt(_unicode, 0xd800), gt(_unicode, 0xdbff))) {\n                    let t_ := mload(_pOut) // Load the whole word.\n                    end_ := mul(end_, eq(shr(240, t_), 0x5c75)) // Fail if not starting with '\\\\u'.\n                    t_, _pOut := decodeUnicodeEscapeSequence(add(_pOut, 2), end_)\n                    _unicode := add(0x10000, add(shl(10, and(0x3ff, _unicode)), and(0x3ff, t_)))\n                }\n            }\n\n            function appendCodePointAsUTF8(pIn_, c_) -> _pOut {\n                if iszero(gt(c_, 0x7f)) {\n                    mstore8(pIn_, c_)\n                    _pOut := add(pIn_, 1)\n                    leave\n                }\n                mstore8(0x1f, c_)\n                mstore8(0x1e, shr(6, c_))\n                if iszero(gt(c_, 0x7ff)) {\n                    mstore(pIn_, shl(240, or(0xc080, and(0x1f3f, mload(0x00)))))\n                    _pOut := add(pIn_, 2)\n                    leave\n                }\n                mstore8(0x1d, shr(12, c_))\n                if iszero(gt(c_, 0xffff)) {\n                    mstore(pIn_, shl(232, or(0xe08080, and(0x0f3f3f, mload(0x00)))))\n                    _pOut := add(pIn_, 3)\n                    leave\n                }\n                mstore8(0x1c, shr(18, c_))\n                mstore(pIn_, shl(224, or(0xf0808080, and(0x073f3f3f, mload(0x00)))))\n                _pOut := add(pIn_, shl(2, lt(c_, 0x110000)))\n            }\n\n            function chr(p_) -> _c {\n                _c := byte(0, mload(p_))\n            }\n\n            let n := mload(s)\n            let end := add(add(s, n), 0x1f)\n            if iszero(and(gt(n, 1), eq(0x2222, or(and(0xff00, mload(add(s, 2))), chr(end))))) {\n                fail() // Fail if not double-quoted.\n            }\n            let out := add(mload(0x40), 0x20)\n            for { let curr := add(s, 0x21) } iszero(eq(curr, end)) {} {\n                let c := chr(curr)\n                curr := add(curr, 1)\n                // Not '\\\\'.\n                if iszero(eq(c, 92)) {\n                    // Not '\"'.\n                    if iszero(eq(c, 34)) {\n                        mstore8(out, c)\n                        out := add(out, 1)\n                        continue\n                    }\n                    curr := end\n                }\n                if iszero(eq(curr, end)) {\n                    let escape := chr(curr)\n                    curr := add(curr, 1)\n                    // '\"', '/', '\\\\'.\n                    if and(shr(escape, 0x100000000000800400000000), 1) {\n                        mstore8(out, escape)\n                        out := add(out, 1)\n                        continue\n                    }\n                    // 'u'.\n                    if eq(escape, 117) {\n                        escape, curr := decodeUnicodeCodePoint(curr, end)\n                        out := appendCodePointAsUTF8(out, escape)\n                        continue\n                    }\n                    // `{'b':'\\b', 'f':'\\f', 'n':'\\n', 'r':'\\r', 't':'\\t'}`.\n                    escape := byte(sub(escape, 85), 0x080000000c000000000000000a0000000d0009)\n                    if escape {\n                        mstore8(out, escape)\n                        out := add(out, 1)\n                        continue\n                    }\n                }\n                fail()\n                break\n            }\n            mstore(out, 0) // Zeroize the last slot.\n            result := mload(0x40)\n            mstore(result, sub(out, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(out, 0x20)) // Allocate the memory.\n        }\n    }",
            "startLine": 374
          },
          {
            "name": "_query",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "bytes32"
              },
              {
                "name": "mode",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _query(bytes32 input, uint256 mode) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function fail() {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            function chr(p_) -> _c {\n                _c := byte(0, mload(p_))\n            }\n\n            function skipWhitespace(pIn_, end_) -> _pOut {\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(and(shr(chr(_pOut), 0x100002600), 1)) { leave } // Not in ' \\n\\r\\t'.\n                }\n            }\n\n            function setP(packed_, bitpos_, p_) -> _packed {\n                // Perform an out-of-gas revert if `p_` exceeds `_BITMASK_POINTER`.\n                returndatacopy(returndatasize(), returndatasize(), gt(p_, _BITMASK_POINTER))\n                _packed := or(and(not(shl(bitpos_, _BITMASK_POINTER)), packed_), shl(bitpos_, p_))\n            }\n\n            function getP(packed_, bitpos_) -> _p {\n                _p := and(_BITMASK_POINTER, shr(bitpos_, packed_))\n            }\n\n            function mallocItem(s_, packed_, pStart_, pCurr_, type_) -> _item {\n                _item := mload(0x40)\n                // forgefmt: disable-next-item\n                packed_ := setP(setP(packed_, _BITPOS_VALUE, sub(pStart_, add(s_, 0x20))),\n                    _BITPOS_VALUE_LENGTH, sub(pCurr_, pStart_))\n                mstore(_item, or(packed_, type_))\n                mstore(0x40, add(_item, 0x20)) // Allocate memory.\n            }\n\n            function parseValue(s_, sibling_, pIn_, end_) -> _item, _pOut {\n                let packed_ := setP(mload(0x00), _BITPOS_SIBLING_OR_PARENT, sibling_)\n                _pOut := skipWhitespace(pIn_, end_)\n                if iszero(lt(_pOut, end_)) { leave }\n                for { let c_ := chr(_pOut) } 1 {} {\n                    // If starts with '\"'.\n                    if eq(c_, 34) {\n                        let pStart_ := _pOut\n                        _pOut := parseStringSub(s_, packed_, _pOut, end_)\n                        _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_STRING)\n                        break\n                    }\n                    // If starts with '['.\n                    if eq(c_, 91) {\n                        _item, _pOut := parseArray(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    // If starts with '{'.\n                    if eq(c_, 123) {\n                        _item, _pOut := parseObject(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    // If starts with any in '0123456789-'.\n                    if and(shr(c_, shl(45, 0x1ff9)), 1) {\n                        _item, _pOut := parseNumber(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    if iszero(gt(add(_pOut, 4), end_)) {\n                        let pStart_ := _pOut\n                        let w_ := shr(224, mload(_pOut))\n                        // 'true' in hex format.\n                        if eq(w_, 0x74727565) {\n                            _pOut := add(_pOut, 4)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\n                            break\n                        }\n                        // 'null' in hex format.\n                        if eq(w_, 0x6e756c6c) {\n                            _pOut := add(_pOut, 4)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_NULL)\n                            break\n                        }\n                    }\n                    if iszero(gt(add(_pOut, 5), end_)) {\n                        let pStart_ := _pOut\n                        let w_ := shr(216, mload(_pOut))\n                        // 'false' in hex format.\n                        if eq(w_, 0x66616c7365) {\n                            _pOut := add(_pOut, 5)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\n                            break\n                        }\n                    }\n                    fail()\n                    break\n                }\n                _pOut := skipWhitespace(_pOut, end_)\n            }\n\n            function parseArray(s_, packed_, pIn_, end_) -> _item, _pOut {\n                let j_ := 0\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(_pOut, end_)) { fail() }\n                    if iszero(_item) {\n                        _pOut := skipWhitespace(_pOut, end_)\n                        if eq(chr(_pOut), 93) { break } // ']'.\n                    }\n                    _item, _pOut := parseValue(s_, _item, _pOut, end_)\n                    if _item {\n\n                        // forgefmt: disable-next-item\n                        mstore(_item, setP(or(_PARENT_IS_ARRAY, mload(_item)),\n                            _BITPOS_KEY, j_))\n                        j_ := add(j_, 1)\n                        let c_ := chr(_pOut)\n                        if eq(c_, 93) { break } // ']'.\n                        if eq(c_, 44) { continue } // ','.\n                    }\n                    _pOut := end_\n                }\n                _pOut := add(_pOut, 1)\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_ARRAY)\n            }\n\n            function parseObject(s_, packed_, pIn_, end_) -> _item, _pOut {\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(_pOut, end_)) { fail() }\n                    if iszero(_item) {\n                        _pOut := skipWhitespace(_pOut, end_)\n                        if eq(chr(_pOut), 125) { break } // '}'.\n                    }\n                    _pOut := skipWhitespace(_pOut, end_)\n                    let pKeyStart_ := _pOut\n                    let pKeyEnd_ := parseStringSub(s_, _item, _pOut, end_)\n                    _pOut := skipWhitespace(pKeyEnd_, end_)\n                    // If ':'.\n                    if eq(chr(_pOut), 58) {\n                        _item, _pOut := parseValue(s_, _item, add(_pOut, 1), end_)\n                        if _item {\n\n                            // forgefmt: disable-next-item\n                            mstore(_item, setP(setP(or(_PARENT_IS_OBJECT, mload(_item)),\n                                _BITPOS_KEY_LENGTH, sub(pKeyEnd_, pKeyStart_)),\n                                    _BITPOS_KEY, sub(pKeyStart_, add(s_, 0x20))))\n                            let c_ := chr(_pOut)\n                            if eq(c_, 125) { break } // '}'.\n                            if eq(c_, 44) { continue } // ','.\n                        }\n                    }\n                    _pOut := end_\n                }\n                _pOut := add(_pOut, 1)\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_OBJECT)\n            }\n\n            function checkStringU(p_, o_) {\n                // If not in '0123456789abcdefABCDEF', revert.\n                if iszero(and(shr(sub(chr(add(p_, o_)), 48), 0x7e0000007e03ff), 1)) { fail() }\n                if iszero(eq(o_, 5)) { checkStringU(p_, add(o_, 1)) }\n            }\n\n            function parseStringSub(s_, packed_, pIn_, end_) -> _pOut {\n                if iszero(lt(pIn_, end_)) { fail() }\n                for { _pOut := add(pIn_, 1) } 1 {} {\n                    let c_ := chr(_pOut)\n                    if eq(c_, 34) { break } // '\"'.\n                    // Not '\\'.\n                    if iszero(eq(c_, 92)) {\n                        _pOut := add(_pOut, 1)\n                        continue\n                    }\n                    c_ := chr(add(_pOut, 1))\n                    // '\"', '\\', '//', 'b', 'f', 'n', 'r', 't'.\n                    if and(shr(sub(c_, 34), 0x510110400000000002001), 1) {\n                        _pOut := add(_pOut, 2)\n                        continue\n                    }\n                    // 'u'.\n                    if eq(c_, 117) {\n                        checkStringU(_pOut, 2)\n                        _pOut := add(_pOut, 6)\n                        continue\n                    }\n                    _pOut := end_\n                    break\n                }\n                if iszero(lt(_pOut, end_)) { fail() }\n                _pOut := add(_pOut, 1)\n            }\n\n            function skip0To9s(pIn_, end_, atLeastOne_) -> _pOut {\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(sub(chr(_pOut), 48), 10)) { break } // Not '0'..'9'.\n                }\n                if and(atLeastOne_, eq(pIn_, _pOut)) { fail() }\n            }\n\n            function parseNumber(s_, packed_, pIn_, end_) -> _item, _pOut {\n                _pOut := pIn_\n                if eq(chr(_pOut), 45) { _pOut := add(_pOut, 1) } // '-'.\n                if iszero(lt(sub(chr(_pOut), 48), 10)) { fail() } // Not '0'..'9'.\n                let c_ := chr(_pOut)\n                _pOut := add(_pOut, 1)\n                if iszero(eq(c_, 48)) { _pOut := skip0To9s(_pOut, end_, 0) } // Not '0'.\n                if eq(chr(_pOut), 46) { _pOut := skip0To9s(add(_pOut, 1), end_, 1) } // '.'.\n                let t_ := mload(_pOut)\n                // 'E', 'e'.\n                if eq(\n                    or(0x20, byte(0, t_)),\n                    101\n                ) {\n\n                    // forgefmt: disable-next-item\n                    _pOut := skip0To9s(add(byte(sub(byte(1, t_), 14), 0x010001), // '+', '-'.\n                        add(_pOut, 1)), end_, 1)\n                }\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_NUMBER)\n            }\n\n            function copyStr(s_, offset_, len_) -> _sCopy {\n                _sCopy := mload(0x40)\n                s_ := add(s_, offset_)\n                let w_ := not(0x1f)\n                for { let i_ := and(add(len_, 0x1f), w_) } 1 {} {\n                    mstore(add(_sCopy, i_), mload(add(s_, i_)))\n                    i_ := add(i_, w_) // `sub(i_, 0x20)`.\n                    if iszero(i_) { break }\n                }\n                mstore(_sCopy, len_) // Copy the length.\n                mstore(add(add(_sCopy, 0x20), len_), 0) // Zeroize the last slot.\n                mstore(0x40, add(add(_sCopy, 0x40), len_)) // Allocate memory.\n            }\n\n            function value(item_) -> _value {\n                let packed_ := mload(item_)\n                _value := getP(packed_, _BITPOS_VALUE) // The offset in the string.\n                if iszero(and(_VALUE_INITED, packed_)) {\n                    let s_ := getP(packed_, _BITPOS_STRING)\n                    _value := copyStr(s_, _value, getP(packed_, _BITPOS_VALUE_LENGTH))\n                    packed_ := setP(packed_, _BITPOS_VALUE, _value)\n                    mstore(s_, or(_VALUE_INITED, packed_))\n                }\n            }\n\n            function children(item_) -> _arr {\n                _arr := 0x60 // Initialize to the zero pointer.\n                let packed_ := mload(item_)\n                for {} iszero(gt(and(_BITMASK_TYPE, packed_), TYPE_OBJECT)) {} {\n                    if or(iszero(packed_), iszero(item_)) { break }\n                    if and(packed_, _CHILDREN_INITED) {\n                        _arr := getP(packed_, _BITPOS_CHILD)\n                        break\n                    }\n                    _arr := mload(0x40)\n                    let o_ := add(_arr, 0x20)\n                    for { let h_ := getP(packed_, _BITPOS_CHILD) } h_ {} {\n                        mstore(o_, h_)\n                        let q_ := mload(h_)\n                        let y_ := getP(q_, _BITPOS_SIBLING_OR_PARENT)\n                        mstore(h_, setP(q_, _BITPOS_SIBLING_OR_PARENT, item_))\n                        h_ := y_\n                        o_ := add(o_, 0x20)\n                    }\n                    let w_ := not(0x1f)\n                    let n_ := add(w_, sub(o_, _arr))\n                    mstore(_arr, shr(5, n_))\n                    mstore(0x40, o_) // Allocate memory.\n                    packed_ := setP(packed_, _BITPOS_CHILD, _arr)\n                    mstore(item_, or(_CHILDREN_INITED, packed_))\n                    // Reverse the array.\n                    if iszero(lt(n_, 0x40)) {\n                        let lo_ := add(_arr, 0x20)\n                        let hi_ := add(_arr, n_)\n                        for {} 1 {} {\n                            let temp_ := mload(lo_)\n                            mstore(lo_, mload(hi_))\n                            mstore(hi_, temp_)\n                            hi_ := add(hi_, w_)\n                            lo_ := add(lo_, 0x20)\n                            if iszero(lt(lo_, hi_)) { break }\n                        }\n                    }\n                    break\n                }\n            }\n\n            function getStr(item_, bitpos_, bitposLength_, bitmaskInited_) -> _result {\n                _result := 0x60 // Initialize to the zero pointer.\n                let packed_ := mload(item_)\n                if or(iszero(item_), iszero(packed_)) { leave }\n                _result := getP(packed_, bitpos_)\n                if iszero(and(bitmaskInited_, packed_)) {\n                    let s_ := getP(packed_, _BITPOS_STRING)\n                    _result := copyStr(s_, _result, getP(packed_, bitposLength_))\n                    mstore(item_, or(bitmaskInited_, setP(packed_, bitpos_, _result)))\n                }\n            }\n\n            switch mode\n            // Get value.\n            case 0 { result := getStr(input, _BITPOS_VALUE, _BITPOS_VALUE_LENGTH, _VALUE_INITED) }\n            // Get key.\n            case 1 { result := getStr(input, _BITPOS_KEY, _BITPOS_KEY_LENGTH, _KEY_INITED) }\n            // Get children.\n            case 3 { result := children(input) }\n            // Parse.\n            default {\n                let p := add(input, 0x20)\n                let e := add(p, mload(input))\n                if iszero(eq(p, e)) {\n                    let c := chr(e)\n                    mstore8(e, 34) // Place a '\"' at the end to speed up parsing.\n                    // The `34 << 248` makes `mallocItem` preserve '\"' at the end.\n                    mstore(0x00, setP(shl(248, 34), _BITPOS_STRING, input))\n                    result, p := parseValue(input, 0, p, e)\n                    mstore8(e, c) // Restore the original char at the end.\n                }\n                if or(lt(p, e), iszero(result)) { fail() }\n            }\n        }\n    }",
            "startLine": 489
          },
          {
            "name": "_toInput",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toInput(string memory input) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := input\n        }\n    }",
            "startLine": 811
          },
          {
            "name": "_toInput",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "Item"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toInput(Item memory input) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := input\n        }\n    }",
            "startLine": 819
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ParsingFailed",
            "parameters": [],
            "startLine": 26
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "TYPE_UNDEFINED",
            "type": "uint8",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 37
          },
          {
            "name": "TYPE_ARRAY",
            "type": "uint8",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 40
          },
          {
            "name": "TYPE_OBJECT",
            "type": "uint8",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 43
          },
          {
            "name": "TYPE_NUMBER",
            "type": "uint8",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 46
          },
          {
            "name": "TYPE_STRING",
            "type": "uint8",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 49
          },
          {
            "name": "TYPE_BOOLEAN",
            "type": "uint8",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 52
          },
          {
            "name": "TYPE_NULL",
            "type": "uint8",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 55
          },
          {
            "name": "_BITPOS_STRING",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 59
          },
          {
            "name": "_BITPOS_KEY_LENGTH",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 60
          },
          {
            "name": "_BITPOS_KEY",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 61
          },
          {
            "name": "_BITPOS_VALUE_LENGTH",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 62
          },
          {
            "name": "_BITPOS_VALUE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 63
          },
          {
            "name": "_BITPOS_CHILD",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 64
          },
          {
            "name": "_BITPOS_SIBLING_OR_PARENT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 65
          },
          {
            "name": "_BITMASK_POINTER",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 66
          },
          {
            "name": "_BITMASK_TYPE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 67
          },
          {
            "name": "_KEY_INITED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 68
          },
          {
            "name": "_VALUE_INITED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 69
          },
          {
            "name": "_CHILDREN_INITED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 70
          },
          {
            "name": "_PARENT_IS_ARRAY",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 71
          },
          {
            "name": "_PARENT_IS_OBJECT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 72
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibBitmap",
        "filePath": "utils/g/LibBitmap.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "isSet",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(Bitmap storage bitmap, uint256 index) internal view returns (bool isSet) {\n        // It is better to set `isSet` to either 0 or 1, than zero vs non-zero.\n        // Both cost the same amount of gas, but the former allows the returned value\n        // to be reused without cleaning the upper bits.\n        uint256 b = (bitmap.map[index >> 8] >> (index & 0xff)) & 1;\n        /// @solidity memory-safe-assembly\n        assembly {\n            isSet := b\n        }\n    }",
            "startLine": 36
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(Bitmap storage bitmap, uint256 index) internal {\n        bitmap.map[index >> 8] |= (1 << (index & 0xff));\n    }",
            "startLine": 48
          },
          {
            "name": "unset",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function unset(Bitmap storage bitmap, uint256 index) internal {\n        bitmap.map[index >> 8] &= ~(1 << (index & 0xff));\n    }",
            "startLine": 53
          },
          {
            "name": "toggle",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "newIsSet",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toggle(Bitmap storage bitmap, uint256 index) internal returns (bool newIsSet) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, index))\n            let storageSlot := keccak256(0x00, 0x40)\n            let shift := and(index, 0xff)\n            let storageValue := xor(sload(storageSlot), shl(shift, 1))\n            // It makes sense to return the `newIsSet`,\n            // as it allow us to skip an additional warm `sload`,\n            // and it costs minimal gas (about 15),\n            // which may be optimized away if the returned value is unused.\n            newIsSet := and(1, shr(shift, storageValue))\n            sstore(storageSlot, storageValue)\n        }\n    }",
            "startLine": 59
          },
          {
            "name": "setTo",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "shouldSet",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function setTo(Bitmap storage bitmap, uint256 index, bool shouldSet) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, index))\n            let storageSlot := keccak256(0x00, 0x40)\n            let storageValue := sload(storageSlot)\n            let shift := and(index, 0xff)\n            sstore(\n                storageSlot,\n                // Unsets the bit at `shift` via `and`, then sets its new value via `or`.\n                or(and(storageValue, not(shl(shift, 1))), shl(shift, iszero(iszero(shouldSet))))\n            )\n        }\n    }",
            "startLine": 77
          },
          {
            "name": "setBatch",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function setBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let max := not(0)\n            let shift := and(start, 0xff)\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, start))\n            if iszero(lt(add(shift, amount), 257)) {\n                let storageSlot := keccak256(0x00, 0x40)\n                sstore(storageSlot, or(sload(storageSlot), shl(shift, max)))\n                let bucket := add(mload(0x00), 1)\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\n                amount := and(add(amount, shift), 0xff)\n                shift := 0\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\n                    mstore(0x00, bucket)\n                    sstore(keccak256(0x00, 0x40), max)\n                }\n                mstore(0x00, bucket)\n            }\n            let storageSlot := keccak256(0x00, 0x40)\n            sstore(storageSlot, or(sload(storageSlot), shl(shift, shr(sub(256, amount), max))))\n        }\n    }",
            "startLine": 94
          },
          {
            "name": "unsetBatch",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function unsetBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let shift := and(start, 0xff)\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, start))\n            if iszero(lt(add(shift, amount), 257)) {\n                let storageSlot := keccak256(0x00, 0x40)\n                sstore(storageSlot, and(sload(storageSlot), not(shl(shift, not(0)))))\n                let bucket := add(mload(0x00), 1)\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\n                amount := and(add(amount, shift), 0xff)\n                shift := 0\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\n                    mstore(0x00, bucket)\n                    sstore(keccak256(0x00, 0x40), 0)\n                }\n                mstore(0x00, bucket)\n            }\n            let storageSlot := keccak256(0x00, 0x40)\n            sstore(\n                storageSlot,\n                and(sload(storageSlot), not(shl(shift, shr(sub(256, amount), not(0)))))\n            )\n        }\n    }",
            "startLine": 120
          },
          {
            "name": "popCount",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "count",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "LibBit.popCount",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function popCount(Bitmap storage bitmap, uint256 start, uint256 amount)\n        internal\n        view\n        returns (uint256 count)\n    {\n        unchecked {\n            uint256 bucket = start >> 8;\n            uint256 shift = start & 0xff;\n            if (!(amount + shift < 257)) {\n                count = LibBit.popCount(bitmap.map[bucket] >> shift);\n                uint256 bucketEnd = bucket + ((amount + shift) >> 8);\n                amount = (amount + shift) & 0xff;\n                shift = 0;\n                for (++bucket; bucket != bucketEnd; ++bucket) {\n                    count += LibBit.popCount(bitmap.map[bucket]);\n                }\n            }\n            count += LibBit.popCount((bitmap.map[bucket] >> shift) << (256 - amount));\n        }\n    }",
            "startLine": 149
          },
          {
            "name": "findLastSet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "upTo",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "setBitIndex",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "LibBit.fls",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function findLastSet(Bitmap storage bitmap, uint256 upTo)\n        internal\n        view\n        returns (uint256 setBitIndex)\n    {\n        setBitIndex = NOT_FOUND;\n        uint256 bucket = upTo >> 8;\n        uint256 bits;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, bucket)\n            mstore(0x20, bitmap.slot)\n            let offset := and(0xff, not(upTo)) // `256 - (255 & upTo) - 1`.\n            bits := shr(offset, shl(offset, sload(keccak256(0x00, 0x40))))\n            if iszero(or(bits, iszero(bucket))) {\n                for {} 1 {} {\n                    bucket := add(bucket, setBitIndex) // `sub(bucket, 1)`.\n                    mstore(0x00, bucket)\n                    bits := sload(keccak256(0x00, 0x40))\n                    if or(bits, iszero(bucket)) { break }\n                }\n            }\n        }\n        if (bits != 0) {\n            setBitIndex = (bucket << 8) | LibBit.fls(bits);\n            /// @solidity memory-safe-assembly\n            assembly {\n                setBitIndex := or(setBitIndex, sub(0, gt(setBitIndex, upTo)))\n            }\n        }\n    }",
            "startLine": 172
          },
          {
            "name": "findFirstUnset",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "bitmap",
                "type": "Bitmap"
              },
              {
                "name": "begin",
                "type": "uint256"
              },
              {
                "name": "upTo",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "unsetBitIndex",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "LibBit.ffs",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function findFirstUnset(Bitmap storage bitmap, uint256 begin, uint256 upTo)\n        internal\n        view\n        returns (uint256 unsetBitIndex)\n    {\n        unsetBitIndex = NOT_FOUND;\n        uint256 bucket = begin >> 8;\n        uint256 negBits;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, bucket)\n            mstore(0x20, bitmap.slot)\n            let offset := and(0xff, begin)\n            negBits := shl(offset, shr(offset, not(sload(keccak256(0x00, 0x40)))))\n            if iszero(negBits) {\n                let lastBucket := shr(8, upTo)\n                for {} 1 {} {\n                    bucket := add(bucket, 1)\n                    mstore(0x00, bucket)\n                    negBits := not(sload(keccak256(0x00, 0x40)))\n                    if or(negBits, gt(bucket, lastBucket)) { break }\n                }\n                if gt(bucket, lastBucket) {\n                    negBits := shl(and(0xff, not(upTo)), shr(and(0xff, not(upTo)), negBits))\n                }\n            }\n        }\n        if (negBits != 0) {\n            uint256 r = (bucket << 8) | LibBit.ffs(negBits);\n            /// @solidity memory-safe-assembly\n            assembly {\n                unsetBitIndex := or(r, sub(0, or(gt(r, upTo), lt(r, begin))))\n            }\n        }\n    }",
            "startLine": 206
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "NOT_FOUND",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 29
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../LibBit.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "LibBytes",
        "filePath": "utils/g/LibBytes.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "BytesStorage"
              },
              {
                "name": "s",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(BytesStorage storage $, bytes memory s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            let packed := or(0xff, shl(8, n))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(n, 0xfe)) {\n                    i := 0x1f\n                    packed := or(n, shl(8, mload(add(s, i))))\n                    if iszero(gt(n, i)) { break }\n                }\n                let o := add(s, 0x20)\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), mload(add(o, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }",
            "startLine": 34
          },
          {
            "name": "setCalldata",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "BytesStorage"
              },
              {
                "name": "s",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function setCalldata(BytesStorage storage $, bytes calldata s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := or(0xff, shl(8, s.length))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(s.length, 0xfe)) {\n                    i := 0x1f\n                    packed := or(s.length, shl(8, shr(8, calldataload(s.offset))))\n                    if iszero(gt(s.length, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), calldataload(add(s.offset, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, s.length)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }",
            "startLine": 59
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "BytesStorage"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clear(BytesStorage storage $) internal {\n        delete $._spacer;\n    }",
            "startLine": 82
          },
          {
            "name": "isEmpty",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "BytesStorage"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isEmpty(BytesStorage storage $) internal view returns (bool) {\n        return uint256($._spacer) & 0xff == uint256(0);\n    }",
            "startLine": 87
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "BytesStorage"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function length(BytesStorage storage $) internal view returns (uint256 result) {\n        result = uint256($._spacer);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := and(0xff, result)\n            result := or(mul(shr(8, result), eq(0xff, n)), mul(n, iszero(eq(0xff, n))))\n        }\n    }",
            "startLine": 92
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "BytesStorage"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(BytesStorage storage $) internal view returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            let packed := sload($.slot)\n            let n := shr(8, packed)\n            for { let i := 0 } 1 {} {\n                if iszero(eq(or(packed, 0xff), packed)) {\n                    mstore(o, packed)\n                    n := and(0xff, packed)\n                    i := 0x1f\n                    if iszero(gt(n, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    mstore(add(o, i), sload(add(p, shr(5, i))))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            mstore(result, n) // Store the length of the memory.\n            mstore(add(o, n), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(o, n), 0x20)) // Allocate memory.\n        }\n    }",
            "startLine": 102
          },
          {
            "name": "uint8At",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "BytesStorage"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint8"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function uint8At(BytesStorage storage $, uint256 i) internal view returns (uint8 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let packed := sload($.slot) } 1 {} {\n                if iszero(eq(or(packed, 0xff), packed)) {\n                    if iszero(gt(i, 0x1e)) {\n                        result := byte(i, packed)\n                        break\n                    }\n                    if iszero(gt(i, and(0xff, packed))) {\n                        mstore(0x00, $.slot)\n                        let j := sub(i, 0x1f)\n                        result := byte(and(j, 0x1f), sload(add(keccak256(0x00, 0x20), shr(5, j))))\n                    }\n                    break\n                }\n                if iszero(gt(i, shr(8, packed))) {\n                    mstore(0x00, $.slot)\n                    result := byte(and(i, 0x1f), sload(add(keccak256(0x00, 0x20), shr(5, i))))\n                }\n                break\n            }\n        }\n    }",
            "startLine": 131
          },
          {
            "name": "replace",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes"
              },
              {
                "name": "replacement",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function replace(bytes memory subject, bytes memory needle, bytes memory replacement)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let needleLen := mload(needle)\n            let replacementLen := mload(replacement)\n            let d := sub(result, subject) // Memory difference.\n            let i := add(subject, 0x20) // Subject bytes pointer.\n            mstore(0x00, add(i, mload(subject))) // End of subject.\n            if iszero(gt(needleLen, mload(subject))) {\n                let subjectSearchEnd := add(sub(mload(0x00), needleLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(needleLen, 0x20)) {\n                    h := keccak256(add(needle, 0x20), needleLen)\n                }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(needleLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `needleLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, needleLen), h)) {\n                                mstore(add(i, d), t)\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let j := 0 } 1 {} {\n                            mstore(add(add(i, d), j), mload(add(add(replacement, 0x20), j)))\n                            j := add(j, 0x20)\n                            if iszero(lt(j, replacementLen)) { break }\n                        }\n                        d := sub(add(d, replacementLen), needleLen)\n                        if needleLen {\n                            i := add(i, needleLen)\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(add(i, d), t)\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n            }\n            let end := mload(0x00)\n            let n := add(sub(d, add(result, 0x20)), end)\n            // Copy the rest of the bytes one word at a time.\n            for {} lt(i, end) { i := add(i, 0x20) } { mstore(add(i, d), mload(i)) }\n            let o := add(i, d)\n            mstore(o, 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n            mstore(result, n) // Store the length.\n        }\n    }",
            "startLine": 161
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function indexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0) // Initialize to `NOT_FOUND`.\n            for { let subjectLen := mload(subject) } 1 {} {\n                if iszero(mload(needle)) {\n                    result := from\n                    if iszero(gt(from, subjectLen)) { break }\n                    result := subjectLen\n                    break\n                }\n                let needleLen := mload(needle)\n                let subjectStart := add(subject, 0x20)\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLen), needleLen), 1)\n                let m := shl(3, sub(0x20, and(needleLen, 0x1f)))\n                let s := mload(add(needle, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLen))) { break }\n\n                if iszero(lt(needleLen, 0x20)) {\n                    for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, needleLen), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }",
            "startLine": 225
          },
          {
            "name": "indexOfByte",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes1"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function indexOfByte(bytes memory subject, bytes1 needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0) // Initialize to `NOT_FOUND`.\n            if gt(mload(subject), from) {\n                let start := add(subject, 0x20)\n                let end := add(start, mload(subject))\n                let m := div(not(0), 255) // `0x0101 ... `.\n                let h := mul(byte(0, needle), m) // Replicating needle mask.\n                m := not(shl(7, m)) // `0x7f7f ... `.\n                for { let i := add(start, from) } 1 {} {\n                    let c := xor(mload(i), h) // Load 32-byte chunk and xor with mask.\n                    c := not(or(or(add(and(c, m), m), c), m)) // Each needle byte will be `0x80`.\n                    if c {\n                        c := and(not(shr(shl(3, sub(end, i)), not(0))), c) // Truncate bytes past the end.\n                        if c {\n                            let r := shl(7, lt(0x8421084210842108cc6318c6db6d54be, c)) // Save bytecode.\n                            r := or(shl(6, lt(0xffffffffffffffff, shr(r, c))), r)\n                            // forgefmt: disable-next-item\n                            result := add(sub(i, start), shr(3, xor(byte(and(0x1f, shr(byte(24,\n                                mul(0x02040810204081, shr(r, c))), 0x8421084210842108cc6318c6db6d54be)),\n                                0xc0c8c8d0c8e8d0d8c8e8e0e8d0d8e0f0c8d0e8d0e0e0d8f0d0d0e0d8f8f8f8f8), r)))\n                            break\n                        }\n                    }\n                    i := add(i, 0x20)\n                    if iszero(lt(i, end)) { break }\n                }\n            }\n        }\n    }",
            "startLine": 279
          },
          {
            "name": "indexOfByte",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes1"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOfByte",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOfByte(bytes memory subject, bytes1 needle)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        return indexOfByte(subject, needle, 0);\n    }",
            "startLine": 318
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(bytes memory subject, bytes memory needle) internal pure returns (uint256) {\n        return indexOf(subject, needle, 0);\n    }",
            "startLine": 329
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let needleLen := mload(needle)\n                if gt(needleLen, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), needleLen)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                    if eq(keccak256(subject, needleLen), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }",
            "startLine": 336
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "lastIndexOf",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(subject, needle, type(uint256).max);\n    }",
            "startLine": 373
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "indexOf",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(bytes memory subject, bytes memory needle) internal pure returns (bool) {\n        return indexOf(subject, needle) != NOT_FOUND;\n    }",
            "startLine": 382
          },
          {
            "name": "startsWith",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function startsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            // Just using keccak256 directly is actually cheaper.\n            let t := eq(keccak256(add(subject, 0x20), n), keccak256(add(needle, 0x20), n))\n            result := lt(gt(n, mload(subject)), t)\n        }\n    }",
            "startLine": 387
          },
          {
            "name": "endsWith",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function endsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            let notInRange := gt(n, mload(subject))\n            // `subject + 0x20 + max(subject.length - needle.length, 0)`.\n            let t := add(add(subject, 0x20), mul(iszero(notInRange), sub(mload(subject), n)))\n            // Just using keccak256 directly is actually cheaper.\n            result := gt(eq(keccak256(t, n), keccak256(add(needle, 0x20), n)), notInRange)\n        }\n    }",
            "startLine": 402
          },
          {
            "name": "repeat",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "times",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function repeat(bytes memory subject, uint256 times)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(or(iszero(times), iszero(l))) {\n                result := mload(0x40)\n                subject := add(subject, 0x20)\n                let o := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let j := 0 } 1 {} {\n                        mstore(add(o, j), mload(add(subject, j)))\n                        j := add(j, 0x20)\n                        if iszero(lt(j, l)) { break }\n                    }\n                    o := add(o, l)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            }\n        }\n    }",
            "startLine": 419
          },
          {
            "name": "slice",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function slice(bytes memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(gt(l, end)) { end := l }\n            if iszero(gt(l, start)) { start := l }\n            if lt(start, end) {\n                result := mload(0x40)\n                let n := sub(end, start)\n                let i := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let j := and(add(n, 0x1f), w) } 1 {} {\n                    mstore(add(result, j), mload(add(i, j)))\n                    j := add(j, w) // `sub(j, 0x20)`.\n                    if iszero(j) { break }\n                }\n                let o := add(add(result, 0x20), n)\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, n) // Store the length.\n            }\n        }\n    }",
            "startLine": 451
          },
          {
            "name": "slice",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "slice",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function slice(bytes memory subject, uint256 start)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        result = slice(subject, start, type(uint256).max);\n    }",
            "startLine": 482
          },
          {
            "name": "sliceCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function sliceCalldata(bytes calldata subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, subject.length), lt(subject.length, end)))\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\n            result.offset := add(subject.offset, start)\n            result.length := mul(lt(start, end), sub(end, start))\n        }\n    }",
            "startLine": 492
          },
          {
            "name": "sliceCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function sliceCalldata(bytes calldata subject, uint256 start)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\n            result.offset := add(subject.offset, start)\n            result.length := mul(lt(start, subject.length), sub(subject.length, start))\n        }\n    }",
            "startLine": 508
          },
          {
            "name": "truncate",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function truncate(bytes memory subject, uint256 n) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := subject\n            mstore(mul(lt(n, mload(result)), result), n)\n        }\n    }",
            "startLine": 523
          },
          {
            "name": "truncatedCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function truncatedCalldata(bytes calldata subject, uint256 n)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.offset := subject.offset\n            result.length := xor(n, mul(xor(n, subject.length), lt(subject.length, n)))\n        }\n    }",
            "startLine": 533
          },
          {
            "name": "indicesOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "needle",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function indicesOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLen := mload(needle)\n            if iszero(gt(searchLen, mload(subject))) {\n                result := mload(0x40)\n                let i := add(subject, 0x20)\n                let o := add(result, 0x20)\n                let subjectSearchEnd := add(sub(add(i, mload(subject)), searchLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(searchLen, 0x20)) {\n                    h := keccak256(add(needle, 0x20), searchLen)\n                }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(searchLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `searchLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, searchLen), h)) {\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        mstore(o, sub(i, add(subject, 0x20))) // Append to `result`.\n                        o := add(o, 0x20)\n                        i := add(i, searchLen) // Advance `i` by `searchLen`.\n                        if searchLen {\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n                mstore(result, shr(5, sub(o, add(result, 0x20)))) // Store the length of `result`.\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(o, 0x20))\n            }\n        }\n    }",
            "startLine": 547
          },
          {
            "name": "split",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "bytes"
              },
              {
                "name": "delimiter",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes[]"
              }
            ],
            "calls": [
              {
                "target": "indicesOf",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function split(bytes memory subject, bytes memory delimiter)\n        internal\n        pure\n        returns (bytes[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            for { let prevIndex := 0 } 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let l := sub(index, prevIndex)\n                    mstore(element, l) // Store the length of the element.\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(l, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    mstore(add(add(element, 0x20), l), 0) // Zeroize the slot after the bytes.\n                    // Allocate memory for the length and the bytes, rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(l, 0x3f), w)))\n                    mstore(indexPtr, element) // Store the `element` into the array.\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }",
            "startLine": 596
          },
          {
            "name": "concat",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "b",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function concat(bytes memory a, bytes memory b) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let w := not(0x1f)\n            let aLen := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLen, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLen := mload(b)\n            let output := add(result, aLen)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLen, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLen := add(aLen, bLen)\n            let last := add(add(result, 0x20), totalLen)\n            mstore(last, 0) // Zeroize the slot after the bytes.\n            mstore(result, totalLen) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate memory.\n        }\n    }",
            "startLine": 641
          },
          {
            "name": "eq",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "b",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function eq(bytes memory a, bytes memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }",
            "startLine": 670
          },
          {
            "name": "eqs",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "b",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function eqs(bytes memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }",
            "startLine": 678
          },
          {
            "name": "cmp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "b",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function cmp(bytes memory a, bytes memory b) internal pure returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLen := mload(a)\n            let bLen := mload(b)\n            let n := and(xor(aLen, mul(xor(aLen, bLen), lt(bLen, aLen))), not(0x1f))\n            if n {\n                for { let i := 0x20 } 1 {} {\n                    let x := mload(add(a, i))\n                    let y := mload(add(b, i))\n                    if iszero(or(xor(x, y), eq(i, n))) {\n                        i := add(i, 0x20)\n                        continue\n                    }\n                    result := sub(gt(x, y), lt(x, y))\n                    break\n                }\n            }\n            // forgefmt: disable-next-item\n            if iszero(result) {\n                let l := 0x201f1e1d1c1b1a191817161514131211100f0e0d0c0b0a090807060504030201\n                let x := and(mload(add(add(a, 0x20), n)), shl(shl(3, byte(sub(aLen, n), l)), not(0)))\n                let y := and(mload(add(add(b, 0x20), n)), shl(shl(3, byte(sub(bLen, n), l)), not(0)))\n                result := sub(gt(x, y), lt(x, y))\n                if iszero(result) { result := sub(gt(aLen, bLen), lt(aLen, bLen)) }\n            }\n        }\n    }",
            "startLine": 697
          },
          {
            "name": "directReturn",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function directReturn(bytes memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Assumes that the bytes does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the bytes is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the bytes.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }",
            "startLine": 727
          },
          {
            "name": "directReturn",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes[]"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function directReturn(bytes[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a) // `a.length`.\n            let o := add(a, 0x20) // Start of elements in `a`.\n            let u := a // Highest memory slot.\n            let w := not(0x1f)\n            for { let i := 0 } iszero(eq(i, n)) { i := add(i, 1) } {\n                let c := add(o, shl(5, i)) // Location of pointer to `a[i]`.\n                let s := mload(c) // `a[i]`.\n                let l := mload(s) // `a[i].length`.\n                let r := and(l, 0x1f) // `a[i].length % 32`.\n                let z := add(0x20, and(l, w)) // Offset of last word in `a[i]` from `s`.\n                // If `s` comes before `o`, or `s` is not zero right padded.\n                if iszero(lt(lt(s, o), or(iszero(r), iszero(shl(shl(3, r), mload(add(s, z))))))) {\n                    let m := mload(0x40)\n                    mstore(m, l) // Copy `a[i].length`.\n                    for {} 1 {} {\n                        mstore(add(m, z), mload(add(s, z))) // Copy `a[i]`, backwards.\n                        z := add(z, w) // `sub(z, 0x20)`.\n                        if iszero(z) { break }\n                    }\n                    let e := add(add(m, 0x20), l)\n                    mstore(e, 0) // Zeroize the slot after the copied bytes.\n                    mstore(0x40, add(e, 0x20)) // Allocate memory.\n                    s := m\n                }\n                mstore(c, sub(s, o)) // Convert to calldata offset.\n                let t := add(l, add(s, 0x20))\n                if iszero(lt(t, u)) { u := t }\n            }\n            let retStart := add(a, w) // Assumes `a` doesn't start from scratch space.\n            mstore(retStart, 0x20) // Store the return offset.\n            return(retStart, add(0x40, sub(u, retStart))) // End the transaction.\n        }\n    }",
            "startLine": 743
          },
          {
            "name": "load",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "offset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function load(bytes memory a, uint256 offset) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), offset))\n        }\n    }",
            "startLine": 781
          },
          {
            "name": "loadCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "offset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function loadCalldata(bytes calldata a, uint256 offset) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := calldataload(add(a.offset, offset))\n        }\n    }",
            "startLine": 789
          },
          {
            "name": "staticStructInCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "offset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function staticStructInCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := sub(a.length, 0x20)\n            result.offset := add(a.offset, offset)\n            result.length := sub(a.length, offset)\n            if or(shr(64, or(l, a.offset)), gt(offset, l)) { revert(l, 0x00) }\n        }\n    }",
            "startLine": 797
          },
          {
            "name": "dynamicStructInCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "offset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function dynamicStructInCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := sub(a.length, 0x20)\n            let s := calldataload(add(a.offset, offset)) // Relative offset of `result` from `a.offset`.\n            result.offset := add(a.offset, s)\n            result.length := sub(a.length, s)\n            if or(shr(64, or(s, or(l, a.offset))), gt(offset, l)) { revert(l, 0x00) }\n        }\n    }",
            "startLine": 812
          },
          {
            "name": "bytesInCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "bytes"
              },
              {
                "name": "offset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function bytesInCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := sub(a.length, 0x20)\n            let s := calldataload(add(a.offset, offset)) // Relative offset of `result` from `a.offset`.\n            result.offset := add(add(a.offset, s), 0x20)\n            result.length := calldataload(add(a.offset, s))\n            // forgefmt: disable-next-item\n            if or(shr(64, or(result.length, or(s, or(l, a.offset)))),\n                or(gt(add(s, result.length), l), gt(offset, l))) { revert(l, 0x00) }\n        }\n    }",
            "startLine": 828
          },
          {
            "name": "checkInCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bytes"
              },
              {
                "name": "a",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function checkInCalldata(bytes calldata x, bytes calldata a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if or(\n                or(lt(x.offset, a.offset), gt(add(x.offset, x.length), add(a.length, a.offset))),\n                shr(64, or(x.length, x.offset))\n            ) { revert(0x00, 0x00) }\n        }\n    }",
            "startLine": 846
          },
          {
            "name": "checkInCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bytes[]"
              },
              {
                "name": "a",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function checkInCalldata(bytes[] calldata x, bytes calldata a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let e := sub(add(a.length, a.offset), 0x20)\n            if or(lt(x.offset, a.offset), shr(64, x.offset)) { revert(0x00, 0x00) }\n            for { let i := 0 } iszero(eq(x.length, i)) { i := add(i, 1) } {\n                let o := calldataload(add(x.offset, shl(5, i)))\n                let t := add(o, x.offset)\n                let l := calldataload(t)\n                if or(shr(64, or(l, o)), gt(add(t, l), e)) { revert(0x00, 0x00) }\n            }\n        }\n    }",
            "startLine": 857
          },
          {
            "name": "emptyCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function emptyCalldata() internal pure returns (bytes calldata result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.length := 0\n        }\n    }",
            "startLine": 872
          },
          {
            "name": "msbToAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function msbToAddress(bytes32 x) internal pure returns (address) {\n        return address(bytes20(x));\n    }",
            "startLine": 880
          },
          {
            "name": "lsbToAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function lsbToAddress(bytes32 x) internal pure returns (address) {\n        return address(uint160(uint256(x)));\n    }",
            "startLine": 885
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "NOT_FOUND",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 27
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibMap",
        "filePath": "utils/g/LibMap.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint8Map"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint8"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(Uint8Map storage map, uint256 index) internal view returns (uint8 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(5, index))\n            result := byte(and(31, not(index)), sload(keccak256(0x00, 0x40)))\n        }\n    }",
            "startLine": 55
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint8Map"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(Uint8Map storage map, uint256 index, uint8 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(5, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            mstore(0x00, sload(s))\n            mstore8(and(31, not(index)), value)\n            sstore(s, mload(0x00))\n        }\n    }",
            "startLine": 65
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint16Map"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint16"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(Uint16Map storage map, uint256 index) internal view returns (uint16 result) {\n        result = uint16(map.map[index >> 4] >> ((index & 15) << 4));\n    }",
            "startLine": 78
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint16Map"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint16"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(Uint16Map storage map, uint256 index, uint16 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(4, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(4, and(index, 15)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }",
            "startLine": 83
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint32Map"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(Uint32Map storage map, uint256 index) internal view returns (uint32 result) {\n        result = uint32(map.map[index >> 3] >> ((index & 7) << 5));\n    }",
            "startLine": 97
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint32Map"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(Uint32Map storage map, uint256 index, uint32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(3, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }",
            "startLine": 102
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint40Map"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint40"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(Uint40Map storage map, uint256 index) internal view returns (uint40 result) {\n        unchecked {\n            result = uint40(map.map[index / 6] >> ((index % 6) * 40));\n        }\n    }",
            "startLine": 116
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint40Map"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint40"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(Uint40Map storage map, uint256 index, uint40 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, div(index, 6))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := mul(40, mod(index, 6)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }",
            "startLine": 123
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint64Map"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint64"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(Uint64Map storage map, uint256 index) internal view returns (uint64 result) {\n        result = uint64(map.map[index >> 2] >> ((index & 3) << 6));\n    }",
            "startLine": 137
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint64Map"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(Uint64Map storage map, uint256 index, uint64 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(2, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(6, and(index, 3)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffffffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }",
            "startLine": 142
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint128Map"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint128"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(Uint128Map storage map, uint256 index) internal view returns (uint128 result) {\n        result = uint128(map.map[index >> 1] >> ((index & 1) << 7));\n    }",
            "startLine": 156
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "Uint128Map"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint128"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(Uint128Map storage map, uint256 index, uint128 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(1, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(7, and(index, 1)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffffffffffffffffffffffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }",
            "startLine": 161
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "mapping(uint256 => uint256)"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "bitWidth",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_rawDiv",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_rawMod",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(mapping(uint256 => uint256) storage map, uint256 index, uint256 bitWidth)\n        internal\n        view\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\n            result = (map[_rawDiv(index, d)] >> (_rawMod(index, d) * bitWidth)) & m;\n        }\n    }",
            "startLine": 175
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "map",
                "type": "mapping(uint256 => uint256)"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "bitWidth",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_rawDiv",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_rawMod",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(\n        mapping(uint256 => uint256) storage map,\n        uint256 index,\n        uint256 value,\n        uint256 bitWidth\n    ) internal {\n        unchecked {\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\n            uint256 o = _rawMod(index, d) * bitWidth; // Storage slot offset (bits).\n            map[_rawDiv(index, d)] ^= (((map[_rawDiv(index, d)] >> o) ^ value) & m) << o;\n        }\n    }",
            "startLine": 188
          },
          {
            "name": "searchSorted",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint8Map"
              },
              {
                "name": "needle",
                "type": "uint8"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "searchSorted",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function searchSorted(Uint8Map storage map, uint8 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 8);\n    }",
            "startLine": 213
          },
          {
            "name": "searchSorted",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint16Map"
              },
              {
                "name": "needle",
                "type": "uint16"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "searchSorted",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function searchSorted(Uint16Map storage map, uint16 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 16);\n    }",
            "startLine": 222
          },
          {
            "name": "searchSorted",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint32Map"
              },
              {
                "name": "needle",
                "type": "uint32"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "searchSorted",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function searchSorted(Uint32Map storage map, uint32 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 32);\n    }",
            "startLine": 231
          },
          {
            "name": "searchSorted",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint40Map"
              },
              {
                "name": "needle",
                "type": "uint40"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "searchSorted",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function searchSorted(Uint40Map storage map, uint40 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 40);\n    }",
            "startLine": 240
          },
          {
            "name": "searchSorted",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint64Map"
              },
              {
                "name": "needle",
                "type": "uint64"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "searchSorted",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function searchSorted(Uint64Map storage map, uint64 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 64);\n    }",
            "startLine": 249
          },
          {
            "name": "searchSorted",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "Uint128Map"
              },
              {
                "name": "needle",
                "type": "uint128"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "searchSorted",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function searchSorted(Uint128Map storage map, uint128 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 128);\n    }",
            "startLine": 258
          },
          {
            "name": "searchSorted",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "map",
                "type": "mapping(uint256 => uint256)"
              },
              {
                "name": "needle",
                "type": "uint256"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              },
              {
                "name": "bitWidth",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "found",
                "type": "bool"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_rawDiv",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_rawMod",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function searchSorted(\n        mapping(uint256 => uint256) storage map,\n        uint256 needle,\n        uint256 start,\n        uint256 end,\n        uint256 bitWidth\n    ) internal view returns (bool found, uint256 index) {\n        unchecked {\n            if (start >= end) end = start;\n            uint256 t;\n            uint256 o = start - 1; // Offset to derive the actual index.\n            uint256 l = 1; // Low.\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\n            uint256 h = end - start; // High.\n            while (true) {\n                index = (l & h) + ((l ^ h) >> 1);\n                if (l > h) break;\n                t = (map[_rawDiv(index + o, d)] >> (_rawMod(index + o, d) * bitWidth)) & m;\n                if (t == needle) break;\n                if (needle <= t) h = index - 1;\n                else l = index + 1;\n            }\n            /// @solidity memory-safe-assembly\n            assembly {\n                m := or(iszero(index), iszero(bitWidth))\n                found := iszero(or(xor(t, needle), m))\n                index := add(o, xor(index, mul(xor(index, 1), m)))\n            }\n        }\n    }",
            "startLine": 267
          },
          {
            "name": "_rawDiv",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _rawDiv(uint256 x, uint256 y) private pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }",
            "startLine": 304
          },
          {
            "name": "_rawMod",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "y",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "z",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _rawMod(uint256 x, uint256 y) private pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }",
            "startLine": 312
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibPRNG",
        "filePath": "utils/g/LibPRNG.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "seed",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              },
              {
                "name": "state",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function seed(PRNG memory prng, uint256 state) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(prng, state)\n        }\n    }",
            "startLine": 66
          },
          {
            "name": "next",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function next(PRNG memory prng) internal pure returns (uint256 result) {\n        // We simply use `keccak256` for a great balance between\n        // runtime gas costs, bytecode size, and statistical properties.\n        //\n        // A high-quality LCG with a 32-byte state\n        // is only about 30% more gas efficient during runtime,\n        // but requires a 32-byte multiplier, which can cause bytecode bloat\n        // when this function is inlined.\n        //\n        // Using this method is about 2x more efficient than\n        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(prng, 0x20)\n            mstore(prng, result)\n        }\n    }",
            "startLine": 75
          },
          {
            "name": "uniform",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              },
              {
                "name": "upper",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := keccak256(prng, 0x20)\n                mstore(prng, result)\n                if iszero(lt(result, mod(sub(0, upper), upper))) { break }\n            }\n            result := mod(result, upper)\n        }\n    }",
            "startLine": 100
          },
          {
            "name": "standardNormalWad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function standardNormalWad(PRNG memory prng) internal pure returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Technically, this is the Irwin-Hall distribution with 20 samples.\n            // The chance of drawing a sample outside 10  from the standard normal distribution\n            // is  0.000000000000000000000015, which is insignificant for most practical purposes.\n            // Passes the Kolmogorov-Smirnov test for 200k samples. Uses about 322 gas.\n            result := keccak256(prng, 0x20)\n            mstore(prng, result)\n            let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\n            let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\n            let m := 0x1fffffffffffffff1fffffffffffffff1fffffffffffffff1fffffffffffffff\n            let s := 0x1000000000000000100000000000000010000000000000001\n            let r1 := mulmod(result, a, n)\n            let r2 := mulmod(r1, a, n)\n            let r3 := mulmod(r2, a, n)\n            // forgefmt: disable-next-item\n            result := sub(sar(96, mul(26614938895861601847173011183,\n                add(add(shr(192, mul(s, add(and(m, result), and(m, r1)))),\n                shr(192, mul(s, add(and(m, r2), and(m, r3))))),\n                shr(192, mul(s, and(m, mulmod(r3, a, n))))))), 7745966692414833770)\n        }\n    }",
            "startLine": 113
          },
          {
            "name": "exponentialWad",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function exponentialWad(PRNG memory prng) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Passes the Kolmogorov-Smirnov test for 200k samples.\n            // Gas usage varies, starting from about 172+ gas.\n            let r := keccak256(prng, 0x20)\n            mstore(prng, r)\n            let p := shl(129, r)\n            let w := shl(1, r)\n            if iszero(gt(w, p)) {\n                let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\n                let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\n                for {} 1 {} {\n                    r := mulmod(r, a, n)\n                    if iszero(lt(shl(129, r), w)) {\n                        r := mulmod(r, a, n)\n                        result := add(1000000000000000000, result)\n                        w := shl(1, r)\n                        p := shl(129, r)\n                        if iszero(lt(w, p)) { break }\n                        continue\n                    }\n                    w := shl(1, r)\n                    if iszero(lt(w, shl(129, r))) { break }\n                }\n            }\n            result := add(div(p, shl(129, 170141183460469231732)), result)\n        }\n    }",
            "startLine": 138
          },
          {
            "name": "shuffle",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              },
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function shuffle(PRNG memory prng, uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a)\n            let w := not(0)\n            let mask := shr(128, w)\n            if n {\n                for { a := add(a, 0x20) } 1 {} {\n                    // We can just directly use `keccak256`, cuz\n                    // the other approaches don't save much.\n                    let r := keccak256(prng, 0x20)\n                    mstore(prng, r)\n\n                    // Note that there will be a very tiny modulo bias\n                    // if the length of the array is not a power of 2.\n                    // For all practical purposes, it is negligible\n                    // and will not be a fairness or security concern.\n                    {\n                        let j := add(a, shl(5, mod(shr(128, r), n)))\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let i := add(a, shl(5, n))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                    }\n\n                    {\n                        let j := add(a, shl(5, mod(and(r, mask), n)))\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let i := add(a, shl(5, n))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                    }\n                }\n            }\n        }\n    }",
            "startLine": 173
          },
          {
            "name": "shuffle",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              },
              {
                "name": "a",
                "type": "int256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "shuffle",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function shuffle(PRNG memory prng, int256[] memory a) internal pure {\n        shuffle(prng, _toUints(a));\n    }",
            "startLine": 217
          },
          {
            "name": "shuffle",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              },
              {
                "name": "a",
                "type": "address[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "shuffle",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function shuffle(PRNG memory prng, address[] memory a) internal pure {\n        shuffle(prng, _toUints(a));\n    }",
            "startLine": 222
          },
          {
            "name": "shuffle",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              },
              {
                "name": "a",
                "type": "uint256[]"
              },
              {
                "name": "k",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function shuffle(PRNG memory prng, uint256[] memory a, uint256 k) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a)\n            k := xor(k, mul(xor(k, n), lt(n, k))) // `min(n, k)`.\n            if k {\n                let mask := shr(128, not(0))\n                let b := 0\n                for { a := add(a, 0x20) } 1 {} {\n                    // We can just directly use `keccak256`, cuz\n                    // the other approaches don't save much.\n                    let r := keccak256(prng, 0x20)\n                    mstore(prng, r)\n\n                    // Note that there will be a very tiny modulo bias\n                    // if the length of the array is not a power of 2.\n                    // For all practical purposes, it is negligible\n                    // and will not be a fairness or security concern.\n                    {\n                        let j := add(a, shl(5, add(b, mod(shr(128, r), sub(n, b)))))\n                        let i := add(a, shl(5, b))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                        b := add(b, 1)\n                        if eq(b, k) { break }\n                    }\n\n                    {\n                        let j := add(a, shl(5, add(b, mod(and(r, mask), sub(n, b)))))\n                        let i := add(a, shl(5, b))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                        b := add(b, 1)\n                        if eq(b, k) { break }\n                    }\n                }\n            }\n        }\n    }",
            "startLine": 228
          },
          {
            "name": "shuffle",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              },
              {
                "name": "a",
                "type": "int256[]"
              },
              {
                "name": "k",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "shuffle",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function shuffle(PRNG memory prng, int256[] memory a, uint256 k) internal pure {\n        shuffle(prng, _toUints(a), k);\n    }",
            "startLine": 272
          },
          {
            "name": "shuffle",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              },
              {
                "name": "a",
                "type": "address[]"
              },
              {
                "name": "k",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "shuffle",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_toUints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function shuffle(PRNG memory prng, address[] memory a, uint256 k) internal pure {\n        shuffle(prng, _toUints(a), k);\n    }",
            "startLine": 278
          },
          {
            "name": "shuffle",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "prng",
                "type": "PRNG"
              },
              {
                "name": "a",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function shuffle(PRNG memory prng, bytes memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a)\n            let w := not(0)\n            let mask := shr(128, w)\n            if n {\n                let b := add(a, 0x01)\n                for { a := add(a, 0x20) } 1 {} {\n                    // We can just directly use `keccak256`, cuz\n                    // the other approaches don't save much.\n                    let r := keccak256(prng, 0x20)\n                    mstore(prng, r)\n\n                    // Note that there will be a very tiny modulo bias\n                    // if the length of the array is not a power of 2.\n                    // For all practical purposes, it is negligible\n                    // and will not be a fairness or security concern.\n                    {\n                        let o := mod(shr(128, r), n)\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let t := mload(add(b, n))\n                        mstore8(add(a, n), mload(add(b, o)))\n                        mstore8(add(a, o), t)\n                    }\n\n                    {\n                        let o := mod(and(r, mask), n)\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let t := mload(add(b, n))\n                        mstore8(add(a, n), mload(add(b, o)))\n                        mstore8(add(a, o), t)\n                    }\n                }\n            }\n        }\n    }",
            "startLine": 283
          },
          {
            "name": "initialize",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "LazyShuffler"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initialize(LazyShuffler storage $, uint256 n) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(sub(n, 1), 0xfffffffe)) {\n                mstore(0x00, 0x83b53941) // `InvalidInitialLazyShufflerLength()`.\n                revert(0x1c, 0x04)\n            }\n            if sload($.slot) {\n                mstore(0x00, 0x0c9f11f2) // `LazyShufflerAlreadyInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, $.slot)\n            sstore($.slot, or(shl(224, n), shl(32, shr(64, keccak256(0x00, 0x20)))))\n        }\n    }",
            "startLine": 333
          },
          {
            "name": "grow",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "LazyShuffler"
              },
              {
                "name": "n",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function grow(LazyShuffler storage $, uint256 n) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot) // The packed value at `$`.\n            // If the new length is smaller than the old length, revert.\n            if lt(n, shr(224, state)) {\n                mstore(0x00, 0xbed37c6e) // `InvalidNewLazyShufflerLength()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(state) {\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            sstore($.slot, or(shl(224, n), shr(32, shl(32, state))))\n        }\n    }",
            "startLine": 351
          },
          {
            "name": "restart",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "LazyShuffler"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function restart(LazyShuffler storage $) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot)\n            if iszero(state) {\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            sstore($.slot, shl(32, shr(32, state)))\n        }\n    }",
            "startLine": 372
          },
          {
            "name": "numShuffled",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "LazyShuffler"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function numShuffled(LazyShuffler storage $) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(0xffffffff, sload($.slot))\n        }\n    }",
            "startLine": 385
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "LazyShuffler"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function length(LazyShuffler storage $) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(224, sload($.slot))\n        }\n    }",
            "startLine": 394
          },
          {
            "name": "initialized",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "LazyShuffler"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initialized(LazyShuffler storage $) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(iszero(sload($.slot)))\n        }\n    }",
            "startLine": 402
          },
          {
            "name": "finished",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "LazyShuffler"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function finished(LazyShuffler storage $) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot) // The packed value at `$`.\n            if iszero(state) {\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            result := eq(shr(224, state), and(0xffffffff, state))\n        }\n    }",
            "startLine": 411
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "LazyShuffler"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(LazyShuffler storage $, uint256 index) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot) // The packed value at `$`.\n            let n := shr(224, state) // Length of `$`.\n            if iszero(lt(index, n)) {\n                mstore(0x00, 0x61367cc4) // `LazyShufflerGetOutOfBounds()`.\n                revert(0x1c, 0x04)\n            }\n            let u32 := gt(n, 0xfffe)\n            let s := add(shr(sub(4, u32), index), shr(64, shl(32, state))) // Bucket slot.\n            let o := shl(add(4, u32), and(index, shr(u32, 15))) // Bucket slot offset (bits).\n            let m := sub(shl(shl(u32, 16), 1), 1) // Value mask.\n            result := and(m, shr(o, sload(s)))\n            result := xor(index, mul(xor(index, sub(result, 1)), iszero(iszero(result))))\n        }\n    }",
            "startLine": 425
          },
          {
            "name": "next",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "LazyShuffler"
              },
              {
                "name": "randomness",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "chosen",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function next(LazyShuffler storage $, uint256 randomness) internal returns (uint256 chosen) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function _get(u32_, state_, i_) -> _value {\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\n                _value := and(m_, shr(o_, sload(s_)))\n                _value := xor(i_, mul(xor(i_, sub(_value, 1)), iszero(iszero(_value))))\n            }\n            function _set(u32_, state_, i_, value_) {\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\n                let v_ := sload(s_) // Bucket slot value.\n                value_ := mul(iszero(eq(i_, value_)), add(value_, 1))\n                sstore(s_, xor(v_, shl(o_, and(m_, xor(shr(o_, v_), value_)))))\n            }\n            let state := sload($.slot) // The packed value at `$`.\n            let shuffled := and(0xffffffff, state) // Number of elements shuffled.\n            let n := shr(224, state) // Length of `$`.\n            let remainder := sub(n, shuffled) // Number of elements left to shuffle.\n            if iszero(remainder) {\n                mstore(0x00, 0x51065f79) // `LazyShuffleFinished()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, randomness) // (Re)hash the randomness so that we don't\n            mstore(0x20, shuffled) // need to expect guarantees on its distribution.\n            let index := add(mod(keccak256(0x00, 0x40), remainder), shuffled)\n            chosen := _get(gt(n, 0xfffe), state, index)\n            _set(gt(n, 0xfffe), state, index, _get(gt(n, 0xfffe), state, shuffled))\n            _set(gt(n, 0xfffe), state, shuffled, chosen)\n            sstore($.slot, add(1, state)) // Increment the `numShuffled` by 1, and store it.\n        }\n    }",
            "startLine": 447
          },
          {
            "name": "_toUints",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "int256[]"
              }
            ],
            "returnValues": [
              {
                "name": "casted",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toUints(int256[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }",
            "startLine": 488
          },
          {
            "name": "_toUints",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "address[]"
              }
            ],
            "returnValues": [
              {
                "name": "casted",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _toUints(address[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // As any address written to memory will have the upper 96 bits\n            // of the word zeroized (as per Solidity spec), we can directly\n            // compare these addresses as if they are whole uint256 words.\n            casted := a\n        }\n    }",
            "startLine": 496
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "InvalidInitialLazyShufflerLength",
            "parameters": [],
            "startLine": 37
          },
          {
            "name": "InvalidNewLazyShufflerLength",
            "parameters": [],
            "startLine": 40
          },
          {
            "name": "LazyShufflerNotInitialized",
            "parameters": [],
            "startLine": 43
          },
          {
            "name": "LazyShufflerAlreadyInitialized",
            "parameters": [],
            "startLine": 46
          },
          {
            "name": "LazyShuffleFinished",
            "parameters": [],
            "startLine": 49
          },
          {
            "name": "LazyShufflerGetOutOfBounds",
            "parameters": [],
            "startLine": 52
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "WAD",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 59
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibRLP",
        "filePath": "utils/g/LibRLP.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "computeAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "deployer",
                "type": "address"
              },
              {
                "name": "nonce",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "deployed",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function computeAddress(address deployer, uint256 nonce)\n        internal\n        pure\n        returns (address deployed)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                // The integer zero is treated as an empty byte string,\n                // and as a result it only has a length prefix, 0x80,\n                // computed via `0x80 + 0`.\n\n                // A one-byte integer in the [0x00, 0x7f] range uses its\n                // own value as a length prefix,\n                // there is no additional `0x80 + length` prefix that precedes it.\n                if iszero(gt(nonce, 0x7f)) {\n                    mstore(0x00, deployer)\n                    // Using `mstore8` instead of `or` naturally cleans\n                    // any dirty upper bits of `deployer`.\n                    mstore8(0x0b, 0x94)\n                    mstore8(0x0a, 0xd6)\n                    // `shl` 7 is equivalent to multiplying by 0x80.\n                    mstore8(0x20, or(shl(7, iszero(nonce)), nonce))\n                    deployed := keccak256(0x0a, 0x17)\n                    break\n                }\n                let i := 8\n                // Just use a loop to generalize all the way with minimal bytecode size.\n                for {} shr(i, nonce) { i := add(i, 8) } {}\n                // `shr` 3 is equivalent to dividing by 8.\n                i := shr(3, i)\n                // Store in descending slot sequence to overlap the values correctly.\n                mstore(i, nonce)\n                mstore(0x00, shl(8, deployer))\n                mstore8(0x1f, add(0x80, i))\n                mstore8(0x0a, 0x94)\n                mstore8(0x09, add(0xd6, i))\n                deployed := keccak256(0x09, add(0x17, i))\n                break\n            }\n        }\n    }",
            "startLine": 50
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function p() internal pure returns (List memory result) {}",
            "startLine": 105
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(uint256 x) internal pure returns (List memory result) {\n        p(result, x);\n    }",
            "startLine": 108
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(address x) internal pure returns (List memory result) {\n        p(result, x);\n    }",
            "startLine": 113
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(bool x) internal pure returns (List memory result) {\n        p(result, x);\n    }",
            "startLine": 118
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(bytes memory x) internal pure returns (List memory result) {\n        p(result, x);\n    }",
            "startLine": 123
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "List"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "p",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(List memory x) internal pure returns (List memory result) {\n        p(result, x);\n    }",
            "startLine": 128
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "list",
                "type": "List"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "_updateTail",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(List memory list, uint256 x) internal pure returns (List memory result) {\n        result._data = x << 48;\n        _updateTail(list, result);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If `x` is too big, we cannot pack it inline with the node.\n            // We'll have to allocate a new slot for `x` and store the pointer to it in the node.\n            if shr(208, x) {\n                let m := mload(0x40)\n                mstore(m, x)\n                mstore(0x40, add(m, 0x20))\n                mstore(result, shl(40, or(1, shl(8, m))))\n            }\n        }\n        result = list;\n    }",
            "startLine": 133
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "list",
                "type": "List"
              },
              {
                "name": "x",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "_updateTail",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(List memory list, address x) internal pure returns (List memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, shl(40, or(4, shl(8, x))))\n        }\n        _updateTail(list, result);\n        result = list;\n    }",
            "startLine": 151
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "list",
                "type": "List"
              },
              {
                "name": "x",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "_updateTail",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(List memory list, bool x) internal pure returns (List memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, shl(48, iszero(iszero(x))))\n        }\n        _updateTail(list, result);\n        result = list;\n    }",
            "startLine": 161
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "list",
                "type": "List"
              },
              {
                "name": "x",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "_updateTail",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(List memory list, bytes memory x) internal pure returns (List memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, shl(40, or(2, shl(8, x))))\n        }\n        _updateTail(list, result);\n        result = list;\n    }",
            "startLine": 171
          },
          {
            "name": "p",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "list",
                "type": "List"
              },
              {
                "name": "x",
                "type": "List"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "List"
              }
            ],
            "calls": [
              {
                "target": "_updateTail",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function p(List memory list, List memory x) internal pure returns (List memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, shl(40, or(3, shl(8, x))))\n        }\n        _updateTail(list, result);\n        result = list;\n    }",
            "startLine": 181
          },
          {
            "name": "encode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "list",
                "type": "List"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function encode(List memory list) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function encodeUint(x_, o_) -> _o {\n                _o := add(o_, 1)\n                if iszero(gt(x_, 0x7f)) {\n                    mstore8(o_, or(shl(7, iszero(x_)), x_)) // Copy `x_`.\n                    leave\n                }\n                let r_ := shl(7, lt(0xffffffffffffffffffffffffffffffff, x_))\n                r_ := or(r_, shl(6, lt(0xffffffffffffffff, shr(r_, x_))))\n                r_ := or(r_, shl(5, lt(0xffffffff, shr(r_, x_))))\n                r_ := or(r_, shl(4, lt(0xffff, shr(r_, x_))))\n                r_ := or(shr(3, r_), lt(0xff, shr(r_, x_)))\n                mstore8(o_, add(r_, 0x81)) // Store the prefix.\n                mstore(0x00, x_)\n                mstore(_o, mload(xor(31, r_))) // Copy `x_`.\n                _o := add(add(1, r_), _o)\n            }\n            function encodeAddress(x_, o_) -> _o {\n                _o := add(o_, 0x15)\n                mstore(o_, shl(88, x_))\n                mstore8(o_, 0x94)\n            }\n            function encodeBytes(x_, o_, c_) -> _o {\n                _o := add(o_, 1)\n                let n_ := mload(x_)\n                if iszero(gt(n_, 55)) {\n                    let f_ := mload(add(0x20, x_))\n                    if iszero(and(eq(1, n_), lt(byte(0, f_), 0x80))) {\n                        mstore8(o_, add(n_, c_)) // Store the prefix.\n                        mstore(add(0x21, o_), mload(add(0x40, x_)))\n                        mstore(_o, f_)\n                        _o := add(n_, _o)\n                        leave\n                    }\n                    mstore(o_, f_) // Copy `x_`.\n                    leave\n                }\n                returndatacopy(returndatasize(), returndatasize(), shr(32, n_))\n                let r_ := add(1, add(lt(0xff, n_), add(lt(0xffff, n_), lt(0xffffff, n_))))\n                mstore(o_, shl(248, add(r_, add(c_, 55)))) // Store the prefix.\n                // Copy `x`.\n                let i_ := add(r_, _o)\n                _o := add(i_, n_)\n                for { let d_ := sub(add(0x20, x_), i_) } 1 {} {\n                    mstore(i_, mload(add(d_, i_)))\n                    i_ := add(i_, 0x20)\n                    if iszero(lt(i_, _o)) { break }\n                }\n                mstore(o_, or(mload(o_), shl(sub(248, shl(3, r_)), n_))) // Store the prefix.\n            }\n            function encodeList(l_, o_) -> _o {\n                if iszero(mload(l_)) {\n                    mstore8(o_, 0xc0)\n                    _o := add(o_, 1)\n                    leave\n                }\n                let j_ := add(o_, 0x20)\n                for { let h_ := l_ } 1 {} {\n                    h_ := and(mload(h_), 0xffffffffff)\n                    if iszero(h_) { break }\n                    let t_ := byte(26, mload(h_))\n                    if iszero(gt(t_, 1)) {\n                        if iszero(t_) {\n                            j_ := encodeUint(shr(48, mload(h_)), j_)\n                            continue\n                        }\n                        j_ := encodeUint(mload(shr(48, mload(h_))), j_)\n                        continue\n                    }\n                    if eq(t_, 2) {\n                        j_ := encodeBytes(shr(48, mload(h_)), j_, 0x80)\n                        continue\n                    }\n                    if eq(t_, 3) {\n                        j_ := encodeList(shr(48, mload(h_)), j_)\n                        continue\n                    }\n                    j_ := encodeAddress(shr(48, mload(h_)), j_)\n                }\n                let n_ := sub(j_, add(o_, 0x20))\n                if iszero(gt(n_, 55)) {\n                    mstore8(o_, add(n_, 0xc0)) // Store the prefix.\n                    mstore(add(0x01, o_), mload(add(0x20, o_)))\n                    mstore(add(0x21, o_), mload(add(0x40, o_)))\n                    _o := add(n_, add(0x01, o_))\n                    leave\n                }\n                mstore(o_, n_)\n                _o := encodeBytes(o_, o_, 0xc0)\n            }\n            result := mload(0x40)\n            let begin := add(result, 0x20)\n            let end := encodeList(list, begin)\n            mstore(result, sub(end, begin)) // Store the length of `result`.\n            mstore(end, 0) // Zeroize the slot after `result`.\n            mstore(0x40, add(end, 0x20)) // Allocate memory for `result`.\n        }\n    }",
            "startLine": 191
          },
          {
            "name": "encode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function encode(uint256 x) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := mload(0x40)\n                if iszero(gt(x, 0x7f)) {\n                    mstore(result, 1) // Store the length of `result`.\n                    mstore(add(result, 0x20), shl(248, or(shl(7, iszero(x)), x))) // Copy `x`.\n                    mstore(0x40, add(result, 0x40)) // Allocate memory for `result`.\n                    break\n                }\n                let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n                r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n                r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n                r := or(r, shl(4, lt(0xffff, shr(r, x))))\n                r := add(2, or(shr(3, r), lt(0xff, shr(r, x))))\n                mstore(add(r, result), x) // Copy `x`.\n                mstore(add(result, 1), add(r, 0x7f)) // Store the prefix.\n                mstore(result, r) // Store the length of `result`.\n                mstore(add(r, add(result, 0x20)), 0) // Zeroize the slot after `result`.\n                mstore(0x40, add(result, 0x60)) // Allocate memory for `result`.\n                break\n            }\n        }\n    }",
            "startLine": 293
          },
          {
            "name": "encode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function encode(address x) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(result, 0x15)\n            let o := add(0x20, result)\n            mstore(o, shl(88, x))\n            mstore8(o, 0x94)\n            mstore(0x40, add(0x20, o))\n        }\n    }",
            "startLine": 320
          },
          {
            "name": "encode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function encode(bool x) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(result, 1)\n            mstore(add(0x20, result), shl(add(0xf8, mul(7, iszero(x))), 0x01))\n            mstore(0x40, add(0x40, result))\n        }\n    }",
            "startLine": 333
          },
          {
            "name": "encode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "x",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function encode(bytes memory x) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := x\n\n            for {} iszero(and(eq(1, mload(x)), lt(byte(0, mload(add(x, 0x20))), 0x80))) {} {\n                result := mload(0x40)\n                let n := mload(x) // Length of `x`.\n                if iszero(gt(n, 55)) {\n                    mstore(0x40, add(result, 0x60))\n                    mstore(add(0x41, result), mload(add(0x40, x)))\n                    mstore(add(0x21, result), mload(add(0x20, x)))\n                    mstore(add(1, result), add(n, 0x80)) // Store the prefix.\n                    mstore(result, add(1, n)) // Store the length of `result`.\n                    mstore(add(add(result, 0x21), n), 0) // Zeroize the slot after `result`.\n                    break\n                }\n                returndatacopy(returndatasize(), returndatasize(), shr(32, n))\n                let r := add(2, add(lt(0xff, n), add(lt(0xffff, n), lt(0xffffff, n))))\n                // Copy `x`.\n                let i := add(r, add(0x20, result))\n                let end := add(i, n)\n                for { let d := sub(add(0x20, x), i) } 1 {} {\n                    mstore(i, mload(add(d, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, end)) { break }\n                }\n                mstore(add(r, result), n) // Store the prefix.\n                mstore(add(1, result), add(r, 0xb6)) // Store the prefix.\n                mstore(result, add(r, n)) // Store the length of `result`.\n                mstore(end, 0) // Zeroize the slot after `result`.\n                mstore(0x40, add(end, 0x20)) // Allocate memory.\n                break\n            }\n        }\n    }",
            "startLine": 344
          },
          {
            "name": "_updateTail",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "list",
                "type": "List"
              },
              {
                "name": "result",
                "type": "List"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _updateTail(List memory list, List memory result) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let v := or(shr(mload(list), result), mload(list))\n            let tail := shr(40, v)\n            mstore(list, xor(shl(40, xor(tail, result)), v)) // Update the tail.\n            mstore(tail, or(mload(tail), result)) // Make the previous tail point to `result`.\n        }\n    }",
            "startLine": 386
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibStorage",
        "filePath": "utils/g/LibStorage.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "slot",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "b",
                "type": "Bump"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function slot(Bump storage b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1f, sload(b.slot))\n            mstore(0x04, _BUMPED_STORAGE_REF_SLOT_SEED)\n            mstore(0x00, b.slot)\n            result := keccak256(0x00, 0x3f)\n        }\n    }",
            "startLine": 42
          },
          {
            "name": "invalidate",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "b",
                "type": "Bump"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function invalidate(Bump storage b) internal {\n        unchecked {\n            ++b._current;\n        }\n    }",
            "startLine": 53
          },
          {
            "name": "bump",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "sSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "$",
                "type": "Bump"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function bump(bytes32 sSlot) internal pure returns (Bump storage $) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            $.slot := sSlot\n        }\n    }",
            "startLine": 60
          },
          {
            "name": "bump",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "sSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "$",
                "type": "Bump"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function bump(uint256 sSlot) internal pure returns (Bump storage $) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            $.slot := sSlot\n        }\n    }",
            "startLine": 68
          },
          {
            "name": "ref",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "sSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "$",
                "type": "Ref"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function ref(bytes32 sSlot) internal pure returns (Ref storage $) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            $.slot := sSlot\n        }\n    }",
            "startLine": 76
          },
          {
            "name": "ref",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "sSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "$",
                "type": "Ref"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function ref(uint256 sSlot) internal pure returns (Ref storage $) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            $.slot := sSlot\n        }\n    }",
            "startLine": 84
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "_BUMPED_STORAGE_REF_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 34
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibString",
        "filePath": "utils/g/LibString.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "StringStorage"
              },
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "LibBytes.set",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "bytesStorage",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function set(StringStorage storage $, string memory s) internal {\n        LibBytes.set(bytesStorage($), bytes(s));\n    }",
            "startLine": 86
          },
          {
            "name": "setCalldata",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "StringStorage"
              },
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "LibBytes.setCalldata",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "bytesStorage",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function setCalldata(StringStorage storage $, string calldata s) internal {\n        LibBytes.setCalldata(bytesStorage($), bytes(s));\n    }",
            "startLine": 91
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "$",
                "type": "StringStorage"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clear(StringStorage storage $) internal {\n        delete $._spacer;\n    }",
            "startLine": 96
          },
          {
            "name": "isEmpty",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "StringStorage"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isEmpty(StringStorage storage $) internal view returns (bool) {\n        return uint256($._spacer) & 0xff == uint256(0);\n    }",
            "startLine": 101
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "StringStorage"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.length",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "bytesStorage",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function length(StringStorage storage $) internal view returns (uint256) {\n        return LibBytes.length(bytesStorage($));\n    }",
            "startLine": 106
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "StringStorage"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.get",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "bytesStorage",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function get(StringStorage storage $) internal view returns (string memory) {\n        return string(LibBytes.get(bytesStorage($)));\n    }",
            "startLine": 111
          },
          {
            "name": "uint8At",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "$",
                "type": "StringStorage"
              },
              {
                "name": "i",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.uint8At",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "bytesStorage",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function uint8At(StringStorage storage $, uint256 i) internal view returns (uint8) {\n        return LibBytes.uint8At(bytesStorage($), i);\n    }",
            "startLine": 116
          },
          {
            "name": "bytesStorage",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "$",
                "type": "StringStorage"
              }
            ],
            "returnValues": [
              {
                "name": "casted",
                "type": "LibBytes.BytesStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function bytesStorage(StringStorage storage $)\n        internal\n        pure\n        returns (LibBytes.BytesStorage storage casted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted.slot := $.slot\n        }\n    }",
            "startLine": 121
          },
          {
            "name": "toString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toString(uint256 value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            result := add(mload(0x40), 0x80)\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end of the memory to calculate the length later.\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                result := add(result, w) // `sub(result, 1)`.\n                // Store the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(result, add(48, mod(temp, 10)))\n                temp := div(temp, 10) // Keep dividing `temp` until zero.\n                if iszero(temp) { break }\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20) // Move the pointer 32 bytes back to make room for the length.\n            mstore(result, n) // Store the length.\n        }\n    }",
            "startLine": 137
          },
          {
            "name": "toString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toString",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function toString(int256 value) internal pure returns (string memory result) {\n        if (value >= 0) return toString(uint256(value));\n        unchecked {\n            result = toString(~uint256(value) + 1);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let n := mload(result) // Load the string length.\n            mstore(result, 0x2d) // Store the '-' character.\n            result := sub(result, 1) // Move back the string pointer by a byte.\n            mstore(result, add(n, 1)) // Update the string length.\n        }\n    }",
            "startLine": 167
          },
          {
            "name": "toHexString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "byteCount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toHexStringNoPrefix",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function toHexString(uint256 value, uint256 byteCount)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = toHexStringNoPrefix(value, byteCount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }",
            "startLine": 192
          },
          {
            "name": "toHexStringNoPrefix",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "byteCount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toHexStringNoPrefix(uint256 value, uint256 byteCount)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `byteCount * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            result := add(mload(0x40), and(add(shl(1, byteCount), 0x42), not(0x1f)))\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end to calculate the length later.\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(result, add(byteCount, byteCount))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                result := add(result, w) // `sub(result, 2)`.\n                mstore8(add(result, 1), mload(and(temp, 15)))\n                mstore8(result, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(result, start)) { break }\n            }\n            if temp {\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\n                revert(0x1c, 0x04)\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20)\n            mstore(result, n) // Store the length.\n        }\n    }",
            "startLine": 212
          },
          {
            "name": "toHexString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toHexStringNoPrefix",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function toHexString(uint256 value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }",
            "startLine": 257
          },
          {
            "name": "toMinimalHexString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toHexStringNoPrefix",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function toMinimalHexString(uint256 value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(add(result, o), 0x3078) // Store the \"0x\" prefix, accounting for leading zero.\n            result := sub(add(result, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.\n        }\n    }",
            "startLine": 272
          },
          {
            "name": "toMinimalHexStringNoPrefix",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toHexStringNoPrefix",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function toMinimalHexStringNoPrefix(uint256 value)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.\n            let n := mload(result) // Get the length.\n            result := add(result, o) // Move the pointer, accounting for leading zero.\n            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.\n        }\n    }",
            "startLine": 287
          },
          {
            "name": "toHexStringNoPrefix",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toHexStringNoPrefix(uint256 value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            result := add(mload(0x40), 0x80)\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end to calculate the length later.\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                result := add(result, w) // `sub(result, 2)`.\n                mstore8(add(result, 1), mload(and(temp, 15)))\n                mstore8(result, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20)\n            mstore(result, n) // Store the length.\n        }\n    }",
            "startLine": 306
          },
          {
            "name": "toHexStringChecksummed",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toHexString",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function toHexStringChecksummed(address value) internal pure returns (string memory result) {\n        result = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(result, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }",
            "startLine": 339
          },
          {
            "name": "toHexString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toHexStringNoPrefix",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function toHexString(address value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }",
            "startLine": 360
          },
          {
            "name": "toHexStringNoPrefix",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toHexStringNoPrefix(address value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            // Allocate memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(result, 0x80))\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n\n            result := add(result, 2)\n            mstore(result, 40) // Store the length.\n            let o := add(result, 0x20)\n            mstore(add(o, 40), 0) // Zeroize the slot after the string.\n            value := shl(96, value)\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }",
            "startLine": 373
          },
          {
            "name": "toHexString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "raw",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toHexStringNoPrefix",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function toHexString(bytes memory raw) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }",
            "startLine": 404
          },
          {
            "name": "toHexStringNoPrefix",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "raw",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(raw)\n            result := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(result, add(n, n)) // Store the length of the output.\n\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n            let o := add(result, 0x20)\n            let end := add(raw, n)\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }",
            "startLine": 417
          },
          {
            "name": "runeCount",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }",
            "startLine": 443
          },
          {
            "name": "is7BitASCII",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            let mask := shl(7, div(not(0), 255))\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }",
            "startLine": 461
          },
          {
            "name": "is7BitASCII",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              },
              {
                "name": "allowed",
                "type": "uint128"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function is7BitASCII(string memory s, uint128 allowed) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if mload(s) {\n                let allowed_ := shr(128, shl(128, allowed))\n                let o := add(s, 0x20)\n                for { let end := add(o, mload(s)) } 1 {} {\n                    result := and(result, shr(byte(0, mload(o)), allowed_))\n                    o := add(o, 1)\n                    if iszero(and(result, lt(o, end))) { break }\n                }\n            }\n        }\n    }",
            "startLine": 488
          },
          {
            "name": "to7BitASCIIAllowedLookup",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint128"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function to7BitASCIIAllowedLookup(string memory s) internal pure returns (uint128 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                let o := add(s, 0x20)\n                for { let end := add(o, mload(s)) } 1 {} {\n                    result := or(result, shl(byte(0, mload(o)), 1))\n                    o := add(o, 1)\n                    if iszero(lt(o, end)) { break }\n                }\n                if shr(128, result) {\n                    mstore(0x00, 0xc9807e0d) // `StringNot7BitASCII()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "startLine": 507
          },
          {
            "name": "replace",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "needle",
                "type": "string"
              },
              {
                "name": "replacement",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.replace",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function replace(string memory subject, string memory needle, string memory replacement)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string(LibBytes.replace(bytes(subject), bytes(needle), bytes(replacement)));\n    }",
            "startLine": 535
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "needle",
                "type": "string"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.indexOf",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(string memory subject, string memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.indexOf(bytes(subject), bytes(needle), from);\n    }",
            "startLine": 546
          },
          {
            "name": "indexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "needle",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.indexOf",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indexOf(string memory subject, string memory needle) internal pure returns (uint256) {\n        return LibBytes.indexOf(bytes(subject), bytes(needle), 0);\n    }",
            "startLine": 557
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "needle",
                "type": "string"
              },
              {
                "name": "from",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.lastIndexOf",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(string memory subject, string memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.lastIndexOf(bytes(subject), bytes(needle), from);\n    }",
            "startLine": 564
          },
          {
            "name": "lastIndexOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "needle",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.lastIndexOf",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lastIndexOf(string memory subject, string memory needle)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.lastIndexOf(bytes(subject), bytes(needle), type(uint256).max);\n    }",
            "startLine": 575
          },
          {
            "name": "contains",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "needle",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.contains",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function contains(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.contains(bytes(subject), bytes(needle));\n    }",
            "startLine": 584
          },
          {
            "name": "startsWith",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "needle",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.startsWith",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function startsWith(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.startsWith(bytes(subject), bytes(needle));\n    }",
            "startLine": 589
          },
          {
            "name": "endsWith",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "needle",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.endsWith",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function endsWith(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.endsWith(bytes(subject), bytes(needle));\n    }",
            "startLine": 594
          },
          {
            "name": "repeat",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "times",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.repeat",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function repeat(string memory subject, uint256 times) internal pure returns (string memory) {\n        return string(LibBytes.repeat(bytes(subject), times));\n    }",
            "startLine": 599
          },
          {
            "name": "slice",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "start",
                "type": "uint256"
              },
              {
                "name": "end",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.slice",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string(LibBytes.slice(bytes(subject), start, end));\n    }",
            "startLine": 605
          },
          {
            "name": "slice",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "start",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.slice",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function slice(string memory subject, uint256 start) internal pure returns (string memory) {\n        return string(LibBytes.slice(bytes(subject), start, type(uint256).max));\n    }",
            "startLine": 615
          },
          {
            "name": "indicesOf",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "needle",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.indicesOf",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function indicesOf(string memory subject, string memory needle)\n        internal\n        pure\n        returns (uint256[] memory)\n    {\n        return LibBytes.indicesOf(bytes(subject), bytes(needle));\n    }",
            "startLine": 621
          },
          {
            "name": "split",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "delimiter",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string[]"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.split",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        bytes[] memory a = LibBytes.split(bytes(subject), bytes(delimiter));\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "startLine": 630
          },
          {
            "name": "concat",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "string"
              },
              {
                "name": "b",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.concat",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function concat(string memory a, string memory b) internal pure returns (string memory) {\n        return string(LibBytes.concat(bytes(a), bytes(b)));\n    }",
            "startLine": 644
          },
          {
            "name": "toCase",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              },
              {
                "name": "toUpper",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(subject)\n            if n {\n                result := mload(0x40)\n                let o := add(result, 0x20)\n                let d := sub(subject, result)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                for { let end := add(o, n) } 1 {} {\n                    let b := byte(0, mload(add(d, o)))\n                    mstore8(o, xor(and(shr(b, flags), 0x20), b))\n                    o := add(o, 1)\n                    if eq(o, end) { break }\n                }\n                mstore(result, n) // Store the length.\n                mstore(o, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n            }\n        }\n    }",
            "startLine": 650
          },
          {
            "name": "fromSmallString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function fromSmallString(bytes32 s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := 0\n            for {} // Scan for '\\0'.\n             byte(n, s) { n := add(n, 1) } {}\n            mstore(result, n) // Store the length.\n            let o := add(result, 0x20)\n            mstore(o, s) // Store the bytes of the string.\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\n            mstore(0x40, add(result, 0x40)) // Allocate memory.\n        }\n    }",
            "startLine": 678
          },
          {
            "name": "normalizeSmallString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} // Scan for '\\0'.\n             byte(result, s) { result := add(result, 1) } {}\n            mstore(0x00, s)\n            mstore(result, 0x00)\n            result := mload(0x00)\n        }\n    }",
            "startLine": 694
          },
          {
            "name": "toSmallString",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function toSmallString(string memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(s)\n            if iszero(lt(result, 33)) {\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\n                revert(0x1c, 0x04)\n            }\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\n        }\n    }",
            "startLine": 706
          },
          {
            "name": "lower",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toCase",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }",
            "startLine": 720
          },
          {
            "name": "upper",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "subject",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "toCase",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }",
            "startLine": 726
          },
          {
            "name": "escapeHTML",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let end := add(s, mload(s))\n            let o := add(result, 0x20)\n            // Store the bytes of the packed offsets and strides into the scratch space.\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n            mstore(0x1f, 0x900094)\n            mstore(0x08, 0xc0000000a6ab)\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(o, c)\n                    o := add(o, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(o, mload(and(t, 0x1f)))\n                o := add(o, shr(5, t))\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }",
            "startLine": 731
          },
          {
            "name": "escapeJSON",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              },
              {
                "name": "addDoubleQuotes",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function escapeJSON(string memory s, bool addDoubleQuotes)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            if addDoubleQuotes {\n                mstore8(o, 34)\n                o := add(1, o)\n            }\n            // Store \"\\\\u0000\" in scratch space.\n            // Store \"0123456789abcdef\" in scratch space.\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n            // into the scratch space.\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\n            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(o, c)\n                        o := add(o, 1)\n                        continue\n                    }\n                    mstore8(o, 0x5c) // \"\\\\\".\n                    mstore8(add(o, 1), c)\n                    o := add(o, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(o, mload(0x19)) // \"\\\\u00XX\".\n                    o := add(o, 6)\n                    continue\n                }\n                mstore8(o, 0x5c) // \"\\\\\".\n                mstore8(add(o, 1), mload(add(c, 8)))\n                o := add(o, 2)\n            }\n            if addDoubleQuotes {\n                mstore8(o, 34)\n                o := add(1, o)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }",
            "startLine": 764
          },
          {
            "name": "escapeJSON",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "escapeJSON",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function escapeJSON(string memory s) internal pure returns (string memory result) {\n        result = escapeJSON(s, false);\n    }",
            "startLine": 822
          },
          {
            "name": "encodeURIComponent",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "s",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function encodeURIComponent(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            // Store \"0123456789ABCDEF\" in scratch space.\n            // Uppercased to be consistent with JavaScript's implementation.\n            mstore(0x0f, 0x30313233343536373839414243444546)\n            let o := add(result, 0x20)\n            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // If not in `[0-9A-Z-a-z-_.!~*'()]`.\n                if iszero(and(1, shr(c, 0x47fffffe87fffffe03ff678200000000))) {\n                    mstore8(o, 0x25) // '%'.\n                    mstore8(add(o, 1), mload(and(shr(4, c), 15)))\n                    mstore8(add(o, 2), mload(and(c, 15)))\n                    o := add(o, 3)\n                    continue\n                }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }",
            "startLine": 831
          },
          {
            "name": "eq",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "string"
              },
              {
                "name": "b",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function eq(string memory a, string memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }",
            "startLine": 860
          },
          {
            "name": "eqs",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "string"
              },
              {
                "name": "b",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }",
            "startLine": 868
          },
          {
            "name": "cmp",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "string"
              },
              {
                "name": "b",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "LibBytes.cmp",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function cmp(string memory a, string memory b) internal pure returns (int256) {\n        return LibBytes.cmp(bytes(a), bytes(b));\n    }",
            "startLine": 887
          },
          {
            "name": "packOne",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result := mul(\n                // Load the length and the bytes.\n                mload(add(a, 0x1f)),\n                // `length != 0 && length < 32`. Abuses underflow.\n                // Assumes that the length is valid and within the block gas limit.\n                lt(sub(mload(a), 1), 0x1f)\n            )\n        }\n    }",
            "startLine": 893
          },
          {
            "name": "unpackOne",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "packed",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer.\n            mstore(0x40, add(result, 0x40)) // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(result, 0) // Zeroize the length slot.\n            mstore(add(result, 0x1f), packed) // Store the length and bytes.\n            mstore(add(add(result, 0x20), mload(result)), 0) // Right pad with zeroes.\n        }\n    }",
            "startLine": 911
          },
          {
            "name": "packTwo",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "string"
              },
              {
                "name": "b",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLen := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result := mul(\n                or( // Load the length and the bytes of `a` and `b`.\n                    shl(shl(3, sub(0x1f, aLen)), mload(add(a, aLen))),\n                    shr(shl(3, add(aLen, 1)), mload(add(b, 0x1f)))\n                ),\n                // `totalLen != 0 && totalLen < 31`. Abuses underflow.\n                // Assumes that the lengths are valid and within the block gas limit.\n                lt(sub(add(aLen, mload(b)), 1), 0x1e)\n            )\n        }\n    }",
            "startLine": 924
          },
          {
            "name": "unpackTwo",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "packed",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "resultA",
                "type": "string"
              },
              {
                "name": "resultB",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            resultA := mload(0x40) // Grab the free memory pointer.\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }",
            "startLine": 945
          },
          {
            "name": "directReturn",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function directReturn(string memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the string.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }",
            "startLine": 969
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "HexLengthInsufficient",
            "parameters": [],
            "startLine": 36
          },
          {
            "name": "TooBigForSmallString",
            "parameters": [],
            "startLine": 39
          },
          {
            "name": "StringNot7BitASCII",
            "parameters": [],
            "startLine": 42
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "NOT_FOUND",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 49
          },
          {
            "name": "ALPHANUMERIC_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 52
          },
          {
            "name": "LETTERS_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 55
          },
          {
            "name": "LOWERCASE_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 58
          },
          {
            "name": "UPPERCASE_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 61
          },
          {
            "name": "DIGITS_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 64
          },
          {
            "name": "HEXDIGITS_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 67
          },
          {
            "name": "OCTDIGITS_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 70
          },
          {
            "name": "PRINTABLE_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 73
          },
          {
            "name": "PUNCTUATION_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 76
          },
          {
            "name": "WHITESPACE_7_BIT_ASCII",
            "type": "uint128",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 79
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../LibBytes.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "LibTransient",
        "filePath": "utils/g/LibTransient.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "tUint256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tUint256(bytes32 tSlot) internal pure returns (TUint256 storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 91
          },
          {
            "name": "tUint256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tUint256(uint256 tSlot) internal pure returns (TUint256 storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 99
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(TUint256 storage ptr) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := tload(ptr.slot)\n        }\n    }",
            "startLine": 107
          },
          {
            "name": "getCompat",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function getCompat(TUint256 storage ptr) internal view returns (uint256 result) {\n        result = block.chainid == 1 ? get(ptr) : _compat(ptr)._spacer;\n    }",
            "startLine": 115
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(TUint256 storage ptr, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, value)\n        }\n    }",
            "startLine": 120
          },
          {
            "name": "setCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function setCompat(TUint256 storage ptr, uint256 value) internal {\n        if (block.chainid == 1) return set(ptr, value);\n        _compat(ptr)._spacer = value;\n    }",
            "startLine": 128
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clear(TUint256 storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, 0)\n        }\n    }",
            "startLine": 134
          },
          {
            "name": "clearCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "clear",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clearCompat(TUint256 storage ptr) internal {\n        if (block.chainid == 1) return clear(ptr);\n        _compat(ptr)._spacer = 0;\n    }",
            "startLine": 142
          },
          {
            "name": "inc",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function inc(TUint256 storage ptr) internal returns (uint256 newValue) {\n        set(ptr, newValue = get(ptr) + 1);\n    }",
            "startLine": 148
          },
          {
            "name": "incCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "setCompat",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "getCompat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function incCompat(TUint256 storage ptr) internal returns (uint256 newValue) {\n        setCompat(ptr, newValue = getCompat(ptr) + 1);\n    }",
            "startLine": 153
          },
          {
            "name": "inc",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "delta",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function inc(TUint256 storage ptr, uint256 delta) internal returns (uint256 newValue) {\n        set(ptr, newValue = get(ptr) + delta);\n    }",
            "startLine": 158
          },
          {
            "name": "incCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "delta",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "setCompat",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "getCompat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function incCompat(TUint256 storage ptr, uint256 delta) internal returns (uint256 newValue) {\n        setCompat(ptr, newValue = getCompat(ptr) + delta);\n    }",
            "startLine": 163
          },
          {
            "name": "dec",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function dec(TUint256 storage ptr) internal returns (uint256 newValue) {\n        set(ptr, newValue = get(ptr) - 1);\n    }",
            "startLine": 168
          },
          {
            "name": "decCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "setCompat",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "getCompat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function decCompat(TUint256 storage ptr) internal returns (uint256 newValue) {\n        setCompat(ptr, newValue = getCompat(ptr) - 1);\n    }",
            "startLine": 173
          },
          {
            "name": "dec",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "delta",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function dec(TUint256 storage ptr, uint256 delta) internal returns (uint256 newValue) {\n        set(ptr, newValue = get(ptr) - delta);\n    }",
            "startLine": 178
          },
          {
            "name": "decCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "delta",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "setCompat",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "getCompat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function decCompat(TUint256 storage ptr, uint256 delta) internal returns (uint256 newValue) {\n        setCompat(ptr, newValue = getCompat(ptr) - delta);\n    }",
            "startLine": 183
          },
          {
            "name": "incSigned",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "delta",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function incSigned(TUint256 storage ptr, int256 delta) internal returns (uint256 newValue) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let currentValue := tload(ptr.slot)\n            newValue := add(currentValue, delta)\n            if iszero(eq(lt(newValue, currentValue), slt(delta, 0))) {\n                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.\n                mstore(0x20, 0x11) // Underflow or overflow panic.\n                revert(0x1c, 0x24)\n            }\n            tstore(ptr.slot, newValue)\n        }\n    }",
            "startLine": 188
          },
          {
            "name": "incSignedCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "delta",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "incSigned",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function incSignedCompat(TUint256 storage ptr, int256 delta)\n        internal\n        returns (uint256 newValue)\n    {\n        if (block.chainid == 1) return incSigned(ptr, delta);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let currentValue := sload(ptr.slot)\n            newValue := add(currentValue, delta)\n            if iszero(eq(lt(newValue, currentValue), slt(delta, 0))) {\n                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.\n                mstore(0x20, 0x11) // Underflow or overflow panic.\n                revert(0x1c, 0x24)\n            }\n            sstore(ptr.slot, newValue)\n        }\n    }",
            "startLine": 203
          },
          {
            "name": "decSigned",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "delta",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function decSigned(TUint256 storage ptr, int256 delta) internal returns (uint256 newValue) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let currentValue := tload(ptr.slot)\n            newValue := sub(currentValue, delta)\n            if iszero(eq(lt(newValue, currentValue), sgt(delta, 0))) {\n                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.\n                mstore(0x20, 0x11) // Underflow or overflow panic.\n                revert(0x1c, 0x24)\n            }\n            tstore(ptr.slot, newValue)\n        }\n    }",
            "startLine": 223
          },
          {
            "name": "decSignedCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              },
              {
                "name": "delta",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "decSigned",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function decSignedCompat(TUint256 storage ptr, int256 delta)\n        internal\n        returns (uint256 newValue)\n    {\n        if (block.chainid == 1) return decSigned(ptr, delta);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let currentValue := sload(ptr.slot)\n            newValue := sub(currentValue, delta)\n            if iszero(eq(lt(newValue, currentValue), sgt(delta, 0))) {\n                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.\n                mstore(0x20, 0x11) // Underflow or overflow panic.\n                revert(0x1c, 0x24)\n            }\n            sstore(ptr.slot, newValue)\n        }\n    }",
            "startLine": 238
          },
          {
            "name": "tInt256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tInt256(bytes32 tSlot) internal pure returns (TInt256 storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 262
          },
          {
            "name": "tInt256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tInt256(uint256 tSlot) internal pure returns (TInt256 storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 270
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "int256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(TInt256 storage ptr) internal view returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := tload(ptr.slot)\n        }\n    }",
            "startLine": 278
          },
          {
            "name": "getCompat",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function getCompat(TInt256 storage ptr) internal view returns (int256 result) {\n        result = block.chainid == 1 ? get(ptr) : int256(_compat(ptr)._spacer);\n    }",
            "startLine": 286
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              },
              {
                "name": "value",
                "type": "int256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(TInt256 storage ptr, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, value)\n        }\n    }",
            "startLine": 291
          },
          {
            "name": "setCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              },
              {
                "name": "value",
                "type": "int256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function setCompat(TInt256 storage ptr, int256 value) internal {\n        if (block.chainid == 1) return set(ptr, value);\n        _compat(ptr)._spacer = uint256(value);\n    }",
            "startLine": 299
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clear(TInt256 storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, 0)\n        }\n    }",
            "startLine": 305
          },
          {
            "name": "clearCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "clear",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clearCompat(TInt256 storage ptr) internal {\n        if (block.chainid == 1) return clear(ptr);\n        _compat(ptr)._spacer = 0;\n    }",
            "startLine": 313
          },
          {
            "name": "inc",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function inc(TInt256 storage ptr) internal returns (int256 newValue) {\n        set(ptr, newValue = get(ptr) + 1);\n    }",
            "startLine": 319
          },
          {
            "name": "incCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "setCompat",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "getCompat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function incCompat(TInt256 storage ptr) internal returns (int256 newValue) {\n        setCompat(ptr, newValue = getCompat(ptr) + 1);\n    }",
            "startLine": 324
          },
          {
            "name": "inc",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              },
              {
                "name": "delta",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function inc(TInt256 storage ptr, int256 delta) internal returns (int256 newValue) {\n        set(ptr, newValue = get(ptr) + delta);\n    }",
            "startLine": 329
          },
          {
            "name": "incCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              },
              {
                "name": "delta",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "setCompat",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "getCompat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function incCompat(TInt256 storage ptr, int256 delta) internal returns (int256 newValue) {\n        setCompat(ptr, newValue = getCompat(ptr) + delta);\n    }",
            "startLine": 334
          },
          {
            "name": "dec",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function dec(TInt256 storage ptr) internal returns (int256 newValue) {\n        set(ptr, newValue = get(ptr) - 1);\n    }",
            "startLine": 339
          },
          {
            "name": "decCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "setCompat",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "getCompat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function decCompat(TInt256 storage ptr) internal returns (int256 newValue) {\n        setCompat(ptr, newValue = getCompat(ptr) - 1);\n    }",
            "startLine": 344
          },
          {
            "name": "dec",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              },
              {
                "name": "delta",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function dec(TInt256 storage ptr, int256 delta) internal returns (int256 newValue) {\n        set(ptr, newValue = get(ptr) - delta);\n    }",
            "startLine": 349
          },
          {
            "name": "decCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              },
              {
                "name": "delta",
                "type": "int256"
              }
            ],
            "returnValues": [
              {
                "name": "newValue",
                "type": "int256"
              }
            ],
            "calls": [
              {
                "target": "setCompat",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "getCompat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function decCompat(TInt256 storage ptr, int256 delta) internal returns (int256 newValue) {\n        setCompat(ptr, newValue = getCompat(ptr) - delta);\n    }",
            "startLine": 354
          },
          {
            "name": "tBytes32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TBytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tBytes32(bytes32 tSlot) internal pure returns (TBytes32 storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 363
          },
          {
            "name": "tBytes32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TBytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tBytes32(uint256 tSlot) internal pure returns (TBytes32 storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 371
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(TBytes32 storage ptr) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := tload(ptr.slot)\n        }\n    }",
            "startLine": 379
          },
          {
            "name": "getCompat",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function getCompat(TBytes32 storage ptr) internal view returns (bytes32 result) {\n        result = block.chainid == 1 ? get(ptr) : bytes32(_compat(ptr)._spacer);\n    }",
            "startLine": 387
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes32"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(TBytes32 storage ptr, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, value)\n        }\n    }",
            "startLine": 392
          },
          {
            "name": "setCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes32"
              },
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function setCompat(TBytes32 storage ptr, bytes32 value) internal {\n        if (block.chainid == 1) return set(ptr, value);\n        _compat(ptr)._spacer = uint256(value);\n    }",
            "startLine": 400
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clear(TBytes32 storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, 0)\n        }\n    }",
            "startLine": 406
          },
          {
            "name": "clearCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "clear",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clearCompat(TBytes32 storage ptr) internal {\n        if (block.chainid == 1) return clear(ptr);\n        _compat(ptr)._spacer = 0;\n    }",
            "startLine": 414
          },
          {
            "name": "tAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TAddress"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tAddress(bytes32 tSlot) internal pure returns (TAddress storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 424
          },
          {
            "name": "tAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TAddress"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tAddress(uint256 tSlot) internal pure returns (TAddress storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 432
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TAddress"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(TAddress storage ptr) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := tload(ptr.slot)\n        }\n    }",
            "startLine": 440
          },
          {
            "name": "getCompat",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TAddress"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function getCompat(TAddress storage ptr) internal view returns (address result) {\n        result = block.chainid == 1 ? get(ptr) : address(uint160(_compat(ptr)._spacer));\n    }",
            "startLine": 448
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TAddress"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(TAddress storage ptr, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, shr(96, shl(96, value)))\n        }\n    }",
            "startLine": 453
          },
          {
            "name": "setCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TAddress"
              },
              {
                "name": "value",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function setCompat(TAddress storage ptr, address value) internal {\n        if (block.chainid == 1) return set(ptr, value);\n        _compat(ptr)._spacer = uint160(value);\n    }",
            "startLine": 461
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TAddress"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clear(TAddress storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, 0)\n        }\n    }",
            "startLine": 467
          },
          {
            "name": "clearCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TAddress"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "clear",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clearCompat(TAddress storage ptr) internal {\n        if (block.chainid == 1) return clear(ptr);\n        _compat(ptr)._spacer = 0;\n    }",
            "startLine": 475
          },
          {
            "name": "tBool",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TBool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tBool(bytes32 tSlot) internal pure returns (TBool storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 485
          },
          {
            "name": "tBool",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TBool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tBool(uint256 tSlot) internal pure returns (TBool storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 493
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(TBool storage ptr) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := tload(ptr.slot)\n        }\n    }",
            "startLine": 501
          },
          {
            "name": "getCompat",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBool"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function getCompat(TBool storage ptr) internal view returns (bool result) {\n        result = block.chainid == 1 ? get(ptr) : _compat(ptr)._spacer != 0;\n    }",
            "startLine": 509
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBool"
              },
              {
                "name": "value",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(TBool storage ptr, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, iszero(iszero(value)))\n        }\n    }",
            "startLine": 514
          },
          {
            "name": "setCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBool"
              },
              {
                "name": "value",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function setCompat(TBool storage ptr, bool value) internal {\n        if (block.chainid == 1) return set(ptr, value);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(ptr.slot, iszero(iszero(value)))\n        }\n    }",
            "startLine": 522
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clear(TBool storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, 0)\n        }\n    }",
            "startLine": 532
          },
          {
            "name": "clearCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "clear",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clearCompat(TBool storage ptr) internal {\n        if (block.chainid == 1) return clear(ptr);\n        _compat(ptr)._spacer = 0;\n    }",
            "startLine": 540
          },
          {
            "name": "tBytes",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TBytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tBytes(bytes32 tSlot) internal pure returns (TBytes storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 550
          },
          {
            "name": "tBytes",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TBytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tBytes(uint256 tSlot) internal pure returns (TBytes storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 558
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function length(TBytes storage ptr) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(224, tload(ptr.slot))\n        }\n    }",
            "startLine": 566
          },
          {
            "name": "lengthCompat",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "length",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function lengthCompat(TBytes storage ptr) internal view returns (uint256 result) {\n        if (block.chainid == 1) return length(ptr);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(224, sload(ptr.slot))\n        }\n    }",
            "startLine": 574
          },
          {
            "name": "get",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function get(TBytes storage ptr) internal view returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(result, 0x00)\n            mstore(add(result, 0x1c), tload(ptr.slot)) // Length and first `0x1c` bytes.\n            let n := mload(result)\n            let e := add(add(result, 0x20), n)\n            if iszero(lt(n, 0x1d)) {\n                mstore(0x00, ptr.slot)\n                let d := sub(keccak256(0x00, 0x20), result)\n                for { let o := add(result, 0x3c) } 1 {} {\n                    mstore(o, tload(add(o, d)))\n                    o := add(o, 0x20)\n                    if iszero(lt(o, e)) { break }\n                }\n            }\n            mstore(e, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(0x20, e)) // Allocate memory.\n        }\n    }",
            "startLine": 584
          },
          {
            "name": "getCompat",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "get",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function getCompat(TBytes storage ptr) internal view returns (bytes memory result) {\n        if (block.chainid == 1) return get(ptr);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(result, 0x00)\n            mstore(add(result, 0x1c), sload(ptr.slot)) // Length and first `0x1c` bytes.\n            let n := mload(result)\n            let e := add(add(result, 0x20), n)\n            if iszero(lt(n, 0x1d)) {\n                mstore(0x00, ptr.slot)\n                let d := sub(keccak256(0x00, 0x20), result)\n                for { let o := add(result, 0x3c) } 1 {} {\n                    mstore(o, sload(add(o, d)))\n                    o := add(o, 0x20)\n                    if iszero(lt(o, e)) { break }\n                }\n            }\n            mstore(e, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(0x20, e)) // Allocate memory.\n        }\n    }",
            "startLine": 607
          },
          {
            "name": "set",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              },
              {
                "name": "value",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function set(TBytes storage ptr, bytes memory value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, mload(add(value, 0x1c)))\n            if iszero(lt(mload(value), 0x1d)) {\n                mstore(0x00, ptr.slot)\n                let e := add(add(value, 0x20), mload(value))\n                let d := sub(keccak256(0x00, or(0x20, sub(0, shr(32, mload(value))))), value)\n                for { let o := add(value, 0x3c) } 1 {} {\n                    tstore(add(o, d), mload(o))\n                    o := add(o, 0x20)\n                    if iszero(lt(o, e)) { break }\n                }\n            }\n        }\n    }",
            "startLine": 632
          },
          {
            "name": "setCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              },
              {
                "name": "value",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "set",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function setCompat(TBytes storage ptr, bytes memory value) internal {\n        if (block.chainid == 1) return set(ptr, value);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(ptr.slot, mload(add(value, 0x1c)))\n            if iszero(lt(mload(value), 0x1d)) {\n                mstore(0x00, ptr.slot)\n                let e := add(add(value, 0x20), mload(value))\n                let d := sub(keccak256(0x00, or(0x20, sub(0, shr(32, mload(value))))), value)\n                for { let o := add(value, 0x3c) } 1 {} {\n                    sstore(add(o, d), mload(o))\n                    o := add(o, 0x20)\n                    if iszero(lt(o, e)) { break }\n                }\n            }\n        }\n    }",
            "startLine": 650
          },
          {
            "name": "setCalldata",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              },
              {
                "name": "value",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function setCalldata(TBytes storage ptr, bytes calldata value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, or(shl(224, value.length), shr(32, calldataload(value.offset))))\n            if iszero(lt(value.length, 0x1d)) {\n                mstore(0x00, ptr.slot)\n                let e := add(value.offset, value.length)\n                // forgefmt: disable-next-item\n                let d := add(sub(keccak256(0x00, or(0x20, sub(0, shr(32, value.length)))),\n                    value.offset), 0x20)\n                for { let o := add(value.offset, 0x1c) } 1 {} {\n                    tstore(add(o, d), calldataload(o))\n                    o := add(o, 0x20)\n                    if iszero(lt(o, e)) { break }\n                }\n            }\n        }\n    }",
            "startLine": 670
          },
          {
            "name": "setCalldataCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              },
              {
                "name": "value",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "setCalldata",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function setCalldataCompat(TBytes storage ptr, bytes calldata value) internal {\n        if (block.chainid == 1) return setCalldata(ptr, value);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(ptr.slot, or(shl(224, value.length), shr(32, calldataload(value.offset))))\n            if iszero(lt(value.length, 0x1d)) {\n                mstore(0x00, ptr.slot)\n                let e := add(value.offset, value.length)\n                // forgefmt: disable-next-item\n                let d := add(sub(keccak256(0x00, or(0x20, sub(0, shr(32, value.length)))),\n                    value.offset), 0x20)\n                for { let o := add(value.offset, 0x1c) } 1 {} {\n                    sstore(add(o, d), calldataload(o))\n                    o := add(o, 0x20)\n                    if iszero(lt(o, e)) { break }\n                }\n            }\n        }\n    }",
            "startLine": 690
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clear(TBytes storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, 0)\n        }\n    }",
            "startLine": 712
          },
          {
            "name": "clearCompat",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "clear",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_compat",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clearCompat(TBytes storage ptr) internal {\n        if (block.chainid == 1) return clear(ptr);\n        _compat(ptr)._spacer = 0;\n    }",
            "startLine": 720
          },
          {
            "name": "tStack",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TStack"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tStack(bytes32 tSlot) internal pure returns (TStack storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 730
          },
          {
            "name": "tStack",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tSlot",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "ptr",
                "type": "TStack"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tStack(uint256 tSlot) internal pure returns (TStack storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "startLine": 738
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TStack"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function length(TStack storage ptr) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(160, shl(128, tload(ptr.slot))) // Removes the base offset and stride.\n        }\n    }",
            "startLine": 746
          },
          {
            "name": "clear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TStack"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clear(TStack storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clears the length and increments the base pointer by `1 << 128`.\n            tstore(ptr.slot, shl(128, add(1, shr(128, tload(ptr.slot)))))\n        }\n    }",
            "startLine": 755
          },
          {
            "name": "place",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TStack"
              }
            ],
            "returnValues": [
              {
                "name": "topPtr",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function place(TStack storage ptr) internal returns (bytes32 topPtr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            topPtr := add(0x100000000, tload(ptr.slot)) // Increments by a stride.\n            tstore(ptr.slot, topPtr)\n            topPtr := add(mul(_STACK_BASE_SALT, ptr.slot), topPtr)\n        }\n    }",
            "startLine": 766
          },
          {
            "name": "peek",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TStack"
              }
            ],
            "returnValues": [
              {
                "name": "topPtr",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function peek(TStack storage ptr) internal view returns (bytes32 topPtr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let t := tload(ptr.slot)\n            topPtr := mul(iszero(iszero(shl(128, t))), add(mul(_STACK_BASE_SALT, ptr.slot), t))\n        }\n    }",
            "startLine": 778
          },
          {
            "name": "top",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "TStack"
              }
            ],
            "returnValues": [
              {
                "name": "topPtr",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function top(TStack storage ptr) internal view returns (bytes32 topPtr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            topPtr := tload(ptr.slot)\n            if iszero(topPtr) {\n                mstore(0x00, 0xbb704e21) // `StackIsEmpty()`.\n                revert(0x1c, 0x04)\n            }\n            topPtr := add(mul(_STACK_BASE_SALT, ptr.slot), topPtr)\n        }\n    }",
            "startLine": 787
          },
          {
            "name": "pop",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "TStack"
              }
            ],
            "returnValues": [
              {
                "name": "lastTopPtr",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function pop(TStack storage ptr) internal returns (bytes32 lastTopPtr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            lastTopPtr := tload(ptr.slot)\n            if iszero(lastTopPtr) {\n                mstore(0x00, 0xbb704e21) // `StackIsEmpty()`.\n                revert(0x1c, 0x04)\n            }\n            tstore(ptr.slot, sub(lastTopPtr, 0x100000000)) // Decrements by a stride.\n            lastTopPtr := add(mul(_STACK_BASE_SALT, ptr.slot), lastTopPtr)\n        }\n    }",
            "startLine": 802
          },
          {
            "name": "registrySet",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "value",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function registrySet(bytes32 key, bytes memory value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0xaac438c0) // `set(bytes32,bytes)`.\n            mstore(add(m, 0x20), key)\n            mstore(add(m, 0x40), 0x40)\n            let n := mload(value)\n            mstore(add(m, 0x60), n)\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x80), i), mload(add(add(value, 0x20), i)))\n            }\n            if iszero(\n                mul(\n                    returndatasize(),\n                    call(gas(), REGISTRY, 0, add(m, 0x1c), add(n, 0x64), 0x00, 0x20)\n                )\n            ) { revert(0x00, returndatasize()) }\n        }\n    }",
            "startLine": 824
          },
          {
            "name": "registryGet",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function registryGet(bytes32 key) internal view returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(0x00, 0x8eaa6ac0) // `get(bytes32)`.\n            mstore(0x20, key)\n            if iszero(mul(returndatasize(), staticcall(gas(), REGISTRY, 0x1c, 0x24, 0x00, 0x20))) {\n                revert(0x00, returndatasize())\n            }\n            // We can safely assume that the bytes will be containing the 0x20 offset.\n            returndatacopy(result, 0x20, sub(returndatasize(), 0x20))\n            mstore(0x40, add(result, returndatasize())) // Allocate memory.\n        }\n    }",
            "startLine": 848
          },
          {
            "name": "registryClear",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function registryClear(bytes32 key) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x97040a45) // `clear(bytes32)`.\n            mstore(0x20, key)\n            if iszero(mul(returndatasize(), call(gas(), REGISTRY, 0, 0x1c, 0x24, 0x00, 0x20))) {\n                revert(0x00, returndatasize())\n            }\n        }\n    }",
            "startLine": 866
          },
          {
            "name": "registryAdminOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "key",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function registryAdminOf(bytes32 key) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0xc5344411) // `adminOf(bytes32)`.\n            mstore(0x20, key)\n            if iszero(mul(returndatasize(), staticcall(gas(), REGISTRY, 0x1c, 0x24, 0x00, 0x20))) {\n                revert(0x00, returndatasize())\n            }\n            result := mload(0x00)\n        }\n    }",
            "startLine": 880
          },
          {
            "name": "registryChangeAdmin",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "key",
                "type": "bytes32"
              },
              {
                "name": "newAdmin",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function registryChangeAdmin(bytes32 key, address newAdmin) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, 0x053b1ca3) // `changeAdmin(bytes32,address)`.\n            mstore(0x20, key)\n            mstore(0x40, shr(96, shl(96, newAdmin)))\n            if iszero(mul(returndatasize(), call(gas(), REGISTRY, 0, 0x1c, 0x44, 0x00, 0x20))) {\n                revert(0x00, returndatasize())\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "startLine": 896
          },
          {
            "name": "_compat",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "ptr",
                "type": "TUint256"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "TUint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _compat(TUint256 storage ptr) private pure returns (TUint256 storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)\n            mstore(0x00, ptr.slot)\n            c.slot := keccak256(0x00, 0x24)\n        }\n    }",
            "startLine": 915
          },
          {
            "name": "_compat",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "ptr",
                "type": "TInt256"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "TInt256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _compat(TInt256 storage ptr) private pure returns (TInt256 storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)\n            mstore(0x00, ptr.slot)\n            c.slot := keccak256(0x00, 0x24)\n        }\n    }",
            "startLine": 925
          },
          {
            "name": "_compat",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes32"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "TBytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _compat(TBytes32 storage ptr) private pure returns (TBytes32 storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)\n            mstore(0x00, ptr.slot)\n            c.slot := keccak256(0x00, 0x24)\n        }\n    }",
            "startLine": 935
          },
          {
            "name": "_compat",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "ptr",
                "type": "TAddress"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "TAddress"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _compat(TAddress storage ptr) private pure returns (TAddress storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)\n            mstore(0x00, ptr.slot)\n            c.slot := keccak256(0x00, 0x24)\n        }\n    }",
            "startLine": 945
          },
          {
            "name": "_compat",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBool"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "TBool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _compat(TBool storage ptr) private pure returns (TBool storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)\n            mstore(0x00, ptr.slot)\n            c.slot := keccak256(0x00, 0x24)\n        }\n    }",
            "startLine": 955
          },
          {
            "name": "_compat",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "ptr",
                "type": "TBytes"
              }
            ],
            "returnValues": [
              {
                "name": "c",
                "type": "TBytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _compat(TBytes storage ptr) private pure returns (TBytes storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)\n            mstore(0x00, ptr.slot)\n            c.slot := keccak256(0x00, 0x24)\n        }\n    }",
            "startLine": 965
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "StackIsEmpty",
            "parameters": [],
            "startLine": 68
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "_LIB_TRANSIENT_COMPAT_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 76
          },
          {
            "name": "_STACK_BASE_SALT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 80
          },
          {
            "name": "REGISTRY",
            "type": "address",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 84
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "MinHeapLib",
        "filePath": "utils/g/MinHeapLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "root",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "heap",
                "type": "Heap"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function root(Heap storage heap) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(sload(heap.slot)) {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, heap.slot)\n            result := sload(keccak256(0x00, 0x20))\n        }\n    }",
            "startLine": 45
          },
          {
            "name": "root",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function root(MemHeap memory heap) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(heap)\n            if iszero(mload(result)) {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(add(0x20, result))\n        }\n    }",
            "startLine": 59
          },
          {
            "name": "reserve",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              },
              {
                "name": "minimum",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function reserve(MemHeap memory heap, uint256 minimum) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let prime := 204053801631428327883786711931463459222251954273621\n            let cap := not(mload(add(mload(heap), w)))\n            if gt(minimum, mul(iszero(mod(cap, prime)), div(cap, prime))) {\n                let data := mload(heap)\n                let n := mload(data)\n                let newCap := and(add(minimum, 0x1f), w) // Round up to multiple of 32.\n                mstore(mload(0x40), not(mul(newCap, prime)))\n                let m := add(mload(0x40), 0x20)\n                mstore(m, n) // Store the length.\n                mstore(0x40, add(add(m, 0x20), shl(5, newCap))) // Allocate `heap.data` memory.\n                mstore(heap, m) // Update `heap.data`.\n                if n {\n                    for { let i := shl(5, n) } 1 {} {\n                        mstore(add(m, i), mload(add(data, i)))\n                        i := add(i, w)\n                        if iszero(i) { break }\n                    }\n                }\n            }\n        }\n    }",
            "startLine": 73
          },
          {
            "name": "smallest",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "heap",
                "type": "Heap"
              },
              {
                "name": "k",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function smallest(Heap storage heap, uint256 k) internal view returns (uint256[] memory a) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function pIndex(h_, p_) -> _i {\n                _i := mload(add(0x20, add(h_, shl(6, p_))))\n            }\n            function pValue(h_, p_) -> _v {\n                _v := mload(add(h_, shl(6, p_)))\n            }\n            function pSet(h_, p_, i_, v_) {\n                mstore(add(h_, shl(6, p_)), v_)\n                mstore(add(0x20, add(h_, shl(6, p_))), i_)\n            }\n            function pSiftdown(h_, p_, i_, v_) {\n                for {} 1 {} {\n                    let u_ := shr(1, sub(p_, 1))\n                    if iszero(mul(p_, lt(v_, pValue(h_, u_)))) { break }\n                    pSet(h_, p_, pIndex(h_, u_), pValue(h_, u_))\n                    p_ := u_\n                }\n                pSet(h_, p_, i_, v_)\n            }\n            function pSiftup(h_, e_, i_, v_) {\n                let p_ := 0\n                for { let c_ := 1 } lt(c_, e_) { c_ := add(1, shl(1, p_)) } {\n                    c_ := add(c_, gt(pValue(h_, c_), pValue(h_, add(c_, lt(add(c_, 1), e_)))))\n                    pSet(h_, p_, pIndex(h_, c_), pValue(h_, c_))\n                    p_ := c_\n                }\n                pSiftdown(h_, p_, i_, v_)\n            }\n            a := mload(0x40)\n            mstore(0x00, heap.slot)\n            let sOffset := keccak256(0x00, 0x20)\n            let o := add(a, 0x20) // Offset into `a`.\n            let n := sload(heap.slot) // The number of items in the heap.\n            let m := xor(n, mul(xor(n, k), lt(k, n))) // `min(k, n)`.\n            let h := add(o, shl(5, m)) // Priority queue.\n            pSet(h, 0, 0, sload(sOffset)) // Store the root into the priority queue.\n            for { let e := iszero(eq(o, h)) } e {} {\n                mstore(o, pValue(h, 0))\n                o := add(0x20, o)\n                if eq(o, h) { break }\n                let childPos := add(shl(1, pIndex(h, 0)), 1)\n                if iszero(lt(childPos, n)) {\n                    e := sub(e, 1)\n                    pSiftup(h, e, pIndex(h, e), pValue(h, e))\n                    continue\n                }\n                pSiftup(h, e, childPos, sload(add(sOffset, childPos)))\n                childPos := add(1, childPos)\n                if iszero(eq(childPos, n)) {\n                    pSiftdown(h, e, childPos, sload(add(sOffset, childPos)))\n                    e := add(e, 1)\n                }\n            }\n            mstore(a, shr(5, sub(o, add(a, 0x20)))) // Store the length.\n            mstore(0x40, o) // Allocate memory.\n        }\n    }",
            "startLine": 102
          },
          {
            "name": "smallest",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              },
              {
                "name": "k",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "a",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function smallest(MemHeap memory heap, uint256 k) internal pure returns (uint256[] memory a) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function pIndex(h_, p_) -> _i {\n                _i := mload(add(0x20, add(h_, shl(6, p_))))\n            }\n            function pValue(h_, p_) -> _v {\n                _v := mload(add(h_, shl(6, p_)))\n            }\n            function pSet(h_, p_, i_, v_) {\n                mstore(add(h_, shl(6, p_)), v_)\n                mstore(add(0x20, add(h_, shl(6, p_))), i_)\n            }\n            function pSiftdown(h_, p_, i_, v_) {\n                for {} 1 {} {\n                    let u_ := shr(1, sub(p_, 1))\n                    if iszero(mul(p_, lt(v_, pValue(h_, u_)))) { break }\n                    pSet(h_, p_, pIndex(h_, u_), pValue(h_, u_))\n                    p_ := u_\n                }\n                pSet(h_, p_, i_, v_)\n            }\n            function pSiftup(h_, e_, i_, v_) {\n                let p_ := 0\n                for { let c_ := 1 } lt(c_, e_) { c_ := add(1, shl(1, p_)) } {\n                    c_ := add(c_, gt(pValue(h_, c_), pValue(h_, add(c_, lt(add(c_, 1), e_)))))\n                    pSet(h_, p_, pIndex(h_, c_), pValue(h_, c_))\n                    p_ := c_\n                }\n                pSiftdown(h_, p_, i_, v_)\n            }\n            a := mload(0x40)\n            let sOffset := add(mload(heap), 0x20)\n            let o := add(a, 0x20) // Offset into `a`.\n            let n := mload(mload(heap)) // The number of items in the heap.\n            let m := xor(n, mul(xor(n, k), lt(k, n))) // `min(k, n)`.\n            let h := add(o, shl(5, m)) // Priority queue.\n            pSet(h, 0, 0, mload(sOffset)) // Store the root into the priority queue.\n            for { let e := iszero(eq(o, h)) } e {} {\n                mstore(o, pValue(h, 0))\n                o := add(0x20, o)\n                if eq(o, h) { break }\n                let childPos := add(shl(1, pIndex(h, 0)), 1)\n                if iszero(lt(childPos, n)) {\n                    e := sub(e, 1)\n                    pSiftup(h, e, pIndex(h, e), pValue(h, e))\n                    continue\n                }\n                pSiftup(h, e, childPos, mload(add(sOffset, shl(5, childPos))))\n                childPos := add(1, childPos)\n                if iszero(eq(childPos, n)) {\n                    pSiftdown(h, e, childPos, mload(add(sOffset, shl(5, childPos))))\n                    e := add(e, 1)\n                }\n            }\n            mstore(a, shr(5, sub(o, add(a, 0x20)))) // Store the length.\n            mstore(0x40, o) // Allocate memory.\n        }\n    }",
            "startLine": 166
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "heap",
                "type": "Heap"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function length(Heap storage heap) internal view returns (uint256) {\n        return heap.data.length;\n    }",
            "startLine": 227
          },
          {
            "name": "length",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function length(MemHeap memory heap) internal pure returns (uint256) {\n        return heap.data.length;\n    }",
            "startLine": 232
          },
          {
            "name": "push",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "heap",
                "type": "Heap"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function push(Heap storage heap, uint256 value) internal {\n        _set(heap, value, 0, 3);\n    }",
            "startLine": 237
          },
          {
            "name": "push",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function push(MemHeap memory heap, uint256 value) internal pure {\n        _set(heap, value, 0, 3);\n    }",
            "startLine": 242
          },
          {
            "name": "pop",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "heap",
                "type": "Heap"
              }
            ],
            "returnValues": [
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pop(Heap storage heap) internal returns (uint256 popped) {\n        (, popped) = _set(heap, 0, 0, 2);\n    }",
            "startLine": 248
          },
          {
            "name": "pop",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              }
            ],
            "returnValues": [
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pop(MemHeap memory heap) internal pure returns (uint256 popped) {\n        (, popped) = _set(heap, 0, 0, 2);\n    }",
            "startLine": 254
          },
          {
            "name": "pushPop",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "heap",
                "type": "Heap"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pushPop(Heap storage heap, uint256 value) internal returns (uint256 popped) {\n        (, popped) = _set(heap, value, 0, 4);\n    }",
            "startLine": 259
          },
          {
            "name": "pushPop",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function pushPop(MemHeap memory heap, uint256 value) internal pure returns (uint256 popped) {\n        (, popped) = _set(heap, value, 0, 4);\n    }",
            "startLine": 264
          },
          {
            "name": "replace",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "heap",
                "type": "Heap"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function replace(Heap storage heap, uint256 value) internal returns (uint256 popped) {\n        (, popped) = _set(heap, value, 0, 1);\n    }",
            "startLine": 270
          },
          {
            "name": "replace",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function replace(MemHeap memory heap, uint256 value) internal pure returns (uint256 popped) {\n        (, popped) = _set(heap, value, 0, 1);\n    }",
            "startLine": 276
          },
          {
            "name": "enqueue",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "heap",
                "type": "Heap"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "maxLength",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "success",
                "type": "bool"
              },
              {
                "name": "hasPopped",
                "type": "bool"
              },
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function enqueue(Heap storage heap, uint256 value, uint256 maxLength)\n        internal\n        returns (bool success, bool hasPopped, uint256 popped)\n    {\n        (value, popped) = _set(heap, value, maxLength, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            hasPopped := eq(3, value)\n            success := value\n        }\n    }",
            "startLine": 301
          },
          {
            "name": "enqueue",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "maxLength",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "success",
                "type": "bool"
              },
              {
                "name": "hasPopped",
                "type": "bool"
              },
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_set",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function enqueue(MemHeap memory heap, uint256 value, uint256 maxLength)\n        internal\n        pure\n        returns (bool success, bool hasPopped, uint256 popped)\n    {\n        (value, popped) = _set(heap, value, maxLength, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            hasPopped := eq(3, value)\n            success := value\n        }\n    }",
            "startLine": 326
          },
          {
            "name": "bumpFreeMemoryPointer",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function bumpFreeMemoryPointer() internal pure {\n        uint256 zero;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, zero)\n            mstore(0x40, add(m, 0x20))\n        }\n    }",
            "startLine": 345
          },
          {
            "name": "_set",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "heap",
                "type": "Heap"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "maxLength",
                "type": "uint256"
              },
              {
                "name": "mode",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "status",
                "type": "uint256"
              },
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _set(Heap storage heap, uint256 value, uint256 maxLength, uint256 mode)\n        private\n        returns (uint256 status, uint256 popped)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := sload(heap.slot)\n            mstore(0x00, heap.slot)\n            let sOffset := keccak256(0x00, 0x20) // Array storage slot offset.\n            let pos := 0\n            let childPos := not(0)\n            // Operations are ordered from most likely usage to least likely usage.\n            for {} 1 {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            } {\n                // Mode: `enqueue`.\n                if iszero(mode) {\n                    if iszero(maxLength) { continue }\n                    // If queue is full.\n                    if iszero(lt(n, maxLength)) {\n                        let r := sload(sOffset)\n                        if iszero(lt(r, value)) { break }\n                        status := 3\n                        childPos := 1\n                        popped := r\n                        break\n                    }\n                    status := 1\n                    pos := n\n                    // Increment and update the length.\n                    sstore(heap.slot, add(pos, 1))\n                    childPos := sOffset\n                    break\n                }\n                if iszero(gt(mode, 2)) {\n                    if iszero(n) { continue }\n                    // Mode: `pop`.\n                    if eq(mode, 2) {\n                        // Decrement and update the length.\n                        n := sub(n, 1)\n                        sstore(heap.slot, n)\n                        // Set the `value` to the last item.\n                        value := sload(add(sOffset, n))\n                        popped := value\n                        if iszero(n) { break }\n                    }\n                    // Mode: `replace`.\n                    popped := sload(sOffset)\n                    childPos := 1\n                    break\n                }\n                // Mode: `push`.\n                if eq(mode, 3) {\n                    // Increment and update the length.\n                    pos := n\n                    sstore(heap.slot, add(pos, 1))\n                    // `sOffset` is used as a value that is `>= n` and `< not(0)`.\n                    childPos := sOffset\n                    break\n                }\n                // Mode: `pushPop`.\n                popped := value\n                if iszero(n) { break }\n                let r := sload(sOffset)\n                if iszero(lt(r, value)) { break }\n                popped := r\n                childPos := 1\n                break\n            }\n            // Siftup.\n            for {} lt(childPos, n) {} {\n                let child := sload(add(sOffset, childPos))\n                let rightPos := add(childPos, 1)\n                let right := sload(add(sOffset, rightPos))\n                if iszero(gt(lt(rightPos, n), lt(child, right))) {\n                    right := child\n                    rightPos := childPos\n                }\n                sstore(add(sOffset, pos), right)\n                pos := rightPos\n                childPos := add(shl(1, pos), 1)\n            }\n            // Siftdown.\n            for {} pos {} {\n                let parentPos := shr(1, sub(pos, 1))\n                let parent := sload(add(sOffset, parentPos))\n                if iszero(lt(value, parent)) { break }\n                sstore(add(sOffset, pos), parent)\n                pos := parentPos\n            }\n            // If `childPos` has been changed from `not(0)`.\n            if add(childPos, 1) { sstore(add(sOffset, pos), value) }\n        }\n    }",
            "startLine": 361
          },
          {
            "name": "_set",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "heap",
                "type": "MemHeap"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "maxLength",
                "type": "uint256"
              },
              {
                "name": "mode",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "status",
                "type": "uint256"
              },
              {
                "name": "popped",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _set(MemHeap memory heap, uint256 value, uint256 maxLength, uint256 mode)\n        private\n        pure\n        returns (uint256 status, uint256 popped)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let data := mload(heap)\n            let n := mload(data)\n            // Allocation / reallocation.\n            for {\n                let cap := not(mload(sub(data, 0x20)))\n                let prime := 204053801631428327883786711931463459222251954273621\n                cap := mul(iszero(mod(cap, prime)), div(cap, prime))\n            } iszero(lt(n, cap)) {} {\n                let newCap := add(add(cap, cap), shl(5, iszero(cap)))\n                if iszero(or(cap, iszero(n))) {\n                    for { cap := n } iszero(gt(newCap, n)) {} { newCap := add(newCap, newCap) }\n                }\n                mstore(mload(0x40), not(mul(newCap, prime))) // Update `heap.capacity`.\n                let m := add(mload(0x40), 0x20)\n                mstore(m, n) // Store the length.\n                mstore(0x40, add(add(m, 0x20), shl(5, newCap))) // Allocate `heap.data` memory.\n                if cap {\n                    let w := not(0x1f)\n                    for { let i := shl(5, cap) } 1 {} {\n                        mstore(add(m, i), mload(add(data, i)))\n                        i := add(i, w)\n                        if iszero(i) { break }\n                    }\n                }\n                mstore(heap, m) // Update `heap.data`.\n                data := m\n                break\n            }\n            let sOffset := add(data, 0x20) // Array memory offset.\n            let pos := 0\n            let childPos := not(0)\n            // Operations are ordered from most likely usage to least likely usage.\n            for {} 1 {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            } {\n                // Mode: `enqueue`.\n                if iszero(mode) {\n                    if iszero(maxLength) { continue }\n                    // If the queue is full.\n                    if iszero(lt(n, maxLength)) {\n                        if iszero(lt(mload(sOffset), value)) { break }\n                        status := 3\n                        childPos := 1\n                        popped := mload(sOffset)\n                        break\n                    }\n                    status := 1\n                    pos := n\n                    // Increment and update the length.\n                    mstore(data, add(pos, 1))\n                    childPos := 0xff0000000000000000\n                    break\n                }\n                if iszero(gt(mode, 2)) {\n                    if iszero(n) { continue }\n                    // Mode: `pop`.\n                    if eq(mode, 2) {\n                        // Decrement and update the length.\n                        n := sub(n, 1)\n                        mstore(data, n)\n                        // Set the `value` to the last item.\n                        value := mload(add(sOffset, shl(5, n)))\n                        popped := value\n                        if iszero(n) { break }\n                    }\n                    // Mode: `replace`.\n                    popped := mload(sOffset)\n                    childPos := 1\n                    break\n                }\n                // Mode: `push`.\n                if eq(mode, 3) {\n                    // Increment and update the length.\n                    pos := n\n                    mstore(data, add(pos, 1))\n                    childPos := 0xff0000000000000000\n                    break\n                }\n                // Mode: `pushPop`.\n                if iszero(mul(n, lt(mload(sOffset), value))) {\n                    popped := value\n                    break\n                }\n                popped := mload(sOffset)\n                childPos := 1\n                break\n            }\n            // Siftup.\n            for {} lt(childPos, n) {} {\n                let child := mload(add(sOffset, shl(5, childPos)))\n                let rightPos := add(childPos, 1)\n                let right := mload(add(sOffset, shl(5, rightPos)))\n                if iszero(gt(lt(rightPos, n), lt(child, right))) {\n                    mstore(add(sOffset, shl(5, pos)), child)\n                    pos := childPos\n                    childPos := add(shl(1, pos), 1)\n                    continue\n                }\n                mstore(add(sOffset, shl(5, pos)), right)\n                pos := rightPos\n                childPos := add(shl(1, pos), 1)\n            }\n            // Siftdown.\n            for {} pos {} {\n                let parentPos := shr(1, sub(pos, 1))\n                let parent := mload(add(sOffset, shl(5, parentPos)))\n                if iszero(lt(value, parent)) { break }\n                mstore(add(sOffset, shl(5, pos)), parent)\n                pos := parentPos\n            }\n            // If `childPos` has been changed from `not(0)`.\n            if iszero(shr(128, childPos)) { mstore(add(sOffset, shl(5, pos)), value) }\n        }\n    }",
            "startLine": 459
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "HeapIsEmpty",
            "parameters": [],
            "startLine": 31
          }
        ],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "RedBlackTreeLib",
        "filePath": "utils/g/RedBlackTreeLib.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "size",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_nodes",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function size(Tree storage tree) internal view returns (uint256 result) {\n        uint256 nodes = _nodes(tree);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(sload(nodes), _BITMASK_KEY)\n        }\n    }",
            "startLine": 103
          },
          {
            "name": "values",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "_nodes",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function values(Tree storage tree) internal view returns (uint256[] memory result) {\n        uint256 nodes = _nodes(tree);\n        /// @solidity memory-safe-assembly\n        assembly {\n            function visit(current_) {\n                if iszero(current_) { leave } // If the current node is null, leave.\n                current_ := or(mload(0x00), current_) // Current node's storage slot.\n                let packed_ := sload(current_)\n                visit(and(packed_, _BITMASK_KEY)) // Visit left child.\n                let value_ := shr(_BITPOS_PACKED_VALUE, packed_) // Current value.\n                if iszero(value_) { value_ := sload(or(current_, _BIT_FULL_VALUE_SLOT)) }\n                mstore(mload(0x20), value_) // Append the value to `results`.\n                mstore(0x20, add(0x20, mload(0x20))) // Advance the offset into `results`.\n                visit(and(shr(_BITPOS_RIGHT, packed_), _BITMASK_KEY)) // Visit right child.\n            }\n            result := mload(0x40)\n            let rootPacked := sload(nodes)\n            mstore(result, and(rootPacked, _BITMASK_KEY)) // Length of `result`.\n            mstore(0x00, nodes) // Cache the nodes pointer in scratch space.\n            mstore(0x20, add(result, 0x20)) // Cache the offset into `results` in scratch space.\n            mstore(0x40, add(mload(0x20), shl(5, mload(result)))) // Allocate memory.\n            visit(shr(128, rootPacked)) // Start the tree traversal from the root node.\n        }\n    }",
            "startLine": 114
          },
          {
            "name": "find",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_find",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_pack",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function find(Tree storage tree, uint256 x) internal view returns (bytes32 result) {\n        (uint256 nodes,, uint256 key) = _find(tree, x);\n        result = _pack(nodes, key);\n    }",
            "startLine": 141
          },
          {
            "name": "nearest",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_find",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_pack",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "value",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "prev",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "next",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function nearest(Tree storage tree, uint256 x) internal view returns (bytes32 result) {\n        (uint256 nodes, uint256 cursor, uint256 key) = _find(tree, x);\n        unchecked {\n            if (cursor == uint256(0)) return result; // Nothing found -- empty tree.\n            if (key != uint256(0)) return _pack(nodes, key); // Exact match.\n            bytes32 a = _pack(nodes, cursor);\n            uint256 aValue = value(a);\n            bytes32 b = x < aValue ? prev(a) : next(a);\n            if (b == bytes32(0)) return a; // Only node found.\n            uint256 bValue = value(b);\n            uint256 aDist = x < aValue ? aValue - x : x - aValue;\n            uint256 bDist = x < bValue ? bValue - x : x - bValue;\n            return (aDist == bDist ? aValue < bValue : aDist < bDist) ? a : b;\n        }\n    }",
            "startLine": 149
          },
          {
            "name": "nearestBefore",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_find",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_pack",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "value",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "prev",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function nearestBefore(Tree storage tree, uint256 x) internal view returns (bytes32 result) {\n        (uint256 nodes, uint256 cursor, uint256 key) = _find(tree, x);\n        if (cursor == uint256(0)) return result; // Nothing found -- empty tree.\n        if (key != uint256(0)) return _pack(nodes, key); // Exact match.\n        bytes32 a = _pack(nodes, cursor);\n        return value(a) < x ? a : prev(a);\n    }",
            "startLine": 167
          },
          {
            "name": "nearestAfter",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_find",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_pack",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "value",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "next",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function nearestAfter(Tree storage tree, uint256 x) internal view returns (bytes32 result) {\n        (uint256 nodes, uint256 cursor, uint256 key) = _find(tree, x);\n        if (cursor == uint256(0)) return result; // Nothing found -- empty tree.\n        if (key != uint256(0)) return _pack(nodes, key); // Exact match.\n        bytes32 a = _pack(nodes, cursor);\n        return value(a) > x ? a : next(a);\n    }",
            "startLine": 177
          },
          {
            "name": "exists",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_find",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function exists(Tree storage tree, uint256 x) internal view returns (bool result) {\n        (,, uint256 key) = _find(tree, x);\n        result = key != 0;\n    }",
            "startLine": 186
          },
          {
            "name": "insert",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "tryInsert",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_revert",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function insert(Tree storage tree, uint256 x) internal {\n        uint256 err = tryInsert(tree, x);\n        if (err != 0) _revert(err);\n    }",
            "startLine": 193
          },
          {
            "name": "tryInsert",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "err",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_find",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_update",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryInsert(Tree storage tree, uint256 x) internal returns (uint256 err) {\n        (uint256 nodes, uint256 cursor, uint256 key) = _find(tree, x);\n        err = _update(nodes, cursor, key, x, 0);\n    }",
            "startLine": 201
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "tryRemove",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_revert",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(Tree storage tree, uint256 x) internal {\n        uint256 err = tryRemove(tree, x);\n        if (err != 0) _revert(err);\n    }",
            "startLine": 208
          },
          {
            "name": "tryRemove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "err",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_find",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_update",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryRemove(Tree storage tree, uint256 x) internal returns (uint256 err) {\n        (uint256 nodes,, uint256 key) = _find(tree, x);\n        err = _update(nodes, 0, key, 0, 1);\n    }",
            "startLine": 216
          },
          {
            "name": "remove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "tryRemove",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_revert",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function remove(bytes32 ptr) internal {\n        uint256 err = tryRemove(ptr);\n        if (err != 0) _revert(err);\n    }",
            "startLine": 226
          },
          {
            "name": "tryRemove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "ptr",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "err",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_unpack",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_update",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function tryRemove(bytes32 ptr) internal returns (uint256 err) {\n        (uint256 nodes, uint256 key) = _unpack(ptr);\n        err = _update(nodes, 0, key, 0, 1);\n    }",
            "startLine": 233
          },
          {
            "name": "value",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function value(bytes32 ptr) internal view returns (uint256 result) {\n        if (ptr == bytes32(0)) return result;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := sload(ptr)\n            result := shr(_BITPOS_PACKED_VALUE, packed)\n            if iszero(result) { result := sload(or(ptr, _BIT_FULL_VALUE_SLOT)) }\n        }\n    }",
            "startLine": 240
          },
          {
            "name": "first",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_end",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function first(Tree storage tree) internal view returns (bytes32 result) {\n        result = _end(tree, _BITPOS_LEFT);\n    }",
            "startLine": 252
          },
          {
            "name": "last",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_end",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function last(Tree storage tree) internal view returns (bytes32 result) {\n        result = _end(tree, _BITPOS_RIGHT);\n    }",
            "startLine": 258
          },
          {
            "name": "next",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_step",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function next(bytes32 ptr) internal view returns (bytes32 result) {\n        result = _step(ptr, _BITPOS_LEFT, _BITPOS_RIGHT);\n    }",
            "startLine": 265
          },
          {
            "name": "prev",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_step",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function prev(bytes32 ptr) internal view returns (bytes32 result) {\n        result = _step(ptr, _BITPOS_RIGHT, _BITPOS_LEFT);\n    }",
            "startLine": 272
          },
          {
            "name": "isEmpty",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "ptr",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function isEmpty(bytes32 ptr) internal pure returns (bool result) {\n        result = ptr == bytes32(0);\n    }",
            "startLine": 277
          },
          {
            "name": "_unpack",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "ptr",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "nodes",
                "type": "uint256"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _unpack(bytes32 ptr) private pure returns (uint256 nodes, uint256 key) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            nodes := shl(_NODES_SLOT_SHIFT, shr(_NODES_SLOT_SHIFT, ptr))\n            key := and(_BITMASK_KEY, ptr)\n        }\n    }",
            "startLine": 286
          },
          {
            "name": "_pack",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "nodes",
                "type": "uint256"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _pack(uint256 nodes, uint256 key) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mul(or(nodes, key), iszero(iszero(key)))\n        }\n    }",
            "startLine": 295
          },
          {
            "name": "_end",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "L",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_nodes",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_pack",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _end(Tree storage tree, uint256 L) private view returns (bytes32 result) {\n        uint256 nodes = _nodes(tree);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(128, sload(nodes))\n            if result {\n                for {} 1 {} {\n                    let packed := sload(or(nodes, result))\n                    let left := and(shr(L, packed), _BITMASK_KEY)\n                    if iszero(left) { break }\n                    result := left\n                }\n            }\n        }\n        result = _pack(nodes, uint256(result));\n    }",
            "startLine": 303
          },
          {
            "name": "_step",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ptr",
                "type": "bytes32"
              },
              {
                "name": "L",
                "type": "uint256"
              },
              {
                "name": "R",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_unpack",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_pack",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _step(bytes32 ptr, uint256 L, uint256 R) private view returns (bytes32 result) {\n        if (ptr == bytes32(0)) return ptr;\n        (uint256 nodes, uint256 target) = _unpack(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := sload(ptr)\n            for { result := and(shr(R, packed), _BITMASK_KEY) } 1 {} {\n                if iszero(result) {\n                    result := and(shr(_BITPOS_PARENT, packed), _BITMASK_KEY)\n                    for {} 1 {} {\n                        if iszero(result) { break }\n                        packed := sload(or(nodes, result))\n                        if iszero(eq(target, and(shr(R, packed), _BITMASK_KEY))) {\n                            break\n                        }\n                        target := result\n                        result := and(shr(_BITPOS_PARENT, packed), _BITMASK_KEY)\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    packed := sload(or(nodes, result))\n                    let left := and(shr(L, packed), _BITMASK_KEY)\n                    if iszero(left) { break }\n                    result := left\n                }\n                break\n            }\n        }\n        result = _pack(nodes, uint256(result));\n    }",
            "startLine": 321
          },
          {
            "name": "_update",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "nodes",
                "type": "uint256"
              },
              {
                "name": "cursor",
                "type": "uint256"
              },
              {
                "name": "key",
                "type": "uint256"
              },
              {
                "name": "x",
                "type": "uint256"
              },
              {
                "name": "mode",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "err",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _update(uint256 nodes, uint256 cursor, uint256 key, uint256 x, uint256 mode)\n        private\n        returns (uint256 err)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function getKey(packed_, bitpos_) -> index_ {\n                index_ := and(_BITMASK_KEY, shr(bitpos_, packed_))\n            }\n\n            function setKey(packed_, bitpos_, key_) -> result_ {\n                result_ := or(and(not(shl(bitpos_, _BITMASK_KEY)), packed_), shl(bitpos_, key_))\n            }\n\n            function rotate(nodes_, key_, L, R) {\n                let packed_ := sload(or(nodes_, key_))\n                let cursor_ := getKey(packed_, R)\n                let parent_ := getKey(packed_, _BITPOS_PARENT)\n                let cursorPacked_ := sload(or(nodes_, cursor_))\n                let cursorLeft_ := getKey(cursorPacked_, L)\n\n                if cursorLeft_ {\n                    let s_ := or(nodes_, cursorLeft_)\n                    sstore(s_, setKey(sload(s_), _BITPOS_PARENT, key_))\n                }\n\n                for {} 1 {} {\n                    if iszero(parent_) {\n                        mstore(0x00, cursor_)\n                        break\n                    }\n                    let s_ := or(nodes_, parent_)\n                    let parentPacked_ := sload(s_)\n                    if eq(key_, getKey(parentPacked_, L)) {\n                        sstore(s_, setKey(parentPacked_, L, cursor_))\n                        break\n                    }\n                    sstore(s_, setKey(parentPacked_, R, cursor_))\n                    break\n                }\n                packed_ := setKey(packed_, R, cursorLeft_)\n                sstore(or(nodes_, key_), setKey(packed_, _BITPOS_PARENT, cursor_))\n                cursorPacked_ := setKey(cursorPacked_, _BITPOS_PARENT, parent_)\n                sstore(or(nodes_, cursor_), setKey(cursorPacked_, L, key_))\n            }\n\n            function insert(nodes_, cursor_, key_, x_) -> err_ {\n                if key_ {\n                    err_ := ERROR_VALUE_ALREADY_EXISTS\n                    leave\n                }\n\n                let totalNodes_ := add(shr(128, mload(0x20)), 1)\n                if gt(totalNodes_, _BITMASK_KEY) {\n                    err_ := ERROR_TREE_IS_FULL\n                    leave\n                }\n\n                mstore(0x20, shl(128, totalNodes_))\n\n                {\n                    let packed_ := or(_BITMASK_RED, shl(_BITPOS_PARENT, cursor_))\n                    let nodePointer_ := or(nodes_, totalNodes_)\n\n                    for {} 1 {} {\n                        if iszero(gt(x_, _BITMASK_PACKED_VALUE)) {\n                            packed_ := or(shl(_BITPOS_PACKED_VALUE, x_), packed_)\n                            break\n                        }\n                        sstore(or(nodePointer_, _BIT_FULL_VALUE_SLOT), x_)\n                        break\n                    }\n                    sstore(nodePointer_, packed_)\n\n                    for {} 1 {} {\n                        if iszero(cursor_) {\n                            mstore(0x00, totalNodes_)\n                            break\n                        }\n                        let s_ := or(nodes_, cursor_)\n                        let cPacked_ := sload(s_)\n                        let cValue_ := shr(_BITPOS_PACKED_VALUE, cPacked_)\n                        if iszero(cValue_) {\n                            cValue_ := sload(or(s_, _BIT_FULL_VALUE_SLOT))\n                        }\n                        if iszero(lt(x_, cValue_)) {\n                            sstore(s_, setKey(cPacked_, _BITPOS_RIGHT, totalNodes_))\n                            break\n                        }\n                        sstore(s_, setKey(cPacked_, _BITPOS_LEFT, totalNodes_))\n                        break\n                    }\n                }\n\n                // Insert fixup workflow:\n\n                key_ := totalNodes_\n                let BR := _BITMASK_RED\n                for {} iszero(eq(key_, mload(0x00))) {} {\n                    let packed_ := sload(or(nodes_, key_))\n                    let parent_ := getKey(packed_, _BITPOS_PARENT)\n                    let parentPacked_ := sload(or(nodes_, parent_))\n                    if iszero(and(BR, parentPacked_)) { break }\n\n                    let grandParent_ := getKey(parentPacked_, _BITPOS_PARENT)\n                    let grandParentPacked_ := sload(or(nodes_, grandParent_))\n\n                    let R := mul(eq(parent_, getKey(grandParentPacked_, 0)), _BITPOS_RIGHT)\n                    let L := xor(R, _BITPOS_RIGHT)\n\n                    let c_ := getKey(grandParentPacked_, R)\n                    let cPacked_ := sload(or(nodes_, c_))\n                    if iszero(and(BR, cPacked_)) {\n                        if eq(key_, getKey(parentPacked_, R)) {\n                            key_ := parent_\n                            rotate(nodes_, key_, L, R)\n                            parent_ := getKey(sload(or(nodes_, key_)), _BITPOS_PARENT)\n                            parentPacked_ := sload(or(nodes_, parent_))\n                        }\n                        sstore(or(nodes_, parent_), and(parentPacked_, not(BR)))\n                        let s_ := or(nodes_, grandParent_)\n                        sstore(s_, or(sload(s_), BR))\n                        rotate(nodes_, grandParent_, R, L)\n                        break\n                    }\n                    sstore(or(nodes_, parent_), and(parentPacked_, not(BR)))\n                    sstore(or(nodes_, c_), and(cPacked_, not(BR)))\n                    sstore(or(nodes_, grandParent_), or(grandParentPacked_, BR))\n                    key_ := grandParent_\n                }\n                let root_ := or(nodes_, mload(0x00))\n                sstore(root_, and(sload(root_), not(BR)))\n            }\n\n            function removeFixup(nodes_, key_) {\n                let BR := _BITMASK_RED\n                for {} iszero(eq(key_, mload(0x00))) {} {\n                    let packed_ := sload(or(nodes_, key_))\n                    if and(BR, packed_) { break }\n\n                    let parent_ := getKey(packed_, _BITPOS_PARENT)\n                    let parentPacked_ := sload(or(nodes_, parent_))\n\n                    let R := mul(eq(key_, getKey(parentPacked_, 0)), _BITPOS_RIGHT)\n                    let L := xor(R, _BITPOS_RIGHT)\n\n                    let cursor_ := getKey(parentPacked_, R)\n                    let cursorPacked_ := sload(or(nodes_, cursor_))\n\n                    if and(BR, cursorPacked_) {\n                        sstore(or(nodes_, cursor_), and(cursorPacked_, not(BR)))\n                        sstore(or(nodes_, parent_), or(parentPacked_, BR))\n                        rotate(nodes_, parent_, L, R)\n                        cursor_ := getKey(sload(or(nodes_, parent_)), R)\n                        cursorPacked_ := sload(or(nodes_, cursor_))\n                    }\n\n                    let cursorLeft_ := getKey(cursorPacked_, L)\n                    let cursorLeftPacked_ := sload(or(nodes_, cursorLeft_))\n                    let cursorRight_ := getKey(cursorPacked_, R)\n                    let cursorRightPacked_ := sload(or(nodes_, cursorRight_))\n\n                    if iszero(and(BR, or(cursorLeftPacked_, cursorRightPacked_))) {\n                        sstore(or(nodes_, cursor_), or(cursorPacked_, BR))\n                        key_ := parent_\n                        continue\n                    }\n\n                    if iszero(and(BR, cursorRightPacked_)) {\n                        sstore(or(nodes_, cursorLeft_), and(cursorLeftPacked_, not(BR)))\n                        sstore(or(nodes_, cursor_), or(cursorPacked_, BR))\n                        rotate(nodes_, cursor_, R, L)\n                        cursor_ := getKey(sload(or(nodes_, parent_)), R)\n                        cursorPacked_ := sload(or(nodes_, cursor_))\n                        cursorRight_ := getKey(cursorPacked_, R)\n                        cursorRightPacked_ := sload(or(nodes_, cursorRight_))\n                    }\n\n                    parentPacked_ := sload(or(nodes_, parent_))\n                    // forgefmt: disable-next-item\n                    sstore(or(nodes_, cursor_), xor(cursorPacked_, and(BR, xor(cursorPacked_, parentPacked_))))\n                    sstore(or(nodes_, parent_), and(parentPacked_, not(BR)))\n                    sstore(or(nodes_, cursorRight_), and(cursorRightPacked_, not(BR)))\n                    rotate(nodes_, parent_, L, R)\n                    break\n                }\n                sstore(or(nodes_, key_), and(sload(or(nodes_, key_)), not(BR)))\n            }\n\n            function replaceParent(nodes_, parent_, a_, b_) {\n                if iszero(parent_) {\n                    mstore(0x00, a_)\n                    leave\n                }\n                let s_ := or(nodes_, parent_)\n                let p_ := sload(s_)\n                let t_ := iszero(eq(b_, getKey(p_, _BITPOS_LEFT)))\n                sstore(s_, setKey(p_, mul(t_, _BITPOS_RIGHT), a_))\n            }\n\n            // In `remove`, the parent of the null value (index 0) may be temporarily set\n            // to a non-zero value. This is an optimization that unifies the removal cases.\n            function remove(nodes_, key_) -> err_ {\n                if gt(key_, shr(128, mload(0x20))) {\n                    err_ := ERROR_POINTER_OUT_OF_BOUNDS\n                    leave\n                }\n                if iszero(key_) {\n                    err_ := ERROR_VALUE_DOES_NOT_EXISTS\n                    leave\n                }\n\n                let cursor_ := key_\n                {\n                    let packed_ := sload(or(nodes_, key_))\n                    let left_ := getKey(packed_, _BITPOS_LEFT)\n                    let right_ := getKey(packed_, _BITPOS_RIGHT)\n                    if mul(left_, right_) {\n                        for { cursor_ := right_ } 1 {} {\n                            let cursorLeft_ := getKey(sload(or(nodes_, cursor_)), _BITPOS_LEFT)\n                            if iszero(cursorLeft_) { break }\n                            cursor_ := cursorLeft_\n                        }\n                    }\n                }\n\n                let cursorPacked_ := sload(or(nodes_, cursor_))\n                let probe_ := getKey(cursorPacked_, _BITPOS_LEFT)\n                probe_ := getKey(cursorPacked_, mul(iszero(probe_), _BITPOS_RIGHT))\n\n                let yParent_ := getKey(cursorPacked_, _BITPOS_PARENT)\n                let probeSlot_ := or(nodes_, probe_)\n                sstore(probeSlot_, setKey(sload(probeSlot_), _BITPOS_PARENT, yParent_))\n                replaceParent(nodes_, yParent_, probe_, cursor_)\n\n                if iszero(eq(cursor_, key_)) {\n                    let packed_ := sload(or(nodes_, key_))\n                    replaceParent(nodes_, getKey(packed_, _BITPOS_PARENT), cursor_, key_)\n\n                    let leftSlot_ := or(nodes_, getKey(packed_, _BITPOS_LEFT))\n                    sstore(leftSlot_, setKey(sload(leftSlot_), _BITPOS_PARENT, cursor_))\n\n                    let rightSlot_ := or(nodes_, getKey(packed_, _BITPOS_RIGHT))\n                    sstore(rightSlot_, setKey(sload(rightSlot_), _BITPOS_PARENT, cursor_))\n\n                    // Copy `left`, `right`, `red` from `key_` to `cursor_`.\n                    // forgefmt: disable-next-item\n                    sstore(or(nodes_, cursor_), xor(cursorPacked_,\n                        and(xor(packed_, cursorPacked_), sub(shl(_BITPOS_PACKED_VALUE, 1), 1))))\n\n                    let t_ := cursor_\n                    cursor_ := key_\n                    key_ := t_\n                }\n\n                if iszero(and(_BITMASK_RED, cursorPacked_)) {\n                    removeFixup(nodes_, probe_)\n                }\n\n                // Remove last workflow:\n\n                let last_ := shr(128, mload(0x20))\n                let lastPacked_ := sload(or(nodes_, last_))\n                let lastValue_ := shr(_BITPOS_PACKED_VALUE, lastPacked_)\n                let lastFullValue_ := 0\n                if iszero(lastValue_) {\n                    lastValue_ := sload(or(_BIT_FULL_VALUE_SLOT, or(nodes_, last_)))\n                    lastFullValue_ := lastValue_\n                }\n\n                let cursorValue_ := shr(_BITPOS_PACKED_VALUE, sload(or(nodes_, cursor_)))\n                let cursorFullValue_ := 0\n                if iszero(cursorValue_) {\n                    cursorValue_ := sload(or(_BIT_FULL_VALUE_SLOT, or(nodes_, cursor_)))\n                    cursorFullValue_ := cursorValue_\n                }\n\n                if iszero(eq(lastValue_, cursorValue_)) {\n                    sstore(or(nodes_, cursor_), lastPacked_)\n                    if iszero(eq(lastFullValue_, cursorFullValue_)) {\n                        sstore(or(_BIT_FULL_VALUE_SLOT, or(nodes_, cursor_)), lastFullValue_)\n                    }\n                    for { let lastParent_ := getKey(lastPacked_, _BITPOS_PARENT) } 1 {} {\n                        if iszero(lastParent_) {\n                            mstore(0x00, cursor_)\n                            break\n                        }\n                        let s_ := or(nodes_, lastParent_)\n                        let p_ := sload(s_)\n                        let t_ := iszero(eq(last_, getKey(p_, _BITPOS_LEFT)))\n                        sstore(s_, setKey(p_, mul(t_, _BITPOS_RIGHT), cursor_))\n                        break\n                    }\n                    let lastRight_ := getKey(lastPacked_, _BITPOS_RIGHT)\n                    if lastRight_ {\n                        let s_ := or(nodes_, lastRight_)\n                        sstore(s_, setKey(sload(s_), _BITPOS_PARENT, cursor_))\n                    }\n                    let lastLeft_ := getKey(lastPacked_, _BITPOS_LEFT)\n                    if lastLeft_ {\n                        let s_ := or(nodes_, lastLeft_)\n                        sstore(s_, setKey(sload(s_), _BITPOS_PARENT, cursor_))\n                    }\n                }\n                sstore(or(nodes_, last_), 0)\n                if lastFullValue_ { sstore(or(_BIT_FULL_VALUE_SLOT, or(nodes_, last_)), 0) }\n\n                mstore(0x20, shl(128, sub(last_, 1)))\n            }\n\n            mstore(0x00, codesize()) // Zeroize the first 0x10 bytes.\n            mstore(0x10, sload(nodes))\n\n            for {} 1 {} {\n                if iszero(mode) {\n                    err := insert(nodes, cursor, key, x)\n                    break\n                }\n                err := remove(nodes, key)\n                break\n            }\n\n            sstore(nodes, mload(0x10))\n        }\n    }",
            "startLine": 354
          },
          {
            "name": "_nodes",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              }
            ],
            "returnValues": [
              {
                "name": "nodes",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _nodes(Tree storage tree) private pure returns (uint256 nodes) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, tree.slot)\n            mstore(0x00, _NODES_SLOT_SEED)\n            nodes := shl(_NODES_SLOT_SHIFT, keccak256(0x00, 0x40))\n        }\n    }",
            "startLine": 681
          },
          {
            "name": "_find",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tree",
                "type": "Tree"
              },
              {
                "name": "x",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "nodes",
                "type": "uint256"
              },
              {
                "name": "cursor",
                "type": "uint256"
              },
              {
                "name": "key",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_revert",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _find(Tree storage tree, uint256 x)\n        private\n        view\n        returns (uint256 nodes, uint256 cursor, uint256 key)\n    {\n        if (x == uint256(0)) _revert(0xc94f1877); // `ValueIsEmpty()`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, tree.slot)\n            mstore(0x00, _NODES_SLOT_SEED)\n            nodes := shl(_NODES_SLOT_SHIFT, keccak256(0x00, 0x40))\n            // Layout scratch space so that `mload(0x00) == 0`, `mload(0x01) == _BITPOS_RIGHT`.\n            mstore(0x01, _BITPOS_RIGHT) // `_BITPOS_RIGHT` is 31.\n            for { let probe := shr(128, sload(nodes)) } probe {} {\n                cursor := probe\n                let nodePacked := sload(or(nodes, probe))\n                let nodeValue := shr(_BITPOS_PACKED_VALUE, nodePacked)\n                if iszero(nodeValue) {\n                    nodeValue := sload(or(or(nodes, probe), _BIT_FULL_VALUE_SLOT))\n                }\n                if eq(nodeValue, x) {\n                    key := cursor\n                    break\n                }\n                probe := and(shr(mload(gt(x, nodeValue)), nodePacked), _BITMASK_KEY)\n            }\n        }\n    }",
            "startLine": 691
          },
          {
            "name": "_revert",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "err",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _revert(uint256 err) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, err)\n            revert(0x1c, 0x04)\n        }\n    }",
            "startLine": 721
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ValueIsEmpty",
            "parameters": [],
            "startLine": 28
          },
          {
            "name": "ValueAlreadyExists",
            "parameters": [],
            "startLine": 31
          },
          {
            "name": "ValueDoesNotExist",
            "parameters": [],
            "startLine": 34
          },
          {
            "name": "PointerOutOfBounds",
            "parameters": [],
            "startLine": 37
          },
          {
            "name": "TreeIsFull",
            "parameters": [],
            "startLine": 40
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "ERROR_VALUE_ALREADY_EXISTS",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 43
          },
          {
            "name": "ERROR_VALUE_DOES_NOT_EXISTS",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 46
          },
          {
            "name": "ERROR_POINTER_OUT_OF_BOUNDS",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 49
          },
          {
            "name": "ERROR_TREE_IS_FULL",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 52
          },
          {
            "name": "_NODES_SLOT_SEED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 86
          },
          {
            "name": "_NODES_SLOT_SHIFT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 87
          },
          {
            "name": "_BITMASK_KEY",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 88
          },
          {
            "name": "_BITPOS_LEFT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 89
          },
          {
            "name": "_BITPOS_RIGHT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 90
          },
          {
            "name": "_BITPOS_PARENT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 91
          },
          {
            "name": "_BITPOS_RED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 92
          },
          {
            "name": "_BITMASK_RED",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 93
          },
          {
            "name": "_BITPOS_PACKED_VALUE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 94
          },
          {
            "name": "_BITMASK_PACKED_VALUE",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 95
          },
          {
            "name": "_BIT_FULL_VALUE_SLOT",
            "type": "uint256",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 96
          }
        ],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "WebAuthn",
        "filePath": "utils/g/WebAuthn.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "verify",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "challenge",
                "type": "bytes"
              },
              {
                "name": "requireUserVerification",
                "type": "bool"
              },
              {
                "name": "auth",
                "type": "WebAuthnAuth"
              },
              {
                "name": "x",
                "type": "bytes32"
              },
              {
                "name": "y",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "Base64.encode",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "P256.verifySignature",
                "type": "library",
                "argCount": 5
              }
            ],
            "isVirtual": false,
            "sourceCode": "function verify(\n        bytes memory challenge,\n        bool requireUserVerification,\n        WebAuthnAuth memory auth,\n        bytes32 x,\n        bytes32 y\n    ) internal view returns (bool result) {\n        bytes32 messageHash;\n        string memory encoded = Base64.encode(challenge, true, true);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let clientDataJSON := mload(add(auth, 0x20))\n            let n := mload(clientDataJSON) // `clientDataJSON`'s length.\n            let o := add(clientDataJSON, 0x20) // Start of `clientData`'s bytes.\n            {\n                let c := mload(add(auth, 0x40)) // Challenge index in `clientDataJSON`.\n                let t := mload(add(auth, 0x60)) // Type index in `clientDataJSON`.\n                let l := mload(encoded) // Cache `encoded`'s length.\n                let q := add(l, 0x0d) // Length of `encoded` prefixed with '\"challenge\":\"'.\n                mstore(encoded, shr(152, '\"challenge\":\"')) // Temp prefix with '\"challenge\":\"'.\n                result := and(\n                    // 11. Verify JSON's type. Also checks for possible addition overflows.\n                    and(\n                        eq(shr(88, mload(add(o, t))), shr(88, '\"type\":\"webauthn.get\"')),\n                        lt(shr(128, or(t, c)), lt(add(0x14, t), n))\n                    ),\n                    // 12. Verify JSON's challenge. Includes a check for the closing '\"'.\n                    and(\n                        eq(keccak256(add(o, c), q), keccak256(add(encoded, 0x13), q)),\n                        and(eq(byte(0, mload(add(add(o, c), q))), 34), lt(add(q, c), n))\n                    )\n                )\n                mstore(encoded, l) // Restore `encoded`'s length, in case of string interning.\n            }\n            // Skip 13., 14., 15.\n            let l := mload(mload(auth)) // Length of `authenticatorData`.\n            // 16. Verify that the \"User Present\" flag is set (bit 0).\n            // 17. Verify that the \"User Verified\" flag is set (bit 2), if required.\n            // See: https://www.w3.org/TR/webauthn-2/#flags.\n            let u := or(1, shl(2, iszero(iszero(requireUserVerification))))\n            result := and(and(result, gt(l, 0x20)), eq(and(mload(add(mload(auth), 0x21)), u), u))\n            if result {\n                let p := add(mload(auth), 0x20) // Start of `authenticatorData`'s bytes.\n                let e := add(p, l) // Location of the word after `authenticatorData`.\n                let w := mload(e) // Cache the word after `authenticatorData`.\n                // 19. Compute `sha256(clientDataJSON)`.\n                // 20. Compute `sha256(authenticatorData  sha256(clientDataJSON))`.\n                // forgefmt: disable-next-item\n                messageHash := mload(staticcall(gas(),\n                    shl(1, staticcall(gas(), 2, o, n, e, 0x20)), p, add(l, 0x20), 0x01, 0x20))\n                mstore(e, w) // Restore the word after `authenticatorData`, in case of reuse.\n                // `returndatasize()` is `0x20` on `sha256` success, and `0x00` otherwise.\n                if iszero(returndatasize()) { invalid() }\n            }\n        }\n        // `P256.verifySignature` returns false if `s > N/2` due to the malleability check.\n        if (result) result = P256.verifySignature(messageHash, auth.r, auth.s, x, y);\n    }",
            "startLine": 90
          },
          {
            "name": "verify",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "challenge",
                "type": "bytes"
              },
              {
                "name": "requireUserVerification",
                "type": "bool"
              },
              {
                "name": "authenticatorData",
                "type": "bytes"
              },
              {
                "name": "clientDataJSON",
                "type": "string"
              },
              {
                "name": "challengeIndex",
                "type": "uint256"
              },
              {
                "name": "typeIndex",
                "type": "uint256"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              },
              {
                "name": "x",
                "type": "bytes32"
              },
              {
                "name": "y",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "verify",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "WebAuthnAuth",
                "type": "external",
                "argCount": 6
              }
            ],
            "isVirtual": false,
            "sourceCode": "function verify(\n        bytes memory challenge,\n        bool requireUserVerification,\n        bytes memory authenticatorData,\n        string memory clientDataJSON,\n        uint256 challengeIndex,\n        uint256 typeIndex,\n        bytes32 r,\n        bytes32 s,\n        bytes32 x,\n        bytes32 y\n    ) internal view returns (bool) {\n        return verify(\n            challenge,\n            requireUserVerification,\n            WebAuthnAuth(authenticatorData, clientDataJSON, challengeIndex, typeIndex, r, s),\n            x,\n            y\n        );\n    }",
            "startLine": 150
          },
          {
            "name": "encodeAuth",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "auth",
                "type": "WebAuthnAuth"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function encodeAuth(WebAuthnAuth memory auth) internal pure returns (bytes memory) {\n        return abi.encode(auth);\n    }",
            "startLine": 176
          },
          {
            "name": "tryDecodeAuth",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "encodedAuth",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "decoded",
                "type": "WebAuthnAuth"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tryDecodeAuth(bytes memory encodedAuth)\n        internal\n        pure\n        returns (WebAuthnAuth memory decoded)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let n := mload(encodedAuth) } iszero(lt(n, 0xc0)) {} {\n                let o := add(encodedAuth, 0x20) // Start of `encodedAuth`'s bytes.\n                let e := add(o, n) // End of `encodedAuth` in memory.\n                let p := add(mload(o), o) // Start of `encodedAuth`.\n                if or(gt(add(p, 0xc0), e), lt(p, o)) { break }\n                let authenticatorData := add(mload(p), p)\n                let clientDataJSON := add(mload(add(p, 0x20)), p)\n                if or(\n                    or(gt(authenticatorData, e), lt(authenticatorData, p)),\n                    or(gt(clientDataJSON, e), lt(clientDataJSON, p))\n                ) { break }\n                if or(\n                    gt(add(add(authenticatorData, 0x20), mload(authenticatorData)), e),\n                    gt(add(add(clientDataJSON, 0x20), mload(clientDataJSON)), e)\n                ) { break }\n                mstore(decoded, authenticatorData) // `authenticatorData`.\n                mstore(add(decoded, 0x20), clientDataJSON) // `clientDataJSON`.\n                mstore(add(decoded, 0x40), mload(add(p, 0x40))) // `challengeIndex`.\n                mstore(add(decoded, 0x60), mload(add(p, 0x60))) // `typeIndex`.\n                mstore(add(decoded, 0x80), mload(add(p, 0x80))) // `r`.\n                mstore(add(decoded, 0xa0), mload(add(p, 0xa0))) // `s`.\n                break\n            }\n        }\n    }",
            "startLine": 183
          },
          {
            "name": "tryEncodeAuthCompact",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "auth",
                "type": "WebAuthnAuth"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tryEncodeAuthCompact(WebAuthnAuth memory auth)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function copyBytes(o_, s_, c_) -> _e {\n                mstore(o_, shl(240, mload(s_)))\n                o_ := add(o_, c_)\n                _e := add(o_, mload(s_)) // The end of the bytes.\n                for { let d_ := sub(add(0x20, s_), o_) } 1 {} {\n                    mstore(o_, mload(add(d_, o_)))\n                    o_ := add(o_, 0x20)\n                    if iszero(lt(o_, _e)) { break }\n                }\n            }\n            let clientDataJSON := mload(add(0x20, auth))\n            let c := mload(add(0x40, auth)) // `challengeIndex`.\n            let t := mload(add(0x60, auth)) // `typeIndex`.\n            // If none of the lengths are more than `0xffff`.\n            if iszero(shr(16, or(or(t, c), or(mload(mload(auth)), mload(clientDataJSON))))) {\n                result := mload(0x40)\n                // `authenticatorData`, `clientDataJSON`.\n                let o := copyBytes(copyBytes(add(result, 0x20), mload(auth), 2), clientDataJSON, 0)\n                mstore(o, or(shl(240, c), shl(224, t))) // `challengeIndex`, `typeIndex`.\n                mstore(add(o, 0x04), mload(add(0x80, auth))) // `r`.\n                mstore(add(o, 0x24), mload(add(0xa0, auth))) // `s`.\n                mstore(result, sub(add(o, 0x24), result)) // Store the length.\n                mstore(add(o, 0x44), 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x64)) // Allocate memory .\n            }\n        }\n    }",
            "startLine": 229
          },
          {
            "name": "tryDecodeAuthCompact",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "encodedAuth",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "decoded",
                "type": "WebAuthnAuth"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tryDecodeAuthCompact(bytes memory encodedAuth)\n        internal\n        pure\n        returns (WebAuthnAuth memory decoded)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function extractBytes(o_, l_) -> _m {\n                _m := mload(0x40) // Grab the free memory pointer.\n                let s_ := add(_m, 0x20)\n                for { let i_ := 0 } 1 {} {\n                    mstore(add(s_, i_), mload(add(o_, i_)))\n                    i_ := add(i_, 0x20)\n                    if iszero(lt(i_, l_)) { break }\n                }\n                mstore(_m, l_) // Store the length.\n                mstore(add(l_, s_), 0) // Zeroize the slot after the string.\n                mstore(0x40, add(0x20, add(l_, s_))) // Allocate memory.\n            }\n            let n := mload(encodedAuth)\n            if iszero(lt(n, 0x46)) {\n                let o := add(encodedAuth, 0x20) // Start of `encodedAuth`'s bytes.\n                let e := add(o, n) // End of `encodedAuth` in memory.\n                n := shr(240, mload(o)) // Length of `authenticatorData`.\n                let a := add(o, 0x02) // Start of `authenticatorData`.\n                let c := add(a, n) // Start of `clientDataJSON`.\n                let j := sub(e, 0x44) // Start of `challengeIndex`.\n                if iszero(gt(c, j)) {\n                    mstore(decoded, extractBytes(a, n)) // `authenticatorData`.\n                    mstore(add(decoded, 0x20), extractBytes(c, sub(j, c))) // `clientDataJSON`.\n                    mstore(add(decoded, 0x40), shr(240, mload(j))) // `challengeIndex`.\n                    mstore(add(decoded, 0x60), shr(240, mload(add(j, 0x02)))) // `typeIndex`.\n                    mstore(add(decoded, 0x80), mload(add(j, 0x04))) // `r`.\n                    mstore(add(decoded, 0xa0), mload(add(j, 0x24))) // `s`.\n                }\n            }\n        }\n    }",
            "startLine": 267
          },
          {
            "name": "tryDecodeAuthCompactCalldata",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "encodedAuth",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "decoded",
                "type": "WebAuthnAuth"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function tryDecodeAuthCompactCalldata(bytes calldata encodedAuth)\n        internal\n        pure\n        returns (WebAuthnAuth memory decoded)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function extractBytes(o_, l_) -> _m {\n                _m := mload(0x40) // Grab the free memory pointer.\n                let s_ := add(_m, 0x20)\n                calldatacopy(s_, o_, l_)\n                mstore(_m, l_) // Store the length.\n                mstore(add(l_, s_), 0) // Zeroize the slot after the string.\n                mstore(0x40, add(0x20, add(l_, s_))) // Allocate memory.\n            }\n            if iszero(lt(encodedAuth.length, 0x46)) {\n                let e := add(encodedAuth.offset, encodedAuth.length) // End of `encodedAuth`.\n                let n := shr(240, calldataload(encodedAuth.offset)) // Length of `authenticatorData`.\n                let a := add(encodedAuth.offset, 0x02) // Start of `authenticatorData`.\n                let c := add(a, n) // Start of `clientDataJSON`.\n                let j := sub(e, 0x44) // Start of `challengeIndex`.\n                if iszero(gt(c, j)) {\n                    mstore(decoded, extractBytes(a, n)) // `authenticatorData`.\n                    mstore(add(decoded, 0x20), extractBytes(c, sub(j, c))) // `clientDataJSON`.\n                    mstore(add(decoded, 0x40), shr(240, calldataload(j))) // `challengeIndex`.\n                    mstore(add(decoded, 0x60), shr(240, calldataload(add(j, 0x02)))) // `typeIndex`.\n                    mstore(add(decoded, 0x80), calldataload(add(j, 0x04))) // `r`.\n                    mstore(add(decoded, 0xa0), calldataload(add(j, 0x24))) // `s`.\n                }\n            }\n        }\n    }",
            "startLine": 307
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../Base64.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../P256.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          }
        ]
      },
      {
        "name": "CWIA",
        "filePath": "utils/legacy/CWIA.sol",
        "kind": "abstract",
        "inherits": [],
        "implements": [],
        "category": "utils",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "_getArgBytes",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "arg",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgBytes() internal pure returns (bytes memory arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := mload(0x40)\n            let length := sub(calldatasize(), add(2, offset)) // 2 bytes are used for the length.\n            mstore(arg, length) // Store the length.\n            calldatacopy(add(arg, 0x20), offset, length)\n            let o := add(add(arg, 0x20), length)\n            mstore(o, 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }",
            "startLine": 10
          },
          {
            "name": "_getArgBytes",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              },
              {
                "name": "length",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgBytes(uint256 argOffset, uint256 length)\n        internal\n        pure\n        returns (bytes memory arg)\n    {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := mload(0x40)\n            mstore(arg, length) // Store the length.\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), length)\n            let o := add(add(arg, 0x20), length)\n            mstore(o, 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }",
            "startLine": 25
          },
          {
            "name": "_getArgAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgAddress(uint256 argOffset) internal pure returns (address arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(96, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 43
          },
          {
            "name": "_getArgUint256Array",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              },
              {
                "name": "length",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint256Array(uint256 argOffset, uint256 length)\n        internal\n        pure\n        returns (uint256[] memory arg)\n    {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := mload(0x40)\n            mstore(arg, length) // Store the length.\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))\n            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.\n        }\n    }",
            "startLine": 52
          },
          {
            "name": "_getArgBytes32Array",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              },
              {
                "name": "length",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "bytes32[]"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgBytes32Array(uint256 argOffset, uint256 length)\n        internal\n        pure\n        returns (bytes32[] memory arg)\n    {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := mload(0x40)\n            mstore(arg, length) // Store the length.\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))\n            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.\n        }\n    }",
            "startLine": 68
          },
          {
            "name": "_getArgBytes32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgBytes32(uint256 argOffset) internal pure returns (bytes32 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := calldataload(add(offset, argOffset))\n        }\n    }",
            "startLine": 84
          },
          {
            "name": "_getArgUint256",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint256(uint256 argOffset) internal pure returns (uint256 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := calldataload(add(offset, argOffset))\n        }\n    }",
            "startLine": 93
          },
          {
            "name": "_getArgUint248",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint248"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint248(uint256 argOffset) internal pure returns (uint248 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(8, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 102
          },
          {
            "name": "_getArgUint240",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint240"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint240(uint256 argOffset) internal pure returns (uint240 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(16, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 111
          },
          {
            "name": "_getArgUint232",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint232"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint232(uint256 argOffset) internal pure returns (uint232 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(24, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 120
          },
          {
            "name": "_getArgUint224",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint224"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint224(uint256 argOffset) internal pure returns (uint224 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(0x20, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 129
          },
          {
            "name": "_getArgUint216",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint216"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint216(uint256 argOffset) internal pure returns (uint216 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(40, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 138
          },
          {
            "name": "_getArgUint208",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint208"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint208(uint256 argOffset) internal pure returns (uint208 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(48, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 147
          },
          {
            "name": "_getArgUint200",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint200"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint200(uint256 argOffset) internal pure returns (uint200 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(56, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 156
          },
          {
            "name": "_getArgUint192",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint192"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint192(uint256 argOffset) internal pure returns (uint192 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(64, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 165
          },
          {
            "name": "_getArgUint184",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint184"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint184(uint256 argOffset) internal pure returns (uint184 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(72, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 174
          },
          {
            "name": "_getArgUint176",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint176"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint176(uint256 argOffset) internal pure returns (uint176 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(80, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 183
          },
          {
            "name": "_getArgUint168",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint168"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint168(uint256 argOffset) internal pure returns (uint168 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(88, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 192
          },
          {
            "name": "_getArgUint160",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint160"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint160(uint256 argOffset) internal pure returns (uint160 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(96, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 201
          },
          {
            "name": "_getArgUint152",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint152"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint152(uint256 argOffset) internal pure returns (uint152 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(104, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 210
          },
          {
            "name": "_getArgUint144",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint144"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint144(uint256 argOffset) internal pure returns (uint144 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(112, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 219
          },
          {
            "name": "_getArgUint136",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint136"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint136(uint256 argOffset) internal pure returns (uint136 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(120, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 228
          },
          {
            "name": "_getArgUint128",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint128"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint128(uint256 argOffset) internal pure returns (uint128 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(128, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 237
          },
          {
            "name": "_getArgUint120",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint120"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint120(uint256 argOffset) internal pure returns (uint120 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(136, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 246
          },
          {
            "name": "_getArgUint112",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint112"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint112(uint256 argOffset) internal pure returns (uint112 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(144, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 255
          },
          {
            "name": "_getArgUint104",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint104"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint104(uint256 argOffset) internal pure returns (uint104 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(152, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 264
          },
          {
            "name": "_getArgUint96",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint96"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint96(uint256 argOffset) internal pure returns (uint96 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(160, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 273
          },
          {
            "name": "_getArgUint88",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint88"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint88(uint256 argOffset) internal pure returns (uint88 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(168, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 282
          },
          {
            "name": "_getArgUint80",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint80"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint80(uint256 argOffset) internal pure returns (uint80 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(176, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 291
          },
          {
            "name": "_getArgUint72",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint72"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint72(uint256 argOffset) internal pure returns (uint72 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(184, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 300
          },
          {
            "name": "_getArgUint64",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint64(uint256 argOffset) internal pure returns (uint64 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(192, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 309
          },
          {
            "name": "_getArgUint56",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint56"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint56(uint256 argOffset) internal pure returns (uint56 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(200, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 318
          },
          {
            "name": "_getArgUint48",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint48"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint48(uint256 argOffset) internal pure returns (uint48 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(208, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 327
          },
          {
            "name": "_getArgUint40",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint40"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint40(uint256 argOffset) internal pure returns (uint40 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(216, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 336
          },
          {
            "name": "_getArgUint32",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint32"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint32(uint256 argOffset) internal pure returns (uint32 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(224, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 345
          },
          {
            "name": "_getArgUint24",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint24"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint24(uint256 argOffset) internal pure returns (uint24 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(232, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 354
          },
          {
            "name": "_getArgUint16",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint16"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint16(uint256 argOffset) internal pure returns (uint16 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(240, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 363
          },
          {
            "name": "_getArgUint8",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "argOffset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "arg",
                "type": "uint8"
              }
            ],
            "calls": [
              {
                "target": "_getImmutableArgsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        /// @solidity memory-safe-assembly\n        assembly {\n            arg := shr(248, calldataload(add(offset, argOffset)))\n        }\n    }",
            "startLine": 372
          },
          {
            "name": "_getImmutableArgsOffset",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "offset",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            offset := sub(calldatasize(), shr(240, calldataload(sub(calldatasize(), 2))))\n        }\n    }",
            "startLine": 381
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      },
      {
        "name": "LibCWIA",
        "filePath": "utils/legacy/LibCWIA.sol",
        "kind": "library",
        "inherits": [],
        "implements": [],
        "category": "library",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "clone",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "clone",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function clone(address implementation, bytes memory data) internal returns (address instance) {\n        instance = clone(0, implementation, data);\n    }",
            "startLine": 36
          },
          {
            "name": "clone",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function clone(uint256 value, address implementation, bytes memory data)\n        internal\n        returns (address instance)\n    {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n            // The `creationSize` is `extraLength + 108`\n            // The `runSize` is `creationSize - 10`.\n\n            /**\n             * ---------------------------------------------------------------------------------------------------+\n             * CREATION (10 bytes)                                                                                |\n             * ---------------------------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\n             * ---------------------------------------------------------------------------------------------------|\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\n             * 81         | DUP2              | r 0 r     |                                                       |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\n             * ---------------------------------------------------------------------------------------------------|\n             * RUNTIME (98 bytes + extraLength)                                                                   |\n             * ---------------------------------------------------------------------------------------------------|\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\n             * ---------------------------------------------------------------------------------------------------|\n             *                                                                                                    |\n             * ::: if no calldata, emit event & return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                      |                                             |\n             * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |\n             * 57       | JUMPI          |                          |                                             |\n             * 34       | CALLVALUE      | cv                       |                                             |\n             * 3d       | RETURNDATASIZE | 0 cv                     |                                             |\n             * 52       | MSTORE         |                          | [0..0x20): callvalue                        |\n             * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |\n             * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |\n             * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |\n             * a1       | LOG1           |                          | [0..0x20): callvalue                        |\n             * 00       | STOP           |                          | [0..0x20): callvalue                        |\n             * 5b       | JUMPDEST       |                          |                                             |\n             *                                                                                                    |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                      |                                             |\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\n             *                                                                                                    |\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\n             *                                                                                                    |\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\n             * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |\n             * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\n             *                                                                                                    |\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\n             *                                                                                                    |\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\n             *                                                                                                    |\n             * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\n             *                                                                                                    |\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\n             *                                                                                                    |\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\n             * ---------------------------------------------------------------------------------------------------+\n             */\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                sub(data, 0x21),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                sub(data, 0x3a),\n                0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\n                // The actual EVM limit may be smaller and may change over time.\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            instance := create(value, sub(data, 0x4c), add(extraLength, 0x6c))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }",
            "startLine": 42
          },
          {
            "name": "cloneDeterministic",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "cloneDeterministic",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, data, salt);\n    }",
            "startLine": 175
          },
          {
            "name": "cloneDeterministic",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "instance",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function cloneDeterministic(\n        uint256 value,\n        address implementation,\n        bytes memory data,\n        bytes32 salt\n    ) internal returns (address instance) {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                sub(data, 0x21),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                sub(data, 0x3a),\n                0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\n                // The actual EVM limit may be smaller and may change over time.\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            instance := create2(value, sub(data, 0x4c), add(extraLength, 0x6c), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }",
            "startLine": 184
          },
          {
            "name": "initCode",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCode(address implementation, bytes memory data)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let dataLength := mload(data)\n\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\n            // The actual EVM limit may be smaller and may change over time.\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\n\n            let o := add(result, 0x8c)\n            let end := add(o, dataLength)\n\n            // Copy the `data` into `result`.\n            for { let d := sub(add(data, 0x20), o) } 1 {} {\n                mstore(o, mload(add(o, d)))\n                o := add(o, 0x20)\n                if iszero(lt(o, end)) { break }\n            }\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n\n            mstore(add(result, 0x6c), 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(add(result, 0x5f), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                add(result, 0x4b),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                add(result, 0x32),\n                0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                add(result, 0x12),\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(end, shl(0xf0, extraLength))\n            mstore(add(end, 0x02), 0) // Zeroize the slot after the result.\n            mstore(result, add(extraLength, 0x6c)) // Store the length.\n            mstore(0x40, add(0x22, end)) // Allocate memory.\n        }\n    }",
            "startLine": 239
          },
          {
            "name": "initCodeHash",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "hash",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function initCodeHash(address implementation, bytes memory data)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\n            // The actual EVM limit may be smaller and may change over time.\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                sub(data, 0x21),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                sub(data, 0x3a),\n                0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                sub(data, 0x5a),\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }",
            "startLine": 292
          },
          {
            "name": "predictDeterministicAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "implementation",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "deployer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "initCodeHash",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "predictDeterministicAddress",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddress(\n        address implementation,\n        bytes memory data,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash(implementation, data);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "startLine": 345
          },
          {
            "name": "predictDeterministicAddress",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "deployer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "predicted",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "startLine": 362
          },
          {
            "name": "checkStartsWith",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "by",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function checkStartsWith(bytes32 salt, address by) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the salt does not start with the zero address or `by`.\n            if iszero(or(iszero(shr(96, salt)), eq(shr(96, shl(96, by)), shr(96, salt)))) {\n                mstore(0x00, 0x0c4549ef) // `SaltDoesNotStartWith()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "startLine": 380
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "DeploymentFailed",
            "parameters": [],
            "startLine": 20
          },
          {
            "name": "SaltDoesNotStartWith",
            "parameters": [],
            "startLine": 23
          },
          {
            "name": "ETHTransferFailed",
            "parameters": [],
            "startLine": 26
          }
        ],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": []
      }
    ],
    "dependencies": [],
    "proxyGroups": [],
    "stats": {
      "totalContracts": 41,
      "totalLibraries": 68,
      "totalInterfaces": 0,
      "totalFunctions": 2712
    }
  }
}