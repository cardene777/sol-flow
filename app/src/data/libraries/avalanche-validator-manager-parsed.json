{
  "id": "avalanche-validator-manager",
  "name": "Avalanche Validator Manager",
  "version": "1.0.0",
  "generatedAt": "2026-01-27T07:24:09.952Z",
  "callGraph": {
    "version": "1.0.0",
    "generatedAt": "2026-01-27T07:24:09.952Z",
    "projectName": "Avalanche Validator Manager",
    "structure": {
      "name": "contracts",
      "type": "directory",
      "path": "contracts",
      "children": [
        {
          "name": "@validator-manager",
          "type": "directory",
          "path": "contracts/@validator-manager",
          "children": [
            {
              "name": "ACP99Manager.sol",
              "type": "file",
              "path": "contracts/@validator-manager/ACP99Manager.sol",
              "contractName": "ACP99Manager"
            },
            {
              "name": "ERC20TokenStakingManager.sol",
              "type": "file",
              "path": "contracts/@validator-manager/ERC20TokenStakingManager.sol",
              "contractName": "ERC20TokenStakingManager"
            },
            {
              "name": "ExampleRewardCalculator.sol",
              "type": "file",
              "path": "contracts/@validator-manager/ExampleRewardCalculator.sol",
              "contractName": "ExampleRewardCalculator"
            },
            {
              "name": "NativeTokenStakingManager.sol",
              "type": "file",
              "path": "contracts/@validator-manager/NativeTokenStakingManager.sol",
              "contractName": "NativeTokenStakingManager"
            },
            {
              "name": "PoAManager.sol",
              "type": "file",
              "path": "contracts/@validator-manager/PoAManager.sol",
              "contractName": "PoAManager"
            },
            {
              "name": "StakingManager.sol",
              "type": "file",
              "path": "contracts/@validator-manager/StakingManager.sol",
              "contractName": "StakingManager"
            },
            {
              "name": "ValidatorManager.sol",
              "type": "file",
              "path": "contracts/@validator-manager/ValidatorManager.sol",
              "contractName": "ValidatorManager"
            },
            {
              "name": "ValidatorMessages.sol",
              "type": "file",
              "path": "contracts/@validator-manager/ValidatorMessages.sol",
              "contractName": "ValidatorMessages"
            },
            {
              "name": "interfaces",
              "type": "directory",
              "path": "contracts/@validator-manager/interfaces",
              "children": [
                {
                  "name": "IACP99Manager.sol",
                  "type": "file",
                  "path": "contracts/@validator-manager/interfaces/IACP99Manager.sol",
                  "contractName": "IACP99Manager"
                },
                {
                  "name": "IERC20Mintable.sol",
                  "type": "file",
                  "path": "contracts/@validator-manager/interfaces/IERC20Mintable.sol",
                  "contractName": "IERC20Mintable"
                },
                {
                  "name": "IERC20TokenStakingManager.sol",
                  "type": "file",
                  "path": "contracts/@validator-manager/interfaces/IERC20TokenStakingManager.sol",
                  "contractName": "IERC20TokenStakingManager"
                },
                {
                  "name": "INativeTokenStakingManager.sol",
                  "type": "file",
                  "path": "contracts/@validator-manager/interfaces/INativeTokenStakingManager.sol",
                  "contractName": "INativeTokenStakingManager"
                },
                {
                  "name": "IPoAManager.sol",
                  "type": "file",
                  "path": "contracts/@validator-manager/interfaces/IPoAManager.sol",
                  "contractName": "IPoAManager"
                },
                {
                  "name": "IRewardCalculator.sol",
                  "type": "file",
                  "path": "contracts/@validator-manager/interfaces/IRewardCalculator.sol",
                  "contractName": "IRewardCalculator"
                },
                {
                  "name": "IStakingManager.sol",
                  "type": "file",
                  "path": "contracts/@validator-manager/interfaces/IStakingManager.sol",
                  "contractName": "IStakingManager"
                },
                {
                  "name": "IValidatorManager.sol",
                  "type": "file",
                  "path": "contracts/@validator-manager/interfaces/IValidatorManager.sol",
                  "contractName": "IValidatorManager"
                },
                {
                  "name": "IValidatorManagerExternalOwnable.sol",
                  "type": "file",
                  "path": "contracts/@validator-manager/interfaces/IValidatorManagerExternalOwnable.sol",
                  "contractName": "IValidatorManagerExternalOwnable"
                }
              ]
            }
          ]
        },
        {
          "name": "@utilities",
          "type": "directory",
          "path": "contracts/@utilities",
          "children": [
            {
              "name": "SafeERC20TransferFrom.sol",
              "type": "file",
              "path": "contracts/@utilities/SafeERC20TransferFrom.sol",
              "contractName": "SafeERC20TransferFrom"
            }
          ]
        },
        {
          "name": "@openzeppelin",
          "type": "directory",
          "path": "contracts/@openzeppelin",
          "children": [
            {
              "name": "contracts-upgradeable@5.0.2",
              "type": "directory",
              "path": "contracts/@openzeppelin/contracts-upgradeable@5.0.2",
              "children": [
                {
                  "name": "proxy",
                  "type": "directory",
                  "path": "contracts/@openzeppelin/contracts-upgradeable@5.0.2/proxy",
                  "children": [
                    {
                      "name": "utils",
                      "type": "directory",
                      "path": "contracts/@openzeppelin/contracts-upgradeable@5.0.2/proxy/utils",
                      "children": [
                        {
                          "name": "Initializable.sol",
                          "type": "file",
                          "path": "contracts/@openzeppelin/contracts-upgradeable@5.0.2/proxy/utils/Initializable.sol",
                          "contractName": "Initializable"
                        }
                      ]
                    }
                  ]
                },
                {
                  "name": "utils",
                  "type": "directory",
                  "path": "contracts/@openzeppelin/contracts-upgradeable@5.0.2/utils",
                  "children": [
                    {
                      "name": "ReentrancyGuardUpgradeable.sol",
                      "type": "file",
                      "path": "contracts/@openzeppelin/contracts-upgradeable@5.0.2/utils/ReentrancyGuardUpgradeable.sol",
                      "contractName": "ReentrancyGuardUpgradeable"
                    },
                    {
                      "name": "ContextUpgradeable.sol",
                      "type": "file",
                      "path": "contracts/@openzeppelin/contracts-upgradeable@5.0.2/utils/ContextUpgradeable.sol",
                      "contractName": "ContextUpgradeable"
                    }
                  ]
                },
                {
                  "name": "access",
                  "type": "directory",
                  "path": "contracts/@openzeppelin/contracts-upgradeable@5.0.2/access",
                  "children": [
                    {
                      "name": "OwnableUpgradeable.sol",
                      "type": "file",
                      "path": "contracts/@openzeppelin/contracts-upgradeable@5.0.2/access/OwnableUpgradeable.sol",
                      "contractName": "OwnableUpgradeable"
                    }
                  ]
                }
              ]
            },
            {
              "name": "contracts@5.0.2",
              "type": "directory",
              "path": "contracts/@openzeppelin/contracts@5.0.2",
              "children": [
                {
                  "name": "token",
                  "type": "directory",
                  "path": "contracts/@openzeppelin/contracts@5.0.2/token",
                  "children": [
                    {
                      "name": "ERC20",
                      "type": "directory",
                      "path": "contracts/@openzeppelin/contracts@5.0.2/token/ERC20",
                      "children": [
                        {
                          "name": "utils",
                          "type": "directory",
                          "path": "contracts/@openzeppelin/contracts@5.0.2/token/ERC20/utils",
                          "children": [
                            {
                              "name": "SafeERC20.sol",
                              "type": "file",
                              "path": "contracts/@openzeppelin/contracts@5.0.2/token/ERC20/utils/SafeERC20.sol",
                              "contractName": "SafeERC20"
                            }
                          ]
                        },
                        {
                          "name": "IERC20.sol",
                          "type": "file",
                          "path": "contracts/@openzeppelin/contracts@5.0.2/token/ERC20/IERC20.sol",
                          "contractName": "IERC20"
                        }
                      ]
                    }
                  ]
                },
                {
                  "name": "utils",
                  "type": "directory",
                  "path": "contracts/@openzeppelin/contracts@5.0.2/utils",
                  "children": [
                    {
                      "name": "Address.sol",
                      "type": "file",
                      "path": "contracts/@openzeppelin/contracts@5.0.2/utils/Address.sol",
                      "contractName": "Address"
                    }
                  ]
                },
                {
                  "name": "access",
                  "type": "directory",
                  "path": "contracts/@openzeppelin/contracts@5.0.2/access",
                  "children": [
                    {
                      "name": "Ownable.sol",
                      "type": "file",
                      "path": "contracts/@openzeppelin/contracts@5.0.2/access/Ownable.sol",
                      "contractName": "Ownable"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "@subnet-evm",
          "type": "directory",
          "path": "contracts/@subnet-evm",
          "children": [
            {
              "name": "INativeMinter.sol",
              "type": "file",
              "path": "contracts/@subnet-evm/INativeMinter.sol",
              "contractName": "INativeMinter"
            },
            {
              "name": "IWarpMessenger.sol",
              "type": "file",
              "path": "contracts/@subnet-evm/IWarpMessenger.sol",
              "contractName": "IWarpMessenger"
            },
            {
              "name": "IAllowList.sol",
              "type": "file",
              "path": "contracts/@subnet-evm/IAllowList.sol",
              "contractName": "IAllowList"
            }
          ]
        }
      ]
    },
    "contracts": [
      {
        "name": "ACP99Manager",
        "kind": "abstract",
        "category": "validator-manager",
        "filePath": "@validator-manager/ACP99Manager.sol",
        "inherits": [],
        "implements": [
          "IACP99Manager"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IACP99Manager",
            "path": "./interfaces/IACP99Manager.sol",
            "isExternal": false
          },
          {
            "name": "PChainOwner",
            "path": "./interfaces/IACP99Manager.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "initializeValidatorSet",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "conversionData",
                "type": "ConversionData"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initializeValidatorSet(\n        ConversionData calldata conversionData,\n        uint32 messageIndex\n    ) external;",
            "startLine": 128,
            "signature": "initializeValidatorSet(ConversionData,uint32)",
            "selector": "0x5d9e08d4",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "IACP99Manager"
          },
          {
            "name": "completeValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorRegistration(\n        uint32 messageIndex\n    ) external returns (bytes32 validationID);",
            "startLine": 142,
            "signature": "completeValidatorRegistration(uint32)",
            "selector": "0x5442dda6",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "IACP99Manager"
          },
          {
            "name": "completeValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorRemoval(\n        uint32 messageIndex\n    ) external returns (bytes32 validationID);",
            "startLine": 155,
            "signature": "completeValidatorRemoval(uint32)",
            "selector": "0x74b83085",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "IACP99Manager"
          },
          {
            "name": "completeValidatorWeightUpdate",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "nonce",
                "type": "uint64"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorWeightUpdate(\n        uint32 messageIndex\n    ) external returns (bytes32 validationID, uint64 nonce);",
            "startLine": 169,
            "signature": "completeValidatorWeightUpdate(uint32)",
            "selector": "0x38c6bf02",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "IACP99Manager"
          },
          {
            "name": "subnetID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function subnetID() external view returns (bytes32 id);",
            "startLine": 174,
            "signature": "subnetID()",
            "selector": "0x4dbc7fc7",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "IACP99Manager"
          },
          {
            "name": "getValidator",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "validator",
                "type": "Validator"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getValidator(\n        bytes32 validationID\n    ) external view returns (Validator memory validator);",
            "startLine": 177,
            "signature": "getValidator(bytes32)",
            "selector": "0x6d91f46b",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "IACP99Manager"
          },
          {
            "name": "l1TotalWeight",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "weight",
                "type": "uint64"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function l1TotalWeight() external view returns (uint64 weight);",
            "startLine": 182,
            "signature": "l1TotalWeight()",
            "selector": "0x36c1df98",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "IACP99Manager"
          }
        ],
        "internalFunctions": [
          {
            "name": "_initiateValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "nodeID",
                "type": "bytes"
              },
              {
                "name": "blsPublicKey",
                "type": "bytes"
              },
              {
                "name": "remainingBalanceOwner",
                "type": "PChainOwner"
              },
              {
                "name": "disableOwner",
                "type": "PChainOwner"
              },
              {
                "name": "weight",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initiateValidatorRegistration(\n        bytes memory nodeID,\n        bytes memory blsPublicKey,\n        PChainOwner memory remainingBalanceOwner,\n        PChainOwner memory disableOwner,\n        uint64 weight\n    ) internal virtual returns (bytes32 validationID);",
            "startLine": 35,
            "visibility": "internal"
          },
          {
            "name": "_initiateValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initiateValidatorRemoval(\n        bytes32 validationID\n    ) internal virtual;",
            "startLine": 51,
            "visibility": "internal"
          },
          {
            "name": "_initiateValidatorWeightUpdate",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "weight",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "nonce",
                "type": "uint64"
              },
              {
                "name": "messageID",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initiateValidatorWeightUpdate(\n        bytes32 validationID,\n        uint64 weight\n    ) internal virtual returns (uint64 nonce, bytes32 messageID);",
            "startLine": 66,
            "visibility": "internal"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "ERC20TokenStakingManager",
        "kind": "contract",
        "category": "validator-manager",
        "filePath": "@validator-manager/ERC20TokenStakingManager.sol",
        "inherits": [
          "Initializable",
          "StakingManager"
        ],
        "implements": [
          "IERC20TokenStakingManager"
        ],
        "usesLibraries": [
          "SafeERC20",
          "SafeERC20TransferFrom"
        ],
        "imports": [
          {
            "name": "StakingManager",
            "path": "./StakingManager.sol",
            "isExternal": false
          },
          {
            "name": "StakingManagerSettings",
            "path": "./interfaces/IStakingManager.sol",
            "isExternal": false
          },
          {
            "name": "PChainOwner",
            "path": "./ACP99Manager.sol",
            "isExternal": false
          },
          {
            "name": "IERC20TokenStakingManager",
            "path": "./interfaces/IERC20TokenStakingManager.sol",
            "isExternal": false
          },
          {
            "name": "IERC20Mintable",
            "path": "./interfaces/IERC20Mintable.sol",
            "isExternal": false
          },
          {
            "name": "ICMInitializable",
            "path": "@utilities/ICMInitializable.sol",
            "isExternal": true
          },
          {
            "name": "SafeERC20TransferFrom",
            "path": "@utilities/SafeERC20TransferFrom.sol",
            "isExternal": true
          },
          {
            "name": "Initializable",
            "path": "@openzeppelin/contracts-upgradeable@5.0.2/proxy/utils/Initializable.sol",
            "isExternal": true
          },
          {
            "name": "SafeERC20",
            "path": "@openzeppelin/contracts@5.0.2/token/ERC20/utils/SafeERC20.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "initialize",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "StakingManagerSettings"
              },
              {
                "name": "token",
                "type": "IERC20Mintable"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ERC20TokenStakingManager_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initialize(\n        StakingManagerSettings calldata settings,\n        IERC20Mintable token\n    ) external initializer {\n        __ERC20TokenStakingManager_init(settings, token);\n    }",
            "startLine": 64,
            "signature": "initialize(StakingManagerSettings,IERC20Mintable)",
            "selector": "0x0ab6f2d9",
            "visibility": "external",
            "modifiers": [
              "initializer"
            ]
          },
          {
            "name": "initiateValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "nodeID",
                "type": "bytes"
              },
              {
                "name": "blsPublicKey",
                "type": "bytes"
              },
              {
                "name": "remainingBalanceOwner",
                "type": "PChainOwner"
              },
              {
                "name": "disableOwner",
                "type": "PChainOwner"
              },
              {
                "name": "delegationFeeBips",
                "type": "uint16"
              },
              {
                "name": "minStakeDuration",
                "type": "uint64"
              },
              {
                "name": "stakeAmount",
                "type": "uint256"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_initiateValidatorRegistration",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorRegistration(\n        bytes memory nodeID,\n        bytes memory blsPublicKey,\n        PChainOwner memory remainingBalanceOwner,\n        PChainOwner memory disableOwner,\n        uint16 delegationFeeBips,\n        uint64 minStakeDuration,\n        uint256 stakeAmount,\n        address rewardRecipient\n    ) external nonReentrant returns (bytes32) {\n        return _initiateValidatorRegistration({\n            nodeID: nodeID,\n            blsPublicKey: blsPublicKey,\n            remainingBalanceOwner: remainingBalanceOwner,\n            disableOwner: disableOwner,\n            delegationFeeBips: delegationFeeBips,\n            minStakeDuration: minStakeDuration,\n            stakeAmount: stakeAmount,\n            rewardRecipient: rewardRecipient\n        });\n    }",
            "startLine": 94,
            "signature": "initiateValidatorRegistration(bytes,bytes,PChainOwner,PChainOwner,uint16,uint64,uint256,address)",
            "selector": "0x015193e5",
            "visibility": "external",
            "modifiers": [
              "nonReentrant"
            ]
          },
          {
            "name": "initiateDelegatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "delegationAmount",
                "type": "uint256"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_initiateDelegatorRegistration",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateDelegatorRegistration(\n        bytes32 validationID,\n        uint256 delegationAmount,\n        address rewardRecipient\n    ) external nonReentrant returns (bytes32) {\n        return _initiateDelegatorRegistration(\n            validationID, _msgSender(), delegationAmount, rewardRecipient\n        );\n    }",
            "startLine": 119,
            "signature": "initiateDelegatorRegistration(bytes32,uint256,address)",
            "selector": "0x72ddb2d1",
            "visibility": "external",
            "modifiers": [
              "nonReentrant"
            ]
          },
          {
            "name": "erc20",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "IERC20Mintable"
              }
            ],
            "calls": [
              {
                "target": "_getERC20StakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function erc20() external view returns (IERC20Mintable) {\n        return _getERC20StakingManagerStorage()._token;\n    }",
            "startLine": 132,
            "signature": "erc20()",
            "selector": "0x59179deb",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "submitUptimeProof",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_isPoSValidator",
                "type": "internal"
              },
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_updateUptime",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function submitUptimeProof(bytes32 validationID, uint32 messageIndex) external {\n        if (!_isPoSValidator(validationID)) {\n            revert ValidatorNotPoS(validationID);\n        }\n        ValidatorStatus status =\n            _getStakingManagerStorage()._manager.getValidator(validationID).status;\n        if (status != ValidatorStatus.Active) {\n            revert InvalidValidatorStatus(status);\n        }\n\n        // Uptime proofs include the absolute number of seconds the validator has been active.\n        _updateUptime(validationID, messageIndex);\n    }",
            "startLine": 198,
            "signature": "submitUptimeProof(bytes32,uint32)",
            "selector": "0x4d54664a",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "claimDelegationFees",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_withdrawValidationRewards",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function claimDelegationFees(\n        bytes32 validationID\n    ) external {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        ValidatorStatus status = $._manager.getValidator(validationID).status;\n        if (status != ValidatorStatus.Completed) {\n            revert InvalidValidatorStatus(status);\n        }\n\n        if ($._posValidatorInfo[validationID].owner != _msgSender()) {\n            revert UnauthorizedOwner(_msgSender());\n        }\n\n        address rewardRecipient = $._rewardRecipients[validationID];\n\n        if (rewardRecipient == address(0)) {\n            rewardRecipient = $._posValidatorInfo[validationID].owner;\n        }\n\n        _withdrawValidationRewards(rewardRecipient, validationID);\n    }",
            "startLine": 215,
            "signature": "claimDelegationFees(bytes32)",
            "selector": "0x363501aa",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "initiateValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiateValidatorRemovalWithCheck",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorRemoval(\n        bytes32 validationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) external {\n        _initiateValidatorRemovalWithCheck(validationID, includeUptimeProof, messageIndex);\n    }",
            "startLine": 241,
            "signature": "initiateValidatorRemoval(bytes32,bool,uint32)",
            "selector": "0x72bceec5",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "forceInitiateValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiatePoSValidatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function forceInitiateValidatorRemoval(\n        bytes32 validationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) external {\n        // Ignore the return value here to force end validation, regardless of possible missed rewards\n        _initiatePoSValidatorRemoval(validationID, includeUptimeProof, messageIndex);\n    }",
            "startLine": 262,
            "signature": "forceInitiateValidatorRemoval(bytes32,bool,uint32)",
            "selector": "0x7475aa66",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "changeValidatorRewardRecipient",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "ValidatorRewardRecipientChanged"
            ],
            "isVirtual": false,
            "sourceCode": "function changeValidatorRewardRecipient(\n        bytes32 validationID,\n        address rewardRecipient\n    ) external {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        if (rewardRecipient == address(0)) {\n            revert InvalidRewardRecipient(rewardRecipient);\n        }\n\n        if ($._posValidatorInfo[validationID].owner != _msgSender()) {\n            revert UnauthorizedOwner(_msgSender());\n        }\n\n        address currentRecipient = $._rewardRecipients[validationID];\n        $._rewardRecipients[validationID] = rewardRecipient;\n\n        emit ValidatorRewardRecipientChanged(validationID, rewardRecipient, currentRecipient);\n    }",
            "startLine": 274,
            "signature": "changeValidatorRewardRecipient(bytes32,address)",
            "selector": "0x08b86a89",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "changeDelegatorRewardRecipient",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "DelegatorRewardRecipientChanged"
            ],
            "isVirtual": false,
            "sourceCode": "function changeDelegatorRewardRecipient(\n        bytes32 delegationID,\n        address rewardRecipient\n    ) external {\n        if (rewardRecipient == address(0)) {\n            revert InvalidRewardRecipient(rewardRecipient);\n        }\n\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        if ($._delegatorStakes[delegationID].owner != _msgSender()) {\n            revert UnauthorizedOwner(_msgSender());\n        }\n\n        address currentRecipient = $._delegatorRewardRecipients[delegationID];\n        $._delegatorRewardRecipients[delegationID] = rewardRecipient;\n\n        emit DelegatorRewardRecipientChanged(delegationID, rewardRecipient, currentRecipient);\n    }",
            "startLine": 297,
            "signature": "changeDelegatorRewardRecipient(bytes32,address)",
            "selector": "0x26295ae8",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "completeValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_isPoSValidator",
                "type": "internal"
              },
              {
                "target": "_withdrawValidationRewards",
                "type": "internal"
              },
              {
                "target": "_unlock",
                "type": "internal"
              },
              {
                "target": "weightToValue",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorRemoval(\n        uint32 messageIndex\n    ) external nonReentrant returns (bytes32) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        // Check if the validator has been already been removed from the validator manager.\n        bytes32 validationID = $._manager.completeValidatorRemoval(messageIndex);\n        Validator memory validator = $._manager.getValidator(validationID);\n\n        // Return now if this was originally a PoA validator that was later migrated to this PoS manager,\n        // or the validator was part of the initial validator set.\n        if (!_isPoSValidator(validationID)) {\n            return validationID;\n        }\n\n        address owner = $._posValidatorInfo[validationID].owner;\n        address rewardRecipient = $._rewardRecipients[validationID];\n\n        // the reward-recipient should always be set, but just in case it isn't, we won't burn the reward\n        if (rewardRecipient == address(0)) {\n            rewardRecipient = owner;\n        }\n\n        // The validator can either be Completed or Invalidated here. We only grant rewards for Completed.\n        if (validator.status == ValidatorStatus.Completed) {\n            _withdrawValidationRewards(rewardRecipient, validationID);\n        }\n\n        // The stake is unlocked whether the validation period is completed or invalidated.\n        _unlock(owner, weightToValue(validator.startingWeight));\n\n        return validationID;\n    }",
            "startLine": 378,
            "signature": "completeValidatorRemoval(uint32)",
            "selector": "0x74b83085",
            "visibility": "external",
            "modifiers": [
              "nonReentrant"
            ],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "completeValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorRegistration(\n        uint32 messageIndex\n    ) external returns (bytes32) {\n        return _getStakingManagerStorage()._manager.completeValidatorRegistration(messageIndex);\n    }",
            "startLine": 520,
            "signature": "completeValidatorRegistration(uint32)",
            "selector": "0x5442dda6",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "valueToWeight",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function valueToWeight(\n        uint256 value\n    ) public view returns (uint64) {\n        uint256 weight = value / _getStakingManagerStorage()._weightToValueFactor;\n        if (weight == 0 || weight > type(uint64).max) {\n            revert InvalidStakeAmount(value);\n        }\n        return uint64(weight);\n    }",
            "startLine": 530,
            "signature": "valueToWeight(uint256)",
            "selector": "0x2bf991d4",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "weightToValue",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "weight",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function weightToValue(\n        uint64 weight\n    ) public view returns (uint256) {\n        return uint256(weight) * _getStakingManagerStorage()._weightToValueFactor;\n    }",
            "startLine": 544,
            "signature": "weightToValue(uint64)",
            "selector": "0x37041e87",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "getStakingManagerSettings",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "StakingManagerSettings"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getStakingManagerSettings() public view returns (StakingManagerSettings memory) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        return StakingManagerSettings({\n            manager: $._manager,\n            minimumStakeAmount: $._minimumStakeAmount,\n            maximumStakeAmount: $._maximumStakeAmount,\n            minimumStakeDuration: $._minimumStakeDuration,\n            minimumDelegationFeeBips: $._minimumDelegationFeeBips,\n            maximumStakeMultiplier: uint8($._maximumStakeMultiplier),\n            weightToValueFactor: $._weightToValueFactor,\n            rewardCalculator: $._rewardCalculator,\n            uptimeBlockchainID: $._uptimeBlockchainID\n        });\n    }",
            "startLine": 553,
            "signature": "getStakingManagerSettings()",
            "selector": "0x6805e870",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "getStakingValidator",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "PoSValidatorInfo"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getStakingValidator(\n        bytes32 validationID\n    ) public view returns (PoSValidatorInfo memory) {\n        return _getStakingManagerStorage()._posValidatorInfo[validationID];\n    }",
            "startLine": 572,
            "signature": "getStakingValidator(bytes32)",
            "selector": "0x0b958a2a",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "getValidatorRewardInfo",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getValidatorRewardInfo(\n        bytes32 validationID\n    ) public view returns (address, uint256) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        return ($._rewardRecipients[validationID], $._redeemableValidatorRewards[validationID]);\n    }",
            "startLine": 583,
            "signature": "getValidatorRewardInfo(bytes32)",
            "selector": "0x1198b36e",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "getDelegatorInfo",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "Delegator"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getDelegatorInfo(\n        bytes32 delegationID\n    ) public view returns (Delegator memory) {\n        return _getStakingManagerStorage()._delegatorStakes[delegationID];\n    }",
            "startLine": 593,
            "signature": "getDelegatorInfo(bytes32)",
            "selector": "0x7f07e78c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "getDelegatorRewardInfo",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getDelegatorRewardInfo(\n        bytes32 delegationID\n    ) public view returns (address, uint256) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        return (\n            $._delegatorRewardRecipients[delegationID], $._redeemableDelegatorRewards[delegationID]\n        );\n    }",
            "startLine": 604,
            "signature": "getDelegatorRewardInfo(bytes32)",
            "selector": "0x149215a3",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "completeDelegatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_completeDelegatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [
              "CompletedDelegatorRegistration"
            ],
            "isVirtual": false,
            "sourceCode": "function completeDelegatorRegistration(bytes32 delegationID, uint32 messageIndex) external {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        Delegator memory delegator = $._delegatorStakes[delegationID];\n        bytes32 validationID = delegator.validationID;\n        Validator memory validator = $._manager.getValidator(validationID);\n\n        // Ensure the delegator is pending added. Since anybody can call this function once\n        // delegator registration has been initiated, we need to make sure that this function is only\n        // callable after that has been done.\n        if (delegator.status != DelegatorStatus.PendingAdded) {\n            revert InvalidDelegatorStatus(delegator.status);\n        }\n\n        // In the case where the validator has completed its validation period, we can no\n        // longer stake and should move our status directly to completed and return the stake.\n        if (validator.status == ValidatorStatus.Completed) {\n            return _completeDelegatorRemoval(delegationID);\n        }\n\n        // If we've already received a weight update with a nonce greater than the delegation's starting nonce,\n        // then there's no requirement to include an ICM message in this function call.\n        if (validator.receivedNonce < delegator.startingNonce) {\n            (bytes32 messageValidationID, uint64 nonce) =\n                $._manager.completeValidatorWeightUpdate(messageIndex);\n\n            if (validationID != messageValidationID) {\n                revert UnexpectedValidationID(messageValidationID, validationID);\n            }\n            if (nonce < delegator.startingNonce) {\n                revert InvalidNonce(nonce);\n            }\n        }\n\n        // Update the delegation status\n        $._delegatorStakes[delegationID].status = DelegatorStatus.Active;\n        $._delegatorStakes[delegationID].startTime = uint64(block.timestamp);\n\n        emit CompletedDelegatorRegistration({\n            delegationID: delegationID,\n            validationID: validationID,\n            startTime: uint64(block.timestamp)\n        });\n    }",
            "startLine": 697,
            "signature": "completeDelegatorRegistration(bytes32,uint32)",
            "selector": "0x7ac53d57",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "initiateDelegatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiateDelegatorRemovalWithCheck",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateDelegatorRemoval(\n        bytes32 delegationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) external {\n        _initiateDelegatorRemovalWithCheck(delegationID, includeUptimeProof, messageIndex);\n    }",
            "startLine": 745,
            "signature": "initiateDelegatorRemoval(bytes32,bool,uint32)",
            "selector": "0x66f514b6",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "forceInitiateDelegatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiateDelegatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function forceInitiateDelegatorRemoval(\n        bytes32 delegationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) external {\n        // Ignore the return value here to force end delegation, regardless of possible missed rewards\n        _initiateDelegatorRemoval(delegationID, includeUptimeProof, messageIndex);\n    }",
            "startLine": 766,
            "signature": "forceInitiateDelegatorRemoval(bytes32,bool,uint32)",
            "selector": "0x7fc27b8b",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "resendUpdateDelegator",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "WARP_MESSENGER.sendWarpMessage",
                "type": "library"
              },
              {
                "target": "ValidatorMessages.packL1ValidatorWeightMessage",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function resendUpdateDelegator(\n        bytes32 delegationID\n    ) external {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        Delegator memory delegator = $._delegatorStakes[delegationID];\n        if (\n            delegator.status != DelegatorStatus.PendingAdded\n                && delegator.status != DelegatorStatus.PendingRemoved\n        ) {\n            revert InvalidDelegatorStatus(delegator.status);\n        }\n\n        Validator memory validator = $._manager.getValidator(delegator.validationID);\n        if (validator.sentNonce == 0) {\n            // Should be unreachable.\n            revert InvalidDelegationID(delegationID);\n        }\n\n        // Submit the message to the Warp precompile.\n        WARP_MESSENGER.sendWarpMessage(\n            ValidatorMessages.packL1ValidatorWeightMessage(\n                delegator.validationID, validator.sentNonce, validator.weight\n            )\n        );\n    }",
            "startLine": 902,
            "signature": "resendUpdateDelegator(bytes32)",
            "selector": "0x28f303d8",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "completeDelegatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_completeDelegatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeDelegatorRemoval(\n        bytes32 delegationID,\n        uint32 messageIndex\n    ) external nonReentrant {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        Delegator memory delegator = $._delegatorStakes[delegationID];\n\n        // Ensure the delegator is pending removed. Since anybody can call this function once\n        // end delegation has been initiated, we need to make sure that this function is only\n        // callable after that has been done.\n        if (delegator.status != DelegatorStatus.PendingRemoved) {\n            revert InvalidDelegatorStatus(delegator.status);\n        }\n        Validator memory validator = $._manager.getValidator(delegator.validationID);\n\n        // We only expect an ICM message if we haven't received a weight update with a nonce greater than the delegation's ending nonce\n        if (\n            $._manager.getValidator(delegator.validationID).status != ValidatorStatus.Completed\n                && validator.receivedNonce < delegator.endingNonce\n        ) {\n            (bytes32 validationID, uint64 nonce) =\n                $._manager.completeValidatorWeightUpdate(messageIndex);\n            if (delegator.validationID != validationID) {\n                revert UnexpectedValidationID(validationID, delegator.validationID);\n            }\n\n            // The received nonce should be at least as high as the delegation's ending nonce. This allows a weight\n            // update using a higher nonce (which implicitly includes the delegation's weight update) to be used to\n            // complete delisting for an earlier delegation. This is necessary because the P-Chain is only willing\n            // to sign the latest weight update.\n            if (delegator.endingNonce > nonce) {\n                revert InvalidNonce(nonce);\n            }\n        }\n\n        _completeDelegatorRemoval(delegationID);\n    }",
            "startLine": 932,
            "signature": "completeDelegatorRemoval(bytes32,uint32)",
            "selector": "0x702b3fb8",
            "visibility": "external",
            "modifiers": [
              "nonReentrant"
            ],
            "inheritedFrom": "StakingManager"
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC20StakingManagerStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC20TokenStakingManagerStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getERC20StakingManagerStorage()\n        private\n        pure\n        returns (ERC20TokenStakingManagerStorage storage $)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := ERC20_STAKING_MANAGER_STORAGE_LOCATION\n        }\n    }",
            "startLine": 40,
            "visibility": "private"
          },
          {
            "name": "__ERC20TokenStakingManager_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "StakingManagerSettings"
              },
              {
                "name": "token",
                "type": "IERC20Mintable"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__StakingManager_init",
                "type": "internal"
              },
              {
                "target": "__ERC20TokenStakingManager_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20TokenStakingManager_init(\n        StakingManagerSettings calldata settings,\n        IERC20Mintable token\n    ) internal onlyInitializing {\n        __StakingManager_init(settings);\n        __ERC20TokenStakingManager_init_unchained(token);\n    }",
            "startLine": 72,
            "visibility": "internal"
          },
          {
            "name": "__ERC20TokenStakingManager_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20Mintable"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20StakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20TokenStakingManager_init_unchained(\n        IERC20Mintable token\n    ) internal onlyInitializing {\n        ERC20TokenStakingManagerStorage storage $ = _getERC20StakingManagerStorage();\n        if (address(token) == address(0)) {\n            revert ZeroAddress();\n        }\n        $._token = token;\n    }",
            "startLine": 81,
            "visibility": "internal"
          },
          {
            "name": "_lock",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20StakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _lock(\n        uint256 value\n    ) internal virtual override returns (uint256) {\n        return _getERC20StakingManagerStorage()._token.safeTransferFrom(value);\n    }",
            "startLine": 140,
            "visibility": "internal"
          },
          {
            "name": "_unlock",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20StakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _unlock(address to, uint256 value) internal virtual override {\n        _getERC20StakingManagerStorage()._token.safeTransfer(to, value);\n    }",
            "startLine": 150,
            "visibility": "internal"
          },
          {
            "name": "_reward",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20StakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _reward(address account, uint256 amount) internal virtual override {\n        ERC20TokenStakingManagerStorage storage $ = _getERC20StakingManagerStorage();\n        $._token.mint(account, amount);\n    }",
            "startLine": 157,
            "visibility": "internal"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getStakingManagerStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "StakingManagerStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getStakingManagerStorage() internal pure returns (StakingManagerStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := STAKING_MANAGER_STORAGE_LOCATION\n        }\n    }",
            "startLine": 117,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "__StakingManager_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "StakingManagerSettings"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ReentrancyGuard_init",
                "type": "internal"
              },
              {
                "target": "__StakingManager_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __StakingManager_init(\n        StakingManagerSettings calldata settings\n    ) internal onlyInitializing {\n        __ReentrancyGuard_init();\n        __StakingManager_init_unchained({\n            manager: settings.manager,\n            minimumStakeAmount: settings.minimumStakeAmount,\n            maximumStakeAmount: settings.maximumStakeAmount,\n            minimumStakeDuration: settings.minimumStakeDuration,\n            minimumDelegationFeeBips: settings.minimumDelegationFeeBips,\n            maximumStakeMultiplier: settings.maximumStakeMultiplier,\n            weightToValueFactor: settings.weightToValueFactor,\n            rewardCalculator: settings.rewardCalculator,\n            uptimeBlockchainID: settings.uptimeBlockchainID\n        });\n    }",
            "startLine": 125,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "__StakingManager_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "manager",
                "type": "IValidatorManager"
              },
              {
                "name": "minimumStakeAmount",
                "type": "uint256"
              },
              {
                "name": "maximumStakeAmount",
                "type": "uint256"
              },
              {
                "name": "minimumStakeDuration",
                "type": "uint64"
              },
              {
                "name": "minimumDelegationFeeBips",
                "type": "uint16"
              },
              {
                "name": "maximumStakeMultiplier",
                "type": "uint8"
              },
              {
                "name": "weightToValueFactor",
                "type": "uint256"
              },
              {
                "name": "rewardCalculator",
                "type": "IRewardCalculator"
              },
              {
                "name": "uptimeBlockchainID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "manager.getChurnPeriodSeconds",
                "type": "external"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __StakingManager_init_unchained(\n        IValidatorManager manager,\n        uint256 minimumStakeAmount,\n        uint256 maximumStakeAmount,\n        uint64 minimumStakeDuration,\n        uint16 minimumDelegationFeeBips,\n        uint8 maximumStakeMultiplier,\n        uint256 weightToValueFactor,\n        IRewardCalculator rewardCalculator,\n        bytes32 uptimeBlockchainID\n    ) internal onlyInitializing {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        if (minimumDelegationFeeBips == 0 || minimumDelegationFeeBips > MAXIMUM_DELEGATION_FEE_BIPS)\n        {\n            revert InvalidDelegationFee(minimumDelegationFeeBips);\n        }\n        if (minimumStakeAmount > maximumStakeAmount) {\n            revert InvalidStakeAmount(minimumStakeAmount);\n        }\n        if (maximumStakeMultiplier == 0 || maximumStakeMultiplier > MAXIMUM_STAKE_MULTIPLIER_LIMIT)\n        {\n            revert InvalidStakeMultiplier(maximumStakeMultiplier);\n        }\n        if (address(manager) == address(0)) {\n            revert ZeroAddress();\n        }\n        if (address(rewardCalculator) == address(0)) {\n            revert ZeroAddress();\n        }\n\n        // Minimum stake duration should be at least one churn period in order to prevent churn tracker abuse.\n        if (minimumStakeDuration < manager.getChurnPeriodSeconds()) {\n            revert InvalidMinStakeDuration(minimumStakeDuration);\n        }\n        if (weightToValueFactor == 0) {\n            revert ZeroWeightToValueFactor();\n        }\n        if (uptimeBlockchainID == bytes32(0)) {\n            revert InvalidUptimeBlockchainID(uptimeBlockchainID);\n        }\n\n        $._manager = manager;\n        $._minimumStakeAmount = minimumStakeAmount;\n        $._maximumStakeAmount = maximumStakeAmount;\n        $._minimumStakeDuration = minimumStakeDuration;\n        $._minimumDelegationFeeBips = minimumDelegationFeeBips;\n        $._maximumStakeMultiplier = maximumStakeMultiplier;\n        $._weightToValueFactor = weightToValueFactor;\n        $._rewardCalculator = rewardCalculator;\n        $._uptimeBlockchainID = uptimeBlockchainID;\n    }",
            "startLine": 143,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_initiateValidatorRemovalWithCheck",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiatePoSValidatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _initiateValidatorRemovalWithCheck(\n        bytes32 validationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) internal {\n        if (!_initiatePoSValidatorRemoval(validationID, includeUptimeProof, messageIndex)) {\n            revert ValidatorIneligibleForRewards(validationID);\n        }\n    }",
            "startLine": 249,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_initiatePoSValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_isPoSValidator",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_updateUptime",
                "type": "internal"
              },
              {
                "target": "weightToValue",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _initiatePoSValidatorRemoval(\n        bytes32 validationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) internal returns (bool) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        $._manager.initiateValidatorRemoval(validationID);\n\n        // The validator must be fetched after the removal has been initiated, since the above call modifies\n        // the validator's state.\n        Validator memory validator = $._manager.getValidator(validationID);\n\n        // Non-PoS validators are required to boostrap the network, but are not eligible for rewards.\n        if (!_isPoSValidator(validationID)) {\n            return true;\n        }\n\n        // PoS validations can only be ended by their owners.\n        if ($._posValidatorInfo[validationID].owner != _msgSender()) {\n            revert UnauthorizedOwner(_msgSender());\n        }\n\n        // Check that minimum stake duration has passed.\n        if (\n            validator.endTime\n                < validator.startTime + $._posValidatorInfo[validationID].minStakeDuration\n        ) {\n            revert MinStakeDurationNotPassed(validator.endTime);\n        }\n\n        // Uptime proofs include the absolute number of seconds the validator has been active.\n        uint64 uptimeSeconds;\n        if (includeUptimeProof) {\n            uptimeSeconds = _updateUptime(validationID, messageIndex);\n        } else {\n            uptimeSeconds = $._posValidatorInfo[validationID].uptimeSeconds;\n        }\n\n        uint256 reward = $._rewardCalculator.calculateReward({\n            stakeAmount: weightToValue(validator.startingWeight),\n            validatorStartTime: validator.startTime,\n            stakingStartTime: validator.startTime,\n            stakingEndTime: validator.endTime,\n            uptimeSeconds: uptimeSeconds\n        });\n\n        $._redeemableValidatorRewards[validationID] += reward;\n\n        return (reward > 0);\n    }",
            "startLine": 322,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_updateUptime",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "WARP_MESSENGER.getVerifiedWarpMessage",
                "type": "library"
              },
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "ValidatorMessages.unpackValidationUptimeMessage",
                "type": "library"
              }
            ],
            "emits": [
              "UptimeUpdated"
            ],
            "isVirtual": false,
            "sourceCode": "function _updateUptime(bytes32 validationID, uint32 messageIndex) internal returns (uint64) {\n        (WarpMessage memory warpMessage, bool valid) =\n            WARP_MESSENGER.getVerifiedWarpMessage(messageIndex);\n        if (!valid) {\n            revert InvalidWarpMessage();\n        }\n\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        // The uptime proof must be from the specifed uptime blockchain\n        if (warpMessage.sourceChainID != $._uptimeBlockchainID) {\n            revert InvalidWarpSourceChainID(warpMessage.sourceChainID);\n        }\n\n        // The sender is required to be the zero address so that we know the validator node\n        // signed the proof directly, rather than as an arbitrary on-chain message\n        if (warpMessage.originSenderAddress != address(0)) {\n            revert InvalidWarpOriginSenderAddress(warpMessage.originSenderAddress);\n        }\n\n        (bytes32 uptimeValidationID, uint64 uptime) =\n            ValidatorMessages.unpackValidationUptimeMessage(warpMessage.payload);\n        if (validationID != uptimeValidationID) {\n            revert UnexpectedValidationID(uptimeValidationID, validationID);\n        }\n\n        if (uptime > $._posValidatorInfo[validationID].uptimeSeconds) {\n            $._posValidatorInfo[validationID].uptimeSeconds = uptime;\n            emit UptimeUpdated(validationID, uptime);\n        } else {\n            uptime = $._posValidatorInfo[validationID].uptimeSeconds;\n        }\n\n        return uptime;\n    }",
            "startLine": 416,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_initiateValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "nodeID",
                "type": "bytes"
              },
              {
                "name": "blsPublicKey",
                "type": "bytes"
              },
              {
                "name": "remainingBalanceOwner",
                "type": "PChainOwner"
              },
              {
                "name": "disableOwner",
                "type": "PChainOwner"
              },
              {
                "name": "delegationFeeBips",
                "type": "uint16"
              },
              {
                "name": "minStakeDuration",
                "type": "uint64"
              },
              {
                "name": "stakeAmount",
                "type": "uint256"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_lock",
                "type": "internal"
              },
              {
                "target": "valueToWeight",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "InitiatedStakingValidatorRegistration"
            ],
            "isVirtual": true,
            "sourceCode": "function _initiateValidatorRegistration(\n        bytes memory nodeID,\n        bytes memory blsPublicKey,\n        PChainOwner memory remainingBalanceOwner,\n        PChainOwner memory disableOwner,\n        uint16 delegationFeeBips,\n        uint64 minStakeDuration,\n        uint256 stakeAmount,\n        address rewardRecipient\n    ) internal virtual returns (bytes32) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        // Validate and save the validator requirements\n        if (\n            delegationFeeBips < $._minimumDelegationFeeBips\n                || delegationFeeBips > MAXIMUM_DELEGATION_FEE_BIPS\n        ) {\n            revert InvalidDelegationFee(delegationFeeBips);\n        }\n\n        if (minStakeDuration < $._minimumStakeDuration) {\n            revert InvalidMinStakeDuration(minStakeDuration);\n        }\n\n        // Ensure the weight is within the valid range.\n        if (stakeAmount < $._minimumStakeAmount || stakeAmount > $._maximumStakeAmount) {\n            revert InvalidStakeAmount(stakeAmount);\n        }\n\n        if (rewardRecipient == address(0)) {\n            revert InvalidRewardRecipient(rewardRecipient);\n        }\n\n        // Lock the stake in the contract.\n        uint256 lockedValue = _lock(stakeAmount);\n\n        uint64 weight = valueToWeight(lockedValue);\n        bytes32 validationID = $._manager.initiateValidatorRegistration({\n            nodeID: nodeID,\n            blsPublicKey: blsPublicKey,\n            remainingBalanceOwner: remainingBalanceOwner,\n            disableOwner: disableOwner,\n            weight: weight\n        });\n\n        address owner = _msgSender();\n\n        $._posValidatorInfo[validationID].owner = owner;\n        $._posValidatorInfo[validationID].delegationFeeBips = delegationFeeBips;\n        $._posValidatorInfo[validationID].minStakeDuration = minStakeDuration;\n        $._posValidatorInfo[validationID].uptimeSeconds = 0;\n        $._rewardRecipients[validationID] = rewardRecipient;\n\n        emit InitiatedStakingValidatorRegistration(\n            validationID, owner, delegationFeeBips, minStakeDuration, rewardRecipient\n        );\n\n        return validationID;\n    }",
            "startLine": 458,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_initiateDelegatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "delegatorAddress",
                "type": "address"
              },
              {
                "name": "delegationAmount",
                "type": "uint256"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "valueToWeight",
                "type": "internal"
              },
              {
                "target": "_lock",
                "type": "internal"
              },
              {
                "target": "_isPoSValidator",
                "type": "internal"
              }
            ],
            "emits": [
              "InitiatedDelegatorRegistration"
            ],
            "isVirtual": false,
            "sourceCode": "function _initiateDelegatorRegistration(\n        bytes32 validationID,\n        address delegatorAddress,\n        uint256 delegationAmount,\n        address rewardRecipient\n    ) internal returns (bytes32) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        uint64 weight = valueToWeight(_lock(delegationAmount));\n\n        // Check that the validation ID is a PoS validator\n        if (!_isPoSValidator(validationID)) {\n            revert ValidatorNotPoS(validationID);\n        }\n\n        if (rewardRecipient == address(0)) {\n            revert InvalidRewardRecipient(rewardRecipient);\n        }\n\n        // Update the validator weight\n        uint64 newValidatorWeight;\n        {\n            Validator memory validator = $._manager.getValidator(validationID);\n            newValidatorWeight = validator.weight + weight;\n            if (newValidatorWeight > validator.startingWeight * $._maximumStakeMultiplier) {\n                revert MaxWeightExceeded(newValidatorWeight);\n            }\n        }\n\n        (uint64 nonce, bytes32 messageID) =\n            $._manager.initiateValidatorWeightUpdate(validationID, newValidatorWeight);\n\n        bytes32 delegationID = keccak256(abi.encodePacked(validationID, nonce));\n        // Store the delegation information. Set the delegator status to pending added,\n        // so that it can be properly started in the complete step, even if the delivered\n        // nonce is greater than the nonce used to initiate registration.\n        $._delegatorStakes[delegationID].status = DelegatorStatus.PendingAdded;\n        $._delegatorStakes[delegationID].owner = delegatorAddress;\n        $._delegatorStakes[delegationID].validationID = validationID;\n        $._delegatorStakes[delegationID].weight = weight;\n        $._delegatorStakes[delegationID].startTime = 0;\n        $._delegatorStakes[delegationID].startingNonce = nonce;\n        $._delegatorStakes[delegationID].endingNonce = 0;\n        $._delegatorRewardRecipients[delegationID] = rewardRecipient;\n\n        emit InitiatedDelegatorRegistration({\n            delegationID: delegationID,\n            validationID: validationID,\n            delegatorAddress: delegatorAddress,\n            nonce: nonce,\n            validatorWeight: newValidatorWeight,\n            delegatorWeight: weight,\n            setWeightMessageID: messageID,\n            rewardRecipient: rewardRecipient\n        });\n        return delegationID;\n    }",
            "startLine": 636,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_initiateDelegatorRemovalWithCheck",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiateDelegatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _initiateDelegatorRemovalWithCheck(\n        bytes32 delegationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) internal {\n        if (!_initiateDelegatorRemoval(delegationID, includeUptimeProof, messageIndex)) {\n            revert DelegatorIneligibleForRewards(delegationID);\n        }\n    }",
            "startLine": 753,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_initiateDelegatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_updateUptime",
                "type": "internal"
              },
              {
                "target": "_calculateAndSetDelegationReward",
                "type": "internal"
              },
              {
                "target": "_completeDelegatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [
              "InitiatedDelegatorRemoval"
            ],
            "isVirtual": false,
            "sourceCode": "function _initiateDelegatorRemoval(\n        bytes32 delegationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) internal returns (bool) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        Delegator memory delegator = $._delegatorStakes[delegationID];\n        bytes32 validationID = delegator.validationID;\n        Validator memory validator = $._manager.getValidator(validationID);\n\n        // Ensure the delegator is active\n        if (delegator.status != DelegatorStatus.Active) {\n            revert InvalidDelegatorStatus(delegator.status);\n        }\n\n        // Only the delegation owner or parent validator can end the delegation.\n        if (delegator.owner != _msgSender()) {\n            // Validators can only remove delegations after the minimum stake duration has passed.\n            if ($._posValidatorInfo[validationID].owner != _msgSender()) {\n                revert UnauthorizedOwner(_msgSender());\n            }\n\n            if (\n                block.timestamp\n                    < validator.startTime + $._posValidatorInfo[validationID].minStakeDuration\n            ) {\n                revert MinStakeDurationNotPassed(uint64(block.timestamp));\n            }\n        }\n\n        address rewardRecipient = $._delegatorRewardRecipients[delegationID];\n        if (validator.status == ValidatorStatus.Active) {\n            // Check that minimum stake duration has passed.\n            if (block.timestamp < delegator.startTime + $._minimumStakeDuration) {\n                revert MinStakeDurationNotPassed(uint64(block.timestamp));\n            }\n\n            if (includeUptimeProof) {\n                // Uptime proofs include the absolute number of seconds the validator has been active.\n                _updateUptime(validationID, messageIndex);\n            }\n\n            // Set the delegator status to pending removed, so that it can be properly removed in\n            // the complete step, even if the delivered nonce is greater than the nonce used to\n            // initiate the removal.\n            $._delegatorStakes[delegationID].status = DelegatorStatus.PendingRemoved;\n\n            ($._delegatorStakes[delegationID].endingNonce,) = $\n                ._manager\n                .initiateValidatorWeightUpdate(validationID, validator.weight - delegator.weight);\n\n            uint256 reward =\n                _calculateAndSetDelegationReward(delegator, rewardRecipient, delegationID);\n\n            emit InitiatedDelegatorRemoval({delegationID: delegationID, validationID: validationID});\n            return (reward > 0);\n        } else if (validator.status == ValidatorStatus.Completed) {\n            _calculateAndSetDelegationReward(delegator, rewardRecipient, delegationID);\n            _completeDelegatorRemoval(delegationID);\n            // If the validator has completed, then no further uptimes may be submitted, so we always\n            // end the delegation.\n            return true;\n        } else {\n            revert InvalidValidatorStatus(validator.status);\n        }\n    }",
            "startLine": 780,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_calculateAndSetDelegationReward",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegator",
                "type": "Delegator"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              },
              {
                "name": "delegationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "weightToValue",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _calculateAndSetDelegationReward(\n        Delegator memory delegator,\n        address rewardRecipient,\n        bytes32 delegationID\n    ) private returns (uint256) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        Validator memory validator = $._manager.getValidator(delegator.validationID);\n\n        uint64 delegationEndTime;\n        if (\n            validator.status == ValidatorStatus.PendingRemoved\n                || validator.status == ValidatorStatus.Completed\n        ) {\n            delegationEndTime = validator.endTime;\n        } else if (validator.status == ValidatorStatus.Active) {\n            delegationEndTime = uint64(block.timestamp);\n        } else {\n            // Should be unreachable.\n            revert InvalidValidatorStatus(validator.status);\n        }\n\n        // Only give rewards in the case that the delegation started before the validator exited.\n        if (delegationEndTime <= delegator.startTime) {\n            return 0;\n        }\n\n        uint256 reward = $._rewardCalculator.calculateReward({\n            stakeAmount: weightToValue(delegator.weight),\n            validatorStartTime: validator.startTime,\n            stakingStartTime: delegator.startTime,\n            stakingEndTime: delegationEndTime,\n            uptimeSeconds: $._posValidatorInfo[delegator.validationID].uptimeSeconds\n        });\n\n        if (rewardRecipient == address(0)) {\n            rewardRecipient = delegator.owner;\n        }\n\n        $._redeemableDelegatorRewards[delegationID] = reward;\n        $._delegatorRewardRecipients[delegationID] = rewardRecipient;\n\n        return reward;\n    }",
            "startLine": 852,
            "visibility": "private",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_completeDelegatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_withdrawDelegationRewards",
                "type": "internal"
              },
              {
                "target": "_unlock",
                "type": "internal"
              },
              {
                "target": "weightToValue",
                "type": "internal"
              }
            ],
            "emits": [
              "CompletedDelegatorRemoval"
            ],
            "isVirtual": false,
            "sourceCode": "function _completeDelegatorRemoval(\n        bytes32 delegationID\n    ) internal {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        Delegator memory delegator = $._delegatorStakes[delegationID];\n        bytes32 validationID = delegator.validationID;\n\n        // To prevent churn tracker abuse, check that one full churn period has passed,\n        // so a delegator may not stake twice in the same churn period.\n        if (block.timestamp < delegator.startTime + $._manager.getChurnPeriodSeconds()) {\n            revert MinStakeDurationNotPassed(uint64(block.timestamp));\n        }\n\n        // Once this function completes, the delegation is completed so we can clear it from state now.\n        delete $._delegatorStakes[delegationID];\n\n        address rewardRecipient = $._delegatorRewardRecipients[delegationID];\n        delete $._delegatorRewardRecipients[delegationID];\n\n        if (rewardRecipient == address(0)) {\n            rewardRecipient = delegator.owner;\n        }\n\n        (uint256 delegationRewards, uint256 validatorFees) =\n            _withdrawDelegationRewards(rewardRecipient, delegationID, validationID);\n\n        // Unlock the delegator's stake.\n        _unlock(delegator.owner, weightToValue(delegator.weight));\n\n        emit CompletedDelegatorRemoval(delegationID, validationID, delegationRewards, validatorFees);\n    }",
            "startLine": 970,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_isPoSValidator",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isPoSValidator(\n        bytes32 validationID\n    ) internal view returns (bool) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        return $._posValidatorInfo[validationID].owner != address(0);\n    }",
            "startLine": 1012,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_withdrawValidationRewards",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "rewardRecipient",
                "type": "address"
              },
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_reward",
                "type": "internal"
              }
            ],
            "emits": [
              "ValidatorRewardClaimed"
            ],
            "isVirtual": false,
            "sourceCode": "function _withdrawValidationRewards(address rewardRecipient, bytes32 validationID) internal {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        uint256 rewards = $._redeemableValidatorRewards[validationID];\n        delete $._redeemableValidatorRewards[validationID];\n\n        _reward(rewardRecipient, rewards);\n\n        emit ValidatorRewardClaimed(validationID, rewardRecipient, rewards);\n    }",
            "startLine": 1019,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_withdrawDelegationRewards",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "rewardRecipient",
                "type": "address"
              },
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_reward",
                "type": "internal"
              }
            ],
            "emits": [
              "DelegatorRewardClaimed"
            ],
            "isVirtual": false,
            "sourceCode": "function _withdrawDelegationRewards(\n        address rewardRecipient,\n        bytes32 delegationID,\n        bytes32 validationID\n    ) internal returns (uint256, uint256) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        uint256 delegationRewards;\n        uint256 validatorFees;\n\n        uint256 rewards = $._redeemableDelegatorRewards[delegationID];\n\n        if (rewards > 0) {\n            delete $._redeemableDelegatorRewards[delegationID];\n\n            validatorFees = (rewards * $._posValidatorInfo[validationID].delegationFeeBips)\n                / BIPS_CONVERSION_FACTOR;\n\n            // Allocate the delegation fees to the validator.\n            $._redeemableValidatorRewards[validationID] += validatorFees;\n\n            // Reward the remaining tokens to the delegator.\n            delegationRewards = rewards - validatorFees;\n            _reward(rewardRecipient, delegationRewards);\n\n            emit DelegatorRewardClaimed(delegationID, rewardRecipient, delegationRewards);\n        }\n\n        return (delegationRewards, validatorFees);\n    }",
            "startLine": 1030,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "__Context_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Context_init() internal onlyInitializing {\n    }",
            "startLine": 18,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "__Context_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Context_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 21,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "_msgSender",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }",
            "startLine": 23,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "_msgData",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }",
            "startLine": 27,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "_contextSuffixLength",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }",
            "startLine": 31,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "_getReentrancyGuardStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ReentrancyGuardStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }",
            "startLine": 49,
            "visibility": "private",
            "inheritedFrom": "ReentrancyGuardUpgradeable"
          },
          {
            "name": "__ReentrancyGuard_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "__ReentrancyGuard_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }",
            "startLine": 60,
            "visibility": "internal",
            "inheritedFrom": "ReentrancyGuardUpgradeable"
          },
          {
            "name": "__ReentrancyGuard_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }",
            "startLine": 64,
            "visibility": "internal",
            "inheritedFrom": "ReentrancyGuardUpgradeable"
          },
          {
            "name": "_nonReentrantBefore",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }",
            "startLine": 82,
            "visibility": "private",
            "inheritedFrom": "ReentrancyGuardUpgradeable"
          },
          {
            "name": "_nonReentrantAfter",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }",
            "startLine": 93,
            "visibility": "private",
            "inheritedFrom": "ReentrancyGuardUpgradeable"
          },
          {
            "name": "_reentrancyGuardEntered",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }",
            "startLine": 104,
            "visibility": "internal",
            "inheritedFrom": "ReentrancyGuardUpgradeable"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "ExampleRewardCalculator",
        "kind": "contract",
        "category": "validator-manager",
        "filePath": "@validator-manager/ExampleRewardCalculator.sol",
        "inherits": [],
        "implements": [
          "IRewardCalculator"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IRewardCalculator",
            "path": "./interfaces/IRewardCalculator.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "calculateReward",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "stakeAmount",
                "type": "uint256"
              },
              {
                "name": "validatorStartTime",
                "type": "uint64"
              },
              {
                "name": "stakingStartTime",
                "type": "uint64"
              },
              {
                "name": "stakingEndTime",
                "type": "uint64"
              },
              {
                "name": "uptimeSeconds",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function calculateReward(\n        uint256 stakeAmount,\n        uint64 validatorStartTime,\n        uint64 stakingStartTime,\n        uint64 stakingEndTime,\n        uint64 uptimeSeconds\n    ) external view returns (uint256) {\n        // Equivalent to uptimeSeconds/(validator.endTime - validator.startTime) < UPTIME_REWARDS_THRESHOLD_PERCENTAGE/100\n        // Rearranged to prevent integer division truncation.\n        if (\n            uptimeSeconds * 100\n                < (stakingEndTime - validatorStartTime) * UPTIME_REWARDS_THRESHOLD_PERCENTAGE\n        ) {\n            return 0;\n        }\n\n        return (stakeAmount * rewardBasisPoints * (stakingEndTime - stakingStartTime))\n            / SECONDS_IN_YEAR / BIPS_CONVERSION_FACTOR;\n    }",
            "startLine": 29,
            "signature": "calculateReward(uint256,uint64,uint64,uint64,uint64)",
            "selector": "0x449215dd",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": []
      },
      {
        "name": "NativeTokenStakingManager",
        "kind": "contract",
        "category": "validator-manager",
        "filePath": "@validator-manager/NativeTokenStakingManager.sol",
        "inherits": [
          "Initializable",
          "StakingManager"
        ],
        "implements": [
          "INativeTokenStakingManager"
        ],
        "usesLibraries": [
          "Address"
        ],
        "imports": [
          {
            "name": "StakingManager",
            "path": "./StakingManager.sol",
            "isExternal": false
          },
          {
            "name": "StakingManagerSettings",
            "path": "./interfaces/IStakingManager.sol",
            "isExternal": false
          },
          {
            "name": "PChainOwner",
            "path": "./ACP99Manager.sol",
            "isExternal": false
          },
          {
            "name": "INativeTokenStakingManager",
            "path": "./interfaces/INativeTokenStakingManager.sol",
            "isExternal": false
          },
          {
            "name": "INativeMinter",
            "path": "@subnet-evm/INativeMinter.sol",
            "isExternal": true
          },
          {
            "name": "ICMInitializable",
            "path": "@utilities/ICMInitializable.sol",
            "isExternal": true
          },
          {
            "name": "Address",
            "path": "@openzeppelin/contracts@5.0.2/utils/Address.sol",
            "isExternal": true
          },
          {
            "name": "Initializable",
            "path": "@openzeppelin/contracts-upgradeable@5.0.2/proxy/utils/Initializable.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "initialize",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "StakingManagerSettings"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__NativeTokenStakingManager_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initialize(\n        StakingManagerSettings calldata settings\n    ) external initializer {\n        __NativeTokenStakingManager_init(settings);\n    }",
            "startLine": 42,
            "signature": "initialize(StakingManagerSettings)",
            "selector": "0x71c6aea8",
            "visibility": "external",
            "modifiers": [
              "initializer"
            ]
          },
          {
            "name": "initiateValidatorRegistration",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "nodeID",
                "type": "bytes"
              },
              {
                "name": "blsPublicKey",
                "type": "bytes"
              },
              {
                "name": "remainingBalanceOwner",
                "type": "PChainOwner"
              },
              {
                "name": "disableOwner",
                "type": "PChainOwner"
              },
              {
                "name": "delegationFeeBips",
                "type": "uint16"
              },
              {
                "name": "minStakeDuration",
                "type": "uint64"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_initiateValidatorRegistration",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorRegistration(\n        bytes memory nodeID,\n        bytes memory blsPublicKey,\n        PChainOwner memory remainingBalanceOwner,\n        PChainOwner memory disableOwner,\n        uint16 delegationFeeBips,\n        uint64 minStakeDuration,\n        address rewardRecipient\n    ) external payable nonReentrant returns (bytes32) {\n        return _initiateValidatorRegistration({\n            nodeID: nodeID,\n            blsPublicKey: blsPublicKey,\n            remainingBalanceOwner: remainingBalanceOwner,\n            disableOwner: disableOwner,\n            delegationFeeBips: delegationFeeBips,\n            minStakeDuration: minStakeDuration,\n            stakeAmount: msg.value,\n            rewardRecipient: rewardRecipient\n        });\n    }",
            "startLine": 61,
            "signature": "initiateValidatorRegistration(bytes,bytes,PChainOwner,PChainOwner,uint16,uint64,address)",
            "selector": "0x045de078",
            "visibility": "external",
            "modifiers": [
              "nonReentrant"
            ]
          },
          {
            "name": "initiateDelegatorRegistration",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_initiateDelegatorRegistration",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateDelegatorRegistration(\n        bytes32 validationID,\n        address rewardRecipient\n    ) external payable nonReentrant returns (bytes32) {\n        return\n            _initiateDelegatorRegistration(validationID, _msgSender(), msg.value, rewardRecipient);\n    }",
            "startLine": 85,
            "signature": "initiateDelegatorRegistration(bytes32,address)",
            "selector": "0x163dab64",
            "visibility": "external",
            "modifiers": [
              "nonReentrant"
            ]
          },
          {
            "name": "submitUptimeProof",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_isPoSValidator",
                "type": "internal"
              },
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_updateUptime",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function submitUptimeProof(bytes32 validationID, uint32 messageIndex) external {\n        if (!_isPoSValidator(validationID)) {\n            revert ValidatorNotPoS(validationID);\n        }\n        ValidatorStatus status =\n            _getStakingManagerStorage()._manager.getValidator(validationID).status;\n        if (status != ValidatorStatus.Active) {\n            revert InvalidValidatorStatus(status);\n        }\n\n        // Uptime proofs include the absolute number of seconds the validator has been active.\n        _updateUptime(validationID, messageIndex);\n    }",
            "startLine": 198,
            "signature": "submitUptimeProof(bytes32,uint32)",
            "selector": "0x4d54664a",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "claimDelegationFees",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_withdrawValidationRewards",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function claimDelegationFees(\n        bytes32 validationID\n    ) external {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        ValidatorStatus status = $._manager.getValidator(validationID).status;\n        if (status != ValidatorStatus.Completed) {\n            revert InvalidValidatorStatus(status);\n        }\n\n        if ($._posValidatorInfo[validationID].owner != _msgSender()) {\n            revert UnauthorizedOwner(_msgSender());\n        }\n\n        address rewardRecipient = $._rewardRecipients[validationID];\n\n        if (rewardRecipient == address(0)) {\n            rewardRecipient = $._posValidatorInfo[validationID].owner;\n        }\n\n        _withdrawValidationRewards(rewardRecipient, validationID);\n    }",
            "startLine": 215,
            "signature": "claimDelegationFees(bytes32)",
            "selector": "0x363501aa",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "initiateValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiateValidatorRemovalWithCheck",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorRemoval(\n        bytes32 validationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) external {\n        _initiateValidatorRemovalWithCheck(validationID, includeUptimeProof, messageIndex);\n    }",
            "startLine": 241,
            "signature": "initiateValidatorRemoval(bytes32,bool,uint32)",
            "selector": "0x72bceec5",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "forceInitiateValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiatePoSValidatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function forceInitiateValidatorRemoval(\n        bytes32 validationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) external {\n        // Ignore the return value here to force end validation, regardless of possible missed rewards\n        _initiatePoSValidatorRemoval(validationID, includeUptimeProof, messageIndex);\n    }",
            "startLine": 262,
            "signature": "forceInitiateValidatorRemoval(bytes32,bool,uint32)",
            "selector": "0x7475aa66",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "changeValidatorRewardRecipient",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "ValidatorRewardRecipientChanged"
            ],
            "isVirtual": false,
            "sourceCode": "function changeValidatorRewardRecipient(\n        bytes32 validationID,\n        address rewardRecipient\n    ) external {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        if (rewardRecipient == address(0)) {\n            revert InvalidRewardRecipient(rewardRecipient);\n        }\n\n        if ($._posValidatorInfo[validationID].owner != _msgSender()) {\n            revert UnauthorizedOwner(_msgSender());\n        }\n\n        address currentRecipient = $._rewardRecipients[validationID];\n        $._rewardRecipients[validationID] = rewardRecipient;\n\n        emit ValidatorRewardRecipientChanged(validationID, rewardRecipient, currentRecipient);\n    }",
            "startLine": 274,
            "signature": "changeValidatorRewardRecipient(bytes32,address)",
            "selector": "0x08b86a89",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "changeDelegatorRewardRecipient",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "DelegatorRewardRecipientChanged"
            ],
            "isVirtual": false,
            "sourceCode": "function changeDelegatorRewardRecipient(\n        bytes32 delegationID,\n        address rewardRecipient\n    ) external {\n        if (rewardRecipient == address(0)) {\n            revert InvalidRewardRecipient(rewardRecipient);\n        }\n\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        if ($._delegatorStakes[delegationID].owner != _msgSender()) {\n            revert UnauthorizedOwner(_msgSender());\n        }\n\n        address currentRecipient = $._delegatorRewardRecipients[delegationID];\n        $._delegatorRewardRecipients[delegationID] = rewardRecipient;\n\n        emit DelegatorRewardRecipientChanged(delegationID, rewardRecipient, currentRecipient);\n    }",
            "startLine": 297,
            "signature": "changeDelegatorRewardRecipient(bytes32,address)",
            "selector": "0x26295ae8",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "completeValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_isPoSValidator",
                "type": "internal"
              },
              {
                "target": "_withdrawValidationRewards",
                "type": "internal"
              },
              {
                "target": "_unlock",
                "type": "internal"
              },
              {
                "target": "weightToValue",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorRemoval(\n        uint32 messageIndex\n    ) external nonReentrant returns (bytes32) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        // Check if the validator has been already been removed from the validator manager.\n        bytes32 validationID = $._manager.completeValidatorRemoval(messageIndex);\n        Validator memory validator = $._manager.getValidator(validationID);\n\n        // Return now if this was originally a PoA validator that was later migrated to this PoS manager,\n        // or the validator was part of the initial validator set.\n        if (!_isPoSValidator(validationID)) {\n            return validationID;\n        }\n\n        address owner = $._posValidatorInfo[validationID].owner;\n        address rewardRecipient = $._rewardRecipients[validationID];\n\n        // the reward-recipient should always be set, but just in case it isn't, we won't burn the reward\n        if (rewardRecipient == address(0)) {\n            rewardRecipient = owner;\n        }\n\n        // The validator can either be Completed or Invalidated here. We only grant rewards for Completed.\n        if (validator.status == ValidatorStatus.Completed) {\n            _withdrawValidationRewards(rewardRecipient, validationID);\n        }\n\n        // The stake is unlocked whether the validation period is completed or invalidated.\n        _unlock(owner, weightToValue(validator.startingWeight));\n\n        return validationID;\n    }",
            "startLine": 378,
            "signature": "completeValidatorRemoval(uint32)",
            "selector": "0x74b83085",
            "visibility": "external",
            "modifiers": [
              "nonReentrant"
            ],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "completeValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorRegistration(\n        uint32 messageIndex\n    ) external returns (bytes32) {\n        return _getStakingManagerStorage()._manager.completeValidatorRegistration(messageIndex);\n    }",
            "startLine": 520,
            "signature": "completeValidatorRegistration(uint32)",
            "selector": "0x5442dda6",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "valueToWeight",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function valueToWeight(\n        uint256 value\n    ) public view returns (uint64) {\n        uint256 weight = value / _getStakingManagerStorage()._weightToValueFactor;\n        if (weight == 0 || weight > type(uint64).max) {\n            revert InvalidStakeAmount(value);\n        }\n        return uint64(weight);\n    }",
            "startLine": 530,
            "signature": "valueToWeight(uint256)",
            "selector": "0x2bf991d4",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "weightToValue",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "weight",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function weightToValue(\n        uint64 weight\n    ) public view returns (uint256) {\n        return uint256(weight) * _getStakingManagerStorage()._weightToValueFactor;\n    }",
            "startLine": 544,
            "signature": "weightToValue(uint64)",
            "selector": "0x37041e87",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "getStakingManagerSettings",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "StakingManagerSettings"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getStakingManagerSettings() public view returns (StakingManagerSettings memory) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        return StakingManagerSettings({\n            manager: $._manager,\n            minimumStakeAmount: $._minimumStakeAmount,\n            maximumStakeAmount: $._maximumStakeAmount,\n            minimumStakeDuration: $._minimumStakeDuration,\n            minimumDelegationFeeBips: $._minimumDelegationFeeBips,\n            maximumStakeMultiplier: uint8($._maximumStakeMultiplier),\n            weightToValueFactor: $._weightToValueFactor,\n            rewardCalculator: $._rewardCalculator,\n            uptimeBlockchainID: $._uptimeBlockchainID\n        });\n    }",
            "startLine": 553,
            "signature": "getStakingManagerSettings()",
            "selector": "0x6805e870",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "getStakingValidator",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "PoSValidatorInfo"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getStakingValidator(\n        bytes32 validationID\n    ) public view returns (PoSValidatorInfo memory) {\n        return _getStakingManagerStorage()._posValidatorInfo[validationID];\n    }",
            "startLine": 572,
            "signature": "getStakingValidator(bytes32)",
            "selector": "0x0b958a2a",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "getValidatorRewardInfo",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getValidatorRewardInfo(\n        bytes32 validationID\n    ) public view returns (address, uint256) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        return ($._rewardRecipients[validationID], $._redeemableValidatorRewards[validationID]);\n    }",
            "startLine": 583,
            "signature": "getValidatorRewardInfo(bytes32)",
            "selector": "0x1198b36e",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "getDelegatorInfo",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "Delegator"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getDelegatorInfo(\n        bytes32 delegationID\n    ) public view returns (Delegator memory) {\n        return _getStakingManagerStorage()._delegatorStakes[delegationID];\n    }",
            "startLine": 593,
            "signature": "getDelegatorInfo(bytes32)",
            "selector": "0x7f07e78c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "getDelegatorRewardInfo",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getDelegatorRewardInfo(\n        bytes32 delegationID\n    ) public view returns (address, uint256) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        return (\n            $._delegatorRewardRecipients[delegationID], $._redeemableDelegatorRewards[delegationID]\n        );\n    }",
            "startLine": 604,
            "signature": "getDelegatorRewardInfo(bytes32)",
            "selector": "0x149215a3",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "completeDelegatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_completeDelegatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [
              "CompletedDelegatorRegistration"
            ],
            "isVirtual": false,
            "sourceCode": "function completeDelegatorRegistration(bytes32 delegationID, uint32 messageIndex) external {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        Delegator memory delegator = $._delegatorStakes[delegationID];\n        bytes32 validationID = delegator.validationID;\n        Validator memory validator = $._manager.getValidator(validationID);\n\n        // Ensure the delegator is pending added. Since anybody can call this function once\n        // delegator registration has been initiated, we need to make sure that this function is only\n        // callable after that has been done.\n        if (delegator.status != DelegatorStatus.PendingAdded) {\n            revert InvalidDelegatorStatus(delegator.status);\n        }\n\n        // In the case where the validator has completed its validation period, we can no\n        // longer stake and should move our status directly to completed and return the stake.\n        if (validator.status == ValidatorStatus.Completed) {\n            return _completeDelegatorRemoval(delegationID);\n        }\n\n        // If we've already received a weight update with a nonce greater than the delegation's starting nonce,\n        // then there's no requirement to include an ICM message in this function call.\n        if (validator.receivedNonce < delegator.startingNonce) {\n            (bytes32 messageValidationID, uint64 nonce) =\n                $._manager.completeValidatorWeightUpdate(messageIndex);\n\n            if (validationID != messageValidationID) {\n                revert UnexpectedValidationID(messageValidationID, validationID);\n            }\n            if (nonce < delegator.startingNonce) {\n                revert InvalidNonce(nonce);\n            }\n        }\n\n        // Update the delegation status\n        $._delegatorStakes[delegationID].status = DelegatorStatus.Active;\n        $._delegatorStakes[delegationID].startTime = uint64(block.timestamp);\n\n        emit CompletedDelegatorRegistration({\n            delegationID: delegationID,\n            validationID: validationID,\n            startTime: uint64(block.timestamp)\n        });\n    }",
            "startLine": 697,
            "signature": "completeDelegatorRegistration(bytes32,uint32)",
            "selector": "0x7ac53d57",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "initiateDelegatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiateDelegatorRemovalWithCheck",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateDelegatorRemoval(\n        bytes32 delegationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) external {\n        _initiateDelegatorRemovalWithCheck(delegationID, includeUptimeProof, messageIndex);\n    }",
            "startLine": 745,
            "signature": "initiateDelegatorRemoval(bytes32,bool,uint32)",
            "selector": "0x66f514b6",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "forceInitiateDelegatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiateDelegatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function forceInitiateDelegatorRemoval(\n        bytes32 delegationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) external {\n        // Ignore the return value here to force end delegation, regardless of possible missed rewards\n        _initiateDelegatorRemoval(delegationID, includeUptimeProof, messageIndex);\n    }",
            "startLine": 766,
            "signature": "forceInitiateDelegatorRemoval(bytes32,bool,uint32)",
            "selector": "0x7fc27b8b",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "resendUpdateDelegator",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "WARP_MESSENGER.sendWarpMessage",
                "type": "library"
              },
              {
                "target": "ValidatorMessages.packL1ValidatorWeightMessage",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function resendUpdateDelegator(\n        bytes32 delegationID\n    ) external {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        Delegator memory delegator = $._delegatorStakes[delegationID];\n        if (\n            delegator.status != DelegatorStatus.PendingAdded\n                && delegator.status != DelegatorStatus.PendingRemoved\n        ) {\n            revert InvalidDelegatorStatus(delegator.status);\n        }\n\n        Validator memory validator = $._manager.getValidator(delegator.validationID);\n        if (validator.sentNonce == 0) {\n            // Should be unreachable.\n            revert InvalidDelegationID(delegationID);\n        }\n\n        // Submit the message to the Warp precompile.\n        WARP_MESSENGER.sendWarpMessage(\n            ValidatorMessages.packL1ValidatorWeightMessage(\n                delegator.validationID, validator.sentNonce, validator.weight\n            )\n        );\n    }",
            "startLine": 902,
            "signature": "resendUpdateDelegator(bytes32)",
            "selector": "0x28f303d8",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "completeDelegatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_completeDelegatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeDelegatorRemoval(\n        bytes32 delegationID,\n        uint32 messageIndex\n    ) external nonReentrant {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        Delegator memory delegator = $._delegatorStakes[delegationID];\n\n        // Ensure the delegator is pending removed. Since anybody can call this function once\n        // end delegation has been initiated, we need to make sure that this function is only\n        // callable after that has been done.\n        if (delegator.status != DelegatorStatus.PendingRemoved) {\n            revert InvalidDelegatorStatus(delegator.status);\n        }\n        Validator memory validator = $._manager.getValidator(delegator.validationID);\n\n        // We only expect an ICM message if we haven't received a weight update with a nonce greater than the delegation's ending nonce\n        if (\n            $._manager.getValidator(delegator.validationID).status != ValidatorStatus.Completed\n                && validator.receivedNonce < delegator.endingNonce\n        ) {\n            (bytes32 validationID, uint64 nonce) =\n                $._manager.completeValidatorWeightUpdate(messageIndex);\n            if (delegator.validationID != validationID) {\n                revert UnexpectedValidationID(validationID, delegator.validationID);\n            }\n\n            // The received nonce should be at least as high as the delegation's ending nonce. This allows a weight\n            // update using a higher nonce (which implicitly includes the delegation's weight update) to be used to\n            // complete delisting for an earlier delegation. This is necessary because the P-Chain is only willing\n            // to sign the latest weight update.\n            if (delegator.endingNonce > nonce) {\n                revert InvalidNonce(nonce);\n            }\n        }\n\n        _completeDelegatorRemoval(delegationID);\n    }",
            "startLine": 932,
            "signature": "completeDelegatorRemoval(bytes32,uint32)",
            "selector": "0x702b3fb8",
            "visibility": "external",
            "modifiers": [
              "nonReentrant"
            ],
            "inheritedFrom": "StakingManager"
          }
        ],
        "internalFunctions": [
          {
            "name": "__NativeTokenStakingManager_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "StakingManagerSettings"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__StakingManager_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __NativeTokenStakingManager_init(\n        StakingManagerSettings calldata settings\n    ) internal onlyInitializing {\n        __StakingManager_init(settings);\n    }",
            "startLine": 49,
            "visibility": "internal"
          },
          {
            "name": "__NativeTokenStakingManager_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __NativeTokenStakingManager_init_unchained() internal onlyInitializing {}",
            "startLine": 56,
            "visibility": "internal"
          },
          {
            "name": "_lock",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _lock(\n        uint256 value\n    ) internal virtual override returns (uint256) {\n        return value;\n    }",
            "startLine": 96,
            "visibility": "internal"
          },
          {
            "name": "_unlock",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _unlock(address to, uint256 value) internal virtual override {\n        payable(to).sendValue(value);\n    }",
            "startLine": 105,
            "visibility": "internal"
          },
          {
            "name": "_reward",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "NATIVE_MINTER.mintNativeCoin",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _reward(address account, uint256 amount) internal virtual override {\n        NATIVE_MINTER.mintNativeCoin(account, amount);\n    }",
            "startLine": 112,
            "visibility": "internal"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getStakingManagerStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "StakingManagerStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getStakingManagerStorage() internal pure returns (StakingManagerStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := STAKING_MANAGER_STORAGE_LOCATION\n        }\n    }",
            "startLine": 117,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "__StakingManager_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "StakingManagerSettings"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ReentrancyGuard_init",
                "type": "internal"
              },
              {
                "target": "__StakingManager_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __StakingManager_init(\n        StakingManagerSettings calldata settings\n    ) internal onlyInitializing {\n        __ReentrancyGuard_init();\n        __StakingManager_init_unchained({\n            manager: settings.manager,\n            minimumStakeAmount: settings.minimumStakeAmount,\n            maximumStakeAmount: settings.maximumStakeAmount,\n            minimumStakeDuration: settings.minimumStakeDuration,\n            minimumDelegationFeeBips: settings.minimumDelegationFeeBips,\n            maximumStakeMultiplier: settings.maximumStakeMultiplier,\n            weightToValueFactor: settings.weightToValueFactor,\n            rewardCalculator: settings.rewardCalculator,\n            uptimeBlockchainID: settings.uptimeBlockchainID\n        });\n    }",
            "startLine": 125,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "__StakingManager_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "manager",
                "type": "IValidatorManager"
              },
              {
                "name": "minimumStakeAmount",
                "type": "uint256"
              },
              {
                "name": "maximumStakeAmount",
                "type": "uint256"
              },
              {
                "name": "minimumStakeDuration",
                "type": "uint64"
              },
              {
                "name": "minimumDelegationFeeBips",
                "type": "uint16"
              },
              {
                "name": "maximumStakeMultiplier",
                "type": "uint8"
              },
              {
                "name": "weightToValueFactor",
                "type": "uint256"
              },
              {
                "name": "rewardCalculator",
                "type": "IRewardCalculator"
              },
              {
                "name": "uptimeBlockchainID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "manager.getChurnPeriodSeconds",
                "type": "external"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __StakingManager_init_unchained(\n        IValidatorManager manager,\n        uint256 minimumStakeAmount,\n        uint256 maximumStakeAmount,\n        uint64 minimumStakeDuration,\n        uint16 minimumDelegationFeeBips,\n        uint8 maximumStakeMultiplier,\n        uint256 weightToValueFactor,\n        IRewardCalculator rewardCalculator,\n        bytes32 uptimeBlockchainID\n    ) internal onlyInitializing {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        if (minimumDelegationFeeBips == 0 || minimumDelegationFeeBips > MAXIMUM_DELEGATION_FEE_BIPS)\n        {\n            revert InvalidDelegationFee(minimumDelegationFeeBips);\n        }\n        if (minimumStakeAmount > maximumStakeAmount) {\n            revert InvalidStakeAmount(minimumStakeAmount);\n        }\n        if (maximumStakeMultiplier == 0 || maximumStakeMultiplier > MAXIMUM_STAKE_MULTIPLIER_LIMIT)\n        {\n            revert InvalidStakeMultiplier(maximumStakeMultiplier);\n        }\n        if (address(manager) == address(0)) {\n            revert ZeroAddress();\n        }\n        if (address(rewardCalculator) == address(0)) {\n            revert ZeroAddress();\n        }\n\n        // Minimum stake duration should be at least one churn period in order to prevent churn tracker abuse.\n        if (minimumStakeDuration < manager.getChurnPeriodSeconds()) {\n            revert InvalidMinStakeDuration(minimumStakeDuration);\n        }\n        if (weightToValueFactor == 0) {\n            revert ZeroWeightToValueFactor();\n        }\n        if (uptimeBlockchainID == bytes32(0)) {\n            revert InvalidUptimeBlockchainID(uptimeBlockchainID);\n        }\n\n        $._manager = manager;\n        $._minimumStakeAmount = minimumStakeAmount;\n        $._maximumStakeAmount = maximumStakeAmount;\n        $._minimumStakeDuration = minimumStakeDuration;\n        $._minimumDelegationFeeBips = minimumDelegationFeeBips;\n        $._maximumStakeMultiplier = maximumStakeMultiplier;\n        $._weightToValueFactor = weightToValueFactor;\n        $._rewardCalculator = rewardCalculator;\n        $._uptimeBlockchainID = uptimeBlockchainID;\n    }",
            "startLine": 143,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_initiateValidatorRemovalWithCheck",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiatePoSValidatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _initiateValidatorRemovalWithCheck(\n        bytes32 validationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) internal {\n        if (!_initiatePoSValidatorRemoval(validationID, includeUptimeProof, messageIndex)) {\n            revert ValidatorIneligibleForRewards(validationID);\n        }\n    }",
            "startLine": 249,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_initiatePoSValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_isPoSValidator",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_updateUptime",
                "type": "internal"
              },
              {
                "target": "weightToValue",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _initiatePoSValidatorRemoval(\n        bytes32 validationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) internal returns (bool) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        $._manager.initiateValidatorRemoval(validationID);\n\n        // The validator must be fetched after the removal has been initiated, since the above call modifies\n        // the validator's state.\n        Validator memory validator = $._manager.getValidator(validationID);\n\n        // Non-PoS validators are required to boostrap the network, but are not eligible for rewards.\n        if (!_isPoSValidator(validationID)) {\n            return true;\n        }\n\n        // PoS validations can only be ended by their owners.\n        if ($._posValidatorInfo[validationID].owner != _msgSender()) {\n            revert UnauthorizedOwner(_msgSender());\n        }\n\n        // Check that minimum stake duration has passed.\n        if (\n            validator.endTime\n                < validator.startTime + $._posValidatorInfo[validationID].minStakeDuration\n        ) {\n            revert MinStakeDurationNotPassed(validator.endTime);\n        }\n\n        // Uptime proofs include the absolute number of seconds the validator has been active.\n        uint64 uptimeSeconds;\n        if (includeUptimeProof) {\n            uptimeSeconds = _updateUptime(validationID, messageIndex);\n        } else {\n            uptimeSeconds = $._posValidatorInfo[validationID].uptimeSeconds;\n        }\n\n        uint256 reward = $._rewardCalculator.calculateReward({\n            stakeAmount: weightToValue(validator.startingWeight),\n            validatorStartTime: validator.startTime,\n            stakingStartTime: validator.startTime,\n            stakingEndTime: validator.endTime,\n            uptimeSeconds: uptimeSeconds\n        });\n\n        $._redeemableValidatorRewards[validationID] += reward;\n\n        return (reward > 0);\n    }",
            "startLine": 322,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_updateUptime",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "WARP_MESSENGER.getVerifiedWarpMessage",
                "type": "library"
              },
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "ValidatorMessages.unpackValidationUptimeMessage",
                "type": "library"
              }
            ],
            "emits": [
              "UptimeUpdated"
            ],
            "isVirtual": false,
            "sourceCode": "function _updateUptime(bytes32 validationID, uint32 messageIndex) internal returns (uint64) {\n        (WarpMessage memory warpMessage, bool valid) =\n            WARP_MESSENGER.getVerifiedWarpMessage(messageIndex);\n        if (!valid) {\n            revert InvalidWarpMessage();\n        }\n\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        // The uptime proof must be from the specifed uptime blockchain\n        if (warpMessage.sourceChainID != $._uptimeBlockchainID) {\n            revert InvalidWarpSourceChainID(warpMessage.sourceChainID);\n        }\n\n        // The sender is required to be the zero address so that we know the validator node\n        // signed the proof directly, rather than as an arbitrary on-chain message\n        if (warpMessage.originSenderAddress != address(0)) {\n            revert InvalidWarpOriginSenderAddress(warpMessage.originSenderAddress);\n        }\n\n        (bytes32 uptimeValidationID, uint64 uptime) =\n            ValidatorMessages.unpackValidationUptimeMessage(warpMessage.payload);\n        if (validationID != uptimeValidationID) {\n            revert UnexpectedValidationID(uptimeValidationID, validationID);\n        }\n\n        if (uptime > $._posValidatorInfo[validationID].uptimeSeconds) {\n            $._posValidatorInfo[validationID].uptimeSeconds = uptime;\n            emit UptimeUpdated(validationID, uptime);\n        } else {\n            uptime = $._posValidatorInfo[validationID].uptimeSeconds;\n        }\n\n        return uptime;\n    }",
            "startLine": 416,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_initiateValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "nodeID",
                "type": "bytes"
              },
              {
                "name": "blsPublicKey",
                "type": "bytes"
              },
              {
                "name": "remainingBalanceOwner",
                "type": "PChainOwner"
              },
              {
                "name": "disableOwner",
                "type": "PChainOwner"
              },
              {
                "name": "delegationFeeBips",
                "type": "uint16"
              },
              {
                "name": "minStakeDuration",
                "type": "uint64"
              },
              {
                "name": "stakeAmount",
                "type": "uint256"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_lock",
                "type": "internal"
              },
              {
                "target": "valueToWeight",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "InitiatedStakingValidatorRegistration"
            ],
            "isVirtual": true,
            "sourceCode": "function _initiateValidatorRegistration(\n        bytes memory nodeID,\n        bytes memory blsPublicKey,\n        PChainOwner memory remainingBalanceOwner,\n        PChainOwner memory disableOwner,\n        uint16 delegationFeeBips,\n        uint64 minStakeDuration,\n        uint256 stakeAmount,\n        address rewardRecipient\n    ) internal virtual returns (bytes32) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        // Validate and save the validator requirements\n        if (\n            delegationFeeBips < $._minimumDelegationFeeBips\n                || delegationFeeBips > MAXIMUM_DELEGATION_FEE_BIPS\n        ) {\n            revert InvalidDelegationFee(delegationFeeBips);\n        }\n\n        if (minStakeDuration < $._minimumStakeDuration) {\n            revert InvalidMinStakeDuration(minStakeDuration);\n        }\n\n        // Ensure the weight is within the valid range.\n        if (stakeAmount < $._minimumStakeAmount || stakeAmount > $._maximumStakeAmount) {\n            revert InvalidStakeAmount(stakeAmount);\n        }\n\n        if (rewardRecipient == address(0)) {\n            revert InvalidRewardRecipient(rewardRecipient);\n        }\n\n        // Lock the stake in the contract.\n        uint256 lockedValue = _lock(stakeAmount);\n\n        uint64 weight = valueToWeight(lockedValue);\n        bytes32 validationID = $._manager.initiateValidatorRegistration({\n            nodeID: nodeID,\n            blsPublicKey: blsPublicKey,\n            remainingBalanceOwner: remainingBalanceOwner,\n            disableOwner: disableOwner,\n            weight: weight\n        });\n\n        address owner = _msgSender();\n\n        $._posValidatorInfo[validationID].owner = owner;\n        $._posValidatorInfo[validationID].delegationFeeBips = delegationFeeBips;\n        $._posValidatorInfo[validationID].minStakeDuration = minStakeDuration;\n        $._posValidatorInfo[validationID].uptimeSeconds = 0;\n        $._rewardRecipients[validationID] = rewardRecipient;\n\n        emit InitiatedStakingValidatorRegistration(\n            validationID, owner, delegationFeeBips, minStakeDuration, rewardRecipient\n        );\n\n        return validationID;\n    }",
            "startLine": 458,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_initiateDelegatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "delegatorAddress",
                "type": "address"
              },
              {
                "name": "delegationAmount",
                "type": "uint256"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "valueToWeight",
                "type": "internal"
              },
              {
                "target": "_lock",
                "type": "internal"
              },
              {
                "target": "_isPoSValidator",
                "type": "internal"
              }
            ],
            "emits": [
              "InitiatedDelegatorRegistration"
            ],
            "isVirtual": false,
            "sourceCode": "function _initiateDelegatorRegistration(\n        bytes32 validationID,\n        address delegatorAddress,\n        uint256 delegationAmount,\n        address rewardRecipient\n    ) internal returns (bytes32) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        uint64 weight = valueToWeight(_lock(delegationAmount));\n\n        // Check that the validation ID is a PoS validator\n        if (!_isPoSValidator(validationID)) {\n            revert ValidatorNotPoS(validationID);\n        }\n\n        if (rewardRecipient == address(0)) {\n            revert InvalidRewardRecipient(rewardRecipient);\n        }\n\n        // Update the validator weight\n        uint64 newValidatorWeight;\n        {\n            Validator memory validator = $._manager.getValidator(validationID);\n            newValidatorWeight = validator.weight + weight;\n            if (newValidatorWeight > validator.startingWeight * $._maximumStakeMultiplier) {\n                revert MaxWeightExceeded(newValidatorWeight);\n            }\n        }\n\n        (uint64 nonce, bytes32 messageID) =\n            $._manager.initiateValidatorWeightUpdate(validationID, newValidatorWeight);\n\n        bytes32 delegationID = keccak256(abi.encodePacked(validationID, nonce));\n        // Store the delegation information. Set the delegator status to pending added,\n        // so that it can be properly started in the complete step, even if the delivered\n        // nonce is greater than the nonce used to initiate registration.\n        $._delegatorStakes[delegationID].status = DelegatorStatus.PendingAdded;\n        $._delegatorStakes[delegationID].owner = delegatorAddress;\n        $._delegatorStakes[delegationID].validationID = validationID;\n        $._delegatorStakes[delegationID].weight = weight;\n        $._delegatorStakes[delegationID].startTime = 0;\n        $._delegatorStakes[delegationID].startingNonce = nonce;\n        $._delegatorStakes[delegationID].endingNonce = 0;\n        $._delegatorRewardRecipients[delegationID] = rewardRecipient;\n\n        emit InitiatedDelegatorRegistration({\n            delegationID: delegationID,\n            validationID: validationID,\n            delegatorAddress: delegatorAddress,\n            nonce: nonce,\n            validatorWeight: newValidatorWeight,\n            delegatorWeight: weight,\n            setWeightMessageID: messageID,\n            rewardRecipient: rewardRecipient\n        });\n        return delegationID;\n    }",
            "startLine": 636,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_initiateDelegatorRemovalWithCheck",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiateDelegatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _initiateDelegatorRemovalWithCheck(\n        bytes32 delegationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) internal {\n        if (!_initiateDelegatorRemoval(delegationID, includeUptimeProof, messageIndex)) {\n            revert DelegatorIneligibleForRewards(delegationID);\n        }\n    }",
            "startLine": 753,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_initiateDelegatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_updateUptime",
                "type": "internal"
              },
              {
                "target": "_calculateAndSetDelegationReward",
                "type": "internal"
              },
              {
                "target": "_completeDelegatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [
              "InitiatedDelegatorRemoval"
            ],
            "isVirtual": false,
            "sourceCode": "function _initiateDelegatorRemoval(\n        bytes32 delegationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) internal returns (bool) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        Delegator memory delegator = $._delegatorStakes[delegationID];\n        bytes32 validationID = delegator.validationID;\n        Validator memory validator = $._manager.getValidator(validationID);\n\n        // Ensure the delegator is active\n        if (delegator.status != DelegatorStatus.Active) {\n            revert InvalidDelegatorStatus(delegator.status);\n        }\n\n        // Only the delegation owner or parent validator can end the delegation.\n        if (delegator.owner != _msgSender()) {\n            // Validators can only remove delegations after the minimum stake duration has passed.\n            if ($._posValidatorInfo[validationID].owner != _msgSender()) {\n                revert UnauthorizedOwner(_msgSender());\n            }\n\n            if (\n                block.timestamp\n                    < validator.startTime + $._posValidatorInfo[validationID].minStakeDuration\n            ) {\n                revert MinStakeDurationNotPassed(uint64(block.timestamp));\n            }\n        }\n\n        address rewardRecipient = $._delegatorRewardRecipients[delegationID];\n        if (validator.status == ValidatorStatus.Active) {\n            // Check that minimum stake duration has passed.\n            if (block.timestamp < delegator.startTime + $._minimumStakeDuration) {\n                revert MinStakeDurationNotPassed(uint64(block.timestamp));\n            }\n\n            if (includeUptimeProof) {\n                // Uptime proofs include the absolute number of seconds the validator has been active.\n                _updateUptime(validationID, messageIndex);\n            }\n\n            // Set the delegator status to pending removed, so that it can be properly removed in\n            // the complete step, even if the delivered nonce is greater than the nonce used to\n            // initiate the removal.\n            $._delegatorStakes[delegationID].status = DelegatorStatus.PendingRemoved;\n\n            ($._delegatorStakes[delegationID].endingNonce,) = $\n                ._manager\n                .initiateValidatorWeightUpdate(validationID, validator.weight - delegator.weight);\n\n            uint256 reward =\n                _calculateAndSetDelegationReward(delegator, rewardRecipient, delegationID);\n\n            emit InitiatedDelegatorRemoval({delegationID: delegationID, validationID: validationID});\n            return (reward > 0);\n        } else if (validator.status == ValidatorStatus.Completed) {\n            _calculateAndSetDelegationReward(delegator, rewardRecipient, delegationID);\n            _completeDelegatorRemoval(delegationID);\n            // If the validator has completed, then no further uptimes may be submitted, so we always\n            // end the delegation.\n            return true;\n        } else {\n            revert InvalidValidatorStatus(validator.status);\n        }\n    }",
            "startLine": 780,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_calculateAndSetDelegationReward",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegator",
                "type": "Delegator"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              },
              {
                "name": "delegationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "weightToValue",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _calculateAndSetDelegationReward(\n        Delegator memory delegator,\n        address rewardRecipient,\n        bytes32 delegationID\n    ) private returns (uint256) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        Validator memory validator = $._manager.getValidator(delegator.validationID);\n\n        uint64 delegationEndTime;\n        if (\n            validator.status == ValidatorStatus.PendingRemoved\n                || validator.status == ValidatorStatus.Completed\n        ) {\n            delegationEndTime = validator.endTime;\n        } else if (validator.status == ValidatorStatus.Active) {\n            delegationEndTime = uint64(block.timestamp);\n        } else {\n            // Should be unreachable.\n            revert InvalidValidatorStatus(validator.status);\n        }\n\n        // Only give rewards in the case that the delegation started before the validator exited.\n        if (delegationEndTime <= delegator.startTime) {\n            return 0;\n        }\n\n        uint256 reward = $._rewardCalculator.calculateReward({\n            stakeAmount: weightToValue(delegator.weight),\n            validatorStartTime: validator.startTime,\n            stakingStartTime: delegator.startTime,\n            stakingEndTime: delegationEndTime,\n            uptimeSeconds: $._posValidatorInfo[delegator.validationID].uptimeSeconds\n        });\n\n        if (rewardRecipient == address(0)) {\n            rewardRecipient = delegator.owner;\n        }\n\n        $._redeemableDelegatorRewards[delegationID] = reward;\n        $._delegatorRewardRecipients[delegationID] = rewardRecipient;\n\n        return reward;\n    }",
            "startLine": 852,
            "visibility": "private",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_completeDelegatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_withdrawDelegationRewards",
                "type": "internal"
              },
              {
                "target": "_unlock",
                "type": "internal"
              },
              {
                "target": "weightToValue",
                "type": "internal"
              }
            ],
            "emits": [
              "CompletedDelegatorRemoval"
            ],
            "isVirtual": false,
            "sourceCode": "function _completeDelegatorRemoval(\n        bytes32 delegationID\n    ) internal {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        Delegator memory delegator = $._delegatorStakes[delegationID];\n        bytes32 validationID = delegator.validationID;\n\n        // To prevent churn tracker abuse, check that one full churn period has passed,\n        // so a delegator may not stake twice in the same churn period.\n        if (block.timestamp < delegator.startTime + $._manager.getChurnPeriodSeconds()) {\n            revert MinStakeDurationNotPassed(uint64(block.timestamp));\n        }\n\n        // Once this function completes, the delegation is completed so we can clear it from state now.\n        delete $._delegatorStakes[delegationID];\n\n        address rewardRecipient = $._delegatorRewardRecipients[delegationID];\n        delete $._delegatorRewardRecipients[delegationID];\n\n        if (rewardRecipient == address(0)) {\n            rewardRecipient = delegator.owner;\n        }\n\n        (uint256 delegationRewards, uint256 validatorFees) =\n            _withdrawDelegationRewards(rewardRecipient, delegationID, validationID);\n\n        // Unlock the delegator's stake.\n        _unlock(delegator.owner, weightToValue(delegator.weight));\n\n        emit CompletedDelegatorRemoval(delegationID, validationID, delegationRewards, validatorFees);\n    }",
            "startLine": 970,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_isPoSValidator",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isPoSValidator(\n        bytes32 validationID\n    ) internal view returns (bool) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        return $._posValidatorInfo[validationID].owner != address(0);\n    }",
            "startLine": 1012,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_withdrawValidationRewards",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "rewardRecipient",
                "type": "address"
              },
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_reward",
                "type": "internal"
              }
            ],
            "emits": [
              "ValidatorRewardClaimed"
            ],
            "isVirtual": false,
            "sourceCode": "function _withdrawValidationRewards(address rewardRecipient, bytes32 validationID) internal {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        uint256 rewards = $._redeemableValidatorRewards[validationID];\n        delete $._redeemableValidatorRewards[validationID];\n\n        _reward(rewardRecipient, rewards);\n\n        emit ValidatorRewardClaimed(validationID, rewardRecipient, rewards);\n    }",
            "startLine": 1019,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "_withdrawDelegationRewards",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "rewardRecipient",
                "type": "address"
              },
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_reward",
                "type": "internal"
              }
            ],
            "emits": [
              "DelegatorRewardClaimed"
            ],
            "isVirtual": false,
            "sourceCode": "function _withdrawDelegationRewards(\n        address rewardRecipient,\n        bytes32 delegationID,\n        bytes32 validationID\n    ) internal returns (uint256, uint256) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        uint256 delegationRewards;\n        uint256 validatorFees;\n\n        uint256 rewards = $._redeemableDelegatorRewards[delegationID];\n\n        if (rewards > 0) {\n            delete $._redeemableDelegatorRewards[delegationID];\n\n            validatorFees = (rewards * $._posValidatorInfo[validationID].delegationFeeBips)\n                / BIPS_CONVERSION_FACTOR;\n\n            // Allocate the delegation fees to the validator.\n            $._redeemableValidatorRewards[validationID] += validatorFees;\n\n            // Reward the remaining tokens to the delegator.\n            delegationRewards = rewards - validatorFees;\n            _reward(rewardRecipient, delegationRewards);\n\n            emit DelegatorRewardClaimed(delegationID, rewardRecipient, delegationRewards);\n        }\n\n        return (delegationRewards, validatorFees);\n    }",
            "startLine": 1030,
            "visibility": "internal",
            "inheritedFrom": "StakingManager"
          },
          {
            "name": "__Context_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Context_init() internal onlyInitializing {\n    }",
            "startLine": 18,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "__Context_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Context_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 21,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "_msgSender",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }",
            "startLine": 23,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "_msgData",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }",
            "startLine": 27,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "_contextSuffixLength",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }",
            "startLine": 31,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "_getReentrancyGuardStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ReentrancyGuardStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }",
            "startLine": 49,
            "visibility": "private",
            "inheritedFrom": "ReentrancyGuardUpgradeable"
          },
          {
            "name": "__ReentrancyGuard_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "__ReentrancyGuard_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }",
            "startLine": 60,
            "visibility": "internal",
            "inheritedFrom": "ReentrancyGuardUpgradeable"
          },
          {
            "name": "__ReentrancyGuard_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }",
            "startLine": 64,
            "visibility": "internal",
            "inheritedFrom": "ReentrancyGuardUpgradeable"
          },
          {
            "name": "_nonReentrantBefore",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }",
            "startLine": 82,
            "visibility": "private",
            "inheritedFrom": "ReentrancyGuardUpgradeable"
          },
          {
            "name": "_nonReentrantAfter",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }",
            "startLine": 93,
            "visibility": "private",
            "inheritedFrom": "ReentrancyGuardUpgradeable"
          },
          {
            "name": "_reentrancyGuardEntered",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }",
            "startLine": 104,
            "visibility": "internal",
            "inheritedFrom": "ReentrancyGuardUpgradeable"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "PoAManager",
        "kind": "contract",
        "category": "validator-manager",
        "filePath": "@validator-manager/PoAManager.sol",
        "inherits": [
          "Ownable"
        ],
        "implements": [
          "IPoAManager"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IPoAManager",
            "path": "./interfaces/IPoAManager.sol",
            "isExternal": false
          },
          {
            "name": "IValidatorManagerExternalOwnable",
            "path": "./interfaces/IValidatorManagerExternalOwnable.sol",
            "isExternal": false
          },
          {
            "name": "PChainOwner",
            "path": "./interfaces/IACP99Manager.sol",
            "isExternal": false
          },
          {
            "name": "Ownable",
            "path": "@openzeppelin/contracts@5.0.2/access/Ownable.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "initiateValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "nodeID",
                "type": "bytes"
              },
              {
                "name": "blsPublicKey",
                "type": "bytes"
              },
              {
                "name": "remainingBalanceOwner",
                "type": "PChainOwner"
              },
              {
                "name": "disableOwner",
                "type": "PChainOwner"
              },
              {
                "name": "weight",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_manager.initiateValidatorRegistration",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorRegistration(\n        bytes memory nodeID,\n        bytes memory blsPublicKey,\n        PChainOwner memory remainingBalanceOwner,\n        PChainOwner memory disableOwner,\n        uint64 weight\n    ) external onlyOwner returns (bytes32) {\n        return _manager.initiateValidatorRegistration(\n            nodeID, blsPublicKey, remainingBalanceOwner, disableOwner, weight\n        );\n    }",
            "startLine": 28,
            "signature": "initiateValidatorRegistration(bytes,bytes,PChainOwner,PChainOwner,uint64)",
            "selector": "0x239c60db",
            "visibility": "external",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "initiateValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_manager.initiateValidatorRemoval",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorRemoval(\n        bytes32 validationID\n    ) external onlyOwner {\n        return _manager.initiateValidatorRemoval(validationID);\n    }",
            "startLine": 43,
            "signature": "initiateValidatorRemoval(bytes32)",
            "selector": "0x5aa039f4",
            "visibility": "external",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "initiateValidatorWeightUpdate",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "newWeight",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              },
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_manager.initiateValidatorWeightUpdate",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorWeightUpdate(\n        bytes32 validationID,\n        uint64 newWeight\n    ) external onlyOwner returns (uint64, bytes32) {\n        return _manager.initiateValidatorWeightUpdate(validationID, newWeight);\n    }",
            "startLine": 52,
            "signature": "initiateValidatorWeightUpdate(bytes32,uint64)",
            "selector": "0x68a81781",
            "visibility": "external",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "completeValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_manager.completeValidatorRegistration",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorRegistration(\n        uint32 messageIndex\n    ) external returns (bytes32) {\n        return _manager.completeValidatorRegistration(messageIndex);\n    }",
            "startLine": 62,
            "signature": "completeValidatorRegistration(uint32)",
            "selector": "0x5442dda6",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "completeValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_manager.completeValidatorRemoval",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorRemoval(\n        uint32 messageIndex\n    ) external returns (bytes32) {\n        return _manager.completeValidatorRemoval(messageIndex);\n    }",
            "startLine": 71,
            "signature": "completeValidatorRemoval(uint32)",
            "selector": "0x74b83085",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "completeValidatorWeightUpdate",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              },
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_manager.completeValidatorWeightUpdate",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorWeightUpdate(\n        uint32 messageIndex\n    ) external returns (bytes32, uint64) {\n        return _manager.completeValidatorWeightUpdate(messageIndex);\n    }",
            "startLine": 80,
            "signature": "completeValidatorWeightUpdate(uint32)",
            "selector": "0x38c6bf02",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "transferValidatorManagerOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_manager.transferOwnership",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function transferValidatorManagerOwnership(\n        address newOwner\n    ) external onlyOwner {\n        _manager.transferOwnership(newOwner);\n    }",
            "startLine": 89,
            "signature": "transferValidatorManagerOwnership(address)",
            "selector": "0x20a2ab0c",
            "visibility": "external",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address) {\n        return _owner;\n    }",
            "startLine": 56,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "Ownable"
          },
          {
            "name": "renounceOwnership",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
            "startLine": 76,
            "signature": "renounceOwnership()",
            "selector": "0x765becbf",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "Ownable"
          },
          {
            "name": "transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }",
            "startLine": 84,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "Ownable"
          }
        ],
        "internalFunctions": [
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }",
            "startLine": 63,
            "visibility": "internal",
            "inheritedFrom": "Ownable"
          },
          {
            "name": "_transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [
              "OwnershipTransferred"
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }",
            "startLine": 95,
            "visibility": "internal",
            "inheritedFrom": "Ownable"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "StakingManager",
        "kind": "abstract",
        "category": "validator-manager",
        "filePath": "@validator-manager/StakingManager.sol",
        "inherits": [
          "ContextUpgradeable",
          "ReentrancyGuardUpgradeable"
        ],
        "implements": [
          "IStakingManager"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "ValidatorMessages",
            "path": "./ValidatorMessages.sol",
            "isExternal": false
          },
          {
            "name": "IValidatorManager",
            "path": "./interfaces/IValidatorManager.sol",
            "isExternal": false
          },
          {
            "name": "Delegator",
            "path": "./interfaces/IStakingManager.sol",
            "isExternal": false
          },
          {
            "name": "DelegatorStatus",
            "path": "./interfaces/IStakingManager.sol",
            "isExternal": false
          },
          {
            "name": "IStakingManager",
            "path": "./interfaces/IStakingManager.sol",
            "isExternal": false
          },
          {
            "name": "PoSValidatorInfo",
            "path": "./interfaces/IStakingManager.sol",
            "isExternal": false
          },
          {
            "name": "StakingManagerSettings",
            "path": "./interfaces/IStakingManager.sol",
            "isExternal": false
          },
          {
            "name": "Validator",
            "path": "./interfaces/IACP99Manager.sol",
            "isExternal": false
          },
          {
            "name": "ValidatorStatus",
            "path": "./interfaces/IACP99Manager.sol",
            "isExternal": false
          },
          {
            "name": "PChainOwner",
            "path": "./interfaces/IACP99Manager.sol",
            "isExternal": false
          },
          {
            "name": "IRewardCalculator",
            "path": "./interfaces/IRewardCalculator.sol",
            "isExternal": false
          },
          {
            "name": "IWarpMessenger",
            "path": "@subnet-evm/IWarpMessenger.sol",
            "isExternal": true
          },
          {
            "name": "WarpMessage",
            "path": "@subnet-evm/IWarpMessenger.sol",
            "isExternal": true
          },
          {
            "name": "ReentrancyGuardUpgradeable",
            "path": "@openzeppelin/contracts-upgradeable@5.0.2/utils/ReentrancyGuardUpgradeable.sol",
            "isExternal": true
          },
          {
            "name": "ContextUpgradeable",
            "path": "@openzeppelin/contracts-upgradeable@5.0.2/utils/ContextUpgradeable.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "submitUptimeProof",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_isPoSValidator",
                "type": "internal"
              },
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_updateUptime",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function submitUptimeProof(bytes32 validationID, uint32 messageIndex) external {\n        if (!_isPoSValidator(validationID)) {\n            revert ValidatorNotPoS(validationID);\n        }\n        ValidatorStatus status =\n            _getStakingManagerStorage()._manager.getValidator(validationID).status;\n        if (status != ValidatorStatus.Active) {\n            revert InvalidValidatorStatus(status);\n        }\n\n        // Uptime proofs include the absolute number of seconds the validator has been active.\n        _updateUptime(validationID, messageIndex);\n    }",
            "startLine": 198,
            "signature": "submitUptimeProof(bytes32,uint32)",
            "selector": "0x4d54664a",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "claimDelegationFees",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_withdrawValidationRewards",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function claimDelegationFees(\n        bytes32 validationID\n    ) external {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        ValidatorStatus status = $._manager.getValidator(validationID).status;\n        if (status != ValidatorStatus.Completed) {\n            revert InvalidValidatorStatus(status);\n        }\n\n        if ($._posValidatorInfo[validationID].owner != _msgSender()) {\n            revert UnauthorizedOwner(_msgSender());\n        }\n\n        address rewardRecipient = $._rewardRecipients[validationID];\n\n        if (rewardRecipient == address(0)) {\n            rewardRecipient = $._posValidatorInfo[validationID].owner;\n        }\n\n        _withdrawValidationRewards(rewardRecipient, validationID);\n    }",
            "startLine": 215,
            "signature": "claimDelegationFees(bytes32)",
            "selector": "0x363501aa",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "initiateValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiateValidatorRemovalWithCheck",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorRemoval(\n        bytes32 validationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) external {\n        _initiateValidatorRemovalWithCheck(validationID, includeUptimeProof, messageIndex);\n    }",
            "startLine": 241,
            "signature": "initiateValidatorRemoval(bytes32,bool,uint32)",
            "selector": "0x72bceec5",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "forceInitiateValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiatePoSValidatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function forceInitiateValidatorRemoval(\n        bytes32 validationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) external {\n        // Ignore the return value here to force end validation, regardless of possible missed rewards\n        _initiatePoSValidatorRemoval(validationID, includeUptimeProof, messageIndex);\n    }",
            "startLine": 262,
            "signature": "forceInitiateValidatorRemoval(bytes32,bool,uint32)",
            "selector": "0x7475aa66",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "changeValidatorRewardRecipient",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "ValidatorRewardRecipientChanged"
            ],
            "isVirtual": false,
            "sourceCode": "function changeValidatorRewardRecipient(\n        bytes32 validationID,\n        address rewardRecipient\n    ) external {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        if (rewardRecipient == address(0)) {\n            revert InvalidRewardRecipient(rewardRecipient);\n        }\n\n        if ($._posValidatorInfo[validationID].owner != _msgSender()) {\n            revert UnauthorizedOwner(_msgSender());\n        }\n\n        address currentRecipient = $._rewardRecipients[validationID];\n        $._rewardRecipients[validationID] = rewardRecipient;\n\n        emit ValidatorRewardRecipientChanged(validationID, rewardRecipient, currentRecipient);\n    }",
            "startLine": 274,
            "signature": "changeValidatorRewardRecipient(bytes32,address)",
            "selector": "0x08b86a89",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "changeDelegatorRewardRecipient",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "DelegatorRewardRecipientChanged"
            ],
            "isVirtual": false,
            "sourceCode": "function changeDelegatorRewardRecipient(\n        bytes32 delegationID,\n        address rewardRecipient\n    ) external {\n        if (rewardRecipient == address(0)) {\n            revert InvalidRewardRecipient(rewardRecipient);\n        }\n\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        if ($._delegatorStakes[delegationID].owner != _msgSender()) {\n            revert UnauthorizedOwner(_msgSender());\n        }\n\n        address currentRecipient = $._delegatorRewardRecipients[delegationID];\n        $._delegatorRewardRecipients[delegationID] = rewardRecipient;\n\n        emit DelegatorRewardRecipientChanged(delegationID, rewardRecipient, currentRecipient);\n    }",
            "startLine": 297,
            "signature": "changeDelegatorRewardRecipient(bytes32,address)",
            "selector": "0x26295ae8",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "completeValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_isPoSValidator",
                "type": "internal"
              },
              {
                "target": "_withdrawValidationRewards",
                "type": "internal"
              },
              {
                "target": "_unlock",
                "type": "internal"
              },
              {
                "target": "weightToValue",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorRemoval(\n        uint32 messageIndex\n    ) external nonReentrant returns (bytes32) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        // Check if the validator has been already been removed from the validator manager.\n        bytes32 validationID = $._manager.completeValidatorRemoval(messageIndex);\n        Validator memory validator = $._manager.getValidator(validationID);\n\n        // Return now if this was originally a PoA validator that was later migrated to this PoS manager,\n        // or the validator was part of the initial validator set.\n        if (!_isPoSValidator(validationID)) {\n            return validationID;\n        }\n\n        address owner = $._posValidatorInfo[validationID].owner;\n        address rewardRecipient = $._rewardRecipients[validationID];\n\n        // the reward-recipient should always be set, but just in case it isn't, we won't burn the reward\n        if (rewardRecipient == address(0)) {\n            rewardRecipient = owner;\n        }\n\n        // The validator can either be Completed or Invalidated here. We only grant rewards for Completed.\n        if (validator.status == ValidatorStatus.Completed) {\n            _withdrawValidationRewards(rewardRecipient, validationID);\n        }\n\n        // The stake is unlocked whether the validation period is completed or invalidated.\n        _unlock(owner, weightToValue(validator.startingWeight));\n\n        return validationID;\n    }",
            "startLine": 378,
            "signature": "completeValidatorRemoval(uint32)",
            "selector": "0x74b83085",
            "visibility": "external",
            "modifiers": [
              "nonReentrant"
            ]
          },
          {
            "name": "completeValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorRegistration(\n        uint32 messageIndex\n    ) external returns (bytes32) {\n        return _getStakingManagerStorage()._manager.completeValidatorRegistration(messageIndex);\n    }",
            "startLine": 520,
            "signature": "completeValidatorRegistration(uint32)",
            "selector": "0x5442dda6",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "valueToWeight",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function valueToWeight(\n        uint256 value\n    ) public view returns (uint64) {\n        uint256 weight = value / _getStakingManagerStorage()._weightToValueFactor;\n        if (weight == 0 || weight > type(uint64).max) {\n            revert InvalidStakeAmount(value);\n        }\n        return uint64(weight);\n    }",
            "startLine": 530,
            "signature": "valueToWeight(uint256)",
            "selector": "0x2bf991d4",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "weightToValue",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "weight",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function weightToValue(\n        uint64 weight\n    ) public view returns (uint256) {\n        return uint256(weight) * _getStakingManagerStorage()._weightToValueFactor;\n    }",
            "startLine": 544,
            "signature": "weightToValue(uint64)",
            "selector": "0x37041e87",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getStakingManagerSettings",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "StakingManagerSettings"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getStakingManagerSettings() public view returns (StakingManagerSettings memory) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        return StakingManagerSettings({\n            manager: $._manager,\n            minimumStakeAmount: $._minimumStakeAmount,\n            maximumStakeAmount: $._maximumStakeAmount,\n            minimumStakeDuration: $._minimumStakeDuration,\n            minimumDelegationFeeBips: $._minimumDelegationFeeBips,\n            maximumStakeMultiplier: uint8($._maximumStakeMultiplier),\n            weightToValueFactor: $._weightToValueFactor,\n            rewardCalculator: $._rewardCalculator,\n            uptimeBlockchainID: $._uptimeBlockchainID\n        });\n    }",
            "startLine": 553,
            "signature": "getStakingManagerSettings()",
            "selector": "0x6805e870",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getStakingValidator",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "PoSValidatorInfo"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getStakingValidator(\n        bytes32 validationID\n    ) public view returns (PoSValidatorInfo memory) {\n        return _getStakingManagerStorage()._posValidatorInfo[validationID];\n    }",
            "startLine": 572,
            "signature": "getStakingValidator(bytes32)",
            "selector": "0x0b958a2a",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getValidatorRewardInfo",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getValidatorRewardInfo(\n        bytes32 validationID\n    ) public view returns (address, uint256) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        return ($._rewardRecipients[validationID], $._redeemableValidatorRewards[validationID]);\n    }",
            "startLine": 583,
            "signature": "getValidatorRewardInfo(bytes32)",
            "selector": "0x1198b36e",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getDelegatorInfo",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "Delegator"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getDelegatorInfo(\n        bytes32 delegationID\n    ) public view returns (Delegator memory) {\n        return _getStakingManagerStorage()._delegatorStakes[delegationID];\n    }",
            "startLine": 593,
            "signature": "getDelegatorInfo(bytes32)",
            "selector": "0x7f07e78c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getDelegatorRewardInfo",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getDelegatorRewardInfo(\n        bytes32 delegationID\n    ) public view returns (address, uint256) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        return (\n            $._delegatorRewardRecipients[delegationID], $._redeemableDelegatorRewards[delegationID]\n        );\n    }",
            "startLine": 604,
            "signature": "getDelegatorRewardInfo(bytes32)",
            "selector": "0x149215a3",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "completeDelegatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_completeDelegatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [
              "CompletedDelegatorRegistration"
            ],
            "isVirtual": false,
            "sourceCode": "function completeDelegatorRegistration(bytes32 delegationID, uint32 messageIndex) external {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        Delegator memory delegator = $._delegatorStakes[delegationID];\n        bytes32 validationID = delegator.validationID;\n        Validator memory validator = $._manager.getValidator(validationID);\n\n        // Ensure the delegator is pending added. Since anybody can call this function once\n        // delegator registration has been initiated, we need to make sure that this function is only\n        // callable after that has been done.\n        if (delegator.status != DelegatorStatus.PendingAdded) {\n            revert InvalidDelegatorStatus(delegator.status);\n        }\n\n        // In the case where the validator has completed its validation period, we can no\n        // longer stake and should move our status directly to completed and return the stake.\n        if (validator.status == ValidatorStatus.Completed) {\n            return _completeDelegatorRemoval(delegationID);\n        }\n\n        // If we've already received a weight update with a nonce greater than the delegation's starting nonce,\n        // then there's no requirement to include an ICM message in this function call.\n        if (validator.receivedNonce < delegator.startingNonce) {\n            (bytes32 messageValidationID, uint64 nonce) =\n                $._manager.completeValidatorWeightUpdate(messageIndex);\n\n            if (validationID != messageValidationID) {\n                revert UnexpectedValidationID(messageValidationID, validationID);\n            }\n            if (nonce < delegator.startingNonce) {\n                revert InvalidNonce(nonce);\n            }\n        }\n\n        // Update the delegation status\n        $._delegatorStakes[delegationID].status = DelegatorStatus.Active;\n        $._delegatorStakes[delegationID].startTime = uint64(block.timestamp);\n\n        emit CompletedDelegatorRegistration({\n            delegationID: delegationID,\n            validationID: validationID,\n            startTime: uint64(block.timestamp)\n        });\n    }",
            "startLine": 697,
            "signature": "completeDelegatorRegistration(bytes32,uint32)",
            "selector": "0x7ac53d57",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "initiateDelegatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiateDelegatorRemovalWithCheck",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateDelegatorRemoval(\n        bytes32 delegationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) external {\n        _initiateDelegatorRemovalWithCheck(delegationID, includeUptimeProof, messageIndex);\n    }",
            "startLine": 745,
            "signature": "initiateDelegatorRemoval(bytes32,bool,uint32)",
            "selector": "0x66f514b6",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "forceInitiateDelegatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiateDelegatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function forceInitiateDelegatorRemoval(\n        bytes32 delegationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) external {\n        // Ignore the return value here to force end delegation, regardless of possible missed rewards\n        _initiateDelegatorRemoval(delegationID, includeUptimeProof, messageIndex);\n    }",
            "startLine": 766,
            "signature": "forceInitiateDelegatorRemoval(bytes32,bool,uint32)",
            "selector": "0x7fc27b8b",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "resendUpdateDelegator",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "WARP_MESSENGER.sendWarpMessage",
                "type": "library"
              },
              {
                "target": "ValidatorMessages.packL1ValidatorWeightMessage",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function resendUpdateDelegator(\n        bytes32 delegationID\n    ) external {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        Delegator memory delegator = $._delegatorStakes[delegationID];\n        if (\n            delegator.status != DelegatorStatus.PendingAdded\n                && delegator.status != DelegatorStatus.PendingRemoved\n        ) {\n            revert InvalidDelegatorStatus(delegator.status);\n        }\n\n        Validator memory validator = $._manager.getValidator(delegator.validationID);\n        if (validator.sentNonce == 0) {\n            // Should be unreachable.\n            revert InvalidDelegationID(delegationID);\n        }\n\n        // Submit the message to the Warp precompile.\n        WARP_MESSENGER.sendWarpMessage(\n            ValidatorMessages.packL1ValidatorWeightMessage(\n                delegator.validationID, validator.sentNonce, validator.weight\n            )\n        );\n    }",
            "startLine": 902,
            "signature": "resendUpdateDelegator(bytes32)",
            "selector": "0x28f303d8",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "completeDelegatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_completeDelegatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeDelegatorRemoval(\n        bytes32 delegationID,\n        uint32 messageIndex\n    ) external nonReentrant {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        Delegator memory delegator = $._delegatorStakes[delegationID];\n\n        // Ensure the delegator is pending removed. Since anybody can call this function once\n        // end delegation has been initiated, we need to make sure that this function is only\n        // callable after that has been done.\n        if (delegator.status != DelegatorStatus.PendingRemoved) {\n            revert InvalidDelegatorStatus(delegator.status);\n        }\n        Validator memory validator = $._manager.getValidator(delegator.validationID);\n\n        // We only expect an ICM message if we haven't received a weight update with a nonce greater than the delegation's ending nonce\n        if (\n            $._manager.getValidator(delegator.validationID).status != ValidatorStatus.Completed\n                && validator.receivedNonce < delegator.endingNonce\n        ) {\n            (bytes32 validationID, uint64 nonce) =\n                $._manager.completeValidatorWeightUpdate(messageIndex);\n            if (delegator.validationID != validationID) {\n                revert UnexpectedValidationID(validationID, delegator.validationID);\n            }\n\n            // The received nonce should be at least as high as the delegation's ending nonce. This allows a weight\n            // update using a higher nonce (which implicitly includes the delegation's weight update) to be used to\n            // complete delisting for an earlier delegation. This is necessary because the P-Chain is only willing\n            // to sign the latest weight update.\n            if (delegator.endingNonce > nonce) {\n                revert InvalidNonce(nonce);\n            }\n        }\n\n        _completeDelegatorRemoval(delegationID);\n    }",
            "startLine": 932,
            "signature": "completeDelegatorRemoval(bytes32,uint32)",
            "selector": "0x702b3fb8",
            "visibility": "external",
            "modifiers": [
              "nonReentrant"
            ]
          }
        ],
        "internalFunctions": [
          {
            "name": "_getStakingManagerStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "StakingManagerStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getStakingManagerStorage() internal pure returns (StakingManagerStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := STAKING_MANAGER_STORAGE_LOCATION\n        }\n    }",
            "startLine": 117,
            "visibility": "internal"
          },
          {
            "name": "__StakingManager_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "StakingManagerSettings"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ReentrancyGuard_init",
                "type": "internal"
              },
              {
                "target": "__StakingManager_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __StakingManager_init(\n        StakingManagerSettings calldata settings\n    ) internal onlyInitializing {\n        __ReentrancyGuard_init();\n        __StakingManager_init_unchained({\n            manager: settings.manager,\n            minimumStakeAmount: settings.minimumStakeAmount,\n            maximumStakeAmount: settings.maximumStakeAmount,\n            minimumStakeDuration: settings.minimumStakeDuration,\n            minimumDelegationFeeBips: settings.minimumDelegationFeeBips,\n            maximumStakeMultiplier: settings.maximumStakeMultiplier,\n            weightToValueFactor: settings.weightToValueFactor,\n            rewardCalculator: settings.rewardCalculator,\n            uptimeBlockchainID: settings.uptimeBlockchainID\n        });\n    }",
            "startLine": 125,
            "visibility": "internal"
          },
          {
            "name": "__StakingManager_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "manager",
                "type": "IValidatorManager"
              },
              {
                "name": "minimumStakeAmount",
                "type": "uint256"
              },
              {
                "name": "maximumStakeAmount",
                "type": "uint256"
              },
              {
                "name": "minimumStakeDuration",
                "type": "uint64"
              },
              {
                "name": "minimumDelegationFeeBips",
                "type": "uint16"
              },
              {
                "name": "maximumStakeMultiplier",
                "type": "uint8"
              },
              {
                "name": "weightToValueFactor",
                "type": "uint256"
              },
              {
                "name": "rewardCalculator",
                "type": "IRewardCalculator"
              },
              {
                "name": "uptimeBlockchainID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "manager.getChurnPeriodSeconds",
                "type": "external"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __StakingManager_init_unchained(\n        IValidatorManager manager,\n        uint256 minimumStakeAmount,\n        uint256 maximumStakeAmount,\n        uint64 minimumStakeDuration,\n        uint16 minimumDelegationFeeBips,\n        uint8 maximumStakeMultiplier,\n        uint256 weightToValueFactor,\n        IRewardCalculator rewardCalculator,\n        bytes32 uptimeBlockchainID\n    ) internal onlyInitializing {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        if (minimumDelegationFeeBips == 0 || minimumDelegationFeeBips > MAXIMUM_DELEGATION_FEE_BIPS)\n        {\n            revert InvalidDelegationFee(minimumDelegationFeeBips);\n        }\n        if (minimumStakeAmount > maximumStakeAmount) {\n            revert InvalidStakeAmount(minimumStakeAmount);\n        }\n        if (maximumStakeMultiplier == 0 || maximumStakeMultiplier > MAXIMUM_STAKE_MULTIPLIER_LIMIT)\n        {\n            revert InvalidStakeMultiplier(maximumStakeMultiplier);\n        }\n        if (address(manager) == address(0)) {\n            revert ZeroAddress();\n        }\n        if (address(rewardCalculator) == address(0)) {\n            revert ZeroAddress();\n        }\n\n        // Minimum stake duration should be at least one churn period in order to prevent churn tracker abuse.\n        if (minimumStakeDuration < manager.getChurnPeriodSeconds()) {\n            revert InvalidMinStakeDuration(minimumStakeDuration);\n        }\n        if (weightToValueFactor == 0) {\n            revert ZeroWeightToValueFactor();\n        }\n        if (uptimeBlockchainID == bytes32(0)) {\n            revert InvalidUptimeBlockchainID(uptimeBlockchainID);\n        }\n\n        $._manager = manager;\n        $._minimumStakeAmount = minimumStakeAmount;\n        $._maximumStakeAmount = maximumStakeAmount;\n        $._minimumStakeDuration = minimumStakeDuration;\n        $._minimumDelegationFeeBips = minimumDelegationFeeBips;\n        $._maximumStakeMultiplier = maximumStakeMultiplier;\n        $._weightToValueFactor = weightToValueFactor;\n        $._rewardCalculator = rewardCalculator;\n        $._uptimeBlockchainID = uptimeBlockchainID;\n    }",
            "startLine": 143,
            "visibility": "internal"
          },
          {
            "name": "_initiateValidatorRemovalWithCheck",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiatePoSValidatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _initiateValidatorRemovalWithCheck(\n        bytes32 validationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) internal {\n        if (!_initiatePoSValidatorRemoval(validationID, includeUptimeProof, messageIndex)) {\n            revert ValidatorIneligibleForRewards(validationID);\n        }\n    }",
            "startLine": 249,
            "visibility": "internal"
          },
          {
            "name": "_initiatePoSValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_isPoSValidator",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_updateUptime",
                "type": "internal"
              },
              {
                "target": "weightToValue",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _initiatePoSValidatorRemoval(\n        bytes32 validationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) internal returns (bool) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        $._manager.initiateValidatorRemoval(validationID);\n\n        // The validator must be fetched after the removal has been initiated, since the above call modifies\n        // the validator's state.\n        Validator memory validator = $._manager.getValidator(validationID);\n\n        // Non-PoS validators are required to boostrap the network, but are not eligible for rewards.\n        if (!_isPoSValidator(validationID)) {\n            return true;\n        }\n\n        // PoS validations can only be ended by their owners.\n        if ($._posValidatorInfo[validationID].owner != _msgSender()) {\n            revert UnauthorizedOwner(_msgSender());\n        }\n\n        // Check that minimum stake duration has passed.\n        if (\n            validator.endTime\n                < validator.startTime + $._posValidatorInfo[validationID].minStakeDuration\n        ) {\n            revert MinStakeDurationNotPassed(validator.endTime);\n        }\n\n        // Uptime proofs include the absolute number of seconds the validator has been active.\n        uint64 uptimeSeconds;\n        if (includeUptimeProof) {\n            uptimeSeconds = _updateUptime(validationID, messageIndex);\n        } else {\n            uptimeSeconds = $._posValidatorInfo[validationID].uptimeSeconds;\n        }\n\n        uint256 reward = $._rewardCalculator.calculateReward({\n            stakeAmount: weightToValue(validator.startingWeight),\n            validatorStartTime: validator.startTime,\n            stakingStartTime: validator.startTime,\n            stakingEndTime: validator.endTime,\n            uptimeSeconds: uptimeSeconds\n        });\n\n        $._redeemableValidatorRewards[validationID] += reward;\n\n        return (reward > 0);\n    }",
            "startLine": 322,
            "visibility": "internal"
          },
          {
            "name": "_updateUptime",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "WARP_MESSENGER.getVerifiedWarpMessage",
                "type": "library"
              },
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "ValidatorMessages.unpackValidationUptimeMessage",
                "type": "library"
              }
            ],
            "emits": [
              "UptimeUpdated"
            ],
            "isVirtual": false,
            "sourceCode": "function _updateUptime(bytes32 validationID, uint32 messageIndex) internal returns (uint64) {\n        (WarpMessage memory warpMessage, bool valid) =\n            WARP_MESSENGER.getVerifiedWarpMessage(messageIndex);\n        if (!valid) {\n            revert InvalidWarpMessage();\n        }\n\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        // The uptime proof must be from the specifed uptime blockchain\n        if (warpMessage.sourceChainID != $._uptimeBlockchainID) {\n            revert InvalidWarpSourceChainID(warpMessage.sourceChainID);\n        }\n\n        // The sender is required to be the zero address so that we know the validator node\n        // signed the proof directly, rather than as an arbitrary on-chain message\n        if (warpMessage.originSenderAddress != address(0)) {\n            revert InvalidWarpOriginSenderAddress(warpMessage.originSenderAddress);\n        }\n\n        (bytes32 uptimeValidationID, uint64 uptime) =\n            ValidatorMessages.unpackValidationUptimeMessage(warpMessage.payload);\n        if (validationID != uptimeValidationID) {\n            revert UnexpectedValidationID(uptimeValidationID, validationID);\n        }\n\n        if (uptime > $._posValidatorInfo[validationID].uptimeSeconds) {\n            $._posValidatorInfo[validationID].uptimeSeconds = uptime;\n            emit UptimeUpdated(validationID, uptime);\n        } else {\n            uptime = $._posValidatorInfo[validationID].uptimeSeconds;\n        }\n\n        return uptime;\n    }",
            "startLine": 416,
            "visibility": "internal"
          },
          {
            "name": "_initiateValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "nodeID",
                "type": "bytes"
              },
              {
                "name": "blsPublicKey",
                "type": "bytes"
              },
              {
                "name": "remainingBalanceOwner",
                "type": "PChainOwner"
              },
              {
                "name": "disableOwner",
                "type": "PChainOwner"
              },
              {
                "name": "delegationFeeBips",
                "type": "uint16"
              },
              {
                "name": "minStakeDuration",
                "type": "uint64"
              },
              {
                "name": "stakeAmount",
                "type": "uint256"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_lock",
                "type": "internal"
              },
              {
                "target": "valueToWeight",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "InitiatedStakingValidatorRegistration"
            ],
            "isVirtual": true,
            "sourceCode": "function _initiateValidatorRegistration(\n        bytes memory nodeID,\n        bytes memory blsPublicKey,\n        PChainOwner memory remainingBalanceOwner,\n        PChainOwner memory disableOwner,\n        uint16 delegationFeeBips,\n        uint64 minStakeDuration,\n        uint256 stakeAmount,\n        address rewardRecipient\n    ) internal virtual returns (bytes32) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        // Validate and save the validator requirements\n        if (\n            delegationFeeBips < $._minimumDelegationFeeBips\n                || delegationFeeBips > MAXIMUM_DELEGATION_FEE_BIPS\n        ) {\n            revert InvalidDelegationFee(delegationFeeBips);\n        }\n\n        if (minStakeDuration < $._minimumStakeDuration) {\n            revert InvalidMinStakeDuration(minStakeDuration);\n        }\n\n        // Ensure the weight is within the valid range.\n        if (stakeAmount < $._minimumStakeAmount || stakeAmount > $._maximumStakeAmount) {\n            revert InvalidStakeAmount(stakeAmount);\n        }\n\n        if (rewardRecipient == address(0)) {\n            revert InvalidRewardRecipient(rewardRecipient);\n        }\n\n        // Lock the stake in the contract.\n        uint256 lockedValue = _lock(stakeAmount);\n\n        uint64 weight = valueToWeight(lockedValue);\n        bytes32 validationID = $._manager.initiateValidatorRegistration({\n            nodeID: nodeID,\n            blsPublicKey: blsPublicKey,\n            remainingBalanceOwner: remainingBalanceOwner,\n            disableOwner: disableOwner,\n            weight: weight\n        });\n\n        address owner = _msgSender();\n\n        $._posValidatorInfo[validationID].owner = owner;\n        $._posValidatorInfo[validationID].delegationFeeBips = delegationFeeBips;\n        $._posValidatorInfo[validationID].minStakeDuration = minStakeDuration;\n        $._posValidatorInfo[validationID].uptimeSeconds = 0;\n        $._rewardRecipients[validationID] = rewardRecipient;\n\n        emit InitiatedStakingValidatorRegistration(\n            validationID, owner, delegationFeeBips, minStakeDuration, rewardRecipient\n        );\n\n        return validationID;\n    }",
            "startLine": 458,
            "visibility": "internal"
          },
          {
            "name": "_lock",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _lock(\n        uint256 value\n    ) internal virtual returns (uint256);",
            "startLine": 617,
            "visibility": "internal"
          },
          {
            "name": "_unlock",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _unlock(address to, uint256 value) internal virtual;",
            "startLine": 626,
            "visibility": "internal"
          },
          {
            "name": "_initiateDelegatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "delegatorAddress",
                "type": "address"
              },
              {
                "name": "delegationAmount",
                "type": "uint256"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "valueToWeight",
                "type": "internal"
              },
              {
                "target": "_lock",
                "type": "internal"
              },
              {
                "target": "_isPoSValidator",
                "type": "internal"
              }
            ],
            "emits": [
              "InitiatedDelegatorRegistration"
            ],
            "isVirtual": false,
            "sourceCode": "function _initiateDelegatorRegistration(\n        bytes32 validationID,\n        address delegatorAddress,\n        uint256 delegationAmount,\n        address rewardRecipient\n    ) internal returns (bytes32) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        uint64 weight = valueToWeight(_lock(delegationAmount));\n\n        // Check that the validation ID is a PoS validator\n        if (!_isPoSValidator(validationID)) {\n            revert ValidatorNotPoS(validationID);\n        }\n\n        if (rewardRecipient == address(0)) {\n            revert InvalidRewardRecipient(rewardRecipient);\n        }\n\n        // Update the validator weight\n        uint64 newValidatorWeight;\n        {\n            Validator memory validator = $._manager.getValidator(validationID);\n            newValidatorWeight = validator.weight + weight;\n            if (newValidatorWeight > validator.startingWeight * $._maximumStakeMultiplier) {\n                revert MaxWeightExceeded(newValidatorWeight);\n            }\n        }\n\n        (uint64 nonce, bytes32 messageID) =\n            $._manager.initiateValidatorWeightUpdate(validationID, newValidatorWeight);\n\n        bytes32 delegationID = keccak256(abi.encodePacked(validationID, nonce));\n        // Store the delegation information. Set the delegator status to pending added,\n        // so that it can be properly started in the complete step, even if the delivered\n        // nonce is greater than the nonce used to initiate registration.\n        $._delegatorStakes[delegationID].status = DelegatorStatus.PendingAdded;\n        $._delegatorStakes[delegationID].owner = delegatorAddress;\n        $._delegatorStakes[delegationID].validationID = validationID;\n        $._delegatorStakes[delegationID].weight = weight;\n        $._delegatorStakes[delegationID].startTime = 0;\n        $._delegatorStakes[delegationID].startingNonce = nonce;\n        $._delegatorStakes[delegationID].endingNonce = 0;\n        $._delegatorRewardRecipients[delegationID] = rewardRecipient;\n\n        emit InitiatedDelegatorRegistration({\n            delegationID: delegationID,\n            validationID: validationID,\n            delegatorAddress: delegatorAddress,\n            nonce: nonce,\n            validatorWeight: newValidatorWeight,\n            delegatorWeight: weight,\n            setWeightMessageID: messageID,\n            rewardRecipient: rewardRecipient\n        });\n        return delegationID;\n    }",
            "startLine": 636,
            "visibility": "internal"
          },
          {
            "name": "_initiateDelegatorRemovalWithCheck",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiateDelegatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _initiateDelegatorRemovalWithCheck(\n        bytes32 delegationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) internal {\n        if (!_initiateDelegatorRemoval(delegationID, includeUptimeProof, messageIndex)) {\n            revert DelegatorIneligibleForRewards(delegationID);\n        }\n    }",
            "startLine": 753,
            "visibility": "internal"
          },
          {
            "name": "_initiateDelegatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_updateUptime",
                "type": "internal"
              },
              {
                "target": "_calculateAndSetDelegationReward",
                "type": "internal"
              },
              {
                "target": "_completeDelegatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [
              "InitiatedDelegatorRemoval"
            ],
            "isVirtual": false,
            "sourceCode": "function _initiateDelegatorRemoval(\n        bytes32 delegationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) internal returns (bool) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        Delegator memory delegator = $._delegatorStakes[delegationID];\n        bytes32 validationID = delegator.validationID;\n        Validator memory validator = $._manager.getValidator(validationID);\n\n        // Ensure the delegator is active\n        if (delegator.status != DelegatorStatus.Active) {\n            revert InvalidDelegatorStatus(delegator.status);\n        }\n\n        // Only the delegation owner or parent validator can end the delegation.\n        if (delegator.owner != _msgSender()) {\n            // Validators can only remove delegations after the minimum stake duration has passed.\n            if ($._posValidatorInfo[validationID].owner != _msgSender()) {\n                revert UnauthorizedOwner(_msgSender());\n            }\n\n            if (\n                block.timestamp\n                    < validator.startTime + $._posValidatorInfo[validationID].minStakeDuration\n            ) {\n                revert MinStakeDurationNotPassed(uint64(block.timestamp));\n            }\n        }\n\n        address rewardRecipient = $._delegatorRewardRecipients[delegationID];\n        if (validator.status == ValidatorStatus.Active) {\n            // Check that minimum stake duration has passed.\n            if (block.timestamp < delegator.startTime + $._minimumStakeDuration) {\n                revert MinStakeDurationNotPassed(uint64(block.timestamp));\n            }\n\n            if (includeUptimeProof) {\n                // Uptime proofs include the absolute number of seconds the validator has been active.\n                _updateUptime(validationID, messageIndex);\n            }\n\n            // Set the delegator status to pending removed, so that it can be properly removed in\n            // the complete step, even if the delivered nonce is greater than the nonce used to\n            // initiate the removal.\n            $._delegatorStakes[delegationID].status = DelegatorStatus.PendingRemoved;\n\n            ($._delegatorStakes[delegationID].endingNonce,) = $\n                ._manager\n                .initiateValidatorWeightUpdate(validationID, validator.weight - delegator.weight);\n\n            uint256 reward =\n                _calculateAndSetDelegationReward(delegator, rewardRecipient, delegationID);\n\n            emit InitiatedDelegatorRemoval({delegationID: delegationID, validationID: validationID});\n            return (reward > 0);\n        } else if (validator.status == ValidatorStatus.Completed) {\n            _calculateAndSetDelegationReward(delegator, rewardRecipient, delegationID);\n            _completeDelegatorRemoval(delegationID);\n            // If the validator has completed, then no further uptimes may be submitted, so we always\n            // end the delegation.\n            return true;\n        } else {\n            revert InvalidValidatorStatus(validator.status);\n        }\n    }",
            "startLine": 780,
            "visibility": "internal"
          },
          {
            "name": "_calculateAndSetDelegationReward",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegator",
                "type": "Delegator"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              },
              {
                "name": "delegationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "weightToValue",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _calculateAndSetDelegationReward(\n        Delegator memory delegator,\n        address rewardRecipient,\n        bytes32 delegationID\n    ) private returns (uint256) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        Validator memory validator = $._manager.getValidator(delegator.validationID);\n\n        uint64 delegationEndTime;\n        if (\n            validator.status == ValidatorStatus.PendingRemoved\n                || validator.status == ValidatorStatus.Completed\n        ) {\n            delegationEndTime = validator.endTime;\n        } else if (validator.status == ValidatorStatus.Active) {\n            delegationEndTime = uint64(block.timestamp);\n        } else {\n            // Should be unreachable.\n            revert InvalidValidatorStatus(validator.status);\n        }\n\n        // Only give rewards in the case that the delegation started before the validator exited.\n        if (delegationEndTime <= delegator.startTime) {\n            return 0;\n        }\n\n        uint256 reward = $._rewardCalculator.calculateReward({\n            stakeAmount: weightToValue(delegator.weight),\n            validatorStartTime: validator.startTime,\n            stakingStartTime: delegator.startTime,\n            stakingEndTime: delegationEndTime,\n            uptimeSeconds: $._posValidatorInfo[delegator.validationID].uptimeSeconds\n        });\n\n        if (rewardRecipient == address(0)) {\n            rewardRecipient = delegator.owner;\n        }\n\n        $._redeemableDelegatorRewards[delegationID] = reward;\n        $._delegatorRewardRecipients[delegationID] = rewardRecipient;\n\n        return reward;\n    }",
            "startLine": 852,
            "visibility": "private"
          },
          {
            "name": "_completeDelegatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_withdrawDelegationRewards",
                "type": "internal"
              },
              {
                "target": "_unlock",
                "type": "internal"
              },
              {
                "target": "weightToValue",
                "type": "internal"
              }
            ],
            "emits": [
              "CompletedDelegatorRemoval"
            ],
            "isVirtual": false,
            "sourceCode": "function _completeDelegatorRemoval(\n        bytes32 delegationID\n    ) internal {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        Delegator memory delegator = $._delegatorStakes[delegationID];\n        bytes32 validationID = delegator.validationID;\n\n        // To prevent churn tracker abuse, check that one full churn period has passed,\n        // so a delegator may not stake twice in the same churn period.\n        if (block.timestamp < delegator.startTime + $._manager.getChurnPeriodSeconds()) {\n            revert MinStakeDurationNotPassed(uint64(block.timestamp));\n        }\n\n        // Once this function completes, the delegation is completed so we can clear it from state now.\n        delete $._delegatorStakes[delegationID];\n\n        address rewardRecipient = $._delegatorRewardRecipients[delegationID];\n        delete $._delegatorRewardRecipients[delegationID];\n\n        if (rewardRecipient == address(0)) {\n            rewardRecipient = delegator.owner;\n        }\n\n        (uint256 delegationRewards, uint256 validatorFees) =\n            _withdrawDelegationRewards(rewardRecipient, delegationID, validationID);\n\n        // Unlock the delegator's stake.\n        _unlock(delegator.owner, weightToValue(delegator.weight));\n\n        emit CompletedDelegatorRemoval(delegationID, validationID, delegationRewards, validatorFees);\n    }",
            "startLine": 970,
            "visibility": "internal"
          },
          {
            "name": "_reward",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _reward(address account, uint256 amount) internal virtual;",
            "startLine": 1006,
            "visibility": "internal"
          },
          {
            "name": "_isPoSValidator",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isPoSValidator(\n        bytes32 validationID\n    ) internal view returns (bool) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n        return $._posValidatorInfo[validationID].owner != address(0);\n    }",
            "startLine": 1012,
            "visibility": "internal"
          },
          {
            "name": "_withdrawValidationRewards",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "rewardRecipient",
                "type": "address"
              },
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_reward",
                "type": "internal"
              }
            ],
            "emits": [
              "ValidatorRewardClaimed"
            ],
            "isVirtual": false,
            "sourceCode": "function _withdrawValidationRewards(address rewardRecipient, bytes32 validationID) internal {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        uint256 rewards = $._redeemableValidatorRewards[validationID];\n        delete $._redeemableValidatorRewards[validationID];\n\n        _reward(rewardRecipient, rewards);\n\n        emit ValidatorRewardClaimed(validationID, rewardRecipient, rewards);\n    }",
            "startLine": 1019,
            "visibility": "internal"
          },
          {
            "name": "_withdrawDelegationRewards",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "rewardRecipient",
                "type": "address"
              },
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getStakingManagerStorage",
                "type": "internal"
              },
              {
                "target": "_reward",
                "type": "internal"
              }
            ],
            "emits": [
              "DelegatorRewardClaimed"
            ],
            "isVirtual": false,
            "sourceCode": "function _withdrawDelegationRewards(\n        address rewardRecipient,\n        bytes32 delegationID,\n        bytes32 validationID\n    ) internal returns (uint256, uint256) {\n        StakingManagerStorage storage $ = _getStakingManagerStorage();\n\n        uint256 delegationRewards;\n        uint256 validatorFees;\n\n        uint256 rewards = $._redeemableDelegatorRewards[delegationID];\n\n        if (rewards > 0) {\n            delete $._redeemableDelegatorRewards[delegationID];\n\n            validatorFees = (rewards * $._posValidatorInfo[validationID].delegationFeeBips)\n                / BIPS_CONVERSION_FACTOR;\n\n            // Allocate the delegation fees to the validator.\n            $._redeemableValidatorRewards[validationID] += validatorFees;\n\n            // Reward the remaining tokens to the delegator.\n            delegationRewards = rewards - validatorFees;\n            _reward(rewardRecipient, delegationRewards);\n\n            emit DelegatorRewardClaimed(delegationID, rewardRecipient, delegationRewards);\n        }\n\n        return (delegationRewards, validatorFees);\n    }",
            "startLine": 1030,
            "visibility": "internal"
          },
          {
            "name": "__Context_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Context_init() internal onlyInitializing {\n    }",
            "startLine": 18,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "__Context_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Context_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 21,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "_msgSender",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }",
            "startLine": 23,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "_msgData",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }",
            "startLine": 27,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "_contextSuffixLength",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }",
            "startLine": 31,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getReentrancyGuardStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ReentrancyGuardStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }",
            "startLine": 49,
            "visibility": "private",
            "inheritedFrom": "ReentrancyGuardUpgradeable"
          },
          {
            "name": "__ReentrancyGuard_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "__ReentrancyGuard_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }",
            "startLine": 60,
            "visibility": "internal",
            "inheritedFrom": "ReentrancyGuardUpgradeable"
          },
          {
            "name": "__ReentrancyGuard_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }",
            "startLine": 64,
            "visibility": "internal",
            "inheritedFrom": "ReentrancyGuardUpgradeable"
          },
          {
            "name": "_nonReentrantBefore",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }",
            "startLine": 82,
            "visibility": "private",
            "inheritedFrom": "ReentrancyGuardUpgradeable"
          },
          {
            "name": "_nonReentrantAfter",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }",
            "startLine": 93,
            "visibility": "private",
            "inheritedFrom": "ReentrancyGuardUpgradeable"
          },
          {
            "name": "_reentrancyGuardEntered",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }",
            "startLine": 104,
            "visibility": "internal",
            "inheritedFrom": "ReentrancyGuardUpgradeable"
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "InvalidDelegationFee",
            "parameters": [
              {
                "name": "delegationFeeBips",
                "type": "uint16"
              }
            ]
          },
          {
            "name": "InvalidDelegationID",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              }
            ]
          },
          {
            "name": "InvalidDelegatorStatus",
            "parameters": [
              {
                "name": "status",
                "type": "DelegatorStatus"
              }
            ]
          },
          {
            "name": "InvalidRewardRecipient",
            "parameters": [
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ]
          },
          {
            "name": "InvalidStakeAmount",
            "parameters": [
              {
                "name": "stakeAmount",
                "type": "uint256"
              }
            ]
          },
          {
            "name": "InvalidMinStakeDuration",
            "parameters": [
              {
                "name": "minStakeDuration",
                "type": "uint64"
              }
            ]
          },
          {
            "name": "InvalidStakeMultiplier",
            "parameters": [
              {
                "name": "maximumStakeMultiplier",
                "type": "uint8"
              }
            ]
          },
          {
            "name": "MaxWeightExceeded",
            "parameters": [
              {
                "name": "newValidatorWeight",
                "type": "uint64"
              }
            ]
          },
          {
            "name": "MinStakeDurationNotPassed",
            "parameters": [
              {
                "name": "endTime",
                "type": "uint64"
              }
            ]
          },
          {
            "name": "UnauthorizedOwner",
            "parameters": [
              {
                "name": "sender",
                "type": "address"
              }
            ]
          },
          {
            "name": "ValidatorNotPoS",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ]
          },
          {
            "name": "ValidatorIneligibleForRewards",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ]
          },
          {
            "name": "DelegatorIneligibleForRewards",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              }
            ]
          },
          {
            "name": "ZeroWeightToValueFactor",
            "parameters": []
          },
          {
            "name": "InvalidUptimeBlockchainID",
            "parameters": [
              {
                "name": "uptimeBlockchainID",
                "type": "bytes32"
              }
            ]
          },
          {
            "name": "InvalidWarpOriginSenderAddress",
            "parameters": [
              {
                "name": "senderAddress",
                "type": "address"
              }
            ]
          },
          {
            "name": "InvalidWarpSourceChainID",
            "parameters": [
              {
                "name": "sourceChainID",
                "type": "bytes32"
              }
            ]
          },
          {
            "name": "UnexpectedValidationID",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "expectedValidationID",
                "type": "bytes32"
              }
            ]
          },
          {
            "name": "InvalidValidatorStatus",
            "parameters": [
              {
                "name": "status",
                "type": "ValidatorStatus"
              }
            ]
          },
          {
            "name": "InvalidNonce",
            "parameters": [
              {
                "name": "nonce",
                "type": "uint64"
              }
            ]
          },
          {
            "name": "InvalidWarpMessage",
            "parameters": []
          },
          {
            "name": "ZeroAddress",
            "parameters": []
          }
        ]
      },
      {
        "name": "ValidatorManager",
        "kind": "contract",
        "category": "validator-manager",
        "filePath": "@validator-manager/ValidatorManager.sol",
        "inherits": [
          "Initializable",
          "OwnableUpgradeable",
          "ACP99Manager"
        ],
        "implements": [
          "IValidatorManager"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IValidatorManager",
            "path": "./interfaces/IValidatorManager.sol",
            "isExternal": false
          },
          {
            "name": "ValidatorMessages",
            "path": "./ValidatorMessages.sol",
            "isExternal": false
          },
          {
            "name": "InitialValidator",
            "path": "./interfaces/IACP99Manager.sol",
            "isExternal": false
          },
          {
            "name": "PChainOwner",
            "path": "./interfaces/IACP99Manager.sol",
            "isExternal": false
          },
          {
            "name": "ConversionData",
            "path": "./interfaces/IACP99Manager.sol",
            "isExternal": false
          },
          {
            "name": "Validator",
            "path": "./interfaces/IACP99Manager.sol",
            "isExternal": false
          },
          {
            "name": "ValidatorStatus",
            "path": "./interfaces/IACP99Manager.sol",
            "isExternal": false
          },
          {
            "name": "ACP99Manager",
            "path": "./ACP99Manager.sol",
            "isExternal": false
          },
          {
            "name": "IWarpMessenger",
            "path": "@subnet-evm/IWarpMessenger.sol",
            "isExternal": true
          },
          {
            "name": "WarpMessage",
            "path": "@subnet-evm/IWarpMessenger.sol",
            "isExternal": true
          },
          {
            "name": "OwnableUpgradeable",
            "path": "@openzeppelin/contracts-upgradeable@5.0.2/access/OwnableUpgradeable.sol",
            "isExternal": true
          },
          {
            "name": "Initializable",
            "path": "@openzeppelin/contracts-upgradeable@5.0.2/proxy/utils/Initializable.sol",
            "isExternal": true
          },
          {
            "name": "ICMInitializable",
            "path": "@utilities/ICMInitializable.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "migrateFromV1",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "receivedNonce",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function migrateFromV1(bytes32 validationID, uint32 receivedNonce) external {\n        ValidatorManagerStorage storage $ = _getValidatorManagerStorage();\n        ValidatorLegacy storage legacy = $._validationPeriodsLegacy[validationID];\n        if (legacy.status == ValidatorStatus.Unknown) {\n            revert InvalidValidationID(validationID);\n        }\n        if (receivedNonce > legacy.messageNonce) {\n            revert InvalidNonce(receivedNonce);\n        }\n\n        $._validationPeriods[validationID] = Validator({\n            status: legacy.status,\n            nodeID: legacy.nodeID,\n            startingWeight: legacy.startingWeight,\n            sentNonce: legacy.messageNonce,\n            receivedNonce: receivedNonce,\n            weight: legacy.weight,\n            startTime: legacy.startedAt,\n            endTime: legacy.endedAt\n        });\n\n        // Set the legacy status to unknown to disallow future migrations.\n        $._validationPeriodsLegacy[validationID].status = ValidatorStatus.Unknown;\n    }",
            "startLine": 138,
            "signature": "migrateFromV1(bytes32,uint32)",
            "selector": "0x71cf6c96",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "initialize",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "ValidatorManagerSettings"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ValidatorManager_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initialize(\n        ValidatorManagerSettings calldata settings\n    ) external initializer {\n        __ValidatorManager_init(settings);\n    }",
            "startLine": 163,
            "signature": "initialize(ValidatorManagerSettings)",
            "selector": "0x3195950d",
            "visibility": "external",
            "modifiers": [
              "initializer"
            ]
          },
          {
            "name": "initializeValidatorSet",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "conversionData",
                "type": "ConversionData"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              },
              {
                "target": "WARP_MESSENGER.getBlockchainID",
                "type": "library"
              },
              {
                "target": "ValidatorMessages.unpackSubnetToL1ConversionMessage",
                "type": "library"
              },
              {
                "target": "_getPChainWarpMessage",
                "type": "internal"
              },
              {
                "target": "ValidatorMessages.packConversionData",
                "type": "library"
              },
              {
                "target": "_fixedNodeID",
                "type": "internal"
              }
            ],
            "emits": [
              "RegisteredInitialValidator"
            ],
            "isVirtual": true,
            "sourceCode": "function initializeValidatorSet(\n        ConversionData calldata conversionData,\n        uint32 messageIndex\n    ) public virtual override {\n        ValidatorManagerStorage storage $ = _getValidatorManagerStorage();\n        if ($._initializedValidatorSet) {\n            revert InvalidInitializationStatus();\n        }\n\n        // Check that the blockchainID and validator manager address in the ConversionData correspond to this contract.\n        // Other validation checks are done by the P-Chain when converting the L1, so are not required here.\n        if (conversionData.validatorManagerBlockchainID != WARP_MESSENGER.getBlockchainID()) {\n            revert InvalidValidatorManagerBlockchainID(conversionData.validatorManagerBlockchainID);\n        }\n        if (address(conversionData.validatorManagerAddress) != address(this)) {\n            revert InvalidValidatorManagerAddress(address(conversionData.validatorManagerAddress));\n        }\n\n        // Verify that the sha256 hash of the L1 conversion data matches with the Warp message's conversionID.\n        bytes32 conversionID = ValidatorMessages.unpackSubnetToL1ConversionMessage(\n            _getPChainWarpMessage(messageIndex).payload\n        );\n        bytes memory encodedConversion = ValidatorMessages.packConversionData(conversionData);\n        bytes32 encodedConversionID = sha256(encodedConversion);\n        if (encodedConversionID != conversionID) {\n            revert InvalidConversionID(encodedConversionID, conversionID);\n        }\n\n        uint256 numInitialValidators = conversionData.initialValidators.length;\n\n        uint64 totalWeight;\n        for (uint32 i; i < numInitialValidators; ++i) {\n            InitialValidator memory initialValidator = conversionData.initialValidators[i];\n            if ($._registeredValidators[initialValidator.nodeID] != bytes32(0)) {\n                revert NodeAlreadyRegistered(initialValidator.nodeID);\n            }\n            if (initialValidator.nodeID.length != NODE_ID_LENGTH) {\n                revert InvalidNodeID(initialValidator.nodeID);\n            }\n\n            // Validation ID of the initial validators is the sha256 hash of the\n            // subnet ID and the index of the initial validator.\n            bytes32 validationID = sha256(abi.encodePacked(conversionData.subnetID, i));\n\n            // Save the initial validator as an active validator.\n            $._registeredValidators[initialValidator.nodeID] = validationID;\n            $._validationPeriods[validationID].status = ValidatorStatus.Active;\n            $._validationPeriods[validationID].nodeID = initialValidator.nodeID;\n            $._validationPeriods[validationID].startingWeight = initialValidator.weight;\n            $._validationPeriods[validationID].sentNonce = 0;\n            $._validationPeriods[validationID].weight = initialValidator.weight;\n            $._validationPeriods[validationID].startTime = uint64(block.timestamp);\n            $._validationPeriods[validationID].endTime = 0;\n            totalWeight += initialValidator.weight;\n\n            emit RegisteredInitialValidator(\n                validationID,\n                _fixedNodeID(initialValidator.nodeID),\n                conversionData.subnetID,\n                initialValidator.weight\n            );\n        }\n        $._churnTracker.totalWeight = totalWeight;\n\n        // Rearranged equation for totalWeight < (100 / $._maximumChurnPercentage)\n        // Total weight must be above this value in order to not trigger churn limits with an added/removed weight of 1.\n        if (totalWeight * $._maximumChurnPercentage < 100) {\n            revert InvalidTotalWeight(totalWeight);\n        }\n\n        $._initializedValidatorSet = true;\n    }",
            "startLine": 208,
            "signature": "initializeValidatorSet(ConversionData,uint32)",
            "selector": "0x5d9e08d4",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "initiateValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "nodeID",
                "type": "bytes"
              },
              {
                "name": "blsPublicKey",
                "type": "bytes"
              },
              {
                "name": "remainingBalanceOwner",
                "type": "PChainOwner"
              },
              {
                "name": "disableOwner",
                "type": "PChainOwner"
              },
              {
                "name": "weight",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_initiateValidatorRegistration",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorRegistration(\n        bytes memory nodeID,\n        bytes memory blsPublicKey,\n        PChainOwner memory remainingBalanceOwner,\n        PChainOwner memory disableOwner,\n        uint64 weight\n    ) public onlyOwner returns (bytes32) {\n        return _initiateValidatorRegistration({\n            nodeID: nodeID,\n            blsPublicKey: blsPublicKey,\n            remainingBalanceOwner: remainingBalanceOwner,\n            disableOwner: disableOwner,\n            weight: weight\n        });\n    }",
            "startLine": 305,
            "signature": "initiateValidatorRegistration(bytes,bytes,PChainOwner,PChainOwner,uint64)",
            "selector": "0x239c60db",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "resendRegisterValidatorMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              },
              {
                "target": "WARP_MESSENGER.sendWarpMessage",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function resendRegisterValidatorMessage(\n        bytes32 validationID\n    ) external {\n        ValidatorManagerStorage storage $ = _getValidatorManagerStorage();\n        // The initial validator set must have been set already to have pending register validation messages.\n        if ($._pendingRegisterValidationMessages[validationID].length == 0) {\n            revert InvalidValidationID(validationID);\n        }\n        if ($._validationPeriods[validationID].status != ValidatorStatus.PendingAdded) {\n            revert InvalidValidatorStatus($._validationPeriods[validationID].status);\n        }\n\n        // Submit the message to the Warp precompile.\n        WARP_MESSENGER.sendWarpMessage($._pendingRegisterValidationMessages[validationID]);\n    }",
            "startLine": 403,
            "signature": "resendRegisterValidatorMessage(bytes32)",
            "selector": "0x3fb1f58c",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "completeValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              },
              {
                "target": "ValidatorMessages.unpackL1ValidatorRegistrationMessage",
                "type": "library"
              },
              {
                "target": "_getPChainWarpMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "CompletedValidatorRegistration"
            ],
            "isVirtual": true,
            "sourceCode": "function completeValidatorRegistration(\n        uint32 messageIndex\n    ) public virtual override onlyOwner returns (bytes32) {\n        ValidatorManagerStorage storage $ = _getValidatorManagerStorage();\n        (bytes32 validationID, bool validRegistration) = ValidatorMessages\n            .unpackL1ValidatorRegistrationMessage(_getPChainWarpMessage(messageIndex).payload);\n\n        if (!validRegistration) {\n            revert UnexpectedRegistrationStatus(validRegistration);\n        }\n        // The initial validator set must have been set already to have pending register validation messages.\n        if ($._pendingRegisterValidationMessages[validationID].length == 0) {\n            revert InvalidValidationID(validationID);\n        }\n        if ($._validationPeriods[validationID].status != ValidatorStatus.PendingAdded) {\n            revert InvalidValidatorStatus($._validationPeriods[validationID].status);\n        }\n\n        delete $._pendingRegisterValidationMessages[validationID];\n        $._validationPeriods[validationID].status = ValidatorStatus.Active;\n        $._validationPeriods[validationID].startTime = uint64(block.timestamp);\n        emit CompletedValidatorRegistration(validationID, $._validationPeriods[validationID].weight);\n\n        return validationID;\n    }",
            "startLine": 422,
            "signature": "completeValidatorRegistration(uint32)",
            "selector": "0x5442dda6",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "getValidator",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "Validator"
              }
            ],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function getValidator(\n        bytes32 validationID\n    ) public view virtual override returns (Validator memory) {\n        ValidatorManagerStorage storage $ = _getValidatorManagerStorage();\n        return $._validationPeriods[validationID];\n    }",
            "startLine": 451,
            "signature": "getValidator(bytes32)",
            "selector": "0x6d91f46b",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "l1TotalWeight",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function l1TotalWeight() public view virtual override returns (uint64) {\n        return _getValidatorManagerStorage()._churnTracker.totalWeight;\n    }",
            "startLine": 461,
            "signature": "l1TotalWeight()",
            "selector": "0x36c1df98",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "subnetID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function subnetID() public view virtual override returns (bytes32) {\n        return _getValidatorManagerStorage()._subnetID;\n    }",
            "startLine": 468,
            "signature": "subnetID()",
            "selector": "0x4dbc7fc7",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getChurnTracker",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              },
              {
                "name": "",
                "type": "uint8"
              },
              {
                "name": "",
                "type": "ValidatorChurnPeriod"
              }
            ],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getChurnTracker() public view returns (uint64, uint8, ValidatorChurnPeriod memory) {\n        ValidatorManagerStorage storage $ = _getValidatorManagerStorage();\n        return ($._churnPeriodSeconds, $._maximumChurnPercentage, $._churnTracker);\n    }",
            "startLine": 478,
            "signature": "getChurnTracker()",
            "selector": "0x66d7be5d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getNodeValidationID",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "nodeID",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getNodeValidationID(\n        bytes calldata nodeID\n    ) public view returns (bytes32) {\n        ValidatorManagerStorage storage $ = _getValidatorManagerStorage();\n        return $._registeredValidators[nodeID];\n    }",
            "startLine": 487,
            "signature": "getNodeValidationID(bytes)",
            "selector": "0x4aff4026",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "isValidatorSetInitialized",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function isValidatorSetInitialized() public view returns (bool) {\n        ValidatorManagerStorage storage $ = _getValidatorManagerStorage();\n        return $._initializedValidatorSet;\n    }",
            "startLine": 497,
            "signature": "isValidatorSetInitialized()",
            "selector": "0x07a29505",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "initiateValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_initiateValidatorRemoval",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorRemoval(\n        bytes32 validationID\n    ) public onlyOwner {\n        _initiateValidatorRemoval(validationID);\n    }",
            "startLine": 505,
            "signature": "initiateValidatorRemoval(bytes32)",
            "selector": "0x5aa039f4",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "resendValidatorRemovalMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              },
              {
                "target": "WARP_MESSENGER.sendWarpMessage",
                "type": "library"
              },
              {
                "target": "ValidatorMessages.packL1ValidatorWeightMessage",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function resendValidatorRemovalMessage(\n        bytes32 validationID\n    ) external {\n        ValidatorManagerStorage storage $ = _getValidatorManagerStorage();\n        Validator memory validator = $._validationPeriods[validationID];\n\n        // The initial validator set must have been set already to have pending end validation messages.\n        if (validator.status != ValidatorStatus.PendingRemoved) {\n            revert InvalidValidatorStatus($._validationPeriods[validationID].status);\n        }\n\n        WARP_MESSENGER.sendWarpMessage(\n            ValidatorMessages.packL1ValidatorWeightMessage(validationID, validator.sentNonce, 0)\n        );\n    }",
            "startLine": 551,
            "signature": "resendValidatorRemovalMessage(bytes32)",
            "selector": "0x296b3215",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "completeValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              },
              {
                "target": "ValidatorMessages.unpackL1ValidatorRegistrationMessage",
                "type": "library"
              },
              {
                "target": "_getPChainWarpMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "CompletedValidatorRemoval"
            ],
            "isVirtual": true,
            "sourceCode": "function completeValidatorRemoval(\n        uint32 messageIndex\n    ) public virtual override onlyOwner returns (bytes32) {\n        ValidatorManagerStorage storage $ = _getValidatorManagerStorage();\n\n        // Get the Warp message.\n        (bytes32 validationID, bool registered) = ValidatorMessages\n            .unpackL1ValidatorRegistrationMessage(_getPChainWarpMessage(messageIndex).payload);\n        if (registered) {\n            revert UnexpectedRegistrationStatus(registered);\n        }\n\n        Validator memory validator = $._validationPeriods[validationID];\n\n        // The validation status is PendingRemoved if validator removal was initiated with a call to {initiateValidatorRemoval}.\n        // The validation status is PendingAdded if the validator was never registered on the P-Chain.\n        // The initial validator set must have been set already to have pending validation messages.\n        if (\n            validator.status != ValidatorStatus.PendingRemoved\n                && validator.status != ValidatorStatus.PendingAdded\n        ) {\n            revert InvalidValidatorStatus(validator.status);\n        }\n\n        if (validator.status == ValidatorStatus.PendingRemoved) {\n            validator.status = ValidatorStatus.Completed;\n        } else {\n            // Remove the validator's weight from the total tracked weight, but don't track it as churn.\n            $._churnTracker.totalWeight -= validator.weight;\n            validator.status = ValidatorStatus.Invalidated;\n        }\n        // Remove the validator from the registered validators mapping.\n        delete $._registeredValidators[validator.nodeID];\n\n        // Update the validator.\n        $._validationPeriods[validationID] = validator;\n\n        // Emit event.\n        emit CompletedValidatorRemoval(validationID);\n\n        return validationID;\n    }",
            "startLine": 570,
            "signature": "completeValidatorRemoval(uint32)",
            "selector": "0x74b83085",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "initiateValidatorWeightUpdate",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "newWeight",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              },
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              },
              {
                "target": "_initiateValidatorWeightUpdate",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorWeightUpdate(\n        bytes32 validationID,\n        uint64 newWeight\n    ) public onlyOwner returns (uint64, bytes32) {\n        ValidatorManagerStorage storage $ = _getValidatorManagerStorage();\n        if ($._validationPeriods[validationID].status != ValidatorStatus.Active) {\n            revert InvalidValidatorStatus($._validationPeriods[validationID].status);\n        }\n\n        return _initiateValidatorWeightUpdate(validationID, newWeight);\n    }",
            "startLine": 639,
            "signature": "initiateValidatorWeightUpdate(bytes32,uint64)",
            "selector": "0x68a81781",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "completeValidatorWeightUpdate",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              },
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getPChainWarpMessage",
                "type": "internal"
              },
              {
                "target": "ValidatorMessages.unpackL1ValidatorWeightMessage",
                "type": "library"
              },
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "CompletedValidatorWeightUpdate"
            ],
            "isVirtual": true,
            "sourceCode": "function completeValidatorWeightUpdate(\n        uint32 messageIndex\n    ) public virtual override onlyOwner returns (bytes32, uint64) {\n        WarpMessage memory warpMessage = _getPChainWarpMessage(messageIndex);\n        (bytes32 validationID, uint64 nonce, uint64 weight) =\n            ValidatorMessages.unpackL1ValidatorWeightMessage(warpMessage.payload);\n\n        ValidatorManagerStorage storage $ = _getValidatorManagerStorage();\n\n        // The received nonce should be no greater than the highest sent nonce to ensure\n        // that weight changes are only initiated by this contract.\n        if ($._validationPeriods[validationID].sentNonce < nonce) {\n            revert InvalidNonce(nonce);\n        }\n\n        $._validationPeriods[validationID].receivedNonce = nonce;\n\n        emit CompletedValidatorWeightUpdate(validationID, nonce, weight);\n\n        return (validationID, nonce);\n    }",
            "startLine": 687,
            "signature": "completeValidatorWeightUpdate(uint32)",
            "selector": "0x38c6bf02",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "getChurnPeriodSeconds",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getChurnPeriodSeconds() public view returns (uint64) {\n        return _getValidatorManagerStorage()._churnPeriodSeconds;\n    }",
            "startLine": 709,
            "signature": "getChurnPeriodSeconds()",
            "selector": "0x4f6fdae9",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }",
            "startLine": 73,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "renounceOwnership",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
            "startLine": 94,
            "signature": "renounceOwnership()",
            "selector": "0x765becbf",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }",
            "startLine": 102,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          }
        ],
        "internalFunctions": [
          {
            "name": "_getValidatorManagerStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ValidatorManagerStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getValidatorManagerStorage()\n        internal\n        pure\n        returns (ValidatorManagerStorage storage $)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := VALIDATOR_MANAGER_STORAGE_LOCATION\n        }\n    }",
            "startLine": 108,
            "visibility": "internal"
          },
          {
            "name": "__ValidatorManager_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "ValidatorManagerSettings"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__Ownable_init",
                "type": "internal"
              },
              {
                "target": "__ValidatorManager_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ValidatorManager_init(\n        ValidatorManagerSettings calldata settings\n    ) internal onlyInitializing {\n        __Ownable_init(settings.admin);\n        __ValidatorManager_init_unchained(settings);\n    }",
            "startLine": 170,
            "visibility": "internal"
          },
          {
            "name": "__ValidatorManager_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "ValidatorManagerSettings"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ValidatorManager_init_unchained(\n        ValidatorManagerSettings calldata settings\n    ) internal onlyInitializing {\n        ValidatorManagerStorage storage $ = _getValidatorManagerStorage();\n        $._subnetID = settings.subnetID;\n\n        if (\n            settings.maximumChurnPercentage > MAXIMUM_CHURN_PERCENTAGE_LIMIT\n                || settings.maximumChurnPercentage == 0\n        ) {\n            revert InvalidMaximumChurnPercentage(settings.maximumChurnPercentage);\n        }\n        if (settings.churnPeriodSeconds > MAXIMUM_CHURN_PERIOD_LENGTH) {\n            revert InvalidChurnPeriodLength(settings.churnPeriodSeconds);\n        }\n\n        $._maximumChurnPercentage = settings.maximumChurnPercentage;\n        $._churnPeriodSeconds = settings.churnPeriodSeconds;\n    }",
            "startLine": 178,
            "visibility": "internal"
          },
          {
            "name": "_validatePChainOwner",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "pChainOwner",
                "type": "PChainOwner"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validatePChainOwner(\n        PChainOwner memory pChainOwner\n    ) internal pure {\n        // If threshold is 0, addresses must be empty.\n        if (pChainOwner.threshold == 0 && pChainOwner.addresses.length != 0) {\n            revert InvalidPChainOwnerThreshold(pChainOwner.threshold, pChainOwner.addresses.length);\n        }\n        // Threshold must be less than or equal to the number of addresses.\n        if (pChainOwner.threshold > pChainOwner.addresses.length) {\n            revert InvalidPChainOwnerThreshold(pChainOwner.threshold, pChainOwner.addresses.length);\n        }\n        // Zero address is invalid. Because we require addresses to be sorted, we only need to check if the first is 0\n        if (pChainOwner.addresses.length > 0 && pChainOwner.addresses[0] == address(0)) {\n            revert ZeroAddress();\n        }\n        // Addresses must be unique and sorted in ascending order\n        for (uint256 i = 1; i < pChainOwner.addresses.length; i++) {\n            // Compare current address with the previous one\n            if (pChainOwner.addresses[i] <= pChainOwner.addresses[i - 1]) {\n                revert InvalidPChainOwnerAddresses();\n            }\n        }\n    }",
            "startLine": 281,
            "visibility": "internal"
          },
          {
            "name": "_initiateValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "nodeID",
                "type": "bytes"
              },
              {
                "name": "blsPublicKey",
                "type": "bytes"
              },
              {
                "name": "remainingBalanceOwner",
                "type": "PChainOwner"
              },
              {
                "name": "disableOwner",
                "type": "PChainOwner"
              },
              {
                "name": "weight",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              },
              {
                "target": "_validatePChainOwner",
                "type": "internal"
              },
              {
                "target": "_checkAndUpdateChurnTracker",
                "type": "internal"
              },
              {
                "target": "ValidatorMessages.packRegisterL1ValidatorMessage",
                "type": "library"
              },
              {
                "target": "ValidatorMessages.ValidationPeriod",
                "type": "library"
              },
              {
                "target": "WARP_MESSENGER.sendWarpMessage",
                "type": "library"
              },
              {
                "target": "_fixedNodeID",
                "type": "internal"
              }
            ],
            "emits": [
              "InitiatedValidatorRegistration"
            ],
            "isVirtual": true,
            "sourceCode": "function _initiateValidatorRegistration(\n        bytes memory nodeID,\n        bytes memory blsPublicKey,\n        PChainOwner memory remainingBalanceOwner,\n        PChainOwner memory disableOwner,\n        uint64 weight\n    ) internal virtual override initializedValidatorSet returns (bytes32) {\n        ValidatorManagerStorage storage $ = _getValidatorManagerStorage();\n\n        // Ensure the new validator doesn't overflow the total weight\n        if (uint256(weight) + uint256($._churnTracker.totalWeight) > type(uint64).max) {\n            revert InvalidTotalWeight(weight);\n        }\n\n        _validatePChainOwner(remainingBalanceOwner);\n        _validatePChainOwner(disableOwner);\n\n        // Ensure the nodeID is not the zero address, and is not already an active validator.\n\n        if (blsPublicKey.length != BLS_PUBLIC_KEY_LENGTH) {\n            revert InvalidBLSKeyLength(blsPublicKey.length);\n        }\n        if (nodeID.length != NODE_ID_LENGTH) {\n            revert InvalidNodeID(nodeID);\n        }\n        if ($._registeredValidators[nodeID] != bytes32(0)) {\n            revert NodeAlreadyRegistered(nodeID);\n        }\n\n        // Check that adding this validator would not exceed the maximum churn rate.\n        _checkAndUpdateChurnTracker(weight, 0);\n\n        uint64 registrationExpiry = uint64(block.timestamp) + REGISTRATION_EXPIRY_LENGTH;\n\n        (bytes32 validationID, bytes memory registerL1ValidatorMessage) = ValidatorMessages\n            .packRegisterL1ValidatorMessage(\n            ValidatorMessages.ValidationPeriod({\n                subnetID: $._subnetID,\n                nodeID: nodeID,\n                blsPublicKey: blsPublicKey,\n                remainingBalanceOwner: remainingBalanceOwner,\n                disableOwner: disableOwner,\n                registrationExpiry: registrationExpiry,\n                weight: weight\n            })\n        );\n\n        // Redundant check to ensure no collision or replay is possible, but with the expiry set as\n        // the block timestamp + 1 day, this should not be possible.\n        if ($._validationPeriods[validationID].status != ValidatorStatus.Unknown) {\n            revert InvalidValidatorStatus($._validationPeriods[validationID].status);\n        }\n\n        $._pendingRegisterValidationMessages[validationID] = registerL1ValidatorMessage;\n        $._registeredValidators[nodeID] = validationID;\n\n        // Submit the message to the Warp precompile.\n        bytes32 messageID = WARP_MESSENGER.sendWarpMessage(registerL1ValidatorMessage);\n        $._validationPeriods[validationID].status = ValidatorStatus.PendingAdded;\n        $._validationPeriods[validationID].nodeID = nodeID;\n        $._validationPeriods[validationID].startingWeight = weight;\n        $._validationPeriods[validationID].sentNonce = 0;\n        $._validationPeriods[validationID].weight = weight;\n        $._validationPeriods[validationID].startTime = 0; // The validation period only starts once the registration is acknowledged.\n        $._validationPeriods[validationID].endTime = 0;\n\n        emit InitiatedValidatorRegistration(\n            validationID, _fixedNodeID(nodeID), messageID, registrationExpiry, weight\n        );\n\n        return validationID;\n    }",
            "startLine": 325,
            "visibility": "internal"
          },
          {
            "name": "_initiateValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              },
              {
                "target": "_initiateValidatorWeightUpdate",
                "type": "internal"
              }
            ],
            "emits": [
              "InitiatedValidatorRemoval"
            ],
            "isVirtual": true,
            "sourceCode": "function _initiateValidatorRemoval(\n        bytes32 validationID\n    ) internal virtual override {\n        ValidatorManagerStorage storage $ = _getValidatorManagerStorage();\n\n        // Ensure the validation period is active.\n        // The initial validator set must have been set already to have active validators.\n        Validator memory validator = $._validationPeriods[validationID];\n        if (validator.status != ValidatorStatus.Active) {\n            revert InvalidValidatorStatus($._validationPeriods[validationID].status);\n        }\n\n        // Update the validator status to pending removal.\n        // They are not removed from the active validators mapping until the P-Chain acknowledges the removal.\n        validator.status = ValidatorStatus.PendingRemoved;\n\n        // Set the end time of the validation period, since it is no longer known to be an active validator\n        // on the P-Chain.\n        validator.endTime = uint64(block.timestamp);\n\n        // Save the validator updates.\n        $._validationPeriods[validationID] = validator;\n\n        (, bytes32 messageID) = _initiateValidatorWeightUpdate(validationID, 0);\n\n        // Emit the event to signal the start of the validator removal process.\n        emit InitiatedValidatorRemoval(\n            validationID, messageID, validator.weight, uint64(block.timestamp)\n        );\n    }",
            "startLine": 515,
            "visibility": "internal"
          },
          {
            "name": "_incrementSentNonce",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _incrementSentNonce(\n        bytes32 validationID\n    ) internal returns (uint64) {\n        ValidatorManagerStorage storage $ = _getValidatorManagerStorage();\n        return ++$._validationPeriods[validationID].sentNonce;\n    }",
            "startLine": 613,
            "visibility": "internal"
          },
          {
            "name": "_getPChainWarpMessage",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "WarpMessage"
              }
            ],
            "calls": [
              {
                "target": "WARP_MESSENGER.getVerifiedWarpMessage",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getPChainWarpMessage(\n        uint32 messageIndex\n    ) internal view returns (WarpMessage memory) {\n        (WarpMessage memory warpMessage, bool valid) =\n            WARP_MESSENGER.getVerifiedWarpMessage(messageIndex);\n        if (!valid) {\n            revert InvalidWarpMessage();\n        }\n        // Must match to P-Chain blockchain id, which is 0.\n        if (warpMessage.sourceChainID != P_CHAIN_BLOCKCHAIN_ID) {\n            revert InvalidWarpSourceChainID(warpMessage.sourceChainID);\n        }\n        if (warpMessage.originSenderAddress != address(0)) {\n            revert InvalidWarpOriginSenderAddress(warpMessage.originSenderAddress);\n        }\n\n        return warpMessage;\n    }",
            "startLine": 620,
            "visibility": "internal"
          },
          {
            "name": "_initiateValidatorWeightUpdate",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "newWeight",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              },
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              },
              {
                "target": "_checkAndUpdateChurnTracker",
                "type": "internal"
              },
              {
                "target": "_incrementSentNonce",
                "type": "internal"
              },
              {
                "target": "WARP_MESSENGER.sendWarpMessage",
                "type": "library"
              },
              {
                "target": "ValidatorMessages.packL1ValidatorWeightMessage",
                "type": "library"
              }
            ],
            "emits": [
              "InitiatedValidatorWeightUpdate"
            ],
            "isVirtual": true,
            "sourceCode": "function _initiateValidatorWeightUpdate(\n        bytes32 validationID,\n        uint64 newWeight\n    ) internal virtual override returns (uint64, bytes32) {\n        ValidatorManagerStorage storage $ = _getValidatorManagerStorage();\n        uint64 validatorWeight = $._validationPeriods[validationID].weight;\n\n        // Check that changing the validator weight would not exceed the maximum churn rate.\n        _checkAndUpdateChurnTracker(newWeight, validatorWeight);\n\n        uint64 nonce = _incrementSentNonce(validationID);\n\n        $._validationPeriods[validationID].weight = newWeight;\n\n        // Submit the message to the Warp precompile.\n        bytes32 messageID = WARP_MESSENGER.sendWarpMessage(\n            ValidatorMessages.packL1ValidatorWeightMessage(validationID, nonce, newWeight)\n        );\n\n        emit InitiatedValidatorWeightUpdate({\n            validationID: validationID,\n            nonce: nonce,\n            weightUpdateMessageID: messageID,\n            weight: newWeight\n        });\n\n        return (nonce, messageID);\n    }",
            "startLine": 655,
            "visibility": "internal"
          },
          {
            "name": "_checkAndUpdateChurnTracker",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newValidatorWeight",
                "type": "uint64"
              },
              {
                "name": "oldValidatorWeight",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getValidatorManagerStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _checkAndUpdateChurnTracker(\n        uint64 newValidatorWeight,\n        uint64 oldValidatorWeight\n    ) private {\n        ValidatorManagerStorage storage $ = _getValidatorManagerStorage();\n\n        uint64 weightChange;\n        if (newValidatorWeight > oldValidatorWeight) {\n            weightChange = newValidatorWeight - oldValidatorWeight;\n        } else {\n            weightChange = oldValidatorWeight - newValidatorWeight;\n        }\n\n        uint256 currentTime = block.timestamp;\n        ValidatorChurnPeriod memory churnTracker = $._churnTracker;\n\n        if (\n            churnTracker.startTime == 0\n                || currentTime >= churnTracker.startTime + $._churnPeriodSeconds\n        ) {\n            churnTracker.churnAmount = weightChange;\n            churnTracker.startTime = currentTime;\n            churnTracker.initialWeight = churnTracker.totalWeight;\n        } else {\n            // Churn is always additive whether the weight is being added or removed.\n            churnTracker.churnAmount += weightChange;\n        }\n\n        // Rearranged equation of maximumChurnPercentage >= currentChurnPercentage to avoid integer division truncation.\n        if ($._maximumChurnPercentage * churnTracker.initialWeight < churnTracker.churnAmount * 100)\n        {\n            revert MaxChurnRateExceeded(churnTracker.churnAmount);\n        }\n\n        // Two separate calculations because we're using uints and (newValidatorWeight - oldValidatorWeight) could underflow.\n        churnTracker.totalWeight += newValidatorWeight;\n        churnTracker.totalWeight -= oldValidatorWeight;\n\n        // Rearranged equation for totalWeight < (100 / $._maximumChurnPercentage)\n        // Total weight must be above this value in order to not trigger churn limits with an added/removed weight of 1.\n        if (churnTracker.totalWeight * $._maximumChurnPercentage < 100) {\n            revert InvalidTotalWeight(churnTracker.totalWeight);\n        }\n\n        $._churnTracker = churnTracker;\n    }",
            "startLine": 718,
            "visibility": "private"
          },
          {
            "name": "_fixedNodeID",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "nodeID",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes20"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _fixedNodeID(\n        bytes memory nodeID\n    ) private pure returns (bytes20) {\n        bytes20 fixedID;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            fixedID := mload(add(nodeID, 32))\n        }\n        return fixedID;\n    }",
            "startLine": 770,
            "visibility": "private"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getOwnableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "OwnableStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }",
            "startLine": 30,
            "visibility": "private",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__Ownable_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }",
            "startLine": 51,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }",
            "startLine": 55,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }",
            "startLine": 81,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "OwnershipTransferred"
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }",
            "startLine": 113,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Context_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Context_init() internal onlyInitializing {\n    }",
            "startLine": 18,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "__Context_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Context_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 21,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "_msgSender",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }",
            "startLine": 23,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "_msgData",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }",
            "startLine": 27,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "_contextSuffixLength",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }",
            "startLine": 31,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "ValidatorMessages",
        "kind": "library",
        "category": "library",
        "filePath": "@validator-manager/ValidatorMessages.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "PChainOwner",
            "path": "./interfaces/IACP99Manager.sol",
            "isExternal": false
          },
          {
            "name": "ConversionData",
            "path": "./interfaces/IACP99Manager.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "packSubnetToL1ConversionMessage",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "conversionID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function packSubnetToL1ConversionMessage(\n        bytes32 conversionID\n    ) external pure returns (bytes memory) {\n        return abi.encodePacked(CODEC_ID, SUBNET_TO_L1_CONVERSION_MESSAGE_TYPE_ID, conversionID);\n    }",
            "startLine": 69,
            "signature": "packSubnetToL1ConversionMessage(bytes32)",
            "selector": "0x3312dc4c",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "unpackSubnetToL1ConversionMessage",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function unpackSubnetToL1ConversionMessage(\n        bytes memory input\n    ) external pure returns (bytes32) {\n        if (input.length != 38) {\n            revert InvalidMessageLength(uint32(input.length), 38);\n        }\n\n        // Unpack the codec ID\n        uint16 codecID;\n        for (uint256 i; i < 2; ++i) {\n            codecID |= uint16(uint8(input[i])) << uint16((8 * (1 - i)));\n        }\n        if (codecID != CODEC_ID) {\n            revert InvalidCodecID(codecID);\n        }\n\n        // Unpack the type ID\n        uint32 typeID;\n        for (uint256 i; i < 4; ++i) {\n            typeID |= uint32(uint8(input[i + 2])) << uint32((8 * (3 - i)));\n        }\n        if (typeID != SUBNET_TO_L1_CONVERSION_MESSAGE_TYPE_ID) {\n            revert InvalidMessageType();\n        }\n\n        // Unpack the conversionID\n        bytes32 conversionID;\n        for (uint256 i; i < 32; ++i) {\n            conversionID |= bytes32(uint256(uint8(input[i + 6])) << (8 * (31 - i)));\n        }\n\n        return conversionID;\n    }",
            "startLine": 82,
            "signature": "unpackSubnetToL1ConversionMessage(bytes)",
            "selector": "0x57a4ab24",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "packConversionData",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "conversionData",
                "type": "ConversionData"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function packConversionData(\n        ConversionData memory conversionData\n    ) external pure returns (bytes memory) {\n        // Hardcoded 20 is for length of the managerAddress on EVM chains\n        // solhint-disable-next-line func-named-parameters\n        bytes memory res = abi.encodePacked(\n            CODEC_ID,\n            conversionData.subnetID,\n            conversionData.validatorManagerBlockchainID,\n            uint32(20),\n            conversionData.validatorManagerAddress,\n            uint32(conversionData.initialValidators.length)\n        );\n        // The approach below of encoding initialValidators using `abi.encodePacked` in a loop\n        // was tested against pre-allocating the array and doing manual byte by byte packing and\n        // it was found to be more gas efficient.\n        for (uint256 i; i < conversionData.initialValidators.length; ++i) {\n            res = abi.encodePacked(\n                res,\n                uint32(conversionData.initialValidators[i].nodeID.length),\n                conversionData.initialValidators[i].nodeID,\n                conversionData.initialValidators[i].blsPublicKey,\n                conversionData.initialValidators[i].weight\n            );\n        }\n        return res;\n    }",
            "startLine": 151,
            "signature": "packConversionData(ConversionData)",
            "selector": "0x07ae5b5a",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "packRegisterL1ValidatorMessage",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "validationPeriod",
                "type": "ValidationPeriod"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              },
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function packRegisterL1ValidatorMessage(\n        ValidationPeriod memory validationPeriod\n    ) external pure returns (bytes32, bytes memory) {\n        if (validationPeriod.blsPublicKey.length != 48) {\n            revert InvalidBLSPublicKey();\n        }\n\n        // solhint-disable-next-line func-named-parameters\n        bytes memory res = abi.encodePacked(\n            CODEC_ID,\n            REGISTER_L1_VALIDATOR_MESSAGE_TYPE_ID,\n            validationPeriod.subnetID,\n            uint32(validationPeriod.nodeID.length),\n            validationPeriod.nodeID,\n            validationPeriod.blsPublicKey,\n            validationPeriod.registrationExpiry,\n            validationPeriod.remainingBalanceOwner.threshold,\n            uint32(validationPeriod.remainingBalanceOwner.addresses.length)\n        );\n        for (uint256 i; i < validationPeriod.remainingBalanceOwner.addresses.length; ++i) {\n            res = abi.encodePacked(res, validationPeriod.remainingBalanceOwner.addresses[i]);\n        }\n        res = abi.encodePacked(\n            res,\n            validationPeriod.disableOwner.threshold,\n            uint32(validationPeriod.disableOwner.addresses.length)\n        );\n        for (uint256 i; i < validationPeriod.disableOwner.addresses.length; ++i) {\n            res = abi.encodePacked(res, validationPeriod.disableOwner.addresses[i]);\n        }\n        res = abi.encodePacked(res, validationPeriod.weight);\n\n        return (sha256(res), res);\n    }",
            "startLine": 218,
            "signature": "packRegisterL1ValidatorMessage(ValidationPeriod)",
            "selector": "0x01b6a843",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "unpackRegisterL1ValidatorMessage",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "ValidationPeriod"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function unpackRegisterL1ValidatorMessage(\n        bytes memory input\n    ) external pure returns (ValidationPeriod memory) {\n        uint32 index;\n        ValidationPeriod memory validation;\n\n        // Unpack the codec ID\n        // Individual fields are unpacked in their own scopes to avoid stack too deep errors.\n        {\n            uint16 codecID;\n            for (uint256 i; i < 2; ++i) {\n                codecID |= uint16(uint8(input[i + index])) << uint16((8 * (1 - i)));\n            }\n            if (codecID != CODEC_ID) {\n                revert InvalidCodecID(codecID);\n            }\n            index += 2;\n        }\n\n        // Unpack the type ID\n        {\n            uint32 typeID;\n            for (uint256 i; i < 4; ++i) {\n                typeID |= uint32(uint8(input[i + index])) << uint32((8 * (3 - i)));\n            }\n            if (typeID != REGISTER_L1_VALIDATOR_MESSAGE_TYPE_ID) {\n                revert InvalidMessageType();\n            }\n            index += 4;\n        }\n\n        // Unpack the subnetID\n        {\n            bytes32 subnetID;\n            for (uint256 i; i < 32; ++i) {\n                subnetID |= bytes32(uint256(uint8(input[i + index])) << (8 * (31 - i)));\n            }\n            validation.subnetID = subnetID;\n            index += 32;\n        }\n\n        // Unpack the nodeID length\n        uint32 nodeIDLength;\n        {\n            for (uint256 i; i < 4; ++i) {\n                nodeIDLength |= uint32(uint8(input[i + index])) << uint32((8 * (3 - i)));\n            }\n            index += 4;\n\n            // Unpack the nodeID\n            bytes memory nodeID = new bytes(nodeIDLength);\n            for (uint256 i; i < nodeIDLength; ++i) {\n                nodeID[i] = input[i + index];\n            }\n            validation.nodeID = nodeID;\n            index += nodeIDLength;\n        }\n\n        // Unpack the blsPublicKey\n        {\n            bytes memory blsPublicKey = new bytes(48);\n            for (uint256 i; i < 48; ++i) {\n                blsPublicKey[i] = input[i + index];\n            }\n            validation.blsPublicKey = blsPublicKey;\n            index += 48;\n        }\n\n        // Unpack the registration expiry\n        {\n            uint64 expiry;\n            for (uint256 i; i < 8; ++i) {\n                expiry |= uint64(uint8(input[i + index])) << uint64((8 * (7 - i)));\n            }\n            validation.registrationExpiry = expiry;\n            index += 8;\n        }\n\n        // Unpack the remainingBalanceOwner threshold\n        uint32 remainingBalanceOwnerAddressesLength;\n        {\n            uint32 remainingBalanceOwnerThreshold;\n            for (uint256 i; i < 4; ++i) {\n                remainingBalanceOwnerThreshold |=\n                    uint32(uint8(input[i + index])) << uint32((8 * (3 - i)));\n            }\n            index += 4;\n\n            // Unpack the remainingBalanceOwner addresses length\n            for (uint256 i; i < 4; ++i) {\n                remainingBalanceOwnerAddressesLength |=\n                    uint32(uint8(input[i + index])) << uint32((8 * (3 - i)));\n            }\n            index += 4;\n\n            // Unpack the remainingBalanceOwner addresses\n            address[] memory remainingBalanceOwnerAddresses =\n                new address[](remainingBalanceOwnerAddressesLength);\n            for (uint256 i; i < remainingBalanceOwnerAddressesLength; ++i) {\n                bytes memory addrBytes = new bytes(20);\n                for (uint256 j; j < 20; ++j) {\n                    addrBytes[j] = input[j + index];\n                }\n                address addr;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    addr := mload(add(addrBytes, 20))\n                }\n                remainingBalanceOwnerAddresses[i] = addr;\n                index += 20;\n            }\n            validation.remainingBalanceOwner = PChainOwner({\n                threshold: remainingBalanceOwnerThreshold,\n                addresses: remainingBalanceOwnerAddresses\n            });\n        }\n\n        // Unpack the disableOwner threshold\n        uint32 disableOwnerAddressesLength;\n        {\n            uint32 disableOwnerThreshold;\n            for (uint256 i; i < 4; ++i) {\n                disableOwnerThreshold |= uint32(uint8(input[i + index])) << uint32((8 * (3 - i)));\n            }\n            index += 4;\n\n            // Unpack the disableOwner addresses length\n            for (uint256 i; i < 4; ++i) {\n                disableOwnerAddressesLength |=\n                    uint32(uint8(input[i + index])) << uint32((8 * (3 - i)));\n            }\n            index += 4;\n\n            // Unpack the disableOwner addresses\n            address[] memory disableOwnerAddresses = new address[](disableOwnerAddressesLength);\n            for (uint256 i; i < disableOwnerAddressesLength; ++i) {\n                bytes memory addrBytes = new bytes(20);\n                for (uint256 j; j < 20; ++j) {\n                    addrBytes[j] = input[j + index];\n                }\n                address addr;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    addr := mload(add(addrBytes, 20))\n                }\n                disableOwnerAddresses[i] = addr;\n                index += 20;\n            }\n            validation.disableOwner =\n                PChainOwner({threshold: disableOwnerThreshold, addresses: disableOwnerAddresses});\n        }\n        // Now that we have all the variable lengths, validate the input length\n        uint32 expectedLength = 122 + nodeIDLength\n            + (remainingBalanceOwnerAddressesLength + disableOwnerAddressesLength) * 20;\n        if (input.length != expectedLength) {\n            revert InvalidMessageLength(uint32(input.length), expectedLength);\n        }\n        // Unpack the weight\n        {\n            uint64 weight;\n            for (uint256 i; i < 8; ++i) {\n                weight |= uint64(uint8(input[i + index])) << uint64((8 * (7 - i)));\n            }\n            validation.weight = weight;\n        }\n\n        return validation;\n    }",
            "startLine": 260,
            "signature": "unpackRegisterL1ValidatorMessage(bytes)",
            "selector": "0x18bf3929",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "packL1ValidatorRegistrationMessage",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "registered",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function packL1ValidatorRegistrationMessage(\n        bytes32 validationID,\n        bool registered\n    ) external pure returns (bytes memory) {\n        return abi.encodePacked(\n            CODEC_ID, L1_VALIDATOR_REGISTRATION_MESSAGE_TYPE_ID, validationID, registered\n        );\n    }",
            "startLine": 449,
            "signature": "packL1ValidatorRegistrationMessage(bytes32,bool)",
            "selector": "0x57c2926f",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "unpackL1ValidatorRegistrationMessage",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              },
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function unpackL1ValidatorRegistrationMessage(\n        bytes memory input\n    ) external pure returns (bytes32, bool) {\n        if (input.length != 39) {\n            revert InvalidMessageLength(uint32(input.length), 39);\n        }\n        // Unpack the codec ID\n        uint16 codecID;\n        for (uint256 i; i < 2; ++i) {\n            codecID |= uint16(uint8(input[i])) << uint16((8 * (1 - i)));\n        }\n        if (codecID != CODEC_ID) {\n            revert InvalidCodecID(codecID);\n        }\n\n        // Unpack the type ID\n        uint32 typeID;\n        for (uint256 i; i < 4; ++i) {\n            typeID |= uint32(uint8(input[i + 2])) << uint32((8 * (3 - i)));\n        }\n        if (typeID != L1_VALIDATOR_REGISTRATION_MESSAGE_TYPE_ID) {\n            revert InvalidMessageType();\n        }\n\n        // Unpack the validation ID.\n        bytes32 validationID;\n        for (uint256 i; i < 32; ++i) {\n            validationID |= bytes32(uint256(uint8(input[i + 6])) << (8 * (31 - i)));\n        }\n\n        // Unpack the validity\n        bool registered = input[38] != 0;\n\n        return (validationID, registered);\n    }",
            "startLine": 466,
            "signature": "unpackL1ValidatorRegistrationMessage(bytes)",
            "selector": "0x65403d2d",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "packL1ValidatorWeightMessage",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "nonce",
                "type": "uint64"
              },
              {
                "name": "weight",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function packL1ValidatorWeightMessage(\n        bytes32 validationID,\n        uint64 nonce,\n        uint64 weight\n    ) external pure returns (bytes memory) {\n        return abi.encodePacked(\n            CODEC_ID, L1_VALIDATOR_WEIGHT_MESSAGE_TYPE_ID, validationID, nonce, weight\n        );\n    }",
            "startLine": 524,
            "signature": "packL1ValidatorWeightMessage(bytes32,uint64,uint64)",
            "selector": "0x6eef3ff4",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "unpackL1ValidatorWeightMessage",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              },
              {
                "name": "",
                "type": "uint64"
              },
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function unpackL1ValidatorWeightMessage(\n        bytes memory input\n    ) external pure returns (bytes32, uint64, uint64) {\n        if (input.length != 54) {\n            revert InvalidMessageLength(uint32(input.length), 54);\n        }\n\n        // Unpack the codec ID.\n        uint16 codecID;\n        for (uint256 i; i < 2; ++i) {\n            codecID |= uint16(uint8(input[i])) << uint16((8 * (1 - i)));\n        }\n        if (codecID != CODEC_ID) {\n            revert InvalidCodecID(codecID);\n        }\n\n        // Unpack the type ID.\n        uint32 typeID;\n        for (uint256 i; i < 4; ++i) {\n            typeID |= uint32(uint8(input[i + 2])) << uint32((8 * (3 - i)));\n        }\n        if (typeID != L1_VALIDATOR_WEIGHT_MESSAGE_TYPE_ID) {\n            revert InvalidMessageType();\n        }\n\n        // Unpack the validation ID.\n        bytes32 validationID;\n        for (uint256 i; i < 32; ++i) {\n            validationID |= bytes32(uint256(uint8(input[i + 6])) << (8 * (31 - i)));\n        }\n\n        // Unpack the nonce.\n        uint64 nonce;\n        for (uint256 i; i < 8; ++i) {\n            nonce |= uint64(uint8(input[i + 38])) << uint64((8 * (7 - i)));\n        }\n\n        // Unpack the weight.\n        uint64 weight;\n        for (uint256 i; i < 8; ++i) {\n            weight |= uint64(uint8(input[i + 46])) << uint64((8 * (7 - i)));\n        }\n\n        return (validationID, nonce, weight);\n    }",
            "startLine": 541,
            "signature": "unpackL1ValidatorWeightMessage(bytes)",
            "selector": "0x6ccf3d6e",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "packValidationUptimeMessage",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "uptime",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function packValidationUptimeMessage(\n        bytes32 validationID,\n        uint64 uptime\n    ) external pure returns (bytes memory) {\n        return abi.encodePacked(CODEC_ID, VALIDATION_UPTIME_MESSAGE_TYPE_ID, validationID, uptime);\n    }",
            "startLine": 606,
            "signature": "packValidationUptimeMessage(bytes32,uint64)",
            "selector": "0x12b94d74",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "unpackValidationUptimeMessage",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              },
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function unpackValidationUptimeMessage(\n        bytes memory input\n    ) external pure returns (bytes32, uint64) {\n        if (input.length != 46) {\n            revert InvalidMessageLength(uint32(input.length), 46);\n        }\n\n        // Unpack the codec ID.\n        uint16 codecID;\n        for (uint256 i; i < 2; ++i) {\n            codecID |= uint16(uint8(input[i])) << uint16((8 * (1 - i)));\n        }\n        if (codecID != CODEC_ID) {\n            revert InvalidCodecID(codecID);\n        }\n\n        // Unpack the type ID.\n        uint32 typeID;\n        for (uint256 i; i < 4; ++i) {\n            typeID |= uint32(uint8(input[i + 2])) << uint32((8 * (3 - i)));\n        }\n        if (typeID != VALIDATION_UPTIME_MESSAGE_TYPE_ID) {\n            revert InvalidMessageType();\n        }\n\n        // Unpack the validation ID.\n        bytes32 validationID;\n        for (uint256 i; i < 32; ++i) {\n            validationID |= bytes32(uint256(uint8(input[i + 6])) << (8 * (31 - i)));\n        }\n\n        // Unpack the uptime.\n        uint64 uptime;\n        for (uint256 i; i < 8; ++i) {\n            uptime |= uint64(uint8(input[i + 38])) << uint64((8 * (7 - i)));\n        }\n\n        return (validationID, uptime);\n    }",
            "startLine": 620,
            "signature": "unpackValidationUptimeMessage(bytes)",
            "selector": "0x5e3ae652",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": [
          {
            "name": "InvalidMessageLength",
            "parameters": [
              {
                "name": "actual",
                "type": "uint32"
              },
              {
                "name": "expected",
                "type": "uint32"
              }
            ]
          },
          {
            "name": "InvalidCodecID",
            "parameters": [
              {
                "name": "id",
                "type": "uint32"
              }
            ]
          },
          {
            "name": "InvalidMessageType",
            "parameters": []
          },
          {
            "name": "InvalidBLSPublicKey",
            "parameters": []
          }
        ]
      },
      {
        "name": "IACP99Manager",
        "kind": "interface",
        "category": "interface",
        "filePath": "@validator-manager/interfaces/IACP99Manager.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "initializeValidatorSet",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "conversionData",
                "type": "ConversionData"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initializeValidatorSet(\n        ConversionData calldata conversionData,\n        uint32 messageIndex\n    ) external;",
            "startLine": 128,
            "signature": "initializeValidatorSet(ConversionData,uint32)",
            "selector": "0x5d9e08d4",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "completeValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorRegistration(\n        uint32 messageIndex\n    ) external returns (bytes32 validationID);",
            "startLine": 142,
            "signature": "completeValidatorRegistration(uint32)",
            "selector": "0x5442dda6",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "completeValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorRemoval(\n        uint32 messageIndex\n    ) external returns (bytes32 validationID);",
            "startLine": 155,
            "signature": "completeValidatorRemoval(uint32)",
            "selector": "0x74b83085",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "completeValidatorWeightUpdate",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "nonce",
                "type": "uint64"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorWeightUpdate(\n        uint32 messageIndex\n    ) external returns (bytes32 validationID, uint64 nonce);",
            "startLine": 169,
            "signature": "completeValidatorWeightUpdate(uint32)",
            "selector": "0x38c6bf02",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "subnetID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function subnetID() external view returns (bytes32 id);",
            "startLine": 174,
            "signature": "subnetID()",
            "selector": "0x4dbc7fc7",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "getValidator",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "validator",
                "type": "Validator"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getValidator(\n        bytes32 validationID\n    ) external view returns (Validator memory validator);",
            "startLine": 177,
            "signature": "getValidator(bytes32)",
            "selector": "0x6d91f46b",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "l1TotalWeight",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "weight",
                "type": "uint64"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function l1TotalWeight() external view returns (uint64 weight);",
            "startLine": 182,
            "signature": "l1TotalWeight()",
            "selector": "0x36c1df98",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [
          {
            "name": "RegisteredInitialValidator",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "nodeID",
                "type": "bytes20",
                "indexed": true
              },
              {
                "name": "subnetID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "weight",
                "type": "uint64",
                "indexed": false
              }
            ]
          },
          {
            "name": "InitiatedValidatorRegistration",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "nodeID",
                "type": "bytes20",
                "indexed": true
              },
              {
                "name": "registrationMessageID",
                "type": "bytes32",
                "indexed": false
              },
              {
                "name": "registrationExpiry",
                "type": "uint64",
                "indexed": false
              },
              {
                "name": "weight",
                "type": "uint64",
                "indexed": false
              }
            ]
          },
          {
            "name": "CompletedValidatorRegistration",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "weight",
                "type": "uint64",
                "indexed": false
              }
            ]
          },
          {
            "name": "InitiatedValidatorRemoval",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "validatorWeightMessageID",
                "type": "bytes32",
                "indexed": false
              },
              {
                "name": "weight",
                "type": "uint64",
                "indexed": false
              },
              {
                "name": "endTime",
                "type": "uint64",
                "indexed": false
              }
            ]
          },
          {
            "name": "CompletedValidatorRemoval",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32",
                "indexed": true
              }
            ]
          },
          {
            "name": "InitiatedValidatorWeightUpdate",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "nonce",
                "type": "uint64",
                "indexed": false
              },
              {
                "name": "weightUpdateMessageID",
                "type": "bytes32",
                "indexed": false
              },
              {
                "name": "weight",
                "type": "uint64",
                "indexed": false
              }
            ]
          },
          {
            "name": "CompletedValidatorWeightUpdate",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "nonce",
                "type": "uint64",
                "indexed": false
              },
              {
                "name": "weight",
                "type": "uint64",
                "indexed": false
              }
            ]
          }
        ],
        "errors": []
      },
      {
        "name": "IERC20Mintable",
        "kind": "interface",
        "category": "interface",
        "filePath": "@validator-manager/interfaces/IERC20Mintable.sol",
        "inherits": [],
        "implements": [
          "IERC20"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IERC20",
            "path": "@openzeppelin/contracts@5.0.2/token/ERC20/IERC20.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "mint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function mint(address account, uint256 amount) external;",
            "startLine": 20,
            "signature": "mint(address,uint256)",
            "selector": "0x7f92a6b2",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": []
      },
      {
        "name": "IERC20TokenStakingManager",
        "kind": "interface",
        "category": "interface",
        "filePath": "@validator-manager/interfaces/IERC20TokenStakingManager.sol",
        "inherits": [],
        "implements": [
          "IStakingManager"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IStakingManager",
            "path": "./IStakingManager.sol",
            "isExternal": false
          },
          {
            "name": "PChainOwner",
            "path": "../ACP99Manager.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "initiateValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "nodeID",
                "type": "bytes"
              },
              {
                "name": "blsPublicKey",
                "type": "bytes"
              },
              {
                "name": "remainingBalanceOwner",
                "type": "PChainOwner"
              },
              {
                "name": "disableOwner",
                "type": "PChainOwner"
              },
              {
                "name": "delegationFeeBips",
                "type": "uint16"
              },
              {
                "name": "minStakeDuration",
                "type": "uint64"
              },
              {
                "name": "stakeAmount",
                "type": "uint256"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorRegistration(\n        bytes memory nodeID,\n        bytes memory blsPublicKey,\n        PChainOwner memory remainingBalanceOwner,\n        PChainOwner memory disableOwner,\n        uint16 delegationFeeBips,\n        uint64 minStakeDuration,\n        uint256 stakeAmount,\n        address rewardRecipient\n    ) external returns (bytes32);",
            "startLine": 27,
            "signature": "initiateValidatorRegistration(bytes,bytes,PChainOwner,PChainOwner,uint16,uint64,uint256,address)",
            "selector": "0x015193e5",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "initiateDelegatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "stakeAmount",
                "type": "uint256"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateDelegatorRegistration(\n        bytes32 validationID,\n        uint256 stakeAmount,\n        address rewardRecipient\n    ) external returns (bytes32);",
            "startLine": 45,
            "signature": "initiateDelegatorRegistration(bytes32,uint256,address)",
            "selector": "0x72ddb2d1",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": []
      },
      {
        "name": "INativeTokenStakingManager",
        "kind": "interface",
        "category": "interface",
        "filePath": "@validator-manager/interfaces/INativeTokenStakingManager.sol",
        "inherits": [],
        "implements": [
          "IStakingManager"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IStakingManager",
            "path": "./IStakingManager.sol",
            "isExternal": false
          },
          {
            "name": "PChainOwner",
            "path": "../ACP99Manager.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "initiateValidatorRegistration",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "nodeID",
                "type": "bytes"
              },
              {
                "name": "blsPublicKey",
                "type": "bytes"
              },
              {
                "name": "remainingBalanceOwner",
                "type": "PChainOwner"
              },
              {
                "name": "disableOwner",
                "type": "PChainOwner"
              },
              {
                "name": "delegationFeeBips",
                "type": "uint16"
              },
              {
                "name": "minStakeDuration",
                "type": "uint64"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorRegistration(\n        bytes memory nodeID,\n        bytes memory blsPublicKey,\n        PChainOwner memory remainingBalanceOwner,\n        PChainOwner memory disableOwner,\n        uint16 delegationFeeBips,\n        uint64 minStakeDuration,\n        address rewardRecipient\n    ) external payable returns (bytes32);",
            "startLine": 26,
            "signature": "initiateValidatorRegistration(bytes,bytes,PChainOwner,PChainOwner,uint16,uint64,address)",
            "selector": "0x045de078",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "initiateDelegatorRegistration",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "rewardRecipient",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateDelegatorRegistration(\n        bytes32 validationID,\n        address rewardRecipient\n    ) external payable returns (bytes32);",
            "startLine": 42,
            "signature": "initiateDelegatorRegistration(bytes32,address)",
            "selector": "0x163dab64",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": []
      },
      {
        "name": "IPoAManager",
        "kind": "interface",
        "category": "interface",
        "filePath": "@validator-manager/interfaces/IPoAManager.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "PChainOwner",
            "path": "./IACP99Manager.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "initiateValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "nodeID",
                "type": "bytes"
              },
              {
                "name": "blsPublicKey",
                "type": "bytes"
              },
              {
                "name": "remainingBalanceOwner",
                "type": "PChainOwner"
              },
              {
                "name": "disableOwner",
                "type": "PChainOwner"
              },
              {
                "name": "weight",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorRegistration(\n        bytes memory nodeID,\n        bytes memory blsPublicKey,\n        PChainOwner memory remainingBalanceOwner,\n        PChainOwner memory disableOwner,\n        uint64 weight\n    ) external returns (bytes32 validationID);",
            "startLine": 28,
            "signature": "initiateValidatorRegistration(bytes,bytes,PChainOwner,PChainOwner,uint64)",
            "selector": "0x239c60db",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "initiateValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorRemoval(\n        bytes32 validationID\n    ) external;",
            "startLine": 40,
            "signature": "initiateValidatorRemoval(bytes32)",
            "selector": "0x5aa039f4",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "initiateValidatorWeightUpdate",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "newWeight",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "nonce",
                "type": "uint64"
              },
              {
                "name": "messageID",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorWeightUpdate(\n        bytes32 validationID,\n        uint64 newWeight\n    ) external returns (uint64 nonce, bytes32 messageID);",
            "startLine": 51,
            "signature": "initiateValidatorWeightUpdate(bytes32,uint64)",
            "selector": "0x68a81781",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "completeValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorRegistration(\n        uint32 messageIndex\n    ) external returns (bytes32 validationID);",
            "startLine": 61,
            "signature": "completeValidatorRegistration(uint32)",
            "selector": "0x5442dda6",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "completeValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorRemoval(\n        uint32 messageIndex\n    ) external returns (bytes32 validationID);",
            "startLine": 70,
            "signature": "completeValidatorRemoval(uint32)",
            "selector": "0x74b83085",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "completeValidatorWeightUpdate",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "nonce",
                "type": "uint64"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorWeightUpdate(\n        uint32 messageIndex\n    ) external returns (bytes32 validationID, uint64 nonce);",
            "startLine": 80,
            "signature": "completeValidatorWeightUpdate(uint32)",
            "selector": "0x38c6bf02",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "transferValidatorManagerOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function transferValidatorManagerOwnership(\n        address newOwner\n    ) external;",
            "startLine": 88,
            "signature": "transferValidatorManagerOwnership(address)",
            "selector": "0x20a2ab0c",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": []
      },
      {
        "name": "IRewardCalculator",
        "kind": "interface",
        "category": "interface",
        "filePath": "@validator-manager/interfaces/IRewardCalculator.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "calculateReward",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "stakeAmount",
                "type": "uint256"
              },
              {
                "name": "validatorStartTime",
                "type": "uint64"
              },
              {
                "name": "stakingStartTime",
                "type": "uint64"
              },
              {
                "name": "stakingEndTime",
                "type": "uint64"
              },
              {
                "name": "uptimeSeconds",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function calculateReward(\n        uint256 stakeAmount,\n        uint64 validatorStartTime,\n        uint64 stakingStartTime,\n        uint64 stakingEndTime,\n        uint64 uptimeSeconds\n    ) external view returns (uint256);",
            "startLine": 20,
            "signature": "calculateReward(uint256,uint64,uint64,uint64,uint64)",
            "selector": "0x449215dd",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": []
      },
      {
        "name": "IStakingManager",
        "kind": "interface",
        "category": "interface",
        "filePath": "@validator-manager/interfaces/IStakingManager.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IValidatorManager",
            "path": "../interfaces/IValidatorManager.sol",
            "isExternal": false
          },
          {
            "name": "IRewardCalculator",
            "path": "./IRewardCalculator.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "submitUptimeProof",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function submitUptimeProof(bytes32 validationID, uint32 messageIndex) external;",
            "startLine": 193,
            "signature": "submitUptimeProof(bytes32,uint32)",
            "selector": "0x4d54664a",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "completeValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorRegistration(\n        uint32 messageIndex\n    ) external returns (bytes32);",
            "startLine": 203,
            "signature": "completeValidatorRegistration(uint32)",
            "selector": "0x5442dda6",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "initiateValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorRemoval(\n        bytes32 validationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) external;",
            "startLine": 218,
            "signature": "initiateValidatorRemoval(bytes32,bool,uint32)",
            "selector": "0x72bceec5",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "forceInitiateValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function forceInitiateValidatorRemoval(\n        bytes32 validationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) external;",
            "startLine": 235,
            "signature": "forceInitiateValidatorRemoval(bytes32,bool,uint32)",
            "selector": "0x7475aa66",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "completeValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeValidatorRemoval(\n        uint32 messageIndex\n    ) external returns (bytes32);",
            "startLine": 249,
            "signature": "completeValidatorRemoval(uint32)",
            "selector": "0x74b83085",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "completeDelegatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeDelegatorRegistration(bytes32 delegationID, uint32 messageIndex) external;",
            "startLine": 264,
            "signature": "completeDelegatorRegistration(bytes32,uint32)",
            "selector": "0x7ac53d57",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "initiateDelegatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateDelegatorRemoval(\n        bytes32 delegationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) external;",
            "startLine": 281,
            "signature": "initiateDelegatorRemoval(bytes32,bool,uint32)",
            "selector": "0x66f514b6",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "forceInitiateDelegatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "includeUptimeProof",
                "type": "bool"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function forceInitiateDelegatorRemoval(\n        bytes32 delegationID,\n        bool includeUptimeProof,\n        uint32 messageIndex\n    ) external;",
            "startLine": 301,
            "signature": "forceInitiateDelegatorRemoval(bytes32,bool,uint32)",
            "selector": "0x7fc27b8b",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "resendUpdateDelegator",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function resendUpdateDelegator(\n        bytes32 delegationID\n    ) external;",
            "startLine": 312,
            "signature": "resendUpdateDelegator(bytes32)",
            "selector": "0x28f303d8",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "completeDelegatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "messageIndex",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function completeDelegatorRemoval(bytes32 delegationID, uint32 messageIndex) external;",
            "startLine": 326,
            "signature": "completeDelegatorRemoval(bytes32,uint32)",
            "selector": "0x702b3fb8",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "claimDelegationFees",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function claimDelegationFees(\n        bytes32 validationID\n    ) external;",
            "startLine": 332,
            "signature": "claimDelegationFees(bytes32)",
            "selector": "0x363501aa",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "changeValidatorRewardRecipient",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "recipient",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function changeValidatorRewardRecipient(bytes32 validationID, address recipient) external;",
            "startLine": 341,
            "signature": "changeValidatorRewardRecipient(bytes32,address)",
            "selector": "0x08b86a89",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "changeDelegatorRewardRecipient",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32"
              },
              {
                "name": "recipient",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function changeDelegatorRewardRecipient(bytes32 delegationID, address recipient) external;",
            "startLine": 348,
            "signature": "changeDelegatorRewardRecipient(bytes32,address)",
            "selector": "0x26295ae8",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [
          {
            "name": "InitiatedDelegatorRegistration",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "validationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "delegatorAddress",
                "type": "address",
                "indexed": true
              },
              {
                "name": "nonce",
                "type": "uint64",
                "indexed": false
              },
              {
                "name": "validatorWeight",
                "type": "uint64",
                "indexed": false
              },
              {
                "name": "delegatorWeight",
                "type": "uint64",
                "indexed": false
              },
              {
                "name": "setWeightMessageID",
                "type": "bytes32",
                "indexed": false
              },
              {
                "name": "rewardRecipient",
                "type": "address",
                "indexed": false
              }
            ]
          },
          {
            "name": "InitiatedStakingValidatorRegistration",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "delegationFeeBips",
                "type": "uint16",
                "indexed": false
              },
              {
                "name": "minStakeDuration",
                "type": "uint64",
                "indexed": false
              },
              {
                "name": "rewardRecipient",
                "type": "address",
                "indexed": false
              }
            ]
          },
          {
            "name": "CompletedDelegatorRegistration",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "validationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "startTime",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "InitiatedDelegatorRemoval",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "validationID",
                "type": "bytes32",
                "indexed": true
              }
            ]
          },
          {
            "name": "CompletedDelegatorRemoval",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "validationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "rewards",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "fees",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "UptimeUpdated",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "uptime",
                "type": "uint64",
                "indexed": false
              }
            ]
          },
          {
            "name": "ValidatorRewardClaimed",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "recipient",
                "type": "address",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "ValidatorRewardRecipientChanged",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "recipient",
                "type": "address",
                "indexed": true
              },
              {
                "name": "oldRecipient",
                "type": "address",
                "indexed": true
              }
            ]
          },
          {
            "name": "DelegatorRewardClaimed",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "recipient",
                "type": "address",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "DelegatorRewardRecipientChanged",
            "parameters": [
              {
                "name": "delegationID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "recipient",
                "type": "address",
                "indexed": true
              },
              {
                "name": "oldRecipient",
                "type": "address",
                "indexed": true
              }
            ]
          }
        ],
        "errors": []
      },
      {
        "name": "IValidatorManager",
        "kind": "interface",
        "category": "interface",
        "filePath": "@validator-manager/interfaces/IValidatorManager.sol",
        "inherits": [],
        "implements": [
          "IACP99Manager"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "PChainOwner",
            "path": "./IACP99Manager.sol",
            "isExternal": false
          },
          {
            "name": "ValidatorStatus",
            "path": "./IACP99Manager.sol",
            "isExternal": false
          },
          {
            "name": "IACP99Manager",
            "path": "./IACP99Manager.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "migrateFromV1",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "receivedNonce",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function migrateFromV1(bytes32 validationID, uint32 receivedNonce) external;",
            "startLine": 43,
            "signature": "migrateFromV1(bytes32,uint32)",
            "selector": "0x71cf6c96",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "initiateValidatorRegistration",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "nodeID",
                "type": "bytes"
              },
              {
                "name": "blsPublicKey",
                "type": "bytes"
              },
              {
                "name": "remainingBalanceOwner",
                "type": "PChainOwner"
              },
              {
                "name": "disableOwner",
                "type": "PChainOwner"
              },
              {
                "name": "weight",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorRegistration(\n        bytes memory nodeID,\n        bytes memory blsPublicKey,\n        PChainOwner memory remainingBalanceOwner,\n        PChainOwner memory disableOwner,\n        uint64 weight\n    ) external returns (bytes32);",
            "startLine": 45,
            "signature": "initiateValidatorRegistration(bytes,bytes,PChainOwner,PChainOwner,uint64)",
            "selector": "0x239c60db",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "resendRegisterValidatorMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function resendRegisterValidatorMessage(\n        bytes32 validationID\n    ) external;",
            "startLine": 58,
            "signature": "resendRegisterValidatorMessage(bytes32)",
            "selector": "0x3fb1f58c",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "initiateValidatorRemoval",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorRemoval(\n        bytes32 validationID\n    ) external;",
            "startLine": 62,
            "signature": "initiateValidatorRemoval(bytes32)",
            "selector": "0x5aa039f4",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "resendValidatorRemovalMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function resendValidatorRemovalMessage(\n        bytes32 validationID\n    ) external;",
            "startLine": 71,
            "signature": "resendValidatorRemovalMessage(bytes32)",
            "selector": "0x296b3215",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "initiateValidatorWeightUpdate",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              },
              {
                "name": "newWeight",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              },
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initiateValidatorWeightUpdate(\n        bytes32 validationID,\n        uint64 newWeight\n    ) external returns (uint64, bytes32);",
            "startLine": 75,
            "signature": "initiateValidatorWeightUpdate(bytes32,uint64)",
            "selector": "0x68a81781",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "getNodeValidationID",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "nodeID",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getNodeValidationID(\n        bytes calldata nodeID\n    ) external view returns (bytes32);",
            "startLine": 84,
            "signature": "getNodeValidationID(bytes)",
            "selector": "0x4aff4026",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "getChurnPeriodSeconds",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getChurnPeriodSeconds() external view returns (uint64);",
            "startLine": 88,
            "signature": "getChurnPeriodSeconds()",
            "selector": "0x4f6fdae9",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": [
          {
            "name": "InvalidValidatorManagerAddress",
            "parameters": [
              {
                "name": "validatorManagerAddress",
                "type": "address"
              }
            ]
          },
          {
            "name": "InvalidWarpOriginSenderAddress",
            "parameters": [
              {
                "name": "senderAddress",
                "type": "address"
              }
            ]
          },
          {
            "name": "InvalidValidatorManagerBlockchainID",
            "parameters": [
              {
                "name": "blockchainID",
                "type": "bytes32"
              }
            ]
          },
          {
            "name": "InvalidWarpSourceChainID",
            "parameters": [
              {
                "name": "sourceChainID",
                "type": "bytes32"
              }
            ]
          },
          {
            "name": "InvalidInitializationStatus",
            "parameters": []
          },
          {
            "name": "InvalidMaximumChurnPercentage",
            "parameters": [
              {
                "name": "maximumChurnPercentage",
                "type": "uint8"
              }
            ]
          },
          {
            "name": "InvalidChurnPeriodLength",
            "parameters": [
              {
                "name": "churnPeriodLength",
                "type": "uint64"
              }
            ]
          },
          {
            "name": "InvalidBLSKeyLength",
            "parameters": [
              {
                "name": "length",
                "type": "uint256"
              }
            ]
          },
          {
            "name": "InvalidNodeID",
            "parameters": [
              {
                "name": "nodeID",
                "type": "bytes"
              }
            ]
          },
          {
            "name": "InvalidConversionID",
            "parameters": [
              {
                "name": "encodedConversionID",
                "type": "bytes32"
              },
              {
                "name": "expectedConversionID",
                "type": "bytes32"
              }
            ]
          },
          {
            "name": "InvalidTotalWeight",
            "parameters": [
              {
                "name": "weight",
                "type": "uint64"
              }
            ]
          },
          {
            "name": "InvalidValidationID",
            "parameters": [
              {
                "name": "validationID",
                "type": "bytes32"
              }
            ]
          },
          {
            "name": "InvalidValidatorStatus",
            "parameters": [
              {
                "name": "status",
                "type": "ValidatorStatus"
              }
            ]
          },
          {
            "name": "InvalidNonce",
            "parameters": [
              {
                "name": "nonce",
                "type": "uint64"
              }
            ]
          },
          {
            "name": "InvalidWarpMessage",
            "parameters": []
          },
          {
            "name": "MaxChurnRateExceeded",
            "parameters": [
              {
                "name": "churnAmount",
                "type": "uint64"
              }
            ]
          },
          {
            "name": "NodeAlreadyRegistered",
            "parameters": [
              {
                "name": "nodeID",
                "type": "bytes"
              }
            ]
          },
          {
            "name": "UnexpectedRegistrationStatus",
            "parameters": [
              {
                "name": "validRegistration",
                "type": "bool"
              }
            ]
          },
          {
            "name": "InvalidPChainOwnerThreshold",
            "parameters": [
              {
                "name": "threshold",
                "type": "uint256"
              },
              {
                "name": "addressesLength",
                "type": "uint256"
              }
            ]
          },
          {
            "name": "InvalidPChainOwnerAddresses",
            "parameters": []
          },
          {
            "name": "ZeroAddress",
            "parameters": []
          }
        ]
      },
      {
        "name": "IValidatorManagerExternalOwnable",
        "kind": "interface",
        "category": "interface",
        "filePath": "@validator-manager/interfaces/IValidatorManagerExternalOwnable.sol",
        "inherits": [],
        "implements": [
          "IValidatorManager"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IValidatorManager",
            "path": "./IValidatorManager.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function transferOwnership(\n        address newOwner\n    ) external;",
            "startLine": 18,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": []
      },
      {
        "name": "SafeERC20TransferFrom",
        "kind": "library",
        "category": "library",
        "filePath": "@utilities/SafeERC20TransferFrom.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [
          "SafeERC20"
        ],
        "imports": [
          {
            "name": "IERC20",
            "path": "@openzeppelin/contracts@5.0.2/token/ERC20/IERC20.sol",
            "isExternal": true
          },
          {
            "name": "SafeERC20",
            "path": "@openzeppelin/contracts@5.0.2/token/ERC20/utils/SafeERC20.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "safeTransferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "erc20",
                "type": "IERC20"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "safeTransferFrom",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function safeTransferFrom(IERC20 erc20, uint256 amount) internal returns (uint256) {\n        return safeTransferFrom(erc20, msg.sender, amount);\n    }",
            "startLine": 31,
            "visibility": "internal"
          },
          {
            "name": "safeTransferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "erc20",
                "type": "IERC20"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "erc20.balanceOf",
                "type": "external"
              },
              {
                "target": "erc20.safeTransferFrom",
                "type": "external"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function safeTransferFrom(\n        IERC20 erc20,\n        address from,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 balanceBefore = erc20.balanceOf(address(this));\n        erc20.safeTransferFrom(from, address(this), amount);\n        uint256 balanceAfter = erc20.balanceOf(address(this));\n\n        require(balanceAfter > balanceBefore, \"SafeERC20TransferFrom: balance not increased\");\n\n        return balanceAfter - balanceBefore;\n    }",
            "startLine": 46,
            "visibility": "internal"
          }
        ],
        "events": [],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "avalanche-icm"
      },
      {
        "name": "Initializable",
        "kind": "abstract",
        "category": "OZ-Upgradeable/proxy",
        "filePath": "@openzeppelin/contracts-upgradeable@5.0.2/proxy/utils/Initializable.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private"
          }
        ],
        "events": [
          {
            "name": "Initialized",
            "parameters": [
              {
                "name": "version",
                "type": "uint64",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "InvalidInitialization",
            "parameters": []
          },
          {
            "name": "NotInitializing",
            "parameters": []
          }
        ],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin-upgradeable"
      },
      {
        "name": "SafeERC20",
        "kind": "library",
        "category": "library",
        "filePath": "@openzeppelin/contracts@5.0.2/token/ERC20/utils/SafeERC20.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IERC20",
            "path": "../IERC20.sol",
            "isExternal": false
          },
          {
            "name": "IERC1363",
            "path": "../../../interfaces/IERC1363.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "safeTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_callOptionalReturn",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }",
            "startLine": 33,
            "visibility": "internal"
          },
          {
            "name": "safeTransferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_callOptionalReturn",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }",
            "startLine": 41,
            "visibility": "internal"
          },
          {
            "name": "trySafeTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_callOptionalReturnBool",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }",
            "startLine": 48,
            "visibility": "internal"
          },
          {
            "name": "trySafeTransferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_callOptionalReturnBool",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }",
            "startLine": 55,
            "visibility": "internal"
          },
          {
            "name": "safeIncreaseAllowance",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "token.allowance",
                "type": "external"
              },
              {
                "target": "forceApprove",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }",
            "startLine": 68,
            "visibility": "internal"
          },
          {
            "name": "safeDecreaseAllowance",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "requestedDecrease",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "token.allowance",
                "type": "external"
              },
              {
                "target": "forceApprove",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }",
            "startLine": 82,
            "visibility": "internal"
          },
          {
            "name": "forceApprove",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_callOptionalReturnBool",
                "type": "internal"
              },
              {
                "target": "_callOptionalReturn",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }",
            "startLine": 101,
            "visibility": "internal"
          },
          {
            "name": "transferAndCallRelaxed",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC1363"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "safeTransfer",
                "type": "internal"
              },
              {
                "target": "token.transferAndCall",
                "type": "external"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }",
            "startLine": 117,
            "visibility": "internal"
          },
          {
            "name": "transferFromAndCallRelaxed",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC1363"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "safeTransferFrom",
                "type": "internal"
              },
              {
                "target": "token.transferFromAndCall",
                "type": "external"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }",
            "startLine": 132,
            "visibility": "internal"
          },
          {
            "name": "approveAndCallRelaxed",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC1363"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "forceApprove",
                "type": "internal"
              },
              {
                "target": "token.approveAndCall",
                "type": "external"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }",
            "startLine": 157,
            "visibility": "internal"
          },
          {
            "name": "_callOptionalReturn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }",
            "startLine": 173,
            "visibility": "private"
          },
          {
            "name": "_callOptionalReturnBool",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }",
            "startLine": 201,
            "visibility": "private"
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "SafeERC20FailedOperation",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              }
            ]
          },
          {
            "name": "SafeERC20FailedDecreaseAllowance",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "currentAllowance",
                "type": "uint256"
              },
              {
                "name": "requestedDecrease",
                "type": "uint256"
              }
            ]
          }
        ],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin"
      },
      {
        "name": "INativeMinter",
        "kind": "interface",
        "category": "interface",
        "filePath": "@subnet-evm/INativeMinter.sol",
        "inherits": [],
        "implements": [
          "IAllowList"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IAllowList",
            "path": "@subnet-evm/IAllowList.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "mintNativeCoin",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "addr",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function mintNativeCoin(address addr, uint256 amount) external;",
            "startLine": 10,
            "signature": "mintNativeCoin(address,uint256)",
            "selector": "0x0372929a",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [
          {
            "name": "NativeCoinMinted",
            "parameters": [
              {
                "name": "sender",
                "type": "address",
                "indexed": true
              },
              {
                "name": "recipient",
                "type": "address",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "avalanche-icm"
      },
      {
        "name": "Address",
        "kind": "library",
        "category": "library",
        "filePath": "@openzeppelin/contracts@5.0.2/utils/Address.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "Errors",
            "path": "./Errors.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "sendValue",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "recipient",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "Errors.InsufficientBalance",
                "type": "library"
              },
              {
                "target": "_revert",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }",
            "startLine": 33,
            "visibility": "internal"
          },
          {
            "name": "functionCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "functionCallWithValue",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }",
            "startLine": 62,
            "visibility": "internal"
          },
          {
            "name": "functionCallWithValue",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "Errors.InsufficientBalance",
                "type": "library"
              },
              {
                "target": "verifyCallResultFromTarget",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }",
            "startLine": 75,
            "visibility": "internal"
          },
          {
            "name": "functionStaticCall",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "target.staticcall",
                "type": "external"
              },
              {
                "target": "verifyCallResultFromTarget",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }",
            "startLine": 87,
            "visibility": "internal"
          },
          {
            "name": "functionDelegateCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "unknown",
                "type": "delegatecall"
              },
              {
                "target": "verifyCallResultFromTarget",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }",
            "startLine": 96,
            "visibility": "internal"
          },
          {
            "name": "verifyCallResultFromTarget",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "success",
                "type": "bool"
              },
              {
                "name": "returndata",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "_revert",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }",
            "startLine": 106,
            "visibility": "internal"
          },
          {
            "name": "verifyCallResult",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "success",
                "type": "bool"
              },
              {
                "name": "returndata",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "_revert",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }",
            "startLine": 127,
            "visibility": "internal"
          },
          {
            "name": "_revert",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "returndata",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "Errors.FailedCall",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }",
            "startLine": 138,
            "visibility": "private"
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "AddressEmptyCode",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              }
            ]
          }
        ],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin"
      },
      {
        "name": "Ownable",
        "kind": "abstract",
        "category": "OpenZeppelin/access",
        "filePath": "@openzeppelin/contracts@5.0.2/access/Ownable.sol",
        "inherits": [
          "Context"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "Context",
            "path": "../utils/Context.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address) {\n        return _owner;\n    }",
            "startLine": 56,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "renounceOwnership",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
            "startLine": 76,
            "signature": "renounceOwnership()",
            "selector": "0x765becbf",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }",
            "startLine": 84,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          }
        ],
        "internalFunctions": [
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }",
            "startLine": 63,
            "visibility": "internal"
          },
          {
            "name": "_transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [
              "OwnershipTransferred"
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }",
            "startLine": 95,
            "visibility": "internal"
          }
        ],
        "events": [
          {
            "name": "OwnershipTransferred",
            "parameters": [
              {
                "name": "previousOwner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "newOwner",
                "type": "address",
                "indexed": true
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "OwnableUnauthorizedAccount",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ]
          },
          {
            "name": "OwnableInvalidOwner",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ]
          }
        ],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin"
      },
      {
        "name": "IWarpMessenger",
        "kind": "interface",
        "category": "interface",
        "filePath": "@subnet-evm/IWarpMessenger.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "sendWarpMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "payload",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "messageID",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function sendWarpMessage(\n        bytes calldata payload\n    ) external returns (bytes32 messageID);",
            "startLine": 26,
            "signature": "sendWarpMessage(bytes)",
            "selector": "0x14602c51",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "getVerifiedWarpMessage",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "index",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "message",
                "type": "WarpMessage"
              },
              {
                "name": "valid",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getVerifiedWarpMessage(\n        uint32 index\n    ) external view returns (WarpMessage calldata message, bool valid);",
            "startLine": 35,
            "signature": "getVerifiedWarpMessage(uint32)",
            "selector": "0x24db2f29",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "getVerifiedWarpBlockHash",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "index",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "warpBlockHash",
                "type": "WarpBlockHash"
              },
              {
                "name": "valid",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getVerifiedWarpBlockHash(\n        uint32 index\n    ) external view returns (WarpBlockHash calldata warpBlockHash, bool valid);",
            "startLine": 44,
            "signature": "getVerifiedWarpBlockHash(uint32)",
            "selector": "0x5b034023",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "getBlockchainID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "blockchainID",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getBlockchainID() external view returns (bytes32 blockchainID);",
            "startLine": 51,
            "signature": "getBlockchainID()",
            "selector": "0x587a98a6",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [
          {
            "name": "SendWarpMessage",
            "parameters": [
              {
                "name": "sender",
                "type": "address",
                "indexed": true
              },
              {
                "name": "messageID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "message",
                "type": "bytes",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "avalanche-icm"
      },
      {
        "name": "ReentrancyGuardUpgradeable",
        "kind": "abstract",
        "category": "OZ-Upgradeable/utils",
        "filePath": "@openzeppelin/contracts-upgradeable@5.0.2/utils/ReentrancyGuardUpgradeable.sol",
        "inherits": [
          "Initializable"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "Initializable",
            "path": "../proxy/utils/Initializable.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "_getReentrancyGuardStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ReentrancyGuardStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }",
            "startLine": 49,
            "visibility": "private"
          },
          {
            "name": "__ReentrancyGuard_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "__ReentrancyGuard_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }",
            "startLine": 60,
            "visibility": "internal"
          },
          {
            "name": "__ReentrancyGuard_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }",
            "startLine": 64,
            "visibility": "internal"
          },
          {
            "name": "_nonReentrantBefore",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }",
            "startLine": 82,
            "visibility": "private"
          },
          {
            "name": "_nonReentrantAfter",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }",
            "startLine": 93,
            "visibility": "private"
          },
          {
            "name": "_reentrancyGuardEntered",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }",
            "startLine": 104,
            "visibility": "internal"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ReentrancyGuardReentrantCall",
            "parameters": []
          }
        ],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin-upgradeable"
      },
      {
        "name": "ContextUpgradeable",
        "kind": "abstract",
        "category": "OZ-Upgradeable/utils",
        "filePath": "@openzeppelin/contracts-upgradeable@5.0.2/utils/ContextUpgradeable.sol",
        "inherits": [
          "Initializable"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "Initializable",
            "path": "../proxy/utils/Initializable.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "__Context_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Context_init() internal onlyInitializing {\n    }",
            "startLine": 18,
            "visibility": "internal"
          },
          {
            "name": "__Context_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Context_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 21,
            "visibility": "internal"
          },
          {
            "name": "_msgSender",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }",
            "startLine": 23,
            "visibility": "internal"
          },
          {
            "name": "_msgData",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }",
            "startLine": 27,
            "visibility": "internal"
          },
          {
            "name": "_contextSuffixLength",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }",
            "startLine": 31,
            "visibility": "internal"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          }
        ],
        "events": [],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin-upgradeable"
      },
      {
        "name": "OwnableUpgradeable",
        "kind": "abstract",
        "category": "OZ-Upgradeable/access",
        "filePath": "@openzeppelin/contracts-upgradeable@5.0.2/access/OwnableUpgradeable.sol",
        "inherits": [
          "Initializable",
          "ContextUpgradeable"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "ContextUpgradeable",
            "path": "../utils/ContextUpgradeable.sol",
            "isExternal": false
          },
          {
            "name": "Initializable",
            "path": "../proxy/utils/Initializable.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }",
            "startLine": 73,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "renounceOwnership",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
            "startLine": 94,
            "signature": "renounceOwnership()",
            "selector": "0x765becbf",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }",
            "startLine": 102,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          }
        ],
        "internalFunctions": [
          {
            "name": "_getOwnableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "OwnableStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }",
            "startLine": 30,
            "visibility": "private"
          },
          {
            "name": "__Ownable_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__Ownable_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }",
            "startLine": 51,
            "visibility": "internal"
          },
          {
            "name": "__Ownable_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }",
            "startLine": 55,
            "visibility": "internal"
          },
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }",
            "startLine": 81,
            "visibility": "internal"
          },
          {
            "name": "_transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "OwnershipTransferred"
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }",
            "startLine": 113,
            "visibility": "internal"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "__Context_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Context_init() internal onlyInitializing {\n    }",
            "startLine": 18,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "__Context_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Context_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 21,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "_msgSender",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }",
            "startLine": 23,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "_msgData",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }",
            "startLine": 27,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          },
          {
            "name": "_contextSuffixLength",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }",
            "startLine": 31,
            "visibility": "internal",
            "inheritedFrom": "ContextUpgradeable"
          }
        ],
        "events": [
          {
            "name": "OwnershipTransferred",
            "parameters": [
              {
                "name": "previousOwner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "newOwner",
                "type": "address",
                "indexed": true
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "OwnableUnauthorizedAccount",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ]
          },
          {
            "name": "OwnableInvalidOwner",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ]
          }
        ],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin-upgradeable"
      },
      {
        "name": "IERC20",
        "kind": "interface",
        "category": "interface",
        "filePath": "@openzeppelin/contracts@5.0.2/token/ERC20/IERC20.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "totalSupply",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function totalSupply() external view returns (uint256);",
            "startLine": 27,
            "signature": "totalSupply()",
            "selector": "0x6190166c",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "balanceOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function balanceOf(address account) external view returns (uint256);",
            "startLine": 32,
            "signature": "balanceOf(address)",
            "selector": "0x7d2b9996",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function transfer(address to, uint256 value) external returns (bool);",
            "startLine": 41,
            "signature": "transfer(address,uint256)",
            "selector": "0x59d228e5",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "allowance",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function allowance(address owner, address spender) external view returns (uint256);",
            "startLine": 50,
            "signature": "allowance(address,address)",
            "selector": "0x596dd87d",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function approve(address spender, uint256 value) external returns (bool);",
            "startLine": 67,
            "signature": "approve(address,uint256)",
            "selector": "0x1d38323d",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "transferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function transferFrom(address from, address to, uint256 value) external returns (bool);",
            "startLine": 78,
            "signature": "transferFrom(address,address,uint256)",
            "selector": "0x447f286d",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [
          {
            "name": "Transfer",
            "parameters": [
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "value",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "Approval",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "spender",
                "type": "address",
                "indexed": true
              },
              {
                "name": "value",
                "type": "uint256",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin"
      },
      {
        "name": "IAllowList",
        "kind": "interface",
        "category": "interface",
        "filePath": "@subnet-evm/IAllowList.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "setAdmin",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "addr",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function setAdmin(\n        address addr\n    ) external;",
            "startLine": 10,
            "signature": "setAdmin(address)",
            "selector": "0x572d4a90",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "setEnabled",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "addr",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function setEnabled(\n        address addr\n    ) external;",
            "startLine": 15,
            "signature": "setEnabled(address)",
            "selector": "0x15c4c53e",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "setManager",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "addr",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function setManager(\n        address addr\n    ) external;",
            "startLine": 20,
            "signature": "setManager(address)",
            "selector": "0x517b7a52",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "setNone",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "addr",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function setNone(\n        address addr\n    ) external;",
            "startLine": 25,
            "signature": "setNone(address)",
            "selector": "0x5fd54d63",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "readAllowList",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "addr",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "role",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function readAllowList(\n        address addr\n    ) external view returns (uint256 role);",
            "startLine": 30,
            "signature": "readAllowList(address)",
            "selector": "0x7613636c",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [
          {
            "name": "RoleSet",
            "parameters": [
              {
                "name": "role",
                "type": "uint256",
                "indexed": true
              },
              {
                "name": "account",
                "type": "address",
                "indexed": true
              },
              {
                "name": "sender",
                "type": "address",
                "indexed": true
              },
              {
                "name": "oldRole",
                "type": "uint256",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "avalanche-icm"
      }
    ],
    "dependencies": [
      {
        "from": "ACP99Manager",
        "to": "IACP99Manager",
        "type": "implements"
      },
      {
        "from": "ERC20TokenStakingManager",
        "to": "Initializable",
        "type": "inherits"
      },
      {
        "from": "ERC20TokenStakingManager",
        "to": "StakingManager",
        "type": "inherits"
      },
      {
        "from": "ERC20TokenStakingManager",
        "to": "IERC20TokenStakingManager",
        "type": "implements"
      },
      {
        "from": "ERC20TokenStakingManager",
        "to": "SafeERC20",
        "type": "uses"
      },
      {
        "from": "ERC20TokenStakingManager",
        "to": "SafeERC20TransferFrom",
        "type": "uses"
      },
      {
        "from": "ExampleRewardCalculator",
        "to": "IRewardCalculator",
        "type": "implements"
      },
      {
        "from": "NativeTokenStakingManager",
        "to": "Initializable",
        "type": "inherits"
      },
      {
        "from": "NativeTokenStakingManager",
        "to": "StakingManager",
        "type": "inherits"
      },
      {
        "from": "NativeTokenStakingManager",
        "to": "INativeTokenStakingManager",
        "type": "implements"
      },
      {
        "from": "NativeTokenStakingManager",
        "to": "Address",
        "type": "uses"
      },
      {
        "from": "PoAManager",
        "to": "Ownable",
        "type": "inherits"
      },
      {
        "from": "PoAManager",
        "to": "IPoAManager",
        "type": "implements"
      },
      {
        "from": "StakingManager",
        "to": "ContextUpgradeable",
        "type": "inherits"
      },
      {
        "from": "StakingManager",
        "to": "ReentrancyGuardUpgradeable",
        "type": "inherits"
      },
      {
        "from": "StakingManager",
        "to": "IStakingManager",
        "type": "implements"
      },
      {
        "from": "ValidatorManager",
        "to": "Initializable",
        "type": "inherits"
      },
      {
        "from": "ValidatorManager",
        "to": "OwnableUpgradeable",
        "type": "inherits"
      },
      {
        "from": "ValidatorManager",
        "to": "ACP99Manager",
        "type": "inherits"
      },
      {
        "from": "ValidatorManager",
        "to": "IValidatorManager",
        "type": "implements"
      },
      {
        "from": "IERC20Mintable",
        "to": "IERC20",
        "type": "implements"
      },
      {
        "from": "IERC20TokenStakingManager",
        "to": "IStakingManager",
        "type": "implements"
      },
      {
        "from": "INativeTokenStakingManager",
        "to": "IStakingManager",
        "type": "implements"
      },
      {
        "from": "IValidatorManager",
        "to": "IACP99Manager",
        "type": "implements"
      },
      {
        "from": "IValidatorManagerExternalOwnable",
        "to": "IValidatorManager",
        "type": "implements"
      },
      {
        "from": "SafeERC20TransferFrom",
        "to": "SafeERC20",
        "type": "uses"
      },
      {
        "from": "INativeMinter",
        "to": "IAllowList",
        "type": "implements"
      },
      {
        "from": "ReentrancyGuardUpgradeable",
        "to": "Initializable",
        "type": "inherits"
      },
      {
        "from": "ContextUpgradeable",
        "to": "Initializable",
        "type": "inherits"
      },
      {
        "from": "OwnableUpgradeable",
        "to": "Initializable",
        "type": "inherits"
      },
      {
        "from": "OwnableUpgradeable",
        "to": "ContextUpgradeable",
        "type": "inherits"
      }
    ],
    "proxyGroups": [],
    "stats": {
      "totalContracts": 12,
      "totalLibraries": 4,
      "totalInterfaces": 13,
      "totalFunctions": 392
    }
  }
}