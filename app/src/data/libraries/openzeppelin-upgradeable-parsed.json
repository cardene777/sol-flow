{
  "id": "openzeppelin-upgradeable",
  "name": "OpenZeppelin Upgradeable",
  "version": "5.0.0",
  "generatedAt": "2026-01-29T07:46:48.361Z",
  "callGraph": {
    "version": "1.0.0",
    "generatedAt": "2026-01-29T07:46:48.361Z",
    "projectName": "OpenZeppelin Upgradeable",
    "structure": {
      "name": "contracts",
      "type": "directory",
      "path": "contracts",
      "children": [
        {
          "name": "access",
          "type": "directory",
          "path": "access",
          "children": [
            {
              "name": "AccessControlUpgradeable.sol",
              "type": "file",
              "path": "access/AccessControlUpgradeable.sol",
              "contractName": "AccessControlUpgradeable"
            },
            {
              "name": "Ownable2StepUpgradeable.sol",
              "type": "file",
              "path": "access/Ownable2StepUpgradeable.sol",
              "contractName": "Ownable2StepUpgradeable"
            },
            {
              "name": "OwnableUpgradeable.sol",
              "type": "file",
              "path": "access/OwnableUpgradeable.sol",
              "contractName": "OwnableUpgradeable"
            },
            {
              "name": "extensions",
              "type": "directory",
              "path": "access/extensions",
              "children": [
                {
                  "name": "AccessControlDefaultAdminRulesUpgradeable.sol",
                  "type": "file",
                  "path": "access/extensions/AccessControlDefaultAdminRulesUpgradeable.sol",
                  "contractName": "AccessControlDefaultAdminRulesUpgradeable"
                },
                {
                  "name": "AccessControlEnumerableUpgradeable.sol",
                  "type": "file",
                  "path": "access/extensions/AccessControlEnumerableUpgradeable.sol",
                  "contractName": "AccessControlEnumerableUpgradeable"
                }
              ]
            },
            {
              "name": "manager",
              "type": "directory",
              "path": "access/manager",
              "children": [
                {
                  "name": "AccessManagedUpgradeable.sol",
                  "type": "file",
                  "path": "access/manager/AccessManagedUpgradeable.sol",
                  "contractName": "AccessManagedUpgradeable"
                },
                {
                  "name": "AccessManagerUpgradeable.sol",
                  "type": "file",
                  "path": "access/manager/AccessManagerUpgradeable.sol",
                  "contractName": "AccessManagerUpgradeable"
                }
              ]
            }
          ]
        },
        {
          "name": "account",
          "type": "directory",
          "path": "account",
          "children": [
            {
              "name": "extensions",
              "type": "directory",
              "path": "account/extensions",
              "children": [
                {
                  "name": "draft-AccountERC7579HookedUpgradeable.sol",
                  "type": "file",
                  "path": "account/extensions/draft-AccountERC7579HookedUpgradeable.sol",
                  "contractName": "AccountERC7579HookedUpgradeable"
                },
                {
                  "name": "draft-AccountERC7579Upgradeable.sol",
                  "type": "file",
                  "path": "account/extensions/draft-AccountERC7579Upgradeable.sol",
                  "contractName": "AccountERC7579Upgradeable"
                }
              ]
            }
          ]
        },
        {
          "name": "crosschain",
          "type": "directory",
          "path": "crosschain",
          "children": [
            {
              "name": "CrosschainLinkedUpgradeable.sol",
              "type": "file",
              "path": "crosschain/CrosschainLinkedUpgradeable.sol",
              "contractName": "CrosschainLinkedUpgradeable"
            },
            {
              "name": "ERC7786RecipientUpgradeable.sol",
              "type": "file",
              "path": "crosschain/ERC7786RecipientUpgradeable.sol",
              "contractName": "ERC7786RecipientUpgradeable"
            },
            {
              "name": "bridges",
              "type": "directory",
              "path": "crosschain/bridges",
              "children": [
                {
                  "name": "BridgeERC20CoreUpgradeable.sol",
                  "type": "file",
                  "path": "crosschain/bridges/BridgeERC20CoreUpgradeable.sol",
                  "contractName": "BridgeERC20CoreUpgradeable"
                },
                {
                  "name": "BridgeERC20Upgradeable.sol",
                  "type": "file",
                  "path": "crosschain/bridges/BridgeERC20Upgradeable.sol",
                  "contractName": "BridgeERC20Upgradeable"
                },
                {
                  "name": "BridgeERC7802Upgradeable.sol",
                  "type": "file",
                  "path": "crosschain/bridges/BridgeERC7802Upgradeable.sol",
                  "contractName": "BridgeERC7802Upgradeable"
                }
              ]
            }
          ]
        },
        {
          "name": "finance",
          "type": "directory",
          "path": "finance",
          "children": [
            {
              "name": "VestingWalletCliffUpgradeable.sol",
              "type": "file",
              "path": "finance/VestingWalletCliffUpgradeable.sol",
              "contractName": "VestingWalletCliffUpgradeable"
            },
            {
              "name": "VestingWalletUpgradeable.sol",
              "type": "file",
              "path": "finance/VestingWalletUpgradeable.sol",
              "contractName": "VestingWalletUpgradeable"
            }
          ]
        },
        {
          "name": "governance",
          "type": "directory",
          "path": "governance",
          "children": [
            {
              "name": "GovernorUpgradeable.sol",
              "type": "file",
              "path": "governance/GovernorUpgradeable.sol",
              "contractName": "GovernorUpgradeable"
            },
            {
              "name": "TimelockControllerUpgradeable.sol",
              "type": "file",
              "path": "governance/TimelockControllerUpgradeable.sol",
              "contractName": "TimelockControllerUpgradeable"
            },
            {
              "name": "extensions",
              "type": "directory",
              "path": "governance/extensions",
              "children": [
                {
                  "name": "GovernorCountingFractionalUpgradeable.sol",
                  "type": "file",
                  "path": "governance/extensions/GovernorCountingFractionalUpgradeable.sol",
                  "contractName": "GovernorCountingFractionalUpgradeable"
                },
                {
                  "name": "GovernorCountingOverridableUpgradeable.sol",
                  "type": "file",
                  "path": "governance/extensions/GovernorCountingOverridableUpgradeable.sol",
                  "contractName": "GovernorCountingOverridableUpgradeable"
                },
                {
                  "name": "GovernorCountingSimpleUpgradeable.sol",
                  "type": "file",
                  "path": "governance/extensions/GovernorCountingSimpleUpgradeable.sol",
                  "contractName": "GovernorCountingSimpleUpgradeable"
                },
                {
                  "name": "GovernorNoncesKeyedUpgradeable.sol",
                  "type": "file",
                  "path": "governance/extensions/GovernorNoncesKeyedUpgradeable.sol",
                  "contractName": "GovernorNoncesKeyedUpgradeable"
                },
                {
                  "name": "GovernorPreventLateQuorumUpgradeable.sol",
                  "type": "file",
                  "path": "governance/extensions/GovernorPreventLateQuorumUpgradeable.sol",
                  "contractName": "GovernorPreventLateQuorumUpgradeable"
                },
                {
                  "name": "GovernorProposalGuardianUpgradeable.sol",
                  "type": "file",
                  "path": "governance/extensions/GovernorProposalGuardianUpgradeable.sol",
                  "contractName": "GovernorProposalGuardianUpgradeable"
                },
                {
                  "name": "GovernorSequentialProposalIdUpgradeable.sol",
                  "type": "file",
                  "path": "governance/extensions/GovernorSequentialProposalIdUpgradeable.sol",
                  "contractName": "GovernorSequentialProposalIdUpgradeable"
                },
                {
                  "name": "GovernorSettingsUpgradeable.sol",
                  "type": "file",
                  "path": "governance/extensions/GovernorSettingsUpgradeable.sol",
                  "contractName": "GovernorSettingsUpgradeable"
                },
                {
                  "name": "GovernorStorageUpgradeable.sol",
                  "type": "file",
                  "path": "governance/extensions/GovernorStorageUpgradeable.sol",
                  "contractName": "GovernorStorageUpgradeable"
                },
                {
                  "name": "GovernorSuperQuorumUpgradeable.sol",
                  "type": "file",
                  "path": "governance/extensions/GovernorSuperQuorumUpgradeable.sol",
                  "contractName": "GovernorSuperQuorumUpgradeable"
                },
                {
                  "name": "GovernorTimelockAccessUpgradeable.sol",
                  "type": "file",
                  "path": "governance/extensions/GovernorTimelockAccessUpgradeable.sol",
                  "contractName": "GovernorTimelockAccessUpgradeable"
                },
                {
                  "name": "GovernorTimelockCompoundUpgradeable.sol",
                  "type": "file",
                  "path": "governance/extensions/GovernorTimelockCompoundUpgradeable.sol",
                  "contractName": "GovernorTimelockCompoundUpgradeable"
                },
                {
                  "name": "GovernorTimelockControlUpgradeable.sol",
                  "type": "file",
                  "path": "governance/extensions/GovernorTimelockControlUpgradeable.sol",
                  "contractName": "GovernorTimelockControlUpgradeable"
                },
                {
                  "name": "GovernorVotesQuorumFractionUpgradeable.sol",
                  "type": "file",
                  "path": "governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol",
                  "contractName": "GovernorVotesQuorumFractionUpgradeable"
                },
                {
                  "name": "GovernorVotesSuperQuorumFractionUpgradeable.sol",
                  "type": "file",
                  "path": "governance/extensions/GovernorVotesSuperQuorumFractionUpgradeable.sol",
                  "contractName": "GovernorVotesSuperQuorumFractionUpgradeable"
                },
                {
                  "name": "GovernorVotesUpgradeable.sol",
                  "type": "file",
                  "path": "governance/extensions/GovernorVotesUpgradeable.sol",
                  "contractName": "GovernorVotesUpgradeable"
                }
              ]
            },
            {
              "name": "utils",
              "type": "directory",
              "path": "governance/utils",
              "children": [
                {
                  "name": "VotesExtendedUpgradeable.sol",
                  "type": "file",
                  "path": "governance/utils/VotesExtendedUpgradeable.sol",
                  "contractName": "VotesExtendedUpgradeable"
                },
                {
                  "name": "VotesUpgradeable.sol",
                  "type": "file",
                  "path": "governance/utils/VotesUpgradeable.sol",
                  "contractName": "VotesUpgradeable"
                }
              ]
            }
          ]
        },
        {
          "name": "metatx",
          "type": "directory",
          "path": "metatx",
          "children": [
            {
              "name": "ERC2771ContextUpgradeable.sol",
              "type": "file",
              "path": "metatx/ERC2771ContextUpgradeable.sol",
              "contractName": "ERC2771ContextUpgradeable"
            },
            {
              "name": "ERC2771ForwarderUpgradeable.sol",
              "type": "file",
              "path": "metatx/ERC2771ForwarderUpgradeable.sol",
              "contractName": "ERC2771ForwarderUpgradeable"
            }
          ]
        },
        {
          "name": "token",
          "type": "directory",
          "path": "token",
          "children": [
            {
              "name": "ERC1155",
              "type": "directory",
              "path": "token/ERC1155",
              "children": [
                {
                  "name": "ERC1155Upgradeable.sol",
                  "type": "file",
                  "path": "token/ERC1155/ERC1155Upgradeable.sol",
                  "contractName": "ERC1155Upgradeable"
                },
                {
                  "name": "extensions",
                  "type": "directory",
                  "path": "token/ERC1155/extensions",
                  "children": [
                    {
                      "name": "ERC1155BurnableUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol",
                      "contractName": "ERC1155BurnableUpgradeable"
                    },
                    {
                      "name": "ERC1155PausableUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC1155/extensions/ERC1155PausableUpgradeable.sol",
                      "contractName": "ERC1155PausableUpgradeable"
                    },
                    {
                      "name": "ERC1155SupplyUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol",
                      "contractName": "ERC1155SupplyUpgradeable"
                    },
                    {
                      "name": "ERC1155URIStorageUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC1155/extensions/ERC1155URIStorageUpgradeable.sol",
                      "contractName": "ERC1155URIStorageUpgradeable"
                    }
                  ]
                }
              ]
            },
            {
              "name": "ERC20",
              "type": "directory",
              "path": "token/ERC20",
              "children": [
                {
                  "name": "ERC20Upgradeable.sol",
                  "type": "file",
                  "path": "token/ERC20/ERC20Upgradeable.sol",
                  "contractName": "ERC20Upgradeable"
                },
                {
                  "name": "extensions",
                  "type": "directory",
                  "path": "token/ERC20/extensions",
                  "children": [
                    {
                      "name": "ERC1363Upgradeable.sol",
                      "type": "file",
                      "path": "token/ERC20/extensions/ERC1363Upgradeable.sol",
                      "contractName": "ERC1363Upgradeable"
                    },
                    {
                      "name": "ERC20BurnableUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC20/extensions/ERC20BurnableUpgradeable.sol",
                      "contractName": "ERC20BurnableUpgradeable"
                    },
                    {
                      "name": "ERC20CappedUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC20/extensions/ERC20CappedUpgradeable.sol",
                      "contractName": "ERC20CappedUpgradeable"
                    },
                    {
                      "name": "ERC20CrosschainUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC20/extensions/ERC20CrosschainUpgradeable.sol",
                      "contractName": "ERC20CrosschainUpgradeable"
                    },
                    {
                      "name": "ERC20FlashMintUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC20/extensions/ERC20FlashMintUpgradeable.sol",
                      "contractName": "ERC20FlashMintUpgradeable"
                    },
                    {
                      "name": "ERC20PausableUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC20/extensions/ERC20PausableUpgradeable.sol",
                      "contractName": "ERC20PausableUpgradeable"
                    },
                    {
                      "name": "ERC20PermitUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC20/extensions/ERC20PermitUpgradeable.sol",
                      "contractName": "ERC20PermitUpgradeable"
                    },
                    {
                      "name": "ERC20VotesUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC20/extensions/ERC20VotesUpgradeable.sol",
                      "contractName": "ERC20VotesUpgradeable"
                    },
                    {
                      "name": "ERC20WrapperUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC20/extensions/ERC20WrapperUpgradeable.sol",
                      "contractName": "ERC20WrapperUpgradeable"
                    },
                    {
                      "name": "ERC4626Upgradeable.sol",
                      "type": "file",
                      "path": "token/ERC20/extensions/ERC4626Upgradeable.sol",
                      "contractName": "ERC4626Upgradeable"
                    },
                    {
                      "name": "draft-ERC20BridgeableUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC20/extensions/draft-ERC20BridgeableUpgradeable.sol",
                      "contractName": "ERC20BridgeableUpgradeable"
                    },
                    {
                      "name": "draft-ERC20TemporaryApprovalUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC20/extensions/draft-ERC20TemporaryApprovalUpgradeable.sol",
                      "contractName": "ERC20TemporaryApprovalUpgradeable"
                    }
                  ]
                }
              ]
            },
            {
              "name": "ERC6909",
              "type": "directory",
              "path": "token/ERC6909",
              "children": [
                {
                  "name": "ERC6909Upgradeable.sol",
                  "type": "file",
                  "path": "token/ERC6909/ERC6909Upgradeable.sol",
                  "contractName": "ERC6909Upgradeable"
                },
                {
                  "name": "extensions",
                  "type": "directory",
                  "path": "token/ERC6909/extensions",
                  "children": [
                    {
                      "name": "ERC6909ContentURIUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC6909/extensions/ERC6909ContentURIUpgradeable.sol",
                      "contractName": "ERC6909ContentURIUpgradeable"
                    },
                    {
                      "name": "ERC6909MetadataUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC6909/extensions/ERC6909MetadataUpgradeable.sol",
                      "contractName": "ERC6909MetadataUpgradeable"
                    },
                    {
                      "name": "ERC6909TokenSupplyUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC6909/extensions/ERC6909TokenSupplyUpgradeable.sol",
                      "contractName": "ERC6909TokenSupplyUpgradeable"
                    }
                  ]
                }
              ]
            },
            {
              "name": "ERC721",
              "type": "directory",
              "path": "token/ERC721",
              "children": [
                {
                  "name": "ERC721Upgradeable.sol",
                  "type": "file",
                  "path": "token/ERC721/ERC721Upgradeable.sol",
                  "contractName": "ERC721Upgradeable"
                },
                {
                  "name": "extensions",
                  "type": "directory",
                  "path": "token/ERC721/extensions",
                  "children": [
                    {
                      "name": "ERC721BurnableUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC721/extensions/ERC721BurnableUpgradeable.sol",
                      "contractName": "ERC721BurnableUpgradeable"
                    },
                    {
                      "name": "ERC721ConsecutiveUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC721/extensions/ERC721ConsecutiveUpgradeable.sol",
                      "contractName": "ERC721ConsecutiveUpgradeable"
                    },
                    {
                      "name": "ERC721EnumerableUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC721/extensions/ERC721EnumerableUpgradeable.sol",
                      "contractName": "ERC721EnumerableUpgradeable"
                    },
                    {
                      "name": "ERC721PausableUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC721/extensions/ERC721PausableUpgradeable.sol",
                      "contractName": "ERC721PausableUpgradeable"
                    },
                    {
                      "name": "ERC721RoyaltyUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC721/extensions/ERC721RoyaltyUpgradeable.sol",
                      "contractName": "ERC721RoyaltyUpgradeable"
                    },
                    {
                      "name": "ERC721URIStorageUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC721/extensions/ERC721URIStorageUpgradeable.sol",
                      "contractName": "ERC721URIStorageUpgradeable"
                    },
                    {
                      "name": "ERC721VotesUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC721/extensions/ERC721VotesUpgradeable.sol",
                      "contractName": "ERC721VotesUpgradeable"
                    },
                    {
                      "name": "ERC721WrapperUpgradeable.sol",
                      "type": "file",
                      "path": "token/ERC721/extensions/ERC721WrapperUpgradeable.sol",
                      "contractName": "ERC721WrapperUpgradeable"
                    }
                  ]
                }
              ]
            },
            {
              "name": "common",
              "type": "directory",
              "path": "token/common",
              "children": [
                {
                  "name": "ERC2981Upgradeable.sol",
                  "type": "file",
                  "path": "token/common/ERC2981Upgradeable.sol",
                  "contractName": "ERC2981Upgradeable"
                }
              ]
            }
          ]
        },
        {
          "name": "utils",
          "type": "directory",
          "path": "utils",
          "children": [
            {
              "name": "ContextUpgradeable.sol",
              "type": "file",
              "path": "utils/ContextUpgradeable.sol",
              "contractName": "ContextUpgradeable"
            },
            {
              "name": "MulticallUpgradeable.sol",
              "type": "file",
              "path": "utils/MulticallUpgradeable.sol",
              "contractName": "MulticallUpgradeable"
            },
            {
              "name": "NoncesKeyedUpgradeable.sol",
              "type": "file",
              "path": "utils/NoncesKeyedUpgradeable.sol",
              "contractName": "NoncesKeyedUpgradeable"
            },
            {
              "name": "NoncesUpgradeable.sol",
              "type": "file",
              "path": "utils/NoncesUpgradeable.sol",
              "contractName": "NoncesUpgradeable"
            },
            {
              "name": "PausableUpgradeable.sol",
              "type": "file",
              "path": "utils/PausableUpgradeable.sol",
              "contractName": "PausableUpgradeable"
            },
            {
              "name": "cryptography",
              "type": "directory",
              "path": "utils/cryptography",
              "children": [
                {
                  "name": "EIP712Upgradeable.sol",
                  "type": "file",
                  "path": "utils/cryptography/EIP712Upgradeable.sol",
                  "contractName": "EIP712Upgradeable"
                },
                {
                  "name": "signers",
                  "type": "directory",
                  "path": "utils/cryptography/signers",
                  "children": [
                    {
                      "name": "MultiSignerERC7913Upgradeable.sol",
                      "type": "file",
                      "path": "utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol",
                      "contractName": "MultiSignerERC7913Upgradeable"
                    },
                    {
                      "name": "MultiSignerERC7913WeightedUpgradeable.sol",
                      "type": "file",
                      "path": "utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol",
                      "contractName": "MultiSignerERC7913WeightedUpgradeable"
                    },
                    {
                      "name": "SignerECDSAUpgradeable.sol",
                      "type": "file",
                      "path": "utils/cryptography/signers/SignerECDSAUpgradeable.sol",
                      "contractName": "SignerECDSAUpgradeable"
                    },
                    {
                      "name": "SignerERC7913Upgradeable.sol",
                      "type": "file",
                      "path": "utils/cryptography/signers/SignerERC7913Upgradeable.sol",
                      "contractName": "SignerERC7913Upgradeable"
                    },
                    {
                      "name": "SignerP256Upgradeable.sol",
                      "type": "file",
                      "path": "utils/cryptography/signers/SignerP256Upgradeable.sol",
                      "contractName": "SignerP256Upgradeable"
                    },
                    {
                      "name": "SignerRSAUpgradeable.sol",
                      "type": "file",
                      "path": "utils/cryptography/signers/SignerRSAUpgradeable.sol",
                      "contractName": "SignerRSAUpgradeable"
                    },
                    {
                      "name": "SignerWebAuthnUpgradeable.sol",
                      "type": "file",
                      "path": "utils/cryptography/signers/SignerWebAuthnUpgradeable.sol",
                      "contractName": "SignerWebAuthnUpgradeable"
                    },
                    {
                      "name": "draft-ERC7739Upgradeable.sol",
                      "type": "file",
                      "path": "utils/cryptography/signers/draft-ERC7739Upgradeable.sol",
                      "contractName": "ERC7739Upgradeable"
                    }
                  ]
                }
              ]
            },
            {
              "name": "introspection",
              "type": "directory",
              "path": "utils/introspection",
              "children": [
                {
                  "name": "ERC165Upgradeable.sol",
                  "type": "file",
                  "path": "utils/introspection/ERC165Upgradeable.sol",
                  "contractName": "ERC165Upgradeable"
                }
              ]
            }
          ]
        }
      ]
    },
    "contracts": [
      {
        "name": "AccessControlUpgradeable",
        "filePath": "access/AccessControlUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ContextUpgradeable",
          "IAccessControl",
          "ERC165Upgradeable"
        ],
        "implements": [],
        "category": "access",
        "externalFunctions": [
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "supportsInterface",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }",
            "startLine": 88
          },
          {
            "name": "hasRole",
            "signature": "hasRole(bytes32,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getAccessControlStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }",
            "startLine": 95
          },
          {
            "name": "getRoleAdmin",
            "signature": "getRoleAdmin(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getAccessControlStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }",
            "startLine": 124
          },
          {
            "name": "grantRole",
            "signature": "grantRole(bytes32,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_grantRole",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }",
            "startLine": 141
          },
          {
            "name": "revokeRole",
            "signature": "revokeRole(bytes32,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_revokeRole",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }",
            "startLine": 156
          },
          {
            "name": "renounceRole",
            "signature": "renounceRole(bytes32,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              },
              {
                "name": "callerConfirmation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_revokeRole",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }",
            "startLine": 176
          }
        ],
        "internalFunctions": [
          {
            "name": "_getAccessControlStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "AccessControlStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }",
            "startLine": 67
          },
          {
            "name": "__AccessControl_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __AccessControl_init() internal onlyInitializing {\n    }",
            "startLine": 82
          },
          {
            "name": "__AccessControl_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __AccessControl_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 85
          },
          {
            "name": "_checkRole",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_checkRole",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }",
            "startLine": 104
          },
          {
            "name": "_checkRole",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "hasRole",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }",
            "startLine": 112
          },
          {
            "name": "_setRoleAdmin",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              },
              {
                "name": "adminRole",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccessControlStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "getRoleAdmin",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }",
            "startLine": 189
          },
          {
            "name": "_grantRole",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getAccessControlStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "hasRole",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }",
            "startLine": 203
          },
          {
            "name": "_revokeRole",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getAccessControlStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "hasRole",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }",
            "startLine": 221
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "RoleData",
            "members": [
              {
                "name": "hasRole",
                "type": "mapping(address => bool)"
              },
              {
                "name": "adminRole",
                "type": "bytes32"
              }
            ],
            "startLine": 51
          },
          {
            "name": "AccessControlStorage",
            "members": [
              {
                "name": "_roles",
                "type": "mapping(bytes32 => RoleData)"
              }
            ],
            "startLine": 60
          }
        ],
        "stateVariables": [
          {
            "name": "DEFAULT_ADMIN_ROLE",
            "type": "bytes32",
            "visibility": "public",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 56
          },
          {
            "name": "AccessControlStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 65
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/access/IAccessControl.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../utils/ContextUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../utils/introspection/ERC165Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {ERC165Upgradeable} from \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc ERC165Upgradeable\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
      },
      {
        "name": "Ownable2StepUpgradeable",
        "filePath": "access/Ownable2StepUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "OwnableUpgradeable"
        ],
        "implements": [],
        "category": "access",
        "externalFunctions": [
          {
            "name": "pendingOwner",
            "signature": "pendingOwner()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getOwnable2StepStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function pendingOwner() public view virtual returns (address) {\n        Ownable2StepStorage storage $ = _getOwnable2StepStorage();\n        return $._pendingOwner;\n    }",
            "startLine": 51
          },
          {
            "name": "transferOwnership",
            "signature": "transferOwnership(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getOwnable2StepStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual override onlyOwner {\n        Ownable2StepStorage storage $ = _getOwnable2StepStorage();\n        $._pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }",
            "startLine": 62
          },
          {
            "name": "acceptOwnership",
            "signature": "acceptOwnership()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "pendingOwner",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_transferOwnership",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }",
            "startLine": 81
          }
        ],
        "internalFunctions": [
          {
            "name": "_getOwnable2StepStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "Ownable2StepStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getOwnable2StepStorage() private pure returns (Ownable2StepStorage storage $) {\n        assembly {\n            $.slot := Ownable2StepStorageLocation\n        }\n    }",
            "startLine": 35
          },
          {
            "name": "__Ownable2Step_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable2Step_init() internal onlyInitializing {\n    }",
            "startLine": 43
          },
          {
            "name": "__Ownable2Step_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable2Step_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 46
          },
          {
            "name": "_transferOwnership",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getOwnable2StepStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_transferOwnership",
                "type": "super",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOwnership(address newOwner) internal virtual override {\n        Ownable2StepStorage storage $ = _getOwnable2StepStorage();\n        delete $._pendingOwner;\n        super._transferOwnership(newOwner);\n    }",
            "startLine": 72
          }
        ],
        "events": [
          {
            "name": "OwnershipTransferStarted",
            "parameters": [
              {
                "name": "previousOwner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "newOwner",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 41
          }
        ],
        "errors": [],
        "structs": [
          {
            "name": "Ownable2StepStorage",
            "members": [
              {
                "name": "_pendingOwner",
                "type": "address"
              }
            ],
            "startLine": 28
          }
        ],
        "stateVariables": [
          {
            "name": "Ownable2StepStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 33
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./OwnableUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {OwnableUpgradeable} from \"./OwnableUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable2Step\n    struct Ownable2StepStorage {\n        address _pendingOwner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable2Step\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant Ownable2StepStorageLocation = 0x237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c00;\n\n    function _getOwnable2StepStorage() private pure returns (Ownable2StepStorage storage $) {\n        assembly {\n            $.slot := Ownable2StepStorageLocation\n        }\n    }\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    function __Ownable2Step_init() internal onlyInitializing {\n    }\n\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        Ownable2StepStorage storage $ = _getOwnable2StepStorage();\n        return $._pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     *\n     * Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        Ownable2StepStorage storage $ = _getOwnable2StepStorage();\n        $._pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        Ownable2StepStorage storage $ = _getOwnable2StepStorage();\n        delete $._pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
      },
      {
        "name": "OwnableUpgradeable",
        "filePath": "access/OwnableUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ContextUpgradeable"
        ],
        "implements": [],
        "category": "access",
        "externalFunctions": [
          {
            "name": "owner",
            "signature": "owner()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }",
            "startLine": 73
          },
          {
            "name": "renounceOwnership",
            "signature": "renounceOwnership()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
            "startLine": 94
          },
          {
            "name": "transferOwnership",
            "signature": "transferOwnership(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }",
            "startLine": 102
          }
        ],
        "internalFunctions": [
          {
            "name": "_getOwnableStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "OwnableStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }",
            "startLine": 30
          },
          {
            "name": "__Ownable_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }",
            "startLine": 51
          },
          {
            "name": "__Ownable_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }",
            "startLine": 55
          },
          {
            "name": "_checkOwner",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }",
            "startLine": 81
          },
          {
            "name": "_transferOwnership",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }",
            "startLine": 113
          }
        ],
        "events": [
          {
            "name": "OwnershipTransferred",
            "parameters": [
              {
                "name": "previousOwner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "newOwner",
                "type": "address",
                "indexed": true
              }
            ],
            "startLine": 46
          }
        ],
        "errors": [
          {
            "name": "OwnableUnauthorizedAccount",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "startLine": 39
          },
          {
            "name": "OwnableInvalidOwner",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "startLine": 44
          }
        ],
        "structs": [
          {
            "name": "OwnableStorage",
            "members": [
              {
                "name": "_owner",
                "type": "address"
              }
            ],
            "startLine": 23
          }
        ],
        "stateVariables": [
          {
            "name": "OwnableStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 28
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../utils/ContextUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      {
        "name": "AccessControlDefaultAdminRulesUpgradeable",
        "filePath": "access/extensions/AccessControlDefaultAdminRulesUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "IAccessControlDefaultAdminRules",
          "IERC5313",
          "AccessControlUpgradeable"
        ],
        "implements": [],
        "category": "access/extensions",
        "externalFunctions": [
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "supportsInterface",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlDefaultAdminRules).interfaceId || super.supportsInterface(interfaceId);\n    }",
            "startLine": 84
          },
          {
            "name": "owner",
            "signature": "owner()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "defaultAdmin",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address) {\n        return defaultAdmin();\n    }",
            "startLine": 89
          },
          {
            "name": "grantRole",
            "signature": "grantRole(bytes32,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "grantRole",
                "type": "super",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function grantRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControl) {\n        if (role == DEFAULT_ADMIN_ROLE) {\n            revert AccessControlEnforcedDefaultAdminRules();\n        }\n        super.grantRole(role, account);\n    }",
            "startLine": 100
          },
          {
            "name": "revokeRole",
            "signature": "revokeRole(bytes32,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "revokeRole",
                "type": "super",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function revokeRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControl) {\n        if (role == DEFAULT_ADMIN_ROLE) {\n            revert AccessControlEnforcedDefaultAdminRules();\n        }\n        super.revokeRole(role, account);\n    }",
            "startLine": 110
          },
          {
            "name": "renounceRole",
            "signature": "renounceRole(bytes32,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccessControlDefaultAdminRulesStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "defaultAdmin",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "pendingDefaultAdmin",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_isScheduleSet",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "renounceRole",
                "type": "super",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function renounceRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControl) {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        if (role == DEFAULT_ADMIN_ROLE && account == defaultAdmin()) {\n            (address newDefaultAdmin, uint48 schedule) = pendingDefaultAdmin();\n            if (newDefaultAdmin != address(0) || !_isScheduleSet(schedule) || !_hasSchedulePassed(schedule)) {\n                revert AccessControlEnforcedDefaultAdminDelay(schedule);\n            }\n            delete $._pendingDefaultAdminSchedule;\n        }\n        super.renounceRole(role, account);\n    }",
            "startLine": 130
          },
          {
            "name": "defaultAdmin",
            "signature": "defaultAdmin()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getAccessControlDefaultAdminRulesStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function defaultAdmin() public view virtual returns (address) {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        return $._currentDefaultAdmin;\n    }",
            "startLine": 186
          },
          {
            "name": "pendingDefaultAdmin",
            "signature": "pendingDefaultAdmin()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "newAdmin",
                "type": "address"
              },
              {
                "name": "schedule",
                "type": "uint48"
              }
            ],
            "calls": [
              {
                "target": "_getAccessControlDefaultAdminRulesStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function pendingDefaultAdmin() public view virtual returns (address newAdmin, uint48 schedule) {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        return ($._pendingDefaultAdmin, $._pendingDefaultAdminSchedule);\n    }",
            "startLine": 192
          },
          {
            "name": "defaultAdminDelay",
            "signature": "defaultAdminDelay()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint48"
              }
            ],
            "calls": [
              {
                "target": "_getAccessControlDefaultAdminRulesStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_isScheduleSet",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function defaultAdminDelay() public view virtual returns (uint48) {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        uint48 schedule = $._pendingDelaySchedule;\n        return (_isScheduleSet(schedule) && _hasSchedulePassed(schedule)) ? $._pendingDelay : $._currentDelay;\n    }",
            "startLine": 198
          },
          {
            "name": "pendingDefaultAdminDelay",
            "signature": "pendingDefaultAdminDelay()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "newDelay",
                "type": "uint48"
              },
              {
                "name": "schedule",
                "type": "uint48"
              }
            ],
            "calls": [
              {
                "target": "_getAccessControlDefaultAdminRulesStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_isScheduleSet",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function pendingDefaultAdminDelay() public view virtual returns (uint48 newDelay, uint48 schedule) {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        schedule = $._pendingDelaySchedule;\n        return (_isScheduleSet(schedule) && !_hasSchedulePassed(schedule)) ? ($._pendingDelay, schedule) : (0, 0);\n    }",
            "startLine": 205
          },
          {
            "name": "defaultAdminDelayIncreaseWait",
            "signature": "defaultAdminDelayIncreaseWait()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint48"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function defaultAdminDelayIncreaseWait() public view virtual returns (uint48) {\n        return 5 days;\n    }",
            "startLine": 212
          },
          {
            "name": "beginDefaultAdminTransfer",
            "signature": "beginDefaultAdminTransfer(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newAdmin",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_beginDefaultAdminTransfer",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function beginDefaultAdminTransfer(address newAdmin) public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _beginDefaultAdminTransfer(newAdmin);\n    }",
            "startLine": 221
          },
          {
            "name": "cancelDefaultAdminTransfer",
            "signature": "cancelDefaultAdminTransfer()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_cancelDefaultAdminTransfer",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function cancelDefaultAdminTransfer() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _cancelDefaultAdminTransfer();\n    }",
            "startLine": 237
          },
          {
            "name": "acceptDefaultAdminTransfer",
            "signature": "acceptDefaultAdminTransfer()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "pendingDefaultAdmin",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_acceptDefaultAdminTransfer",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function acceptDefaultAdminTransfer() public virtual {\n        (address newDefaultAdmin, ) = pendingDefaultAdmin();\n        if (_msgSender() != newDefaultAdmin) {\n            // Enforce newDefaultAdmin explicit acceptance.\n            revert AccessControlInvalidDefaultAdmin(_msgSender());\n        }\n        _acceptDefaultAdminTransfer();\n    }",
            "startLine": 251
          },
          {
            "name": "changeDefaultAdminDelay",
            "signature": "changeDefaultAdminDelay(uint48)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newDelay",
                "type": "uint48"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_changeDefaultAdminDelay",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function changeDefaultAdminDelay(uint48 newDelay) public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _changeDefaultAdminDelay(newDelay);\n    }",
            "startLine": 282
          },
          {
            "name": "rollbackDefaultAdminDelay",
            "signature": "rollbackDefaultAdminDelay()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_rollbackDefaultAdminDelay",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function rollbackDefaultAdminDelay() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _rollbackDefaultAdminDelay();\n    }",
            "startLine": 298
          }
        ],
        "internalFunctions": [
          {
            "name": "_getAccessControlDefaultAdminRulesStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "AccessControlDefaultAdminRulesStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getAccessControlDefaultAdminRulesStorage() private pure returns (AccessControlDefaultAdminRulesStorage storage $) {\n        assembly {\n            $.slot := AccessControlDefaultAdminRulesStorageLocation\n        }\n    }",
            "startLine": 61
          },
          {
            "name": "__AccessControlDefaultAdminRules_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialDelay",
                "type": "uint48"
              },
              {
                "name": "initialDefaultAdmin",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __AccessControlDefaultAdminRules_init(uint48 initialDelay, address initialDefaultAdmin) internal onlyInitializing {\n        __AccessControlDefaultAdminRules_init_unchained(initialDelay, initialDefaultAdmin);\n    }",
            "startLine": 70
          },
          {
            "name": "__AccessControlDefaultAdminRules_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialDelay",
                "type": "uint48"
              },
              {
                "name": "initialDefaultAdmin",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccessControlDefaultAdminRulesStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_grantRole",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __AccessControlDefaultAdminRules_init_unchained(uint48 initialDelay, address initialDefaultAdmin) internal onlyInitializing {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        if (initialDefaultAdmin == address(0)) {\n            revert AccessControlInvalidDefaultAdmin(address(0));\n        }\n        $._currentDelay = initialDelay;\n        _grantRole(DEFAULT_ADMIN_ROLE, initialDefaultAdmin);\n    }",
            "startLine": 74
          },
          {
            "name": "_grantRole",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getAccessControlDefaultAdminRulesStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "defaultAdmin",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_grantRole",
                "type": "super",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        if (role == DEFAULT_ADMIN_ROLE) {\n            if (defaultAdmin() != address(0)) {\n                revert AccessControlEnforcedDefaultAdminRules();\n            }\n            $._currentDefaultAdmin = account;\n        }\n        return super._grantRole(role, account);\n    }",
            "startLine": 151
          },
          {
            "name": "_revokeRole",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getAccessControlDefaultAdminRulesStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "defaultAdmin",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_revokeRole",
                "type": "super",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        if (role == DEFAULT_ADMIN_ROLE && account == defaultAdmin()) {\n            delete $._currentDefaultAdmin;\n        }\n        return super._revokeRole(role, account);\n    }",
            "startLine": 163
          },
          {
            "name": "_setRoleAdmin",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              },
              {
                "name": "adminRole",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setRoleAdmin",
                "type": "super",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual override {\n        if (role == DEFAULT_ADMIN_ROLE) {\n            revert AccessControlEnforcedDefaultAdminRules();\n        }\n        super._setRoleAdmin(role, adminRole);\n    }",
            "startLine": 174
          },
          {
            "name": "_beginDefaultAdminTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newAdmin",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "SafeCast.toUint48",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "defaultAdminDelay",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_setPendingDefaultAdmin",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _beginDefaultAdminTransfer(address newAdmin) internal virtual {\n        uint48 newSchedule = SafeCast.toUint48(block.timestamp) + defaultAdminDelay();\n        _setPendingDefaultAdmin(newAdmin, newSchedule);\n        emit DefaultAdminTransferScheduled(newAdmin, newSchedule);\n    }",
            "startLine": 230
          },
          {
            "name": "_cancelDefaultAdminTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_setPendingDefaultAdmin",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _cancelDefaultAdminTransfer() internal virtual {\n        _setPendingDefaultAdmin(address(0), 0);\n    }",
            "startLine": 246
          },
          {
            "name": "_acceptDefaultAdminTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccessControlDefaultAdminRulesStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "pendingDefaultAdmin",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_isScheduleSet",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_revokeRole",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "defaultAdmin",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_grantRole",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _acceptDefaultAdminTransfer() internal virtual {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        (address newAdmin, uint48 schedule) = pendingDefaultAdmin();\n        if (!_isScheduleSet(schedule) || !_hasSchedulePassed(schedule)) {\n            revert AccessControlEnforcedDefaultAdminDelay(schedule);\n        }\n        _revokeRole(DEFAULT_ADMIN_ROLE, defaultAdmin());\n        _grantRole(DEFAULT_ADMIN_ROLE, newAdmin);\n        delete $._pendingDefaultAdmin;\n        delete $._pendingDefaultAdminSchedule;\n    }",
            "startLine": 265
          },
          {
            "name": "_changeDefaultAdminDelay",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newDelay",
                "type": "uint48"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "SafeCast.toUint48",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "_delayChangeWait",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_setPendingDelay",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _changeDefaultAdminDelay(uint48 newDelay) internal virtual {\n        uint48 newSchedule = SafeCast.toUint48(block.timestamp) + _delayChangeWait(newDelay);\n        _setPendingDelay(newDelay, newSchedule);\n        emit DefaultAdminDelayChangeScheduled(newDelay, newSchedule);\n    }",
            "startLine": 291
          },
          {
            "name": "_rollbackDefaultAdminDelay",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_setPendingDelay",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _rollbackDefaultAdminDelay() internal virtual {\n        _setPendingDelay(0, 0);\n    }",
            "startLine": 307
          },
          {
            "name": "_delayChangeWait",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "newDelay",
                "type": "uint48"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint48"
              }
            ],
            "calls": [
              {
                "target": "defaultAdminDelay",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Math.min",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "defaultAdminDelayIncreaseWait",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _delayChangeWait(uint48 newDelay) internal view virtual returns (uint48) {\n        uint48 currentDelay = defaultAdminDelay();\n\n        // When increasing the delay, we schedule the delay change to occur after a period of \"new delay\" has passed, up\n        // to a maximum given by defaultAdminDelayIncreaseWait, by default 5 days. For example, if increasing from 1 day\n        // to 3 days, the new delay will come into effect after 3 days. If increasing from 1 day to 10 days, the new\n        // delay will come into effect after 5 days. The 5 day wait period is intended to be able to fix an error like\n        // using milliseconds instead of seconds.\n        //\n        // When decreasing the delay, we wait the difference between \"current delay\" and \"new delay\". This guarantees\n        // that an admin transfer cannot be made faster than \"current delay\" at the time the delay change is scheduled.\n        // For example, if decreasing from 10 days to 3 days, the new delay will come into effect after 7 days.\n        return\n            newDelay > currentDelay\n                ? uint48(Math.min(newDelay, defaultAdminDelayIncreaseWait())) // no need to safecast, both inputs are uint48\n                : currentDelay - newDelay;\n    }",
            "startLine": 320
          },
          {
            "name": "_setPendingDefaultAdmin",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newAdmin",
                "type": "address"
              },
              {
                "name": "newSchedule",
                "type": "uint48"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccessControlDefaultAdminRulesStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "pendingDefaultAdmin",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_isScheduleSet",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _setPendingDefaultAdmin(address newAdmin, uint48 newSchedule) private {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        (, uint48 oldSchedule) = pendingDefaultAdmin();\n\n        $._pendingDefaultAdmin = newAdmin;\n        $._pendingDefaultAdminSchedule = newSchedule;\n\n        // An `oldSchedule` from `pendingDefaultAdmin()` is only set if it hasn't been accepted.\n        if (_isScheduleSet(oldSchedule)) {\n            // Emit for implicit cancellations when another default admin was scheduled.\n            emit DefaultAdminTransferCanceled();\n        }\n    }",
            "startLine": 347
          },
          {
            "name": "_setPendingDelay",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newDelay",
                "type": "uint48"
              },
              {
                "name": "newSchedule",
                "type": "uint48"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccessControlDefaultAdminRulesStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_isScheduleSet",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _setPendingDelay(uint48 newDelay, uint48 newSchedule) private {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        uint48 oldSchedule = $._pendingDelaySchedule;\n\n        if (_isScheduleSet(oldSchedule)) {\n            if (_hasSchedulePassed(oldSchedule)) {\n                // Materialize a virtual delay\n                $._currentDelay = $._pendingDelay;\n            } else {\n                // Emit for implicit cancellations when another delay was scheduled.\n                emit DefaultAdminDelayChangeCanceled();\n            }\n        }\n\n        $._pendingDelay = newDelay;\n        $._pendingDelaySchedule = newSchedule;\n    }",
            "startLine": 366
          },
          {
            "name": "_isScheduleSet",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "schedule",
                "type": "uint48"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _isScheduleSet(uint48 schedule) private pure returns (bool) {\n        return schedule != 0;\n    }",
            "startLine": 391
          },
          {
            "name": "_hasSchedulePassed",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "schedule",
                "type": "uint48"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _hasSchedulePassed(uint48 schedule) private view returns (bool) {\n        return schedule < block.timestamp;\n    }",
            "startLine": 398
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "AccessControlDefaultAdminRulesStorage",
            "members": [
              {
                "name": "_pendingDefaultAdmin",
                "type": "address"
              },
              {
                "name": "_pendingDefaultAdminSchedule",
                "type": "uint48"
              },
              {
                "name": "_currentDelay",
                "type": "uint48"
              },
              {
                "name": "_currentDefaultAdmin",
                "type": "address"
              },
              {
                "name": "_pendingDelay",
                "type": "uint48"
              },
              {
                "name": "_pendingDelaySchedule",
                "type": "uint48"
              }
            ],
            "startLine": 45
          }
        ],
        "stateVariables": [
          {
            "name": "AccessControlDefaultAdminRulesStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 59
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/access/extensions/IAccessControlDefaultAdminRules.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../AccessControlUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/access/IAccessControl.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/math/SafeCast.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/math/Math.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/interfaces/IERC5313.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/introspection/IERC165.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (access/extensions/AccessControlDefaultAdminRules.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControlDefaultAdminRules} from \"@openzeppelin/contracts/access/extensions/IAccessControlDefaultAdminRules.sol\";\nimport {AccessControlUpgradeable} from \"../AccessControlUpgradeable.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC5313} from \"@openzeppelin/contracts/interfaces/IERC5313.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows specifying special rules to manage\n * the `DEFAULT_ADMIN_ROLE` holder, which is a sensitive role with special permissions\n * over other roles that may potentially have privileged rights in the system.\n *\n * If a specific role doesn't have an admin role assigned, the holder of the\n * `DEFAULT_ADMIN_ROLE` will have the ability to grant it and revoke it.\n *\n * This contract implements the following risk mitigations on top of {AccessControl}:\n *\n * * Only one account holds the `DEFAULT_ADMIN_ROLE` since deployment until it's potentially renounced.\n * * Enforces a 2-step process to transfer the `DEFAULT_ADMIN_ROLE` to another account.\n * * Enforces a configurable delay between the two steps, with the ability to cancel before the transfer is accepted.\n * * The delay can be changed by scheduling, see {changeDefaultAdminDelay}.\n * * Role transfers must wait at least one block after scheduling before it can be accepted.\n * * It is not possible to use another role to manage the `DEFAULT_ADMIN_ROLE`.\n *\n * Example usage:\n *\n * ```solidity\n * contract MyToken is AccessControlDefaultAdminRules {\n *   constructor() AccessControlDefaultAdminRules(\n *     3 days,\n *     msg.sender // Explicit initial `DEFAULT_ADMIN_ROLE` holder\n *    ) {}\n * }\n * ```\n */\nabstract contract AccessControlDefaultAdminRulesUpgradeable is Initializable, IAccessControlDefaultAdminRules, IERC5313, AccessControlUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControlDefaultAdminRules\n    struct AccessControlDefaultAdminRulesStorage {\n        // pending admin pair read/written together frequently\n        address _pendingDefaultAdmin;\n        uint48 _pendingDefaultAdminSchedule; // 0 == unset\n\n        uint48 _currentDelay;\n        address _currentDefaultAdmin;\n\n        // pending delay pair read/written together frequently\n        uint48 _pendingDelay;\n        uint48 _pendingDelaySchedule; // 0 == unset\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessControlDefaultAdminRules\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlDefaultAdminRulesStorageLocation = 0xeef3dac4538c82c8ace4063ab0acd2d15cdb5883aa1dff7c2673abb3d8698400;\n\n    function _getAccessControlDefaultAdminRulesStorage() private pure returns (AccessControlDefaultAdminRulesStorage storage $) {\n        assembly {\n            $.slot := AccessControlDefaultAdminRulesStorageLocation\n        }\n    }\n\n    /**\n     * @dev Sets the initial values for {defaultAdminDelay} and {defaultAdmin} address.\n     */\n    function __AccessControlDefaultAdminRules_init(uint48 initialDelay, address initialDefaultAdmin) internal onlyInitializing {\n        __AccessControlDefaultAdminRules_init_unchained(initialDelay, initialDefaultAdmin);\n    }\n\n    function __AccessControlDefaultAdminRules_init_unchained(uint48 initialDelay, address initialDefaultAdmin) internal onlyInitializing {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        if (initialDefaultAdmin == address(0)) {\n            revert AccessControlInvalidDefaultAdmin(address(0));\n        }\n        $._currentDelay = initialDelay;\n        _grantRole(DEFAULT_ADMIN_ROLE, initialDefaultAdmin);\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlDefaultAdminRules).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IERC5313\n    function owner() public view virtual returns (address) {\n        return defaultAdmin();\n    }\n\n    ///\n    /// Override AccessControl role management\n    ///\n\n    /**\n     * @dev See {AccessControl-grantRole}. Reverts for `DEFAULT_ADMIN_ROLE`.\n     */\n    function grantRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControl) {\n        if (role == DEFAULT_ADMIN_ROLE) {\n            revert AccessControlEnforcedDefaultAdminRules();\n        }\n        super.grantRole(role, account);\n    }\n\n    /**\n     * @dev See {AccessControl-revokeRole}. Reverts for `DEFAULT_ADMIN_ROLE`.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControl) {\n        if (role == DEFAULT_ADMIN_ROLE) {\n            revert AccessControlEnforcedDefaultAdminRules();\n        }\n        super.revokeRole(role, account);\n    }\n\n    /**\n     * @dev See {AccessControl-renounceRole}.\n     *\n     * For the `DEFAULT_ADMIN_ROLE`, it only allows renouncing in two steps by first calling\n     * {beginDefaultAdminTransfer} to the `address(0)`, so it's required that the {pendingDefaultAdmin} schedule\n     * has also passed when calling this function.\n     *\n     * After its execution, it will not be possible to call `onlyRole(DEFAULT_ADMIN_ROLE)` functions.\n     *\n     * NOTE: Renouncing `DEFAULT_ADMIN_ROLE` will leave the contract without a {defaultAdmin},\n     * thereby disabling any functionality that is only available for it, and the possibility of reassigning a\n     * non-administrated role.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControl) {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        if (role == DEFAULT_ADMIN_ROLE && account == defaultAdmin()) {\n            (address newDefaultAdmin, uint48 schedule) = pendingDefaultAdmin();\n            if (newDefaultAdmin != address(0) || !_isScheduleSet(schedule) || !_hasSchedulePassed(schedule)) {\n                revert AccessControlEnforcedDefaultAdminDelay(schedule);\n            }\n            delete $._pendingDefaultAdminSchedule;\n        }\n        super.renounceRole(role, account);\n    }\n\n    /**\n     * @dev See {AccessControl-_grantRole}.\n     *\n     * For `DEFAULT_ADMIN_ROLE`, it only allows granting if there isn't already a {defaultAdmin} or if the\n     * role has been previously renounced.\n     *\n     * NOTE: Exposing this function through another mechanism may make the `DEFAULT_ADMIN_ROLE`\n     * assignable again. Make sure to guarantee this is the expected behavior in your implementation.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        if (role == DEFAULT_ADMIN_ROLE) {\n            if (defaultAdmin() != address(0)) {\n                revert AccessControlEnforcedDefaultAdminRules();\n            }\n            $._currentDefaultAdmin = account;\n        }\n        return super._grantRole(role, account);\n    }\n\n    /// @inheritdoc AccessControlUpgradeable\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        if (role == DEFAULT_ADMIN_ROLE && account == defaultAdmin()) {\n            delete $._currentDefaultAdmin;\n        }\n        return super._revokeRole(role, account);\n    }\n\n    /**\n     * @dev See {AccessControl-_setRoleAdmin}. Reverts for `DEFAULT_ADMIN_ROLE`.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual override {\n        if (role == DEFAULT_ADMIN_ROLE) {\n            revert AccessControlEnforcedDefaultAdminRules();\n        }\n        super._setRoleAdmin(role, adminRole);\n    }\n\n    ///\n    /// AccessControlDefaultAdminRules accessors\n    ///\n\n    /// @inheritdoc IAccessControlDefaultAdminRules\n    function defaultAdmin() public view virtual returns (address) {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        return $._currentDefaultAdmin;\n    }\n\n    /// @inheritdoc IAccessControlDefaultAdminRules\n    function pendingDefaultAdmin() public view virtual returns (address newAdmin, uint48 schedule) {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        return ($._pendingDefaultAdmin, $._pendingDefaultAdminSchedule);\n    }\n\n    /// @inheritdoc IAccessControlDefaultAdminRules\n    function defaultAdminDelay() public view virtual returns (uint48) {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        uint48 schedule = $._pendingDelaySchedule;\n        return (_isScheduleSet(schedule) && _hasSchedulePassed(schedule)) ? $._pendingDelay : $._currentDelay;\n    }\n\n    /// @inheritdoc IAccessControlDefaultAdminRules\n    function pendingDefaultAdminDelay() public view virtual returns (uint48 newDelay, uint48 schedule) {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        schedule = $._pendingDelaySchedule;\n        return (_isScheduleSet(schedule) && !_hasSchedulePassed(schedule)) ? ($._pendingDelay, schedule) : (0, 0);\n    }\n\n    /// @inheritdoc IAccessControlDefaultAdminRules\n    function defaultAdminDelayIncreaseWait() public view virtual returns (uint48) {\n        return 5 days;\n    }\n\n    ///\n    /// AccessControlDefaultAdminRules public and internal setters for defaultAdmin/pendingDefaultAdmin\n    ///\n\n    /// @inheritdoc IAccessControlDefaultAdminRules\n    function beginDefaultAdminTransfer(address newAdmin) public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _beginDefaultAdminTransfer(newAdmin);\n    }\n\n    /**\n     * @dev See {beginDefaultAdminTransfer}.\n     *\n     * Internal function without access restriction.\n     */\n    function _beginDefaultAdminTransfer(address newAdmin) internal virtual {\n        uint48 newSchedule = SafeCast.toUint48(block.timestamp) + defaultAdminDelay();\n        _setPendingDefaultAdmin(newAdmin, newSchedule);\n        emit DefaultAdminTransferScheduled(newAdmin, newSchedule);\n    }\n\n    /// @inheritdoc IAccessControlDefaultAdminRules\n    function cancelDefaultAdminTransfer() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _cancelDefaultAdminTransfer();\n    }\n\n    /**\n     * @dev See {cancelDefaultAdminTransfer}.\n     *\n     * Internal function without access restriction.\n     */\n    function _cancelDefaultAdminTransfer() internal virtual {\n        _setPendingDefaultAdmin(address(0), 0);\n    }\n\n    /// @inheritdoc IAccessControlDefaultAdminRules\n    function acceptDefaultAdminTransfer() public virtual {\n        (address newDefaultAdmin, ) = pendingDefaultAdmin();\n        if (_msgSender() != newDefaultAdmin) {\n            // Enforce newDefaultAdmin explicit acceptance.\n            revert AccessControlInvalidDefaultAdmin(_msgSender());\n        }\n        _acceptDefaultAdminTransfer();\n    }\n\n    /**\n     * @dev See {acceptDefaultAdminTransfer}.\n     *\n     * Internal function without access restriction.\n     */\n    function _acceptDefaultAdminTransfer() internal virtual {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        (address newAdmin, uint48 schedule) = pendingDefaultAdmin();\n        if (!_isScheduleSet(schedule) || !_hasSchedulePassed(schedule)) {\n            revert AccessControlEnforcedDefaultAdminDelay(schedule);\n        }\n        _revokeRole(DEFAULT_ADMIN_ROLE, defaultAdmin());\n        _grantRole(DEFAULT_ADMIN_ROLE, newAdmin);\n        delete $._pendingDefaultAdmin;\n        delete $._pendingDefaultAdminSchedule;\n    }\n\n    ///\n    /// AccessControlDefaultAdminRules public and internal setters for defaultAdminDelay/pendingDefaultAdminDelay\n    ///\n\n    /// @inheritdoc IAccessControlDefaultAdminRules\n    function changeDefaultAdminDelay(uint48 newDelay) public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _changeDefaultAdminDelay(newDelay);\n    }\n\n    /**\n     * @dev See {changeDefaultAdminDelay}.\n     *\n     * Internal function without access restriction.\n     */\n    function _changeDefaultAdminDelay(uint48 newDelay) internal virtual {\n        uint48 newSchedule = SafeCast.toUint48(block.timestamp) + _delayChangeWait(newDelay);\n        _setPendingDelay(newDelay, newSchedule);\n        emit DefaultAdminDelayChangeScheduled(newDelay, newSchedule);\n    }\n\n    /// @inheritdoc IAccessControlDefaultAdminRules\n    function rollbackDefaultAdminDelay() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\n        _rollbackDefaultAdminDelay();\n    }\n\n    /**\n     * @dev See {rollbackDefaultAdminDelay}.\n     *\n     * Internal function without access restriction.\n     */\n    function _rollbackDefaultAdminDelay() internal virtual {\n        _setPendingDelay(0, 0);\n    }\n\n    /**\n     * @dev Returns the amount of seconds to wait after the `newDelay` will\n     * become the new {defaultAdminDelay}.\n     *\n     * The value returned guarantees that if the delay is reduced, it will go into effect\n     * after a wait that honors the previously set delay.\n     *\n     * See {defaultAdminDelayIncreaseWait}.\n     */\n    function _delayChangeWait(uint48 newDelay) internal view virtual returns (uint48) {\n        uint48 currentDelay = defaultAdminDelay();\n\n        // When increasing the delay, we schedule the delay change to occur after a period of \"new delay\" has passed, up\n        // to a maximum given by defaultAdminDelayIncreaseWait, by default 5 days. For example, if increasing from 1 day\n        // to 3 days, the new delay will come into effect after 3 days. If increasing from 1 day to 10 days, the new\n        // delay will come into effect after 5 days. The 5 day wait period is intended to be able to fix an error like\n        // using milliseconds instead of seconds.\n        //\n        // When decreasing the delay, we wait the difference between \"current delay\" and \"new delay\". This guarantees\n        // that an admin transfer cannot be made faster than \"current delay\" at the time the delay change is scheduled.\n        // For example, if decreasing from 10 days to 3 days, the new delay will come into effect after 7 days.\n        return\n            newDelay > currentDelay\n                ? uint48(Math.min(newDelay, defaultAdminDelayIncreaseWait())) // no need to safecast, both inputs are uint48\n                : currentDelay - newDelay;\n    }\n\n    ///\n    /// Private setters\n    ///\n\n    /**\n     * @dev Setter of the tuple for pending admin and its schedule.\n     *\n     * May emit a {DefaultAdminTransferCanceled} event.\n     */\n    function _setPendingDefaultAdmin(address newAdmin, uint48 newSchedule) private {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        (, uint48 oldSchedule) = pendingDefaultAdmin();\n\n        $._pendingDefaultAdmin = newAdmin;\n        $._pendingDefaultAdminSchedule = newSchedule;\n\n        // An `oldSchedule` from `pendingDefaultAdmin()` is only set if it hasn't been accepted.\n        if (_isScheduleSet(oldSchedule)) {\n            // Emit for implicit cancellations when another default admin was scheduled.\n            emit DefaultAdminTransferCanceled();\n        }\n    }\n\n    /**\n     * @dev Setter of the tuple for pending delay and its schedule.\n     *\n     * May emit a {DefaultAdminDelayChangeCanceled} event.\n     */\n    function _setPendingDelay(uint48 newDelay, uint48 newSchedule) private {\n        AccessControlDefaultAdminRulesStorage storage $ = _getAccessControlDefaultAdminRulesStorage();\n        uint48 oldSchedule = $._pendingDelaySchedule;\n\n        if (_isScheduleSet(oldSchedule)) {\n            if (_hasSchedulePassed(oldSchedule)) {\n                // Materialize a virtual delay\n                $._currentDelay = $._pendingDelay;\n            } else {\n                // Emit for implicit cancellations when another delay was scheduled.\n                emit DefaultAdminDelayChangeCanceled();\n            }\n        }\n\n        $._pendingDelay = newDelay;\n        $._pendingDelaySchedule = newSchedule;\n    }\n\n    ///\n    /// Private helpers\n    ///\n\n    /**\n     * @dev Defines if a `schedule` is considered set. For consistency purposes.\n     */\n    function _isScheduleSet(uint48 schedule) private pure returns (bool) {\n        return schedule != 0;\n    }\n\n    /**\n     * @dev Defines if a `schedule` is considered passed. For consistency purposes.\n     */\n    function _hasSchedulePassed(uint48 schedule) private view returns (bool) {\n        return schedule < block.timestamp;\n    }\n}\n"
      },
      {
        "name": "AccessControlEnumerableUpgradeable",
        "filePath": "access/extensions/AccessControlEnumerableUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "IAccessControlEnumerable",
          "AccessControlUpgradeable"
        ],
        "implements": [],
        "category": "access/extensions",
        "externalFunctions": [
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "supportsInterface",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }",
            "startLine": 38
          },
          {
            "name": "getRoleMember",
            "signature": "getRoleMember(bytes32,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getAccessControlEnumerableStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "EnumerableSet.at",
                "type": "library",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        AccessControlEnumerableStorage storage $ = _getAccessControlEnumerableStorage();\n        return $._roleMembers[role].at(index);\n    }",
            "startLine": 54
          },
          {
            "name": "getRoleMemberCount",
            "signature": "getRoleMemberCount(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getAccessControlEnumerableStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "EnumerableSet.length",
                "type": "library",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        AccessControlEnumerableStorage storage $ = _getAccessControlEnumerableStorage();\n        return $._roleMembers[role].length();\n    }",
            "startLine": 63
          },
          {
            "name": "getRoleMembers",
            "signature": "getRoleMembers(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address[]"
              }
            ],
            "calls": [
              {
                "target": "_getAccessControlEnumerableStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "EnumerableSet.values",
                "type": "library",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getRoleMembers(bytes32 role) public view virtual returns (address[] memory) {\n        AccessControlEnumerableStorage storage $ = _getAccessControlEnumerableStorage();\n        return $._roleMembers[role].values();\n    }",
            "startLine": 76
          }
        ],
        "internalFunctions": [
          {
            "name": "_getAccessControlEnumerableStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "AccessControlEnumerableStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getAccessControlEnumerableStorage() private pure returns (AccessControlEnumerableStorage storage $) {\n        assembly {\n            $.slot := AccessControlEnumerableStorageLocation\n        }\n    }",
            "startLine": 26
          },
          {
            "name": "__AccessControlEnumerable_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __AccessControlEnumerable_init() internal onlyInitializing {\n    }",
            "startLine": 32
          },
          {
            "name": "__AccessControlEnumerable_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 35
          },
          {
            "name": "_grantRole",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getAccessControlEnumerableStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_grantRole",
                "type": "super",
                "argCount": 2
              },
              {
                "target": "EnumerableSet.add",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        AccessControlEnumerableStorage storage $ = _getAccessControlEnumerableStorage();\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            $._roleMembers[role].add(account);\n        }\n        return granted;\n    }",
            "startLine": 84
          },
          {
            "name": "_revokeRole",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "role",
                "type": "bytes32"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getAccessControlEnumerableStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_revokeRole",
                "type": "super",
                "argCount": 2
              },
              {
                "target": "EnumerableSet.remove",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        AccessControlEnumerableStorage storage $ = _getAccessControlEnumerableStorage();\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            $._roleMembers[role].remove(account);\n        }\n        return revoked;\n    }",
            "startLine": 96
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "AccessControlEnumerableStorage",
            "members": [
              {
                "name": "_roleMembers",
                "type": "mapping(bytes32 => EnumerableSet.AddressSet)"
              }
            ],
            "startLine": 19
          }
        ],
        "stateVariables": [
          {
            "name": "AccessControlEnumerableStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 24
          }
        ],
        "usesLibraries": [
          "EnumerableSet"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../AccessControlUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/structs/EnumerableSet.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/introspection/IERC165.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (access/extensions/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.24;\n\nimport {IAccessControlEnumerable} from \"@openzeppelin/contracts/access/extensions/IAccessControlEnumerable.sol\";\nimport {AccessControlUpgradeable} from \"../AccessControlUpgradeable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerable, AccessControlUpgradeable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControlEnumerable\n    struct AccessControlEnumerableStorage {\n        mapping(bytes32 role => EnumerableSet.AddressSet) _roleMembers;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessControlEnumerable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlEnumerableStorageLocation = 0xc1f6fe24621ce81ec5827caf0253cadb74709b061630e6b55e82371705932000;\n\n    function _getAccessControlEnumerableStorage() private pure returns (AccessControlEnumerableStorage storage $) {\n        assembly {\n            $.slot := AccessControlEnumerableStorageLocation\n        }\n    }\n\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual returns (address) {\n        AccessControlEnumerableStorage storage $ = _getAccessControlEnumerableStorage();\n        return $._roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual returns (uint256) {\n        AccessControlEnumerableStorage storage $ = _getAccessControlEnumerableStorage();\n        return $._roleMembers[role].length();\n    }\n\n    /**\n     * @dev Return all accounts that have `role`\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function getRoleMembers(bytes32 role) public view virtual returns (address[] memory) {\n        AccessControlEnumerableStorage storage $ = _getAccessControlEnumerableStorage();\n        return $._roleMembers[role].values();\n    }\n\n    /**\n     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {\n        AccessControlEnumerableStorage storage $ = _getAccessControlEnumerableStorage();\n        bool granted = super._grantRole(role, account);\n        if (granted) {\n            $._roleMembers[role].add(account);\n        }\n        return granted;\n    }\n\n    /**\n     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {\n        AccessControlEnumerableStorage storage $ = _getAccessControlEnumerableStorage();\n        bool revoked = super._revokeRole(role, account);\n        if (revoked) {\n            $._roleMembers[role].remove(account);\n        }\n        return revoked;\n    }\n}\n"
      },
      {
        "name": "AccessManagedUpgradeable",
        "filePath": "access/manager/AccessManagedUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ContextUpgradeable",
          "IAccessManaged"
        ],
        "implements": [],
        "category": "access/manager",
        "externalFunctions": [
          {
            "name": "authority",
            "signature": "authority()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getAccessManagedStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function authority() public view virtual returns (address) {\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\n        return $._authority;\n    }",
            "startLine": 78
          },
          {
            "name": "setAuthority",
            "signature": "setAuthority(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newAuthority",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "authority",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_setAuthority",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setAuthority(address newAuthority) public virtual {\n        address caller = _msgSender();\n        if (caller != authority()) {\n            revert AccessManagedUnauthorized(caller);\n        }\n        if (newAuthority.code.length == 0) {\n            revert AccessManagedInvalidAuthority(newAuthority);\n        }\n        _setAuthority(newAuthority);\n    }",
            "startLine": 84
          },
          {
            "name": "isConsumingScheduledOp",
            "signature": "isConsumingScheduledOp()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes4"
              }
            ],
            "calls": [
              {
                "target": "_getAccessManagedStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function isConsumingScheduledOp() public view returns (bytes4) {\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\n        return $._consumingSchedule ? this.isConsumingScheduledOp.selector : bytes4(0);\n    }",
            "startLine": 96
          }
        ],
        "internalFunctions": [
          {
            "name": "_getAccessManagedStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "AccessManagedStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getAccessManagedStorage() private pure returns (AccessManagedStorage storage $) {\n        assembly {\n            $.slot := AccessManagedStorageLocation\n        }\n    }",
            "startLine": 31
          },
          {
            "name": "__AccessManaged_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialAuthority",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __AccessManaged_init(address initialAuthority) internal onlyInitializing {\n        __AccessManaged_init_unchained(initialAuthority);\n    }",
            "startLine": 40
          },
          {
            "name": "__AccessManaged_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialAuthority",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setAuthority",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __AccessManaged_init_unchained(address initialAuthority) internal onlyInitializing {\n        _setAuthority(initialAuthority);\n    }",
            "startLine": 44
          },
          {
            "name": "_setAuthority",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newAuthority",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccessManagedStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setAuthority(address newAuthority) internal virtual {\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\n        $._authority = newAuthority;\n        emit AuthorityUpdated(newAuthority);\n    }",
            "startLine": 105
          },
          {
            "name": "_checkCanCall",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "caller",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccessManagedStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "AuthorityUtils.canCallWithDelay",
                "type": "library",
                "argCount": 4
              },
              {
                "target": "authority",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "consumeScheduledOp",
                "type": "external",
                "targetType": "AccessManager",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkCanCall(address caller, bytes calldata data) internal virtual {\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\n        (bool immediate, uint32 delay) = AuthorityUtils.canCallWithDelay(\n            authority(),\n            caller,\n            address(this),\n            bytes4(data[0:4])\n        );\n        if (!immediate) {\n            if (delay > 0) {\n                $._consumingSchedule = true;\n                IAccessManager(authority()).consumeScheduledOp(caller, data);\n                $._consumingSchedule = false;\n            } else {\n                revert AccessManagedUnauthorized(caller);\n            }\n        }\n    }",
            "startLine": 115
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "AccessManagedStorage",
            "members": [
              {
                "name": "_authority",
                "type": "address"
              },
              {
                "name": "_consumingSchedule",
                "type": "bool"
              }
            ],
            "startLine": 22
          }
        ],
        "stateVariables": [
          {
            "name": "AccessManagedStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 29
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/access/manager/AuthorityUtils.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/access/manager/IAccessManager.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/access/manager/IAccessManaged.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../../utils/ContextUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/manager/AccessManaged.sol)\n\npragma solidity ^0.8.20;\n\nimport {AuthorityUtils} from \"@openzeppelin/contracts/access/manager/AuthorityUtils.sol\";\nimport {IAccessManager} from \"@openzeppelin/contracts/access/manager/IAccessManager.sol\";\nimport {IAccessManaged} from \"@openzeppelin/contracts/access/manager/IAccessManaged.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev This contract module makes available a {restricted} modifier. Functions decorated with this modifier will be\n * permissioned according to an \"authority\": a contract like {AccessManager} that follows the {IAuthority} interface,\n * implementing a policy that allows certain callers to access certain functions.\n *\n * IMPORTANT: The `restricted` modifier should never be used on `internal` functions, judiciously used in `public`\n * functions, and ideally only used in `external` functions. See {restricted}.\n */\nabstract contract AccessManagedUpgradeable is Initializable, ContextUpgradeable, IAccessManaged {\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessManaged\n    struct AccessManagedStorage {\n        address _authority;\n\n        bool _consumingSchedule;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessManaged\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessManagedStorageLocation = 0xf3177357ab46d8af007ab3fdb9af81da189e1068fefdc0073dca88a2cab40a00;\n\n    function _getAccessManagedStorage() private pure returns (AccessManagedStorage storage $) {\n        assembly {\n            $.slot := AccessManagedStorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the contract connected to an initial authority.\n     */\n    function __AccessManaged_init(address initialAuthority) internal onlyInitializing {\n        __AccessManaged_init_unchained(initialAuthority);\n    }\n\n    function __AccessManaged_init_unchained(address initialAuthority) internal onlyInitializing {\n        _setAuthority(initialAuthority);\n    }\n\n    /**\n     * @dev Restricts access to a function as defined by the connected Authority for this contract and the\n     * caller and selector of the function that entered the contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * In general, this modifier should only be used on `external` functions. It is okay to use it on `public`\n     * functions that are used as external entry points and are not called internally. Unless you know what you're\n     * doing, it should never be used on `internal` functions. Failure to follow these rules can have critical security\n     * implications! This is because the permissions are determined by the function that entered the contract, i.e. the\n     * function at the bottom of the call stack, and not the function where the modifier is visible in the source code.\n     * ====\n     *\n     * [WARNING]\n     * ====\n     * Avoid adding this modifier to the https://docs.soliditylang.org/en/v0.8.20/contracts.html#receive-ether-function[`receive()`]\n     * function or the https://docs.soliditylang.org/en/v0.8.20/contracts.html#fallback-function[`fallback()`]. These\n     * functions are the only execution paths where a function selector cannot be unambiguously determined from the calldata\n     * since the selector defaults to `0x00000000` in the `receive()` function and similarly in the `fallback()` function\n     * if no calldata is provided. (See {_checkCanCall}).\n     *\n     * The `receive()` function will always panic whereas the `fallback()` may panic depending on the calldata length.\n     * ====\n     */\n    modifier restricted() {\n        _checkCanCall(_msgSender(), _msgData());\n        _;\n    }\n\n    /// @inheritdoc IAccessManaged\n    function authority() public view virtual returns (address) {\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\n        return $._authority;\n    }\n\n    /// @inheritdoc IAccessManaged\n    function setAuthority(address newAuthority) public virtual {\n        address caller = _msgSender();\n        if (caller != authority()) {\n            revert AccessManagedUnauthorized(caller);\n        }\n        if (newAuthority.code.length == 0) {\n            revert AccessManagedInvalidAuthority(newAuthority);\n        }\n        _setAuthority(newAuthority);\n    }\n\n    /// @inheritdoc IAccessManaged\n    function isConsumingScheduledOp() public view returns (bytes4) {\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\n        return $._consumingSchedule ? this.isConsumingScheduledOp.selector : bytes4(0);\n    }\n\n    /**\n     * @dev Transfers control to a new authority. Internal function with no access restriction. Allows bypassing the\n     * permissions set by the current authority.\n     */\n    function _setAuthority(address newAuthority) internal virtual {\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\n        $._authority = newAuthority;\n        emit AuthorityUpdated(newAuthority);\n    }\n\n    /**\n     * @dev Reverts if the caller is not allowed to call the function identified by a selector. Panics if the calldata\n     * is less than 4 bytes long.\n     */\n    function _checkCanCall(address caller, bytes calldata data) internal virtual {\n        AccessManagedStorage storage $ = _getAccessManagedStorage();\n        (bool immediate, uint32 delay) = AuthorityUtils.canCallWithDelay(\n            authority(),\n            caller,\n            address(this),\n            bytes4(data[0:4])\n        );\n        if (!immediate) {\n            if (delay > 0) {\n                $._consumingSchedule = true;\n                IAccessManager(authority()).consumeScheduledOp(caller, data);\n                $._consumingSchedule = false;\n            } else {\n                revert AccessManagedUnauthorized(caller);\n            }\n        }\n    }\n}\n"
      },
      {
        "name": "AccessManagerUpgradeable",
        "filePath": "access/manager/AccessManagerUpgradeable.sol",
        "kind": "contract",
        "inherits": [
          "Initializable",
          "ContextUpgradeable",
          "MulticallUpgradeable",
          "IAccessManager"
        ],
        "implements": [],
        "category": "access/manager",
        "externalFunctions": [
          {
            "name": "initialize",
            "signature": "initialize(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialAdmin",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__AccessManager_init",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function initialize(address initialAdmin) public virtual initializer {\n        __AccessManager_init(initialAdmin);\n    }",
            "startLine": 142
          },
          {
            "name": "canCall",
            "signature": "canCall(address,address,bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "caller",
                "type": "address"
              },
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "selector",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "immediate",
                "type": "bool"
              },
              {
                "name": "delay",
                "type": "uint32"
              }
            ],
            "calls": [
              {
                "target": "isTargetClosed",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_isExecuting",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "getTargetFunctionRole",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "hasRole",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function canCall(\n        address caller,\n        address target,\n        bytes4 selector\n    ) public view virtual returns (bool immediate, uint32 delay) {\n        if (isTargetClosed(target)) {\n            return (false, 0);\n        } else if (caller == address(this)) {\n            // Caller is AccessManager, this means the call was sent through {execute} and it already checked\n            // permissions. We verify that the call \"identifier\", which is set during {execute}, is correct.\n            return (_isExecuting(target, selector), 0);\n        } else {\n            uint64 roleId = getTargetFunctionRole(target, selector);\n            (bool isMember, uint32 currentDelay) = hasRole(roleId, caller);\n            return isMember ? (currentDelay == 0, currentDelay) : (false, 0);\n        }\n    }",
            "startLine": 160
          },
          {
            "name": "expiration",
            "signature": "expiration()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint32"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function expiration() public view virtual returns (uint32) {\n        return 1 weeks;\n    }",
            "startLine": 179
          },
          {
            "name": "minSetback",
            "signature": "minSetback()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint32"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function minSetback() public view virtual returns (uint32) {\n        return 5 days;\n    }",
            "startLine": 184
          },
          {
            "name": "isTargetClosed",
            "signature": "isTargetClosed(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function isTargetClosed(address target) public view virtual returns (bool) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        return $._targets[target].closed;\n    }",
            "startLine": 189
          },
          {
            "name": "getTargetFunctionRole",
            "signature": "getTargetFunctionRole(address,bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "selector",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getTargetFunctionRole(address target, bytes4 selector) public view virtual returns (uint64) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        return $._targets[target].allowedRoles[selector];\n    }",
            "startLine": 195
          },
          {
            "name": "getTargetAdminDelay",
            "signature": "getTargetAdminDelay(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint32"
              }
            ],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Time.get",
                "type": "library",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getTargetAdminDelay(address target) public view virtual returns (uint32) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        return $._targets[target].adminDelay.get();\n    }",
            "startLine": 201
          },
          {
            "name": "getRoleAdmin",
            "signature": "getRoleAdmin(uint64)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "roleId",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getRoleAdmin(uint64 roleId) public view virtual returns (uint64) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        return $._roles[roleId].admin;\n    }",
            "startLine": 207
          },
          {
            "name": "getRoleGuardian",
            "signature": "getRoleGuardian(uint64)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "roleId",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getRoleGuardian(uint64 roleId) public view virtual returns (uint64) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        return $._roles[roleId].guardian;\n    }",
            "startLine": 213
          },
          {
            "name": "getRoleGrantDelay",
            "signature": "getRoleGrantDelay(uint64)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "roleId",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint32"
              }
            ],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Time.get",
                "type": "library",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getRoleGrantDelay(uint64 roleId) public view virtual returns (uint32) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        return $._roles[roleId].grantDelay.get();\n    }",
            "startLine": 219
          },
          {
            "name": "getAccess",
            "signature": "getAccess(uint64,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "roleId",
                "type": "uint64"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "since",
                "type": "uint48"
              },
              {
                "name": "currentDelay",
                "type": "uint32"
              },
              {
                "name": "pendingDelay",
                "type": "uint32"
              },
              {
                "name": "effect",
                "type": "uint48"
              }
            ],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Time.getFull",
                "type": "library",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getAccess(\n        uint64 roleId,\n        address account\n    ) public view virtual returns (uint48 since, uint32 currentDelay, uint32 pendingDelay, uint48 effect) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        Access storage access = $._roles[roleId].members[account];\n\n        since = access.since;\n        (currentDelay, pendingDelay, effect) = access.delay.getFull();\n\n        return (since, currentDelay, pendingDelay, effect);\n    }",
            "startLine": 225
          },
          {
            "name": "hasRole",
            "signature": "hasRole(uint64,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "roleId",
                "type": "uint64"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "isMember",
                "type": "bool"
              },
              {
                "name": "executionDelay",
                "type": "uint32"
              }
            ],
            "calls": [
              {
                "target": "getAccess",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "Time.timestamp",
                "type": "library",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function hasRole(\n        uint64 roleId,\n        address account\n    ) public view virtual returns (bool isMember, uint32 executionDelay) {\n        if (roleId == PUBLIC_ROLE) {\n            return (true, 0);\n        } else {\n            (uint48 hasRoleSince, uint32 currentDelay, , ) = getAccess(roleId, account);\n            return (hasRoleSince != 0 && hasRoleSince <= Time.timestamp(), currentDelay);\n        }\n    }",
            "startLine": 239
          },
          {
            "name": "labelRole",
            "signature": "labelRole(uint64,string)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "roleId",
                "type": "uint64"
              },
              {
                "name": "label",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function labelRole(uint64 roleId, string calldata label) public virtual onlyAuthorized {\n        if (roleId == ADMIN_ROLE || roleId == PUBLIC_ROLE) {\n            revert AccessManagerLockedRole(roleId);\n        }\n        emit RoleLabel(roleId, label);\n    }",
            "startLine": 253
          },
          {
            "name": "grantRole",
            "signature": "grantRole(uint64,address,uint32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "roleId",
                "type": "uint64"
              },
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "executionDelay",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_grantRole",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "getRoleGrantDelay",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function grantRole(uint64 roleId, address account, uint32 executionDelay) public virtual onlyAuthorized {\n        _grantRole(roleId, account, getRoleGrantDelay(roleId), executionDelay);\n    }",
            "startLine": 261
          },
          {
            "name": "revokeRole",
            "signature": "revokeRole(uint64,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "roleId",
                "type": "uint64"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_revokeRole",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function revokeRole(uint64 roleId, address account) public virtual onlyAuthorized {\n        _revokeRole(roleId, account);\n    }",
            "startLine": 266
          },
          {
            "name": "renounceRole",
            "signature": "renounceRole(uint64,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "roleId",
                "type": "uint64"
              },
              {
                "name": "callerConfirmation",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_revokeRole",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function renounceRole(uint64 roleId, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessManagerBadConfirmation();\n        }\n        _revokeRole(roleId, callerConfirmation);\n    }",
            "startLine": 271
          },
          {
            "name": "setRoleAdmin",
            "signature": "setRoleAdmin(uint64,uint64)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "roleId",
                "type": "uint64"
              },
              {
                "name": "admin",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setRoleAdmin",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setRoleAdmin(uint64 roleId, uint64 admin) public virtual onlyAuthorized {\n        _setRoleAdmin(roleId, admin);\n    }",
            "startLine": 279
          },
          {
            "name": "setRoleGuardian",
            "signature": "setRoleGuardian(uint64,uint64)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "roleId",
                "type": "uint64"
              },
              {
                "name": "guardian",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setRoleGuardian",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setRoleGuardian(uint64 roleId, uint64 guardian) public virtual onlyAuthorized {\n        _setRoleGuardian(roleId, guardian);\n    }",
            "startLine": 284
          },
          {
            "name": "setGrantDelay",
            "signature": "setGrantDelay(uint64,uint32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "roleId",
                "type": "uint64"
              },
              {
                "name": "newDelay",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setGrantDelay",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setGrantDelay(uint64 roleId, uint32 newDelay) public virtual onlyAuthorized {\n        _setGrantDelay(roleId, newDelay);\n    }",
            "startLine": 289
          },
          {
            "name": "setTargetFunctionRole",
            "signature": "setTargetFunctionRole(address,bytes4[],uint64)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "selectors",
                "type": "bytes4[]"
              },
              {
                "name": "roleId",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setTargetFunctionRole",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setTargetFunctionRole(\n        address target,\n        bytes4[] calldata selectors,\n        uint64 roleId\n    ) public virtual onlyAuthorized {\n        for (uint256 i = 0; i < selectors.length; ++i) {\n            _setTargetFunctionRole(target, selectors[i], roleId);\n        }\n    }",
            "startLine": 407
          },
          {
            "name": "setTargetAdminDelay",
            "signature": "setTargetAdminDelay(address,uint32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "newDelay",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setTargetAdminDelay",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setTargetAdminDelay(address target, uint32 newDelay) public virtual onlyAuthorized {\n        _setTargetAdminDelay(target, newDelay);\n    }",
            "startLine": 429
          },
          {
            "name": "setTargetClosed",
            "signature": "setTargetClosed(address,bool)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "closed",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setTargetClosed(address target, bool closed) public virtual onlyAuthorized {\n        _setTargetClosed(target, closed);\n    }",
            "startLine": 448
          },
          {
            "name": "getSchedule",
            "signature": "getSchedule(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint48"
              }
            ],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getSchedule(bytes32 id) public view virtual returns (uint48) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        uint48 timepoint = $._schedules[id].timepoint;\n        return _isExpired(timepoint) ? 0 : timepoint;\n    }",
            "startLine": 465
          },
          {
            "name": "getNonce",
            "signature": "getNonce(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint32"
              }
            ],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getNonce(bytes32 id) public view virtual returns (uint32) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        return $._schedules[id].nonce;\n    }",
            "startLine": 472
          },
          {
            "name": "schedule",
            "signature": "schedule(address,bytes,uint48)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "when",
                "type": "uint48"
              }
            ],
            "returnValues": [
              {
                "name": "operationId",
                "type": "bytes32"
              },
              {
                "name": "nonce",
                "type": "uint32"
              }
            ],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Time.timestamp",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "Math.max",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "hashOperation",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function schedule(\n        address target,\n        bytes calldata data,\n        uint48 when\n    ) public virtual returns (bytes32 operationId, uint32 nonce) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        address caller = _msgSender();\n\n        // Fetch restrictions that apply to the caller on the targeted function\n        (, uint32 setback) = _canCallExtended(caller, target, data);\n\n        uint48 minWhen = Time.timestamp() + setback;\n\n        // If call with delay is not authorized, or if requested timing is too soon, revert\n        if (setback == 0 || (when > 0 && when < minWhen)) {\n            revert AccessManagerUnauthorizedCall(caller, target, _checkSelector(data));\n        }\n\n        // Reuse variable due to stack too deep\n        when = uint48(Math.max(when, minWhen)); // cast is safe: both inputs are uint48\n\n        // If caller is authorised, schedule operation\n        operationId = hashOperation(caller, target, data);\n\n        _checkNotScheduled(operationId);\n\n        unchecked {\n            // It's not feasible to overflow the nonce in less than 1000 years\n            nonce = $._schedules[operationId].nonce + 1;\n        }\n        $._schedules[operationId].timepoint = when;\n        $._schedules[operationId].nonce = nonce;\n        emit OperationScheduled(operationId, nonce, when, caller, target, data);\n\n        // Using named return values because otherwise we get stack too deep\n    }",
            "startLine": 478
          },
          {
            "name": "execute",
            "signature": "execute(address,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint32"
              }
            ],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "hashOperation",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "getSchedule",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_consumeScheduledOp",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_hashExecutionId",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_checkSelector",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "Address.functionCallWithValue",
                "type": "library",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function execute(address target, bytes calldata data) public payable virtual returns (uint32) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        address caller = _msgSender();\n\n        // Fetch restrictions that apply to the caller on the targeted function\n        (bool immediate, uint32 setback) = _canCallExtended(caller, target, data);\n\n        // If call is not authorized, revert\n        if (!immediate && setback == 0) {\n            revert AccessManagerUnauthorizedCall(caller, target, _checkSelector(data));\n        }\n\n        bytes32 operationId = hashOperation(caller, target, data);\n        uint32 nonce;\n\n        // If caller is authorised, check operation was scheduled early enough\n        // Consume an available schedule even if there is no currently enforced delay\n        if (setback != 0 || getSchedule(operationId) != 0) {\n            nonce = _consumeScheduledOp(operationId);\n        }\n\n        // Mark the target and selector as authorised\n        bytes32 executionIdBefore = $._executionId;\n        $._executionId = _hashExecutionId(target, _checkSelector(data));\n\n        // Perform call\n        Address.functionCallWithValue(target, data, msg.value);\n\n        // Reset execute identifier\n        $._executionId = executionIdBefore;\n\n        return nonce;\n    }",
            "startLine": 532
          },
          {
            "name": "cancel",
            "signature": "cancel(address,address,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "caller",
                "type": "address"
              },
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint32"
              }
            ],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_checkSelector",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "hashOperation",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "hasRole",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "getRoleGuardian",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "getTargetFunctionRole",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function cancel(address caller, address target, bytes calldata data) public virtual returns (uint32) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        address msgsender = _msgSender();\n        bytes4 selector = _checkSelector(data);\n\n        bytes32 operationId = hashOperation(caller, target, data);\n        if ($._schedules[operationId].timepoint == 0) {\n            revert AccessManagerNotScheduled(operationId);\n        } else if (caller != msgsender) {\n            // calls can only be canceled by the account that scheduled them, a global admin, or by a guardian of the required role.\n            (bool isAdmin, ) = hasRole(ADMIN_ROLE, msgsender);\n            (bool isGuardian, ) = hasRole(getRoleGuardian(getTargetFunctionRole(target, selector)), msgsender);\n            if (!isAdmin && !isGuardian) {\n                revert AccessManagerUnauthorizedCancel(msgsender, caller, target, selector);\n            }\n        }\n\n        delete $._schedules[operationId].timepoint; // reset the timepoint, keep the nonce\n        uint32 nonce = $._schedules[operationId].nonce;\n        emit OperationCanceled(operationId, nonce);\n\n        return nonce;\n    }",
            "startLine": 567
          },
          {
            "name": "consumeScheduledOp",
            "signature": "consumeScheduledOp(address,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "caller",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "isConsumingScheduledOp",
                "type": "external",
                "targetType": "AccessManaged",
                "argCount": 0
              },
              {
                "target": "_consumeScheduledOp",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "hashOperation",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function consumeScheduledOp(address caller, bytes calldata data) public virtual {\n        address target = _msgSender();\n        if (IAccessManaged(target).isConsumingScheduledOp() != IAccessManaged.isConsumingScheduledOp.selector) {\n            revert AccessManagerUnauthorizedConsume(target);\n        }\n        _consumeScheduledOp(hashOperation(caller, target, data));\n    }",
            "startLine": 592
          },
          {
            "name": "hashOperation",
            "signature": "hashOperation(address,address,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "caller",
                "type": "address"
              },
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function hashOperation(address caller, address target, bytes calldata data) public view virtual returns (bytes32) {\n        return keccak256(abi.encode(caller, target, data));\n    }",
            "startLine": 625
          },
          {
            "name": "updateAuthority",
            "signature": "updateAuthority(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "newAuthority",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "setAuthority",
                "type": "external",
                "targetType": "AccessManaged",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function updateAuthority(address target, address newAuthority) public virtual onlyAuthorized {\n        IAccessManaged(target).setAuthority(newAuthority);\n    }",
            "startLine": 631
          }
        ],
        "internalFunctions": [
          {
            "name": "_getAccessManagerStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "AccessManagerStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getAccessManagerStorage() private pure returns (AccessManagerStorage storage $) {\n        assembly {\n            $.slot := AccessManagerStorageLocation\n        }\n    }",
            "startLine": 127
          },
          {
            "name": "__AccessManager_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialAdmin",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __AccessManager_init(address initialAdmin) internal onlyInitializing {\n        __AccessManager_init_unchained(initialAdmin);\n    }",
            "startLine": 145
          },
          {
            "name": "__AccessManager_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialAdmin",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_grantRole",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __AccessManager_init_unchained(address initialAdmin) internal onlyInitializing {\n        if (initialAdmin == address(0)) {\n            revert AccessManagerInvalidInitialAdmin(address(0));\n        }\n\n        // admin is active immediately and without any execution delay.\n        _grantRole(ADMIN_ROLE, initialAdmin, 0, 0);\n    }",
            "startLine": 149
          },
          {
            "name": "_grantRole",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "roleId",
                "type": "uint64"
              },
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "grantDelay",
                "type": "uint32"
              },
              {
                "name": "executionDelay",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Time.timestamp",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "Access",
                "type": "external",
                "argCount": 2
              },
              {
                "target": "Time.toDelay",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "Time.withUpdate",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _grantRole(\n        uint64 roleId,\n        address account,\n        uint32 grantDelay,\n        uint32 executionDelay\n    ) internal virtual returns (bool) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        if (roleId == PUBLIC_ROLE) {\n            revert AccessManagerLockedRole(roleId);\n        }\n\n        bool newMember = $._roles[roleId].members[account].since == 0;\n        uint48 since;\n\n        if (newMember) {\n            since = Time.timestamp() + grantDelay;\n            $._roles[roleId].members[account] = Access({since: since, delay: executionDelay.toDelay()});\n        } else {\n            // No setback here. Value can be reset by doing revoke + grant, effectively allowing the admin to perform\n            // any change to the execution delay within the duration of the role admin delay.\n            ($._roles[roleId].members[account].delay, since) = $._roles[roleId].members[account].delay.withUpdate(\n                executionDelay,\n                0\n            );\n        }\n\n        emit RoleGranted(roleId, account, executionDelay, since, newMember);\n        return newMember;\n    }",
            "startLine": 298
          },
          {
            "name": "_revokeRole",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "roleId",
                "type": "uint64"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _revokeRole(uint64 roleId, address account) internal virtual returns (bool) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        if (roleId == PUBLIC_ROLE) {\n            revert AccessManagerLockedRole(roleId);\n        }\n\n        if ($._roles[roleId].members[account].since == 0) {\n            return false;\n        }\n\n        delete $._roles[roleId].members[account];\n\n        emit RoleRevoked(roleId, account);\n        return true;\n    }",
            "startLine": 334
          },
          {
            "name": "_setRoleAdmin",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "roleId",
                "type": "uint64"
              },
              {
                "name": "admin",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setRoleAdmin(uint64 roleId, uint64 admin) internal virtual {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        if (roleId == ADMIN_ROLE || roleId == PUBLIC_ROLE) {\n            revert AccessManagerLockedRole(roleId);\n        }\n\n        $._roles[roleId].admin = admin;\n\n        emit RoleAdminChanged(roleId, admin);\n    }",
            "startLine": 358
          },
          {
            "name": "_setRoleGuardian",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "roleId",
                "type": "uint64"
              },
              {
                "name": "guardian",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setRoleGuardian(uint64 roleId, uint64 guardian) internal virtual {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        if (roleId == ADMIN_ROLE || roleId == PUBLIC_ROLE) {\n            revert AccessManagerLockedRole(roleId);\n        }\n\n        $._roles[roleId].guardian = guardian;\n\n        emit RoleGuardianChanged(roleId, guardian);\n    }",
            "startLine": 377
          },
          {
            "name": "_setGrantDelay",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "roleId",
                "type": "uint64"
              },
              {
                "name": "newDelay",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Time.withUpdate",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "minSetback",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setGrantDelay(uint64 roleId, uint32 newDelay) internal virtual {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        if (roleId == PUBLIC_ROLE) {\n            revert AccessManagerLockedRole(roleId);\n        }\n\n        uint48 effect;\n        ($._roles[roleId].grantDelay, effect) = $._roles[roleId].grantDelay.withUpdate(newDelay, minSetback());\n\n        emit RoleGrantDelayChanged(roleId, newDelay, effect);\n    }",
            "startLine": 393
          },
          {
            "name": "_setTargetFunctionRole",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "selector",
                "type": "bytes4"
              },
              {
                "name": "roleId",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setTargetFunctionRole(address target, bytes4 selector, uint64 roleId) internal virtual {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        $._targets[target].allowedRoles[selector] = roleId;\n        emit TargetFunctionRoleUpdated(target, selector, roleId);\n    }",
            "startLine": 422
          },
          {
            "name": "_setTargetAdminDelay",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "newDelay",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Time.withUpdate",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "minSetback",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setTargetAdminDelay(address target, uint32 newDelay) internal virtual {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        uint48 effect;\n        ($._targets[target].adminDelay, effect) = $._targets[target].adminDelay.withUpdate(newDelay, minSetback());\n\n        emit TargetAdminDelayUpdated(target, newDelay, effect);\n    }",
            "startLine": 438
          },
          {
            "name": "_setTargetClosed",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "closed",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setTargetClosed(address target, bool closed) internal virtual {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        $._targets[target].closed = closed;\n        emit TargetClosed(target, closed);\n    }",
            "startLine": 457
          },
          {
            "name": "_checkNotScheduled",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "operationId",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _checkNotScheduled(bytes32 operationId) private view {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        uint48 prevTimepoint = $._schedules[operationId].timepoint;\n        if (prevTimepoint != 0 && !_isExpired(prevTimepoint)) {\n            revert AccessManagerAlreadyScheduled(operationId);\n        }\n    }",
            "startLine": 520
          },
          {
            "name": "_consumeScheduledOp",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "operationId",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint32"
              }
            ],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Time.timestamp",
                "type": "library",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _consumeScheduledOp(bytes32 operationId) internal virtual returns (uint32) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        uint48 timepoint = $._schedules[operationId].timepoint;\n        uint32 nonce = $._schedules[operationId].nonce;\n\n        if (timepoint == 0) {\n            revert AccessManagerNotScheduled(operationId);\n        } else if (timepoint > Time.timestamp()) {\n            revert AccessManagerNotReady(operationId);\n        } else if (_isExpired(timepoint)) {\n            revert AccessManagerExpired(operationId);\n        }\n\n        delete $._schedules[operationId].timepoint; // reset the timepoint, keep the nonce\n        emit OperationExecuted(operationId, nonce);\n\n        return nonce;\n    }",
            "startLine": 605
          },
          {
            "name": "_checkAuthorized",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_canCallSelf",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_msgData",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_getAdminRestrictions",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_consumeScheduledOp",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "hashOperation",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _checkAuthorized() private {\n        address caller = _msgSender();\n        (bool immediate, uint32 delay) = _canCallSelf(caller, _msgData());\n        if (!immediate) {\n            if (delay == 0) {\n                (, uint64 requiredRole, ) = _getAdminRestrictions(_msgData());\n                revert AccessManagerUnauthorizedAccount(caller, requiredRole);\n            } else {\n                _consumeScheduledOp(hashOperation(caller, address(this), _msgData()));\n            }\n        }\n    }",
            "startLine": 641
          },
          {
            "name": "_getAdminRestrictions",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "adminRestricted",
                "type": "bool"
              },
              {
                "name": "roleAdminId",
                "type": "uint64"
              },
              {
                "name": "executionDelay",
                "type": "uint32"
              }
            ],
            "calls": [
              {
                "target": "_checkSelector",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "getTargetAdminDelay",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "getRoleAdmin",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "getTargetFunctionRole",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getAdminRestrictions(\n        bytes calldata data\n    ) private view returns (bool adminRestricted, uint64 roleAdminId, uint32 executionDelay) {\n        if (data.length < 4) {\n            return (false, 0, 0);\n        }\n\n        bytes4 selector = _checkSelector(data);\n\n        // Restricted to ADMIN with no delay beside any execution delay the caller may have\n        if (\n            selector == this.labelRole.selector ||\n            selector == this.setRoleAdmin.selector ||\n            selector == this.setRoleGuardian.selector ||\n            selector == this.setGrantDelay.selector ||\n            selector == this.setTargetAdminDelay.selector\n        ) {\n            return (true, ADMIN_ROLE, 0);\n        }\n\n        // Restricted to ADMIN with the admin delay corresponding to the target\n        if (\n            selector == this.updateAuthority.selector ||\n            selector == this.setTargetClosed.selector ||\n            selector == this.setTargetFunctionRole.selector\n        ) {\n            // First argument is a target.\n            address target = abi.decode(data[0x04:0x24], (address));\n            uint32 delay = getTargetAdminDelay(target);\n            return (true, ADMIN_ROLE, delay);\n        }\n\n        // Restricted to that role's admin with no delay beside any execution delay the caller may have.\n        if (selector == this.grantRole.selector || selector == this.revokeRole.selector) {\n            // First argument is a roleId.\n            uint64 roleId = abi.decode(data[0x04:0x24], (uint64));\n            return (true, getRoleAdmin(roleId), 0);\n        }\n\n        return (false, getTargetFunctionRole(address(this), selector), 0);\n    }",
            "startLine": 662
          },
          {
            "name": "_canCallExtended",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "caller",
                "type": "address"
              },
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "immediate",
                "type": "bool"
              },
              {
                "name": "delay",
                "type": "uint32"
              }
            ],
            "calls": [
              {
                "target": "_canCallSelf",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "canCall",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_checkSelector",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _canCallExtended(\n        address caller,\n        address target,\n        bytes calldata data\n    ) private view returns (bool immediate, uint32 delay) {\n        if (target == address(this)) {\n            return _canCallSelf(caller, data);\n        } else {\n            return data.length < 4 ? (false, 0) : canCall(caller, target, _checkSelector(data));\n        }\n    }",
            "startLine": 713
          },
          {
            "name": "_canCallSelf",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "caller",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "immediate",
                "type": "bool"
              },
              {
                "name": "delay",
                "type": "uint32"
              }
            ],
            "calls": [
              {
                "target": "_isExecuting",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_checkSelector",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_getAdminRestrictions",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "isTargetClosed",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "hasRole",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "Math.max",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _canCallSelf(address caller, bytes calldata data) private view returns (bool immediate, uint32 delay) {\n        if (data.length < 4) {\n            return (false, 0);\n        }\n\n        if (caller == address(this)) {\n            // Caller is AccessManager, this means the call was sent through {execute} and it already checked\n            // permissions. We verify that the call \"identifier\", which is set during {execute}, is correct.\n            return (_isExecuting(address(this), _checkSelector(data)), 0);\n        }\n\n        (bool adminRestricted, uint64 roleId, uint32 operationDelay) = _getAdminRestrictions(data);\n\n        // isTargetClosed apply to non-admin-restricted function\n        if (!adminRestricted && isTargetClosed(address(this))) {\n            return (false, 0);\n        }\n\n        (bool inRole, uint32 executionDelay) = hasRole(roleId, caller);\n        if (!inRole) {\n            return (false, 0);\n        }\n\n        // downcast is safe because both options are uint32\n        delay = uint32(Math.max(operationDelay, executionDelay));\n        return (delay == 0, delay);\n    }",
            "startLine": 728
          },
          {
            "name": "_isExecuting",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "selector",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getAccessManagerStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_hashExecutionId",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _isExecuting(address target, bytes4 selector) private view returns (bool) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        return $._executionId == _hashExecutionId(target, selector);\n    }",
            "startLine": 759
          },
          {
            "name": "_isExpired",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "timepoint",
                "type": "uint48"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "expiration",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Time.timestamp",
                "type": "library",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _isExpired(uint48 timepoint) private view returns (bool) {\n        return timepoint + expiration() <= Time.timestamp();\n    }",
            "startLine": 767
          },
          {
            "name": "_checkSelector",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes4"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _checkSelector(bytes calldata data) private pure returns (bytes4) {\n        return bytes4(data[0:4]);\n    }",
            "startLine": 774
          },
          {
            "name": "_hashExecutionId",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "selector",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "Hashes.efficientKeccak256",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _hashExecutionId(address target, bytes4 selector) private pure returns (bytes32) {\n        return Hashes.efficientKeccak256(bytes32(uint256(uint160(target))), selector);\n    }",
            "startLine": 781
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "TargetConfig",
            "members": [
              {
                "name": "allowedRoles",
                "type": "mapping(bytes4 => uint64)"
              },
              {
                "name": "adminDelay",
                "type": "Time.Delay"
              },
              {
                "name": "closed",
                "type": "bool"
              }
            ],
            "startLine": 67
          },
          {
            "name": "Access",
            "members": [
              {
                "name": "since",
                "type": "uint48"
              },
              {
                "name": "delay",
                "type": "Time.Delay"
              }
            ],
            "startLine": 74
          },
          {
            "name": "Role",
            "members": [
              {
                "name": "members",
                "type": "mapping(address => Access)"
              },
              {
                "name": "admin",
                "type": "uint64"
              },
              {
                "name": "guardian",
                "type": "uint64"
              },
              {
                "name": "grantDelay",
                "type": "Time.Delay"
              }
            ],
            "startLine": 83
          },
          {
            "name": "Schedule",
            "members": [
              {
                "name": "timepoint",
                "type": "uint48"
              },
              {
                "name": "nonce",
                "type": "uint32"
              }
            ],
            "startLine": 95
          },
          {
            "name": "AccessManagerStorage",
            "members": [
              {
                "name": "_targets",
                "type": "mapping(address => TargetConfig)"
              },
              {
                "name": "_roles",
                "type": "mapping(uint64 => Role)"
              },
              {
                "name": "_schedules",
                "type": "mapping(bytes32 => Schedule)"
              },
              {
                "name": "_executionId",
                "type": "bytes32"
              }
            ],
            "startLine": 114
          }
        ],
        "stateVariables": [
          {
            "name": "ADMIN_ROLE",
            "type": "uint64",
            "visibility": "public",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 106
          },
          {
            "name": "PUBLIC_ROLE",
            "type": "uint64",
            "visibility": "public",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 111
          },
          {
            "name": "AccessManagerStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 125
          }
        ],
        "usesLibraries": [
          "Time"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/access/manager/IAccessManager.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/access/manager/IAccessManaged.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/Address.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../../utils/ContextUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../../utils/MulticallUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/math/Math.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/types/Time.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/cryptography/Hashes.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (access/manager/AccessManager.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessManager} from \"@openzeppelin/contracts/access/manager/IAccessManager.sol\";\nimport {IAccessManaged} from \"@openzeppelin/contracts/access/manager/IAccessManaged.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {MulticallUpgradeable} from \"../../utils/MulticallUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Time} from \"@openzeppelin/contracts/utils/types/Time.sol\";\nimport {Hashes} from \"@openzeppelin/contracts/utils/cryptography/Hashes.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev AccessManager is a central contract to store the permissions of a system.\n *\n * A smart contract under the control of an AccessManager instance is known as a target, and will inherit from the\n * {AccessManaged} contract, be connected to this contract as its manager and implement the {AccessManaged-restricted}\n * modifier on a set of functions selected to be permissioned. Note that any function without this setup won't be\n * effectively restricted.\n *\n * The restriction rules for such functions are defined in terms of \"roles\" identified by an `uint64` and scoped\n * by target (`address`) and function selectors (`bytes4`). These roles are stored in this contract and can be\n * configured by admins (`ADMIN_ROLE` members) after a delay (see {getTargetAdminDelay}).\n *\n * For each target contract, admins can configure the following without any delay:\n *\n * * The target's {AccessManaged-authority} via {updateAuthority}.\n * * Close or open a target via {setTargetClosed} keeping the permissions intact.\n * * The roles that are allowed (or disallowed) to call a given function (identified by its selector) through {setTargetFunctionRole}.\n *\n * By default every address is member of the `PUBLIC_ROLE` and every target function is restricted to the `ADMIN_ROLE` until configured otherwise.\n * Additionally, each role has the following configuration options restricted to this manager's admins:\n *\n * * A role's admin role via {setRoleAdmin} who can grant or revoke roles.\n * * A role's guardian role via {setRoleGuardian} who's allowed to cancel operations.\n * * A delay in which a role takes effect after being granted through {setGrantDelay}.\n * * A delay of any target's admin action via {setTargetAdminDelay}.\n * * A role label for discoverability purposes with {labelRole}.\n *\n * Any account can be added and removed into any number of these roles by using the {grantRole} and {revokeRole} functions\n * restricted to each role's admin (see {getRoleAdmin}).\n *\n * Since all the permissions of the managed system can be modified by the admins of this instance, it is expected that\n * they will be highly secured (e.g., a multisig or a well-configured DAO).\n *\n * NOTE: This contract implements a form of the {IAuthority} interface, but {canCall} has additional return data so it\n * doesn't inherit `IAuthority`. It is however compatible with the `IAuthority` interface since the first 32 bytes of\n * the return data are a boolean as expected by that interface.\n *\n * NOTE: Systems that implement other access control mechanisms (for example using {Ownable}) can be paired with an\n * {AccessManager} by transferring permissions (ownership in the case of {Ownable}) directly to the {AccessManager}.\n * Users will be able to interact with these contracts through the {execute} function, following the access rules\n * registered in the {AccessManager}. Keep in mind that in that context, the msg.sender seen by restricted functions\n * will be {AccessManager} itself.\n *\n * WARNING: When granting permissions over an {Ownable} or {AccessControl} contract to an {AccessManager}, be very\n * mindful of the danger associated with functions such as {Ownable-renounceOwnership} or\n * {AccessControl-renounceRole}.\n */\ncontract AccessManagerUpgradeable is Initializable, ContextUpgradeable, MulticallUpgradeable, IAccessManager {\n    using Time for *;\n\n    // Structure that stores the details for a target contract.\n    struct TargetConfig {\n        mapping(bytes4 selector => uint64 roleId) allowedRoles;\n        Time.Delay adminDelay;\n        bool closed;\n    }\n\n    // Structure that stores the details for a role/account pair. This structure fits into a single slot.\n    struct Access {\n        // Timepoint at which the user gets the permission.\n        // If this is either 0 or in the future, then the role permission is not available.\n        uint48 since;\n        // Delay for execution. Only applies to restricted() / execute() calls.\n        Time.Delay delay;\n    }\n\n    // Structure that stores the details of a role.\n    struct Role {\n        // Members of the role.\n        mapping(address user => Access access) members;\n        // Admin who can grant or revoke permissions.\n        uint64 admin;\n        // Guardian who can cancel operations targeting functions that need this role.\n        uint64 guardian;\n        // Delay in which the role takes effect after being granted.\n        Time.Delay grantDelay;\n    }\n\n    // Structure that stores the details for a scheduled operation. This structure fits into a single slot.\n    struct Schedule {\n        // Moment at which the operation can be executed.\n        uint48 timepoint;\n        // Operation nonce to allow third-party contracts to identify the operation.\n        uint32 nonce;\n    }\n\n    /**\n     * @dev The identifier of the admin role. Required to perform most configuration operations including\n     * other roles' management and target restrictions.\n     */\n    uint64 public constant ADMIN_ROLE = type(uint64).min; // 0\n\n    /**\n     * @dev The identifier of the public role. Automatically granted to all addresses with no delay.\n     */\n    uint64 public constant PUBLIC_ROLE = type(uint64).max; // 2**64-1\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessManager\n    struct AccessManagerStorage {\n        mapping(address target => TargetConfig mode) _targets;\n        mapping(uint64 roleId => Role) _roles;\n        mapping(bytes32 operationId => Schedule) _schedules;\n\n        // Used to identify operations that are currently being executed via {execute}.\n        // This should be transient storage when supported by the EVM.\n        bytes32 _executionId;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessManager\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessManagerStorageLocation = 0x40c6c8c28789853c7efd823ab20824bbd71718a8a5915e855f6f288c9a26ad00;\n\n    function _getAccessManagerStorage() private pure returns (AccessManagerStorage storage $) {\n        assembly {\n            $.slot := AccessManagerStorageLocation\n        }\n    }\n\n    /**\n     * @dev Check that the caller is authorized to perform the operation.\n     * See {AccessManager} description for a detailed breakdown of the authorization logic.\n     */\n    modifier onlyAuthorized() {\n        _checkAuthorized();\n        _;\n    }\n\n    function initialize(address initialAdmin) public virtual initializer {\n        __AccessManager_init(initialAdmin);\n    }\n    function __AccessManager_init(address initialAdmin) internal onlyInitializing {\n        __AccessManager_init_unchained(initialAdmin);\n    }\n\n    function __AccessManager_init_unchained(address initialAdmin) internal onlyInitializing {\n        if (initialAdmin == address(0)) {\n            revert AccessManagerInvalidInitialAdmin(address(0));\n        }\n\n        // admin is active immediately and without any execution delay.\n        _grantRole(ADMIN_ROLE, initialAdmin, 0, 0);\n    }\n\n    // =================================================== GETTERS ====================================================\n    /// @inheritdoc IAccessManager\n    function canCall(\n        address caller,\n        address target,\n        bytes4 selector\n    ) public view virtual returns (bool immediate, uint32 delay) {\n        if (isTargetClosed(target)) {\n            return (false, 0);\n        } else if (caller == address(this)) {\n            // Caller is AccessManager, this means the call was sent through {execute} and it already checked\n            // permissions. We verify that the call \"identifier\", which is set during {execute}, is correct.\n            return (_isExecuting(target, selector), 0);\n        } else {\n            uint64 roleId = getTargetFunctionRole(target, selector);\n            (bool isMember, uint32 currentDelay) = hasRole(roleId, caller);\n            return isMember ? (currentDelay == 0, currentDelay) : (false, 0);\n        }\n    }\n\n    /// @inheritdoc IAccessManager\n    function expiration() public view virtual returns (uint32) {\n        return 1 weeks;\n    }\n\n    /// @inheritdoc IAccessManager\n    function minSetback() public view virtual returns (uint32) {\n        return 5 days;\n    }\n\n    /// @inheritdoc IAccessManager\n    function isTargetClosed(address target) public view virtual returns (bool) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        return $._targets[target].closed;\n    }\n\n    /// @inheritdoc IAccessManager\n    function getTargetFunctionRole(address target, bytes4 selector) public view virtual returns (uint64) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        return $._targets[target].allowedRoles[selector];\n    }\n\n    /// @inheritdoc IAccessManager\n    function getTargetAdminDelay(address target) public view virtual returns (uint32) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        return $._targets[target].adminDelay.get();\n    }\n\n    /// @inheritdoc IAccessManager\n    function getRoleAdmin(uint64 roleId) public view virtual returns (uint64) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        return $._roles[roleId].admin;\n    }\n\n    /// @inheritdoc IAccessManager\n    function getRoleGuardian(uint64 roleId) public view virtual returns (uint64) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        return $._roles[roleId].guardian;\n    }\n\n    /// @inheritdoc IAccessManager\n    function getRoleGrantDelay(uint64 roleId) public view virtual returns (uint32) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        return $._roles[roleId].grantDelay.get();\n    }\n\n    /// @inheritdoc IAccessManager\n    function getAccess(\n        uint64 roleId,\n        address account\n    ) public view virtual returns (uint48 since, uint32 currentDelay, uint32 pendingDelay, uint48 effect) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        Access storage access = $._roles[roleId].members[account];\n\n        since = access.since;\n        (currentDelay, pendingDelay, effect) = access.delay.getFull();\n\n        return (since, currentDelay, pendingDelay, effect);\n    }\n\n    /// @inheritdoc IAccessManager\n    function hasRole(\n        uint64 roleId,\n        address account\n    ) public view virtual returns (bool isMember, uint32 executionDelay) {\n        if (roleId == PUBLIC_ROLE) {\n            return (true, 0);\n        } else {\n            (uint48 hasRoleSince, uint32 currentDelay, , ) = getAccess(roleId, account);\n            return (hasRoleSince != 0 && hasRoleSince <= Time.timestamp(), currentDelay);\n        }\n    }\n\n    // =============================================== ROLE MANAGEMENT ===============================================\n    /// @inheritdoc IAccessManager\n    function labelRole(uint64 roleId, string calldata label) public virtual onlyAuthorized {\n        if (roleId == ADMIN_ROLE || roleId == PUBLIC_ROLE) {\n            revert AccessManagerLockedRole(roleId);\n        }\n        emit RoleLabel(roleId, label);\n    }\n\n    /// @inheritdoc IAccessManager\n    function grantRole(uint64 roleId, address account, uint32 executionDelay) public virtual onlyAuthorized {\n        _grantRole(roleId, account, getRoleGrantDelay(roleId), executionDelay);\n    }\n\n    /// @inheritdoc IAccessManager\n    function revokeRole(uint64 roleId, address account) public virtual onlyAuthorized {\n        _revokeRole(roleId, account);\n    }\n\n    /// @inheritdoc IAccessManager\n    function renounceRole(uint64 roleId, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessManagerBadConfirmation();\n        }\n        _revokeRole(roleId, callerConfirmation);\n    }\n\n    /// @inheritdoc IAccessManager\n    function setRoleAdmin(uint64 roleId, uint64 admin) public virtual onlyAuthorized {\n        _setRoleAdmin(roleId, admin);\n    }\n\n    /// @inheritdoc IAccessManager\n    function setRoleGuardian(uint64 roleId, uint64 guardian) public virtual onlyAuthorized {\n        _setRoleGuardian(roleId, guardian);\n    }\n\n    /// @inheritdoc IAccessManager\n    function setGrantDelay(uint64 roleId, uint32 newDelay) public virtual onlyAuthorized {\n        _setGrantDelay(roleId, newDelay);\n    }\n\n    /**\n     * @dev Internal version of {grantRole} without access control. Returns true if the role was newly granted.\n     *\n     * Emits a {RoleGranted} event.\n     */\n    function _grantRole(\n        uint64 roleId,\n        address account,\n        uint32 grantDelay,\n        uint32 executionDelay\n    ) internal virtual returns (bool) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        if (roleId == PUBLIC_ROLE) {\n            revert AccessManagerLockedRole(roleId);\n        }\n\n        bool newMember = $._roles[roleId].members[account].since == 0;\n        uint48 since;\n\n        if (newMember) {\n            since = Time.timestamp() + grantDelay;\n            $._roles[roleId].members[account] = Access({since: since, delay: executionDelay.toDelay()});\n        } else {\n            // No setback here. Value can be reset by doing revoke + grant, effectively allowing the admin to perform\n            // any change to the execution delay within the duration of the role admin delay.\n            ($._roles[roleId].members[account].delay, since) = $._roles[roleId].members[account].delay.withUpdate(\n                executionDelay,\n                0\n            );\n        }\n\n        emit RoleGranted(roleId, account, executionDelay, since, newMember);\n        return newMember;\n    }\n\n    /**\n     * @dev Internal version of {revokeRole} without access control. This logic is also used by {renounceRole}.\n     * Returns true if the role was previously granted.\n     *\n     * Emits a {RoleRevoked} event if the account had the role.\n     */\n    function _revokeRole(uint64 roleId, address account) internal virtual returns (bool) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        if (roleId == PUBLIC_ROLE) {\n            revert AccessManagerLockedRole(roleId);\n        }\n\n        if ($._roles[roleId].members[account].since == 0) {\n            return false;\n        }\n\n        delete $._roles[roleId].members[account];\n\n        emit RoleRevoked(roleId, account);\n        return true;\n    }\n\n    /**\n     * @dev Internal version of {setRoleAdmin} without access control.\n     *\n     * Emits a {RoleAdminChanged} event.\n     *\n     * NOTE: Setting the admin role as the `PUBLIC_ROLE` is allowed, but it will effectively allow\n     * anyone to set grant or revoke such role.\n     */\n    function _setRoleAdmin(uint64 roleId, uint64 admin) internal virtual {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        if (roleId == ADMIN_ROLE || roleId == PUBLIC_ROLE) {\n            revert AccessManagerLockedRole(roleId);\n        }\n\n        $._roles[roleId].admin = admin;\n\n        emit RoleAdminChanged(roleId, admin);\n    }\n\n    /**\n     * @dev Internal version of {setRoleGuardian} without access control.\n     *\n     * Emits a {RoleGuardianChanged} event.\n     *\n     * NOTE: Setting the guardian role as the `PUBLIC_ROLE` is allowed, but it will effectively allow\n     * anyone to cancel any scheduled operation for such role.\n     */\n    function _setRoleGuardian(uint64 roleId, uint64 guardian) internal virtual {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        if (roleId == ADMIN_ROLE || roleId == PUBLIC_ROLE) {\n            revert AccessManagerLockedRole(roleId);\n        }\n\n        $._roles[roleId].guardian = guardian;\n\n        emit RoleGuardianChanged(roleId, guardian);\n    }\n\n    /**\n     * @dev Internal version of {setGrantDelay} without access control.\n     *\n     * Emits a {RoleGrantDelayChanged} event.\n     */\n    function _setGrantDelay(uint64 roleId, uint32 newDelay) internal virtual {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        if (roleId == PUBLIC_ROLE) {\n            revert AccessManagerLockedRole(roleId);\n        }\n\n        uint48 effect;\n        ($._roles[roleId].grantDelay, effect) = $._roles[roleId].grantDelay.withUpdate(newDelay, minSetback());\n\n        emit RoleGrantDelayChanged(roleId, newDelay, effect);\n    }\n\n    // ============================================= FUNCTION MANAGEMENT ==============================================\n    /// @inheritdoc IAccessManager\n    function setTargetFunctionRole(\n        address target,\n        bytes4[] calldata selectors,\n        uint64 roleId\n    ) public virtual onlyAuthorized {\n        for (uint256 i = 0; i < selectors.length; ++i) {\n            _setTargetFunctionRole(target, selectors[i], roleId);\n        }\n    }\n\n    /**\n     * @dev Internal version of {setTargetFunctionRole} without access control.\n     *\n     * Emits a {TargetFunctionRoleUpdated} event.\n     */\n    function _setTargetFunctionRole(address target, bytes4 selector, uint64 roleId) internal virtual {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        $._targets[target].allowedRoles[selector] = roleId;\n        emit TargetFunctionRoleUpdated(target, selector, roleId);\n    }\n\n    /// @inheritdoc IAccessManager\n    function setTargetAdminDelay(address target, uint32 newDelay) public virtual onlyAuthorized {\n        _setTargetAdminDelay(target, newDelay);\n    }\n\n    /**\n     * @dev Internal version of {setTargetAdminDelay} without access control.\n     *\n     * Emits a {TargetAdminDelayUpdated} event.\n     */\n    function _setTargetAdminDelay(address target, uint32 newDelay) internal virtual {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        uint48 effect;\n        ($._targets[target].adminDelay, effect) = $._targets[target].adminDelay.withUpdate(newDelay, minSetback());\n\n        emit TargetAdminDelayUpdated(target, newDelay, effect);\n    }\n\n    // =============================================== MODE MANAGEMENT ================================================\n    /// @inheritdoc IAccessManager\n    function setTargetClosed(address target, bool closed) public virtual onlyAuthorized {\n        _setTargetClosed(target, closed);\n    }\n\n    /**\n     * @dev Set the closed flag for a contract. This is an internal setter with no access restrictions.\n     *\n     * Emits a {TargetClosed} event.\n     */\n    function _setTargetClosed(address target, bool closed) internal virtual {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        $._targets[target].closed = closed;\n        emit TargetClosed(target, closed);\n    }\n\n    // ============================================== DELAYED OPERATIONS ==============================================\n    /// @inheritdoc IAccessManager\n    function getSchedule(bytes32 id) public view virtual returns (uint48) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        uint48 timepoint = $._schedules[id].timepoint;\n        return _isExpired(timepoint) ? 0 : timepoint;\n    }\n\n    /// @inheritdoc IAccessManager\n    function getNonce(bytes32 id) public view virtual returns (uint32) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        return $._schedules[id].nonce;\n    }\n\n    /// @inheritdoc IAccessManager\n    function schedule(\n        address target,\n        bytes calldata data,\n        uint48 when\n    ) public virtual returns (bytes32 operationId, uint32 nonce) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        address caller = _msgSender();\n\n        // Fetch restrictions that apply to the caller on the targeted function\n        (, uint32 setback) = _canCallExtended(caller, target, data);\n\n        uint48 minWhen = Time.timestamp() + setback;\n\n        // If call with delay is not authorized, or if requested timing is too soon, revert\n        if (setback == 0 || (when > 0 && when < minWhen)) {\n            revert AccessManagerUnauthorizedCall(caller, target, _checkSelector(data));\n        }\n\n        // Reuse variable due to stack too deep\n        when = uint48(Math.max(when, minWhen)); // cast is safe: both inputs are uint48\n\n        // If caller is authorised, schedule operation\n        operationId = hashOperation(caller, target, data);\n\n        _checkNotScheduled(operationId);\n\n        unchecked {\n            // It's not feasible to overflow the nonce in less than 1000 years\n            nonce = $._schedules[operationId].nonce + 1;\n        }\n        $._schedules[operationId].timepoint = when;\n        $._schedules[operationId].nonce = nonce;\n        emit OperationScheduled(operationId, nonce, when, caller, target, data);\n\n        // Using named return values because otherwise we get stack too deep\n    }\n\n    /**\n     * @dev Reverts if the operation is currently scheduled and has not expired.\n     *\n     * NOTE: This function was introduced due to stack too deep errors in schedule.\n     */\n    function _checkNotScheduled(bytes32 operationId) private view {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        uint48 prevTimepoint = $._schedules[operationId].timepoint;\n        if (prevTimepoint != 0 && !_isExpired(prevTimepoint)) {\n            revert AccessManagerAlreadyScheduled(operationId);\n        }\n    }\n\n    /// @inheritdoc IAccessManager\n    // Reentrancy is not an issue because permissions are checked on msg.sender. Additionally,\n    // _consumeScheduledOp guarantees a scheduled operation is only executed once.\n    // slither-disable-next-line reentrancy-no-eth\n    function execute(address target, bytes calldata data) public payable virtual returns (uint32) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        address caller = _msgSender();\n\n        // Fetch restrictions that apply to the caller on the targeted function\n        (bool immediate, uint32 setback) = _canCallExtended(caller, target, data);\n\n        // If call is not authorized, revert\n        if (!immediate && setback == 0) {\n            revert AccessManagerUnauthorizedCall(caller, target, _checkSelector(data));\n        }\n\n        bytes32 operationId = hashOperation(caller, target, data);\n        uint32 nonce;\n\n        // If caller is authorised, check operation was scheduled early enough\n        // Consume an available schedule even if there is no currently enforced delay\n        if (setback != 0 || getSchedule(operationId) != 0) {\n            nonce = _consumeScheduledOp(operationId);\n        }\n\n        // Mark the target and selector as authorised\n        bytes32 executionIdBefore = $._executionId;\n        $._executionId = _hashExecutionId(target, _checkSelector(data));\n\n        // Perform call\n        Address.functionCallWithValue(target, data, msg.value);\n\n        // Reset execute identifier\n        $._executionId = executionIdBefore;\n\n        return nonce;\n    }\n\n    /// @inheritdoc IAccessManager\n    function cancel(address caller, address target, bytes calldata data) public virtual returns (uint32) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        address msgsender = _msgSender();\n        bytes4 selector = _checkSelector(data);\n\n        bytes32 operationId = hashOperation(caller, target, data);\n        if ($._schedules[operationId].timepoint == 0) {\n            revert AccessManagerNotScheduled(operationId);\n        } else if (caller != msgsender) {\n            // calls can only be canceled by the account that scheduled them, a global admin, or by a guardian of the required role.\n            (bool isAdmin, ) = hasRole(ADMIN_ROLE, msgsender);\n            (bool isGuardian, ) = hasRole(getRoleGuardian(getTargetFunctionRole(target, selector)), msgsender);\n            if (!isAdmin && !isGuardian) {\n                revert AccessManagerUnauthorizedCancel(msgsender, caller, target, selector);\n            }\n        }\n\n        delete $._schedules[operationId].timepoint; // reset the timepoint, keep the nonce\n        uint32 nonce = $._schedules[operationId].nonce;\n        emit OperationCanceled(operationId, nonce);\n\n        return nonce;\n    }\n\n    /// @inheritdoc IAccessManager\n    function consumeScheduledOp(address caller, bytes calldata data) public virtual {\n        address target = _msgSender();\n        if (IAccessManaged(target).isConsumingScheduledOp() != IAccessManaged.isConsumingScheduledOp.selector) {\n            revert AccessManagerUnauthorizedConsume(target);\n        }\n        _consumeScheduledOp(hashOperation(caller, target, data));\n    }\n\n    /**\n     * @dev Internal variant of {consumeScheduledOp} that operates on bytes32 operationId.\n     *\n     * Returns the nonce of the scheduled operation that is consumed.\n     */\n    function _consumeScheduledOp(bytes32 operationId) internal virtual returns (uint32) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        uint48 timepoint = $._schedules[operationId].timepoint;\n        uint32 nonce = $._schedules[operationId].nonce;\n\n        if (timepoint == 0) {\n            revert AccessManagerNotScheduled(operationId);\n        } else if (timepoint > Time.timestamp()) {\n            revert AccessManagerNotReady(operationId);\n        } else if (_isExpired(timepoint)) {\n            revert AccessManagerExpired(operationId);\n        }\n\n        delete $._schedules[operationId].timepoint; // reset the timepoint, keep the nonce\n        emit OperationExecuted(operationId, nonce);\n\n        return nonce;\n    }\n\n    /// @inheritdoc IAccessManager\n    function hashOperation(address caller, address target, bytes calldata data) public view virtual returns (bytes32) {\n        return keccak256(abi.encode(caller, target, data));\n    }\n\n    // ==================================================== OTHERS ====================================================\n    /// @inheritdoc IAccessManager\n    function updateAuthority(address target, address newAuthority) public virtual onlyAuthorized {\n        IAccessManaged(target).setAuthority(newAuthority);\n    }\n\n    // ================================================= ADMIN LOGIC ==================================================\n    /**\n     * @dev Check if the current call is authorized according to admin and roles logic.\n     *\n     * WARNING: Carefully review the considerations of {AccessManaged-restricted} since they apply to this modifier.\n     */\n    function _checkAuthorized() private {\n        address caller = _msgSender();\n        (bool immediate, uint32 delay) = _canCallSelf(caller, _msgData());\n        if (!immediate) {\n            if (delay == 0) {\n                (, uint64 requiredRole, ) = _getAdminRestrictions(_msgData());\n                revert AccessManagerUnauthorizedAccount(caller, requiredRole);\n            } else {\n                _consumeScheduledOp(hashOperation(caller, address(this), _msgData()));\n            }\n        }\n    }\n\n    /**\n     * @dev Get the admin restrictions of a given function call based on the function and arguments involved.\n     *\n     * Returns:\n     * - bool restricted: does this data match a restricted operation\n     * - uint64: which role is this operation restricted to\n     * - uint32: minimum delay to enforce for that operation (max between operation's delay and admin's execution delay)\n     */\n    function _getAdminRestrictions(\n        bytes calldata data\n    ) private view returns (bool adminRestricted, uint64 roleAdminId, uint32 executionDelay) {\n        if (data.length < 4) {\n            return (false, 0, 0);\n        }\n\n        bytes4 selector = _checkSelector(data);\n\n        // Restricted to ADMIN with no delay beside any execution delay the caller may have\n        if (\n            selector == this.labelRole.selector ||\n            selector == this.setRoleAdmin.selector ||\n            selector == this.setRoleGuardian.selector ||\n            selector == this.setGrantDelay.selector ||\n            selector == this.setTargetAdminDelay.selector\n        ) {\n            return (true, ADMIN_ROLE, 0);\n        }\n\n        // Restricted to ADMIN with the admin delay corresponding to the target\n        if (\n            selector == this.updateAuthority.selector ||\n            selector == this.setTargetClosed.selector ||\n            selector == this.setTargetFunctionRole.selector\n        ) {\n            // First argument is a target.\n            address target = abi.decode(data[0x04:0x24], (address));\n            uint32 delay = getTargetAdminDelay(target);\n            return (true, ADMIN_ROLE, delay);\n        }\n\n        // Restricted to that role's admin with no delay beside any execution delay the caller may have.\n        if (selector == this.grantRole.selector || selector == this.revokeRole.selector) {\n            // First argument is a roleId.\n            uint64 roleId = abi.decode(data[0x04:0x24], (uint64));\n            return (true, getRoleAdmin(roleId), 0);\n        }\n\n        return (false, getTargetFunctionRole(address(this), selector), 0);\n    }\n\n    // =================================================== HELPERS ====================================================\n    /**\n     * @dev An extended version of {canCall} for internal usage that checks {_canCallSelf}\n     * when the target is this contract.\n     *\n     * Returns:\n     * - bool immediate: whether the operation can be executed immediately (with no delay)\n     * - uint32 delay: the execution delay\n     */\n    function _canCallExtended(\n        address caller,\n        address target,\n        bytes calldata data\n    ) private view returns (bool immediate, uint32 delay) {\n        if (target == address(this)) {\n            return _canCallSelf(caller, data);\n        } else {\n            return data.length < 4 ? (false, 0) : canCall(caller, target, _checkSelector(data));\n        }\n    }\n\n    /**\n     * @dev A version of {canCall} that checks for restrictions in this contract.\n     */\n    function _canCallSelf(address caller, bytes calldata data) private view returns (bool immediate, uint32 delay) {\n        if (data.length < 4) {\n            return (false, 0);\n        }\n\n        if (caller == address(this)) {\n            // Caller is AccessManager, this means the call was sent through {execute} and it already checked\n            // permissions. We verify that the call \"identifier\", which is set during {execute}, is correct.\n            return (_isExecuting(address(this), _checkSelector(data)), 0);\n        }\n\n        (bool adminRestricted, uint64 roleId, uint32 operationDelay) = _getAdminRestrictions(data);\n\n        // isTargetClosed apply to non-admin-restricted function\n        if (!adminRestricted && isTargetClosed(address(this))) {\n            return (false, 0);\n        }\n\n        (bool inRole, uint32 executionDelay) = hasRole(roleId, caller);\n        if (!inRole) {\n            return (false, 0);\n        }\n\n        // downcast is safe because both options are uint32\n        delay = uint32(Math.max(operationDelay, executionDelay));\n        return (delay == 0, delay);\n    }\n\n    /**\n     * @dev Returns true if a call with `target` and `selector` is being executed via {executed}.\n     */\n    function _isExecuting(address target, bytes4 selector) private view returns (bool) {\n        AccessManagerStorage storage $ = _getAccessManagerStorage();\n        return $._executionId == _hashExecutionId(target, selector);\n    }\n\n    /**\n     * @dev Returns true if a schedule timepoint is past its expiration deadline.\n     */\n    function _isExpired(uint48 timepoint) private view returns (bool) {\n        return timepoint + expiration() <= Time.timestamp();\n    }\n\n    /**\n     * @dev Extracts the selector from calldata. Panics if data is not at least 4 bytes\n     */\n    function _checkSelector(bytes calldata data) private pure returns (bytes4) {\n        return bytes4(data[0:4]);\n    }\n\n    /**\n     * @dev Hashing function for execute protection\n     */\n    function _hashExecutionId(address target, bytes4 selector) private pure returns (bytes32) {\n        return Hashes.efficientKeccak256(bytes32(uint256(uint160(target))), selector);\n    }\n}\n"
      },
      {
        "name": "AccountERC7579HookedUpgradeable",
        "filePath": "account/extensions/draft-AccountERC7579HookedUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "AccountERC7579Upgradeable"
        ],
        "implements": [],
        "category": "account",
        "externalFunctions": [
          {
            "name": "accountId",
            "signature": "accountId()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function accountId() public view virtual override returns (string memory) {\n        // vendorname.accountname.semver\n        return \"@openzeppelin/contracts.AccountERC7579Hooked.v1.0.0\";\n    }",
            "startLine": 61
          },
          {
            "name": "hook",
            "signature": "hook()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getAccountERC7579HookedStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function hook() public view virtual returns (address) {\n        AccountERC7579HookedStorage storage $ = _getAccountERC7579HookedStorage();\n        return $._hook;\n    }",
            "startLine": 67
          },
          {
            "name": "supportsModule",
            "signature": "supportsModule(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "moduleTypeId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "supportsModule",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsModule(uint256 moduleTypeId) public view virtual override returns (bool) {\n        return moduleTypeId == MODULE_TYPE_HOOK || super.supportsModule(moduleTypeId);\n    }",
            "startLine": 73
          },
          {
            "name": "isModuleInstalled",
            "signature": "isModuleInstalled(uint256,address,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "moduleTypeId",
                "type": "uint256"
              },
              {
                "name": "module",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "hook",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "isModuleInstalled",
                "type": "super",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata data\n    ) public view virtual override returns (bool) {\n        return\n            (moduleTypeId == MODULE_TYPE_HOOK && module == hook()) ||\n            super.isModuleInstalled(moduleTypeId, module, data);\n    }",
            "startLine": 78
          }
        ],
        "internalFunctions": [
          {
            "name": "_getAccountERC7579HookedStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "AccountERC7579HookedStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getAccountERC7579HookedStorage() private pure returns (AccountERC7579HookedStorage storage $) {\n        assembly {\n            $.slot := AccountERC7579HookedStorageLocation\n        }\n    }",
            "startLine": 32
          },
          {
            "name": "__AccountERC7579Hooked_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __AccountERC7579Hooked_init() internal onlyInitializing {\n    }",
            "startLine": 55
          },
          {
            "name": "__AccountERC7579Hooked_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __AccountERC7579Hooked_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 58
          },
          {
            "name": "_installModule",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "moduleTypeId",
                "type": "uint256"
              },
              {
                "name": "module",
                "type": "address"
              },
              {
                "name": "initData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccountERC7579HookedStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_installModule",
                "type": "super",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes memory initData\n    ) internal virtual override withHook {\n        AccountERC7579HookedStorage storage $ = _getAccountERC7579HookedStorage();\n        if (moduleTypeId == MODULE_TYPE_HOOK) {\n            require($._hook == address(0), ERC7579HookModuleAlreadyPresent($._hook));\n            $._hook = module;\n        }\n        super._installModule(moduleTypeId, module, initData);\n    }",
            "startLine": 89
          },
          {
            "name": "_uninstallModule",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "moduleTypeId",
                "type": "uint256"
              },
              {
                "name": "module",
                "type": "address"
              },
              {
                "name": "deInitData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccountERC7579HookedStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "ERC7579Utils.ERC7579UninstalledModule",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "_uninstallModule",
                "type": "super",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes memory deInitData\n    ) internal virtual override withHook {\n        AccountERC7579HookedStorage storage $ = _getAccountERC7579HookedStorage();\n        if (moduleTypeId == MODULE_TYPE_HOOK) {\n            require($._hook == module, ERC7579Utils.ERC7579UninstalledModule(moduleTypeId, module));\n            $._hook = address(0);\n        }\n        super._uninstallModule(moduleTypeId, module, deInitData);\n    }",
            "startLine": 103
          },
          {
            "name": "_execute",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "mode",
                "type": "Mode"
              },
              {
                "name": "executionCalldata",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes[]"
              }
            ],
            "calls": [
              {
                "target": "_execute",
                "type": "super",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _execute(\n        Mode mode,\n        bytes calldata executionCalldata\n    ) internal virtual override withHook returns (bytes[] memory) {\n        return super._execute(mode, executionCalldata);\n    }",
            "startLine": 117
          },
          {
            "name": "_fallback",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "_fallback",
                "type": "super",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _fallback() internal virtual override withHook returns (bytes memory) {\n        return super._fallback();\n    }",
            "startLine": 125
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ERC7579HookModuleAlreadyPresent",
            "parameters": [
              {
                "name": "hook",
                "type": "address"
              }
            ],
            "startLine": 39
          }
        ],
        "structs": [
          {
            "name": "AccountERC7579HookedStorage",
            "members": [
              {
                "name": "_hook",
                "type": "address"
              }
            ],
            "startLine": 25
          }
        ],
        "stateVariables": [
          {
            "name": "AccountERC7579HookedStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 30
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/interfaces/draft-IERC7579.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/account/utils/draft-ERC7579Utils.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "./draft-AccountERC7579Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (account/extensions/draft-AccountERC7579Hooked.sol)\n\npragma solidity ^0.8.26;\n\nimport {IERC7579Hook, MODULE_TYPE_HOOK} from \"@openzeppelin/contracts/interfaces/draft-IERC7579.sol\";\nimport {ERC7579Utils, Mode} from \"@openzeppelin/contracts/account/utils/draft-ERC7579Utils.sol\";\nimport {AccountERC7579Upgradeable} from \"./draft-AccountERC7579Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccountERC7579} with support for a single hook module (type 4).\n *\n * If installed, this extension will call the hook module's {IERC7579Hook-preCheck} before executing any operation\n * with {_execute} (including {execute} and {executeFromExecutor} by default) and {IERC7579Hook-postCheck} thereafter.\n *\n * NOTE: Hook modules break the check-effect-interaction pattern. In particular, the {IERC7579Hook-preCheck} hook can\n * lead to potentially dangerous reentrancy. Using the `withHook()` modifier is safe if no effect is performed\n * before the preHook or after the postHook. That is the case on all functions here, but it may not be the case if\n * functions that have this modifier are overridden. Developers should be extremely careful when implementing hook\n * modules or further overriding functions that involve hooks.\n */\nabstract contract AccountERC7579HookedUpgradeable is Initializable, AccountERC7579Upgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccountERC7579Hooked\n    struct AccountERC7579HookedStorage {\n        address _hook;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccountERC7579Hooked\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccountERC7579HookedStorageLocation = 0x2b49b75317ffc1021ca7da4ca3423bf8403e18b223e63e6bc7abe8f39a5ed700;\n\n    function _getAccountERC7579HookedStorage() private pure returns (AccountERC7579HookedStorage storage $) {\n        assembly {\n            $.slot := AccountERC7579HookedStorageLocation\n        }\n    }\n\n    /// @dev A hook module is already present. This contract only supports one hook module.\n    error ERC7579HookModuleAlreadyPresent(address hook);\n\n    /**\n     * @dev Calls {IERC7579Hook-preCheck} before executing the modified function and {IERC7579Hook-postCheck}\n     * thereafter.\n     */\n    modifier withHook() {\n        address hook_ = hook();\n        bytes memory hookData;\n\n        // slither-disable-next-line reentrancy-no-eth\n        if (hook_ != address(0)) hookData = IERC7579Hook(hook_).preCheck(msg.sender, msg.value, msg.data);\n        _;\n        if (hook_ != address(0)) IERC7579Hook(hook_).postCheck(hookData);\n    }\n\n    function __AccountERC7579Hooked_init() internal onlyInitializing {\n    }\n\n    function __AccountERC7579Hooked_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc AccountERC7579Upgradeable\n    function accountId() public view virtual override returns (string memory) {\n        // vendorname.accountname.semver\n        return \"@openzeppelin/contracts.AccountERC7579Hooked.v1.0.0\";\n    }\n\n    /// @dev Returns the hook module address if installed, or `address(0)` otherwise.\n    function hook() public view virtual returns (address) {\n        AccountERC7579HookedStorage storage $ = _getAccountERC7579HookedStorage();\n        return $._hook;\n    }\n\n    /// @dev Supports hook modules. See {AccountERC7579-supportsModule}\n    function supportsModule(uint256 moduleTypeId) public view virtual override returns (bool) {\n        return moduleTypeId == MODULE_TYPE_HOOK || super.supportsModule(moduleTypeId);\n    }\n\n    /// @inheritdoc AccountERC7579Upgradeable\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata data\n    ) public view virtual override returns (bool) {\n        return\n            (moduleTypeId == MODULE_TYPE_HOOK && module == hook()) ||\n            super.isModuleInstalled(moduleTypeId, module, data);\n    }\n\n    /// @dev Installs a module with support for hook modules. See {AccountERC7579-_installModule}\n    function _installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes memory initData\n    ) internal virtual override withHook {\n        AccountERC7579HookedStorage storage $ = _getAccountERC7579HookedStorage();\n        if (moduleTypeId == MODULE_TYPE_HOOK) {\n            require($._hook == address(0), ERC7579HookModuleAlreadyPresent($._hook));\n            $._hook = module;\n        }\n        super._installModule(moduleTypeId, module, initData);\n    }\n\n    /// @dev Uninstalls a module with support for hook modules. See {AccountERC7579-_uninstallModule}\n    function _uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes memory deInitData\n    ) internal virtual override withHook {\n        AccountERC7579HookedStorage storage $ = _getAccountERC7579HookedStorage();\n        if (moduleTypeId == MODULE_TYPE_HOOK) {\n            require($._hook == module, ERC7579Utils.ERC7579UninstalledModule(moduleTypeId, module));\n            $._hook = address(0);\n        }\n        super._uninstallModule(moduleTypeId, module, deInitData);\n    }\n\n    /// @dev Hooked version of {AccountERC7579-_execute}.\n    function _execute(\n        Mode mode,\n        bytes calldata executionCalldata\n    ) internal virtual override withHook returns (bytes[] memory) {\n        return super._execute(mode, executionCalldata);\n    }\n\n    /// @dev Hooked version of {AccountERC7579-_fallback}.\n    function _fallback() internal virtual override withHook returns (bytes memory) {\n        return super._fallback();\n    }\n}\n"
      },
      {
        "name": "AccountERC7579Upgradeable",
        "filePath": "account/extensions/draft-AccountERC7579Upgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "Account",
          "IERC1271",
          "IERC7579Execution",
          "IERC7579AccountConfig",
          "IERC7579ModuleConfig"
        ],
        "implements": [],
        "category": "account",
        "externalFunctions": [
          {
            "name": "fallback",
            "signature": "fallback(bytes)",
            "selector": "",
            "visibility": "external",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "_fallback",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "fallback(bytes calldata) external payable virtual returns (bytes memory) {\n        return _fallback();\n    }",
            "startLine": 90
          },
          {
            "name": "accountId",
            "signature": "accountId()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function accountId() public view virtual returns (string memory) {\n        // vendorname.accountname.semver\n        return \"@openzeppelin/contracts.AccountERC7579.v1.0.0\";\n    }",
            "startLine": 95
          },
          {
            "name": "supportsExecutionMode",
            "signature": "supportsExecutionMode(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "encodedMode",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "Bytes.decodeMode",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "Mode.wrap",
                "type": "library",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsExecutionMode(bytes32 encodedMode) public view virtual returns (bool) {\n        (CallType callType, ExecType execType, , ) = Mode.wrap(encodedMode).decodeMode();\n        return\n            (callType == ERC7579Utils.CALLTYPE_SINGLE ||\n                callType == ERC7579Utils.CALLTYPE_BATCH ||\n                callType == ERC7579Utils.CALLTYPE_DELEGATECALL) &&\n            (execType == ERC7579Utils.EXECTYPE_DEFAULT || execType == ERC7579Utils.EXECTYPE_TRY);\n    }",
            "startLine": 112
          },
          {
            "name": "supportsModule",
            "signature": "supportsModule(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "moduleTypeId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsModule(uint256 moduleTypeId) public view virtual returns (bool) {\n        return\n            moduleTypeId == MODULE_TYPE_VALIDATOR ||\n            moduleTypeId == MODULE_TYPE_EXECUTOR ||\n            moduleTypeId == MODULE_TYPE_FALLBACK;\n    }",
            "startLine": 131
          },
          {
            "name": "installModule",
            "signature": "installModule(uint256,address,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "moduleTypeId",
                "type": "uint256"
              },
              {
                "name": "module",
                "type": "address"
              },
              {
                "name": "initData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_installModule",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    ) public virtual onlyEntryPointOrSelf {\n        _installModule(moduleTypeId, module, initData);\n    }",
            "startLine": 139
          },
          {
            "name": "uninstallModule",
            "signature": "uninstallModule(uint256,address,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "moduleTypeId",
                "type": "uint256"
              },
              {
                "name": "module",
                "type": "address"
              },
              {
                "name": "deInitData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_uninstallModule",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    ) public virtual onlyEntryPointOrSelf {\n        _uninstallModule(moduleTypeId, module, deInitData);\n    }",
            "startLine": 148
          },
          {
            "name": "isModuleInstalled",
            "signature": "isModuleInstalled(uint256,address,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "moduleTypeId",
                "type": "uint256"
              },
              {
                "name": "module",
                "type": "address"
              },
              {
                "name": "additionalContext",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getAccountERC7579Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Bytes.contains",
                "type": "library",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    ) public view virtual returns (bool) {\n        AccountERC7579Storage storage $ = _getAccountERC7579Storage();\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) return $._validators.contains(module);\n        if (moduleTypeId == MODULE_TYPE_EXECUTOR) return $._executors.contains(module);\n        if (moduleTypeId == MODULE_TYPE_FALLBACK)\n            // ERC-7579 requires this function to return bool, never revert. Check length to avoid out-of-bounds access.\n            return additionalContext.length > 3 && $._fallbacks[bytes4(additionalContext[0:4])] == module;\n        return false;\n    }",
            "startLine": 157
          },
          {
            "name": "execute",
            "signature": "execute(bytes32,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              },
              {
                "name": "executionCalldata",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_execute",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "Mode.wrap",
                "type": "library",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function execute(bytes32 mode, bytes calldata executionCalldata) public payable virtual onlyEntryPointOrSelf {\n        _execute(Mode.wrap(mode), executionCalldata);\n    }",
            "startLine": 172
          },
          {
            "name": "executeFromExecutor",
            "signature": "executeFromExecutor(bytes32,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "mode",
                "type": "bytes32"
              },
              {
                "name": "executionCalldata",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "returnData",
                "type": "bytes[]"
              }
            ],
            "calls": [
              {
                "target": "_execute",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "Mode.wrap",
                "type": "library",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function executeFromExecutor(\n        bytes32 mode,\n        bytes calldata executionCalldata\n    )\n        public\n        payable\n        virtual\n        onlyModule(MODULE_TYPE_EXECUTOR, Calldata.emptyBytes())\n        returns (bytes[] memory returnData)\n    {\n        return _execute(Mode.wrap(mode), executionCalldata);\n    }",
            "startLine": 177
          },
          {
            "name": "isValidSignature",
            "signature": "isValidSignature(bytes32,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes4"
              }
            ],
            "calls": [
              {
                "target": "_extractSignatureValidator",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "isModuleInstalled",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "Calldata.emptyBytes",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "isValidSignatureWithSender",
                "type": "external",
                "targetType": "ERC7579Validator",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function isValidSignature(bytes32 hash, bytes calldata signature) public view virtual returns (bytes4) {\n        // check signature length is enough for extraction\n        if (signature.length >= 20) {\n            (address module, bytes calldata innerSignature) = _extractSignatureValidator(signature);\n            // if module is not installed, skip\n            if (isModuleInstalled(MODULE_TYPE_VALIDATOR, module, Calldata.emptyBytes())) {\n                // try validation, skip any revert\n                try IERC7579Validator(module).isValidSignatureWithSender(msg.sender, hash, innerSignature) returns (\n                    bytes4 magic\n                ) {\n                    return magic;\n                } catch {}\n            }\n        }\n        return bytes4(0xffffffff);\n    }",
            "startLine": 197
          }
        ],
        "internalFunctions": [
          {
            "name": "_getAccountERC7579Storage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "AccountERC7579Storage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getAccountERC7579Storage() private pure returns (AccountERC7579Storage storage $) {\n        assembly {\n            $.slot := AccountERC7579StorageLocation\n        }\n    }",
            "startLine": 66
          },
          {
            "name": "__AccountERC7579_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __AccountERC7579_init() internal onlyInitializing {\n    }",
            "startLine": 84
          },
          {
            "name": "__AccountERC7579_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __AccountERC7579_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 87
          },
          {
            "name": "_validateUserOp",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "userOp",
                "type": "PackedUserOperation"
              },
              {
                "name": "userOpHash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_extractUserOpValidator",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "isModuleInstalled",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "Calldata.emptyBytes",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "validateUserOp",
                "type": "external",
                "targetType": "ERC7579Validator",
                "argCount": 2
              },
              {
                "target": "_signableUserOpHash",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_validateUserOp",
                "type": "super",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        bytes calldata signature\n    ) internal virtual override returns (uint256) {\n        address module = _extractUserOpValidator(userOp);\n        return\n            isModuleInstalled(MODULE_TYPE_VALIDATOR, module, Calldata.emptyBytes())\n                ? IERC7579Validator(module).validateUserOp(userOp, _signableUserOpHash(userOp, userOpHash))\n                : super._validateUserOp(userOp, userOpHash, signature);\n    }",
            "startLine": 221
          },
          {
            "name": "_execute",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "mode",
                "type": "Mode"
              },
              {
                "name": "executionCalldata",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "returnData",
                "type": "bytes[]"
              }
            ],
            "calls": [
              {
                "target": "Bytes.decodeMode",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "Bytes.execSingle",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "Bytes.execBatch",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "Bytes.execDelegateCall",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _execute(\n        Mode mode,\n        bytes calldata executionCalldata\n    ) internal virtual returns (bytes[] memory returnData) {\n        (CallType callType, ExecType execType, , ) = mode.decodeMode();\n        if (callType == ERC7579Utils.CALLTYPE_SINGLE) return executionCalldata.execSingle(execType);\n        if (callType == ERC7579Utils.CALLTYPE_BATCH) return executionCalldata.execBatch(execType);\n        if (callType == ERC7579Utils.CALLTYPE_DELEGATECALL) return executionCalldata.execDelegateCall(execType);\n        revert ERC7579Utils.ERC7579UnsupportedCallType(callType);\n    }",
            "startLine": 238
          },
          {
            "name": "_installModule",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "moduleTypeId",
                "type": "uint256"
              },
              {
                "name": "module",
                "type": "address"
              },
              {
                "name": "initData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccountERC7579Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "supportsModule",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "ERC7579Utils.ERC7579UnsupportedModuleType",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "isModuleType",
                "type": "external",
                "targetType": "ERC7579Module",
                "argCount": 1
              },
              {
                "target": "ERC7579Utils.ERC7579MismatchedModuleTypeId",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "Bytes.add",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "ERC7579Utils.ERC7579AlreadyInstalledModule",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "_decodeFallbackData",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "onInstall",
                "type": "external",
                "targetType": "ERC7579Module",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _installModule(uint256 moduleTypeId, address module, bytes memory initData) internal virtual {\n        AccountERC7579Storage storage $ = _getAccountERC7579Storage();\n        require(supportsModule(moduleTypeId), ERC7579Utils.ERC7579UnsupportedModuleType(moduleTypeId));\n        require(\n            IERC7579Module(module).isModuleType(moduleTypeId),\n            ERC7579Utils.ERC7579MismatchedModuleTypeId(moduleTypeId, module)\n        );\n\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            require($._validators.add(module), ERC7579Utils.ERC7579AlreadyInstalledModule(moduleTypeId, module));\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            require($._executors.add(module), ERC7579Utils.ERC7579AlreadyInstalledModule(moduleTypeId, module));\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            bytes4 selector;\n            (selector, initData) = _decodeFallbackData(initData);\n            require(\n                $._fallbacks[selector] == address(0),\n                ERC7579Utils.ERC7579AlreadyInstalledModule(moduleTypeId, module)\n            );\n            $._fallbacks[selector] = module;\n        }\n\n        IERC7579Module(module).onInstall(initData);\n        emit ModuleInstalled(moduleTypeId, module);\n    }",
            "startLine": 263
          },
          {
            "name": "_uninstallModule",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "moduleTypeId",
                "type": "uint256"
              },
              {
                "name": "module",
                "type": "address"
              },
              {
                "name": "deInitData",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getAccountERC7579Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "supportsModule",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "ERC7579Utils.ERC7579UnsupportedModuleType",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "Bytes.remove",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "ERC7579Utils.ERC7579UninstalledModule",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "_decodeFallbackData",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_fallbackHandler",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "LowLevelCall.callNoReturn",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _uninstallModule(uint256 moduleTypeId, address module, bytes memory deInitData) internal virtual {\n        AccountERC7579Storage storage $ = _getAccountERC7579Storage();\n        require(supportsModule(moduleTypeId), ERC7579Utils.ERC7579UnsupportedModuleType(moduleTypeId));\n\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            require($._validators.remove(module), ERC7579Utils.ERC7579UninstalledModule(moduleTypeId, module));\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            require($._executors.remove(module), ERC7579Utils.ERC7579UninstalledModule(moduleTypeId, module));\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            bytes4 selector;\n            (selector, deInitData) = _decodeFallbackData(deInitData);\n            require(\n                _fallbackHandler(selector) == module && module != address(0),\n                ERC7579Utils.ERC7579UninstalledModule(moduleTypeId, module)\n            );\n            delete $._fallbacks[selector];\n        }\n\n        // Ignores success purposely to avoid modules that revert on uninstall\n        LowLevelCall.callNoReturn(module, abi.encodeCall(IERC7579Module.onUninstall, (deInitData)));\n        emit ModuleUninstalled(moduleTypeId, module);\n    }",
            "startLine": 299
          },
          {
            "name": "_fallback",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "_fallbackHandler",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "ERC7579MissingFallbackHandler",
                "type": "external",
                "argCount": 1
              },
              {
                "target": "LowLevelCall.callNoReturn",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "LowLevelCall.returnData",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "LowLevelCall.bubbleRevert",
                "type": "library",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _fallback() internal virtual returns (bytes memory) {\n        address handler = _fallbackHandler(msg.sig);\n        require(handler != address(0), ERC7579MissingFallbackHandler(msg.sig));\n\n        // From https://eips.ethereum.org/EIPS/eip-7579#fallback[ERC-7579 specifications]:\n        // - MUST utilize ERC-2771 to add the original msg.sender to the calldata sent to the fallback handler\n        // - MUST use call to invoke the fallback handler\n        if (LowLevelCall.callNoReturn(handler, msg.value, abi.encodePacked(msg.data, msg.sender))) {\n            return LowLevelCall.returnData();\n        } else {\n            LowLevelCall.bubbleRevert();\n        }\n    }",
            "startLine": 330
          },
          {
            "name": "_fallbackHandler",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "selector",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getAccountERC7579Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _fallbackHandler(bytes4 selector) internal view virtual returns (address) {\n        AccountERC7579Storage storage $ = _getAccountERC7579Storage();\n        return $._fallbacks[selector];\n    }",
            "startLine": 345
          },
          {
            "name": "_checkModule",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "moduleTypeId",
                "type": "uint256"
              },
              {
                "name": "module",
                "type": "address"
              },
              {
                "name": "additionalContext",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "isModuleInstalled",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "ERC7579Utils.ERC7579UninstalledModule",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    ) internal view virtual {\n        require(\n            isModuleInstalled(moduleTypeId, module, additionalContext),\n            ERC7579Utils.ERC7579UninstalledModule(moduleTypeId, module)\n        );\n    }",
            "startLine": 351
          },
          {
            "name": "_extractUserOpValidator",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "userOp",
                "type": "PackedUserOperation"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "Bytes.extract_32_20",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _extractUserOpValidator(PackedUserOperation calldata userOp) internal pure virtual returns (address) {\n        return address(bytes32(userOp.nonce).extract_32_20(0));\n    }",
            "startLine": 380
          },
          {
            "name": "_extractSignatureValidator",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "module",
                "type": "address"
              },
              {
                "name": "innerSignature",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _extractSignatureValidator(\n        bytes calldata signature\n    ) internal pure virtual returns (address module, bytes calldata innerSignature) {\n        return (address(bytes20(signature)), signature[20:]);\n    }",
            "startLine": 404
          },
          {
            "name": "_decodeFallbackData",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "selector",
                "type": "bytes4"
              },
              {
                "name": "remaining",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "ERC7579CannotDecodeFallbackData",
                "type": "external",
                "argCount": 0
              },
              {
                "target": "Bytes.slice",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _decodeFallbackData(\n        bytes memory data\n    ) internal pure virtual returns (bytes4 selector, bytes memory remaining) {\n        require(data.length > 3, ERC7579CannotDecodeFallbackData());\n        return (bytes4(data), data.slice(4));\n    }",
            "startLine": 419
          },
          {
            "name": "_rawSignatureValidation",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "",
                "type": "bytes32"
              },
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _rawSignatureValidation(\n        bytes32 /*hash*/,\n        bytes calldata /*signature*/\n    ) internal view virtual override returns (bool) {\n        return false;\n    }",
            "startLine": 427
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ERC7579MissingFallbackHandler",
            "parameters": [
              {
                "name": "selector",
                "type": "bytes4"
              }
            ],
            "startLine": 73
          },
          {
            "name": "ERC7579CannotDecodeFallbackData",
            "parameters": [],
            "startLine": 76
          }
        ],
        "structs": [
          {
            "name": "AccountERC7579Storage",
            "members": [
              {
                "name": "_validators",
                "type": "EnumerableSet.AddressSet"
              },
              {
                "name": "_executors",
                "type": "EnumerableSet.AddressSet"
              },
              {
                "name": "_fallbacks",
                "type": "mapping(bytes4 => address)"
              }
            ],
            "startLine": 57
          }
        ],
        "stateVariables": [
          {
            "name": "AccountERC7579StorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 64
          }
        ],
        "usesLibraries": [
          "Bytes",
          "ERC7579Utils",
          "EnumerableSet",
          "Packing"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/interfaces/draft-IERC4337.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/interfaces/IERC1271.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/interfaces/draft-IERC7579.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/account/utils/draft-ERC7579Utils.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/structs/EnumerableSet.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/LowLevelCall.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/Bytes.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/Packing.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/Calldata.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/account/Account.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (account/extensions/draft-AccountERC7579.sol)\n\npragma solidity ^0.8.26;\n\nimport {PackedUserOperation} from \"@openzeppelin/contracts/interfaces/draft-IERC4337.sol\";\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {IERC7579Module, IERC7579Validator, IERC7579Execution, IERC7579AccountConfig, IERC7579ModuleConfig, MODULE_TYPE_VALIDATOR, MODULE_TYPE_EXECUTOR, MODULE_TYPE_FALLBACK} from \"@openzeppelin/contracts/interfaces/draft-IERC7579.sol\";\nimport {ERC7579Utils, Mode, CallType, ExecType} from \"@openzeppelin/contracts/account/utils/draft-ERC7579Utils.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {LowLevelCall} from \"@openzeppelin/contracts/utils/LowLevelCall.sol\";\nimport {Bytes} from \"@openzeppelin/contracts/utils/Bytes.sol\";\nimport {Packing} from \"@openzeppelin/contracts/utils/Packing.sol\";\nimport {Calldata} from \"@openzeppelin/contracts/utils/Calldata.sol\";\nimport {Account} from \"@openzeppelin/contracts/account/Account.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Account} that implements support for ERC-7579 modules.\n *\n * To comply with the ERC-1271 support requirement, this contract defers signature validation to\n * installed validator modules by calling {IERC7579Validator-isValidSignatureWithSender}.\n *\n * This contract does not implement validation logic for user operations since this functionality\n * is often delegated to self-contained validation modules. Developers must install a validator module\n * upon initialization (or any other mechanism to enable execution from the account):\n *\n * ```solidity\n * contract MyAccountERC7579 is AccountERC7579, Initializable {\n *   function initializeAccount(address validator, bytes calldata validatorData) public initializer {\n *     _installModule(MODULE_TYPE_VALIDATOR, validator, validatorData);\n *   }\n * }\n * ```\n *\n * [NOTE]\n * ====\n * * Hook support is not included. See {AccountERC7579Hooked} for a version that hooks to execution.\n * * Validator selection, when verifying either ERC-1271 signature or ERC-4337 UserOperation is implemented in\n *   internal virtual functions {_extractUserOpValidator} and {_extractSignatureValidator}. Both are implemented\n *   following common practices. However, this part is not standardized in ERC-7579 (or in any follow-up ERC). Some\n *   accounts may want to override these internal functions.\n * * When combined with {ERC7739}, resolution ordering of {isValidSignature} may have an impact ({ERC7739} does not\n *   call super). Manual resolution might be necessary.\n * * Static calls (using callType `0xfe`) are currently NOT supported.\n * ====\n *\n * WARNING: Removing all validator modules will render the account inoperable, as no user operations can be validated thereafter.\n */\nabstract contract AccountERC7579Upgradeable is Initializable, Account, IERC1271, IERC7579Execution, IERC7579AccountConfig, IERC7579ModuleConfig {\n    using Bytes for *;\n    using ERC7579Utils for *;\n    using EnumerableSet for *;\n    using Packing for bytes32;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccountERC7579\n    struct AccountERC7579Storage {\n        EnumerableSet.AddressSet _validators;\n        EnumerableSet.AddressSet _executors;\n        mapping(bytes4 selector => address) _fallbacks;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccountERC7579\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccountERC7579StorageLocation = 0x0a47d913d72b2639f4ca1c145cc07ddf7170b73b257c8e0d4fced7cc8e3e3900;\n\n    function _getAccountERC7579Storage() private pure returns (AccountERC7579Storage storage $) {\n        assembly {\n            $.slot := AccountERC7579StorageLocation\n        }\n    }\n\n    /// @dev The account's {fallback} was called with a selector that doesn't have an installed handler.\n    error ERC7579MissingFallbackHandler(bytes4 selector);\n\n    /// @dev The provided initData/deInitData for a fallback module is too short to extract a selector.\n    error ERC7579CannotDecodeFallbackData();\n\n    /// @dev Modifier that checks if the caller is an installed module of the given type.\n    modifier onlyModule(uint256 moduleTypeId, bytes calldata additionalContext) {\n        _checkModule(moduleTypeId, msg.sender, additionalContext);\n        _;\n    }\n\n    function __AccountERC7579_init() internal onlyInitializing {\n    }\n\n    function __AccountERC7579_init_unchained() internal onlyInitializing {\n    }\n    /// @dev See {_fallback}.\n    fallback(bytes calldata) external payable virtual returns (bytes memory) {\n        return _fallback();\n    }\n\n    /// @inheritdoc IERC7579AccountConfig\n    function accountId() public view virtual returns (string memory) {\n        // vendorname.accountname.semver\n        return \"@openzeppelin/contracts.AccountERC7579.v1.0.0\";\n    }\n\n    /**\n     * @inheritdoc IERC7579AccountConfig\n     *\n     * @dev Supported call types:\n     * * Single (`0x00`): A single transaction execution.\n     * * Batch (`0x01`): A batch of transactions execution.\n     * * Delegate (`0xff`): A delegate call execution.\n     *\n     * Supported exec types:\n     * * Default (`0x00`): Default execution type (revert on failure).\n     * * Try (`0x01`): Try execution type (emits ERC7579TryExecuteFail on failure).\n     */\n    function supportsExecutionMode(bytes32 encodedMode) public view virtual returns (bool) {\n        (CallType callType, ExecType execType, , ) = Mode.wrap(encodedMode).decodeMode();\n        return\n            (callType == ERC7579Utils.CALLTYPE_SINGLE ||\n                callType == ERC7579Utils.CALLTYPE_BATCH ||\n                callType == ERC7579Utils.CALLTYPE_DELEGATECALL) &&\n            (execType == ERC7579Utils.EXECTYPE_DEFAULT || execType == ERC7579Utils.EXECTYPE_TRY);\n    }\n\n    /**\n     * @inheritdoc IERC7579AccountConfig\n     *\n     * @dev Supported module types:\n     *\n     * * Validator: A module used during the validation phase to determine if a transaction is valid and\n     * should be executed on the account.\n     * * Executor: A module that can execute transactions on behalf of the smart account via a callback.\n     * * Fallback Handler: A module that can extend the fallback functionality of a smart account.\n     */\n    function supportsModule(uint256 moduleTypeId) public view virtual returns (bool) {\n        return\n            moduleTypeId == MODULE_TYPE_VALIDATOR ||\n            moduleTypeId == MODULE_TYPE_EXECUTOR ||\n            moduleTypeId == MODULE_TYPE_FALLBACK;\n    }\n\n    /// @inheritdoc IERC7579ModuleConfig\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    ) public virtual onlyEntryPointOrSelf {\n        _installModule(moduleTypeId, module, initData);\n    }\n\n    /// @inheritdoc IERC7579ModuleConfig\n    function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    ) public virtual onlyEntryPointOrSelf {\n        _uninstallModule(moduleTypeId, module, deInitData);\n    }\n\n    /// @inheritdoc IERC7579ModuleConfig\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    ) public view virtual returns (bool) {\n        AccountERC7579Storage storage $ = _getAccountERC7579Storage();\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) return $._validators.contains(module);\n        if (moduleTypeId == MODULE_TYPE_EXECUTOR) return $._executors.contains(module);\n        if (moduleTypeId == MODULE_TYPE_FALLBACK)\n            // ERC-7579 requires this function to return bool, never revert. Check length to avoid out-of-bounds access.\n            return additionalContext.length > 3 && $._fallbacks[bytes4(additionalContext[0:4])] == module;\n        return false;\n    }\n\n    /// @inheritdoc IERC7579Execution\n    function execute(bytes32 mode, bytes calldata executionCalldata) public payable virtual onlyEntryPointOrSelf {\n        _execute(Mode.wrap(mode), executionCalldata);\n    }\n\n    /// @inheritdoc IERC7579Execution\n    function executeFromExecutor(\n        bytes32 mode,\n        bytes calldata executionCalldata\n    )\n        public\n        payable\n        virtual\n        onlyModule(MODULE_TYPE_EXECUTOR, Calldata.emptyBytes())\n        returns (bytes[] memory returnData)\n    {\n        return _execute(Mode.wrap(mode), executionCalldata);\n    }\n\n    /**\n     * @dev Implement ERC-1271 through IERC7579Validator modules. If module based validation fails, fallback to\n     * \"native\" validation by the abstract signer.\n     *\n     * NOTE: when combined with {ERC7739}, resolution ordering may have an impact ({ERC7739} does not call super).\n     * Manual resolution might be necessary.\n     */\n    function isValidSignature(bytes32 hash, bytes calldata signature) public view virtual returns (bytes4) {\n        // check signature length is enough for extraction\n        if (signature.length >= 20) {\n            (address module, bytes calldata innerSignature) = _extractSignatureValidator(signature);\n            // if module is not installed, skip\n            if (isModuleInstalled(MODULE_TYPE_VALIDATOR, module, Calldata.emptyBytes())) {\n                // try validation, skip any revert\n                try IERC7579Validator(module).isValidSignatureWithSender(msg.sender, hash, innerSignature) returns (\n                    bytes4 magic\n                ) {\n                    return magic;\n                } catch {}\n            }\n        }\n        return bytes4(0xffffffff);\n    }\n\n    /**\n     * @dev Validates a user operation with {_signableUserOpHash} and returns the validation data\n     * if the module specified by the first 20 bytes of the nonce key is installed. Falls back to\n     * {Account-_validateUserOp} otherwise.\n     *\n     * See {_extractUserOpValidator} for the module extraction logic.\n     */\n    function _validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        bytes calldata signature\n    ) internal virtual override returns (uint256) {\n        address module = _extractUserOpValidator(userOp);\n        return\n            isModuleInstalled(MODULE_TYPE_VALIDATOR, module, Calldata.emptyBytes())\n                ? IERC7579Validator(module).validateUserOp(userOp, _signableUserOpHash(userOp, userOpHash))\n                : super._validateUserOp(userOp, userOpHash, signature);\n    }\n\n    /**\n     * @dev ERC-7579 execution logic. See {supportsExecutionMode} for supported modes.\n     *\n     * Reverts if the call type is not supported.\n     */\n    function _execute(\n        Mode mode,\n        bytes calldata executionCalldata\n    ) internal virtual returns (bytes[] memory returnData) {\n        (CallType callType, ExecType execType, , ) = mode.decodeMode();\n        if (callType == ERC7579Utils.CALLTYPE_SINGLE) return executionCalldata.execSingle(execType);\n        if (callType == ERC7579Utils.CALLTYPE_BATCH) return executionCalldata.execBatch(execType);\n        if (callType == ERC7579Utils.CALLTYPE_DELEGATECALL) return executionCalldata.execDelegateCall(execType);\n        revert ERC7579Utils.ERC7579UnsupportedCallType(callType);\n    }\n\n    /**\n     * @dev Installs a module of the given type with the given initialization data.\n     *\n     * For the fallback module type, the `initData` is expected to be the (packed) concatenation of a 4-byte\n     * selector and the rest of the data to be sent to the handler when calling {IERC7579Module-onInstall}.\n     *\n     * Requirements:\n     *\n     * * Module type must be supported. See {supportsModule}. Reverts with {ERC7579Utils-ERC7579UnsupportedModuleType}.\n     * * Module must be of the given type. Reverts with {ERC7579Utils-ERC7579MismatchedModuleTypeId}.\n     * * Module must not be already installed. Reverts with {ERC7579Utils-ERC7579AlreadyInstalledModule}.\n     *\n     * Emits a {IERC7579ModuleConfig-ModuleInstalled} event.\n     */\n    function _installModule(uint256 moduleTypeId, address module, bytes memory initData) internal virtual {\n        AccountERC7579Storage storage $ = _getAccountERC7579Storage();\n        require(supportsModule(moduleTypeId), ERC7579Utils.ERC7579UnsupportedModuleType(moduleTypeId));\n        require(\n            IERC7579Module(module).isModuleType(moduleTypeId),\n            ERC7579Utils.ERC7579MismatchedModuleTypeId(moduleTypeId, module)\n        );\n\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            require($._validators.add(module), ERC7579Utils.ERC7579AlreadyInstalledModule(moduleTypeId, module));\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            require($._executors.add(module), ERC7579Utils.ERC7579AlreadyInstalledModule(moduleTypeId, module));\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            bytes4 selector;\n            (selector, initData) = _decodeFallbackData(initData);\n            require(\n                $._fallbacks[selector] == address(0),\n                ERC7579Utils.ERC7579AlreadyInstalledModule(moduleTypeId, module)\n            );\n            $._fallbacks[selector] = module;\n        }\n\n        IERC7579Module(module).onInstall(initData);\n        emit ModuleInstalled(moduleTypeId, module);\n    }\n\n    /**\n     * @dev Uninstalls a module of the given type with the given de-initialization data.\n     *\n     * For the fallback module type, the `deInitData` is expected to be the (packed) concatenation of a 4-byte\n     * selector and the rest of the data to be sent to the handler when calling {IERC7579Module-onUninstall}.\n     *\n     * Requirements:\n     *\n     * * Module must be already installed. Reverts with {ERC7579Utils-ERC7579UninstalledModule} otherwise.\n     */\n    function _uninstallModule(uint256 moduleTypeId, address module, bytes memory deInitData) internal virtual {\n        AccountERC7579Storage storage $ = _getAccountERC7579Storage();\n        require(supportsModule(moduleTypeId), ERC7579Utils.ERC7579UnsupportedModuleType(moduleTypeId));\n\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            require($._validators.remove(module), ERC7579Utils.ERC7579UninstalledModule(moduleTypeId, module));\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            require($._executors.remove(module), ERC7579Utils.ERC7579UninstalledModule(moduleTypeId, module));\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            bytes4 selector;\n            (selector, deInitData) = _decodeFallbackData(deInitData);\n            require(\n                _fallbackHandler(selector) == module && module != address(0),\n                ERC7579Utils.ERC7579UninstalledModule(moduleTypeId, module)\n            );\n            delete $._fallbacks[selector];\n        }\n\n        // Ignores success purposely to avoid modules that revert on uninstall\n        LowLevelCall.callNoReturn(module, abi.encodeCall(IERC7579Module.onUninstall, (deInitData)));\n        emit ModuleUninstalled(moduleTypeId, module);\n    }\n\n    /**\n     * @dev Fallback function that delegates the call to the installed handler for the given selector.\n     *\n     * Reverts with {ERC7579MissingFallbackHandler} if the handler is not installed.\n     *\n     * Calls the handler with the original `msg.sender` appended at the end of the calldata following\n     * the ERC-2771 format.\n     */\n    function _fallback() internal virtual returns (bytes memory) {\n        address handler = _fallbackHandler(msg.sig);\n        require(handler != address(0), ERC7579MissingFallbackHandler(msg.sig));\n\n        // From https://eips.ethereum.org/EIPS/eip-7579#fallback[ERC-7579 specifications]:\n        // - MUST utilize ERC-2771 to add the original msg.sender to the calldata sent to the fallback handler\n        // - MUST use call to invoke the fallback handler\n        if (LowLevelCall.callNoReturn(handler, msg.value, abi.encodePacked(msg.data, msg.sender))) {\n            return LowLevelCall.returnData();\n        } else {\n            LowLevelCall.bubbleRevert();\n        }\n    }\n\n    /// @dev Returns the fallback handler for the given selector. Returns `address(0)` if not installed.\n    function _fallbackHandler(bytes4 selector) internal view virtual returns (address) {\n        AccountERC7579Storage storage $ = _getAccountERC7579Storage();\n        return $._fallbacks[selector];\n    }\n\n    /// @dev Checks if the module is installed. Reverts if the module is not installed.\n    function _checkModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    ) internal view virtual {\n        require(\n            isModuleInstalled(moduleTypeId, module, additionalContext),\n            ERC7579Utils.ERC7579UninstalledModule(moduleTypeId, module)\n        );\n    }\n\n    /**\n     * @dev Extracts the nonce validator from the user operation.\n     *\n     * To construct a nonce key, set nonce as follows:\n     *\n     * ```\n     * <module address (20 bytes)> | <key (4 bytes)> | <nonce (8 bytes)>\n     * ```\n     * NOTE: The default behavior of this function replicates the behavior of\n     * https://github.com/rhinestonewtf/safe7579/blob/bb29e8b1a66658790c4169e72608e27d220f79be/src/Safe7579.sol#L266[Safe adapter],\n     * https://github.com/etherspot/etherspot-prime-contracts/blob/cfcdb48c4172cea0d66038324c0bae3288aa8caa/src/modular-etherspot-wallet/wallet/ModularEtherspotWallet.sol#L227[Etherspot's Prime Account], and\n     * https://github.com/erc7579/erc7579-implementation/blob/16138d1afd4e9711f6c1425133538837bd7787b5/src/MSAAdvanced.sol#L247[ERC7579 reference implementation].\n     *\n     * This is not standardized in ERC-7579 (or in any follow-up ERC). Some accounts may want to override these internal functions.\n     *\n     * For example, https://github.com/bcnmy/nexus/blob/54f4e19baaff96081a8843672977caf712ef19f4/contracts/lib/NonceLib.sol#L17[Biconomy's Nexus]\n     * uses a similar yet incompatible approach (the validator address is also part of the nonce, but not at the same location)\n     */\n    function _extractUserOpValidator(PackedUserOperation calldata userOp) internal pure virtual returns (address) {\n        return address(bytes32(userOp.nonce).extract_32_20(0));\n    }\n\n    /**\n     * @dev Extracts the signature validator from the signature.\n     *\n     * To construct a signature, set the first 20 bytes as the module address and the remaining bytes as the\n     * signature data:\n     *\n     * ```\n     * <module address (20 bytes)> | <signature data>\n     * ```\n     *\n     * NOTE: The default behavior of this function replicates the behavior of\n     * https://github.com/rhinestonewtf/safe7579/blob/bb29e8b1a66658790c4169e72608e27d220f79be/src/Safe7579.sol#L350[Safe adapter],\n     * https://github.com/bcnmy/nexus/blob/54f4e19baaff96081a8843672977caf712ef19f4/contracts/Nexus.sol#L239[Biconomy's Nexus],\n     * https://github.com/etherspot/etherspot-prime-contracts/blob/cfcdb48c4172cea0d66038324c0bae3288aa8caa/src/modular-etherspot-wallet/wallet/ModularEtherspotWallet.sol#L252[Etherspot's Prime Account], and\n     * https://github.com/erc7579/erc7579-implementation/blob/16138d1afd4e9711f6c1425133538837bd7787b5/src/MSAAdvanced.sol#L296[ERC7579 reference implementation].\n     *\n     * This is not standardized in ERC-7579 (or in any follow-up ERC). Some accounts may want to override these internal functions.\n     *\n     * NOTE: This function expects the signature to be at least 20 bytes long. Panics with {Panic-ARRAY_OUT_OF_BOUNDS} (0x32) otherwise.\n     */\n    function _extractSignatureValidator(\n        bytes calldata signature\n    ) internal pure virtual returns (address module, bytes calldata innerSignature) {\n        return (address(bytes20(signature)), signature[20:]);\n    }\n\n    /**\n     * @dev Extract the function selector from initData/deInitData for MODULE_TYPE_FALLBACK\n     *\n     * NOTE: If we had calldata here, we could use calldata slice which are cheaper to manipulate and don't require\n     * actual copy. However, this would require `_installModule` to get a calldata bytes object instead of a memory\n     * bytes object. This would prevent calling `_installModule` from a contract constructor and would force the use\n     * of external initializers. That may change in the future, as most accounts will probably be deployed as\n     * clones/proxy/EIP-7702 delegates and therefore rely on initializers anyway.\n     */\n    function _decodeFallbackData(\n        bytes memory data\n    ) internal pure virtual returns (bytes4 selector, bytes memory remaining) {\n        require(data.length > 3, ERC7579CannotDecodeFallbackData());\n        return (bytes4(data), data.slice(4));\n    }\n\n    /// @dev By default, only use the modules for validation of userOp and signature. Disable raw signatures.\n    function _rawSignatureValidation(\n        bytes32 /*hash*/,\n        bytes calldata /*signature*/\n    ) internal view virtual override returns (bool) {\n        return false;\n    }\n}\n"
      },
      {
        "name": "CrosschainLinkedUpgradeable",
        "filePath": "crosschain/CrosschainLinkedUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC7786RecipientUpgradeable"
        ],
        "implements": [],
        "category": "crosschain",
        "externalFunctions": [
          {
            "name": "getLink",
            "signature": "getLink(bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "chain",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "gateway",
                "type": "address"
              },
              {
                "name": "counterpart",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "_getCrosschainLinkedStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getLink(bytes memory chain) public view virtual returns (address gateway, bytes memory counterpart) {\n        CrosschainLinkedStorage storage $ = _getCrosschainLinkedStorage();\n        Link storage self = $._links[chain];\n        return (self.gateway, self.counterpart);\n    }",
            "startLine": 74
          }
        ],
        "internalFunctions": [
          {
            "name": "_getCrosschainLinkedStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "CrosschainLinkedStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getCrosschainLinkedStorage() private pure returns (CrosschainLinkedStorage storage $) {\n        assembly {\n            $.slot := CrosschainLinkedStorageLocation\n        }\n    }",
            "startLine": 38
          },
          {
            "name": "__CrosschainLinked_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "links",
                "type": "Link[]"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __CrosschainLinked_init(Link[] memory links) internal onlyInitializing {\n        __CrosschainLinked_init_unchained(links);\n    }",
            "startLine": 58
          },
          {
            "name": "__CrosschainLinked_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "links",
                "type": "Link[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setLink",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __CrosschainLinked_init_unchained(Link[] memory links) internal onlyInitializing {\n        for (uint256 i = 0; i < links.length; ++i) {\n            _setLink(links[i].gateway, links[i].counterpart, false);\n        }\n    }",
            "startLine": 62
          },
          {
            "name": "_setLink",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "gateway",
                "type": "address"
              },
              {
                "name": "counterpart",
                "type": "bytes"
              },
              {
                "name": "allowOverride",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getCrosschainLinkedStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "supportsAttribute",
                "type": "external",
                "targetType": "ERC7786GatewaySource",
                "argCount": 1
              },
              {
                "target": "_extractChain",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "Link",
                "type": "external",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setLink(address gateway, bytes memory counterpart, bool allowOverride) internal virtual {\n        CrosschainLinkedStorage storage $ = _getCrosschainLinkedStorage();\n        // Sanity check, this should revert if gateway is not an ERC-7786 implementation. Note that since\n        // supportsAttribute returns data, an EOA would fail that test (nothing returned).\n        IERC7786GatewaySource(gateway).supportsAttribute(bytes4(0));\n\n        bytes memory chain = _extractChain(counterpart);\n        if (allowOverride || $._links[chain].gateway == address(0)) {\n            $._links[chain] = Link(gateway, counterpart);\n            emit LinkRegistered(gateway, counterpart);\n        } else {\n            revert LinkAlreadyRegistered(chain);\n        }\n    }",
            "startLine": 85
          },
          {
            "name": "_sendMessageToCounterpart",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "chain",
                "type": "bytes"
              },
              {
                "name": "payload",
                "type": "bytes"
              },
              {
                "name": "attributes",
                "type": "bytes[]"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "getLink",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "sendMessage",
                "type": "external",
                "targetType": "ERC7786GatewaySource",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _sendMessageToCounterpart(\n        bytes memory chain,\n        bytes memory payload,\n        bytes[] memory attributes\n    ) internal virtual returns (bytes32) {\n        (address gateway, bytes memory counterpart) = getLink(chain);\n        return IERC7786GatewaySource(gateway).sendMessage(counterpart, payload, attributes);\n    }",
            "startLine": 105
          },
          {
            "name": "_isAuthorizedGateway",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "instance",
                "type": "address"
              },
              {
                "name": "sender",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "getLink",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_extractChain",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "Bytes.equal",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _isAuthorizedGateway(\n        address instance,\n        bytes calldata sender\n    ) internal view virtual override returns (bool) {\n        (address gateway, bytes memory router) = getLink(_extractChain(sender));\n        return instance == gateway && sender.equal(router);\n    }",
            "startLine": 115
          },
          {
            "name": "_extractChain",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "self",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "Bytes.parseV1",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "InteroperableAddress.formatV1",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _extractChain(bytes memory self) private pure returns (bytes memory) {\n        (bytes2 chainType, bytes memory chainReference, ) = self.parseV1();\n        return InteroperableAddress.formatV1(chainType, chainReference, hex\"\");\n    }",
            "startLine": 123
          }
        ],
        "events": [
          {
            "name": "LinkRegistered",
            "parameters": [
              {
                "name": "gateway",
                "type": "address",
                "indexed": false
              },
              {
                "name": "counterpart",
                "type": "bytes",
                "indexed": false
              }
            ],
            "startLine": 49
          }
        ],
        "errors": [
          {
            "name": "LinkAlreadyRegistered",
            "parameters": [
              {
                "name": "chain",
                "type": "bytes"
              }
            ],
            "startLine": 56
          }
        ],
        "structs": [
          {
            "name": "Link",
            "members": [
              {
                "name": "gateway",
                "type": "address"
              },
              {
                "name": "counterpart",
                "type": "bytes"
              }
            ],
            "startLine": 26
          },
          {
            "name": "CrosschainLinkedStorage",
            "members": [
              {
                "name": "_links",
                "type": "mapping(bytes => Link)"
              }
            ],
            "startLine": 31
          }
        ],
        "stateVariables": [
          {
            "name": "CrosschainLinkedStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 36
          }
        ],
        "usesLibraries": [
          "Bytes",
          "InteroperableAddress"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/interfaces/draft-IERC7786.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/draft-InteroperableAddress.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/Bytes.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "./ERC7786RecipientUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.26;\n\nimport {IERC7786GatewaySource} from \"@openzeppelin/contracts/interfaces/draft-IERC7786.sol\";\nimport {InteroperableAddress} from \"@openzeppelin/contracts/utils/draft-InteroperableAddress.sol\";\nimport {Bytes} from \"@openzeppelin/contracts/utils/Bytes.sol\";\nimport {ERC7786RecipientUpgradeable} from \"./ERC7786RecipientUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Core bridging mechanism.\n *\n * This contract contains the logic to register and send messages to counterparts on remote chains using ERC-7786\n * gateways. It ensure received messages originate from a counterpart. This is the base of token bridges such as\n * {BridgeERC20Core}.\n *\n * Contracts that inherit from this contract can use the internal {_sendMessageToCounterpart} to send messages to their\n * counterpart on a foreign chain. They must override the {_processMessage} function to handle messages that have\n * been verified.\n */\nabstract contract CrosschainLinkedUpgradeable is Initializable, ERC7786RecipientUpgradeable {\n    using Bytes for bytes;\n    using InteroperableAddress for bytes;\n\n    struct Link {\n        address gateway;\n        bytes counterpart; // Full InteroperableAddress (chain ref + address)\n    }\n    /// @custom:storage-location erc7201:openzeppelin.storage.CrosschainLinked\n    struct CrosschainLinkedStorage {\n        mapping(bytes chain => Link) _links;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.CrosschainLinked\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant CrosschainLinkedStorageLocation = 0xb1919b8acb826911820798909343454eff798c0ea16342cfea7647f1c8b2df00;\n\n    function _getCrosschainLinkedStorage() private pure returns (CrosschainLinkedStorage storage $) {\n        assembly {\n            $.slot := CrosschainLinkedStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when a new link is registered.\n     *\n     * Note: the `counterpart` argument is a full InteroperableAddress (chain ref + address).\n     */\n    event LinkRegistered(address gateway, bytes counterpart);\n\n    /**\n     * @dev Reverted when trying to register a link for a chain that is already registered.\n     *\n     * Note: the `chain` argument is a \"chain-only\" InteroperableAddress (empty address).\n     */\n    error LinkAlreadyRegistered(bytes chain);\n\n    function __CrosschainLinked_init(Link[] memory links) internal onlyInitializing {\n        __CrosschainLinked_init_unchained(links);\n    }\n\n    function __CrosschainLinked_init_unchained(Link[] memory links) internal onlyInitializing {\n        for (uint256 i = 0; i < links.length; ++i) {\n            _setLink(links[i].gateway, links[i].counterpart, false);\n        }\n    }\n\n    /**\n     * @dev Returns the ERC-7786 gateway used for sending and receiving cross-chain messages to a given chain.\n     *\n     * Note: The `chain` parameter is a \"chain-only\" InteroperableAddress (empty address) and the `counterpart` returns\n     * the full InteroperableAddress (chain ref + address) that is on `chain`.\n     */\n    function getLink(bytes memory chain) public view virtual returns (address gateway, bytes memory counterpart) {\n        CrosschainLinkedStorage storage $ = _getCrosschainLinkedStorage();\n        Link storage self = $._links[chain];\n        return (self.gateway, self.counterpart);\n    }\n\n    /**\n     * @dev Internal setter to change the ERC-7786 gateway and counterpart for a given chain. Called at construction.\n     *\n     * Note: The `counterpart` parameter is the full InteroperableAddress (chain ref + address).\n     */\n    function _setLink(address gateway, bytes memory counterpart, bool allowOverride) internal virtual {\n        CrosschainLinkedStorage storage $ = _getCrosschainLinkedStorage();\n        // Sanity check, this should revert if gateway is not an ERC-7786 implementation. Note that since\n        // supportsAttribute returns data, an EOA would fail that test (nothing returned).\n        IERC7786GatewaySource(gateway).supportsAttribute(bytes4(0));\n\n        bytes memory chain = _extractChain(counterpart);\n        if (allowOverride || $._links[chain].gateway == address(0)) {\n            $._links[chain] = Link(gateway, counterpart);\n            emit LinkRegistered(gateway, counterpart);\n        } else {\n            revert LinkAlreadyRegistered(chain);\n        }\n    }\n\n    /**\n     * @dev Internal messaging function\n     *\n     * Note: The `chain` parameter is a \"chain-only\" InteroperableAddress (empty address).\n     */\n    function _sendMessageToCounterpart(\n        bytes memory chain,\n        bytes memory payload,\n        bytes[] memory attributes\n    ) internal virtual returns (bytes32) {\n        (address gateway, bytes memory counterpart) = getLink(chain);\n        return IERC7786GatewaySource(gateway).sendMessage(counterpart, payload, attributes);\n    }\n\n    /// @inheritdoc ERC7786RecipientUpgradeable\n    function _isAuthorizedGateway(\n        address instance,\n        bytes calldata sender\n    ) internal view virtual override returns (bool) {\n        (address gateway, bytes memory router) = getLink(_extractChain(sender));\n        return instance == gateway && sender.equal(router);\n    }\n\n    function _extractChain(bytes memory self) private pure returns (bytes memory) {\n        (bytes2 chainType, bytes memory chainReference, ) = self.parseV1();\n        return InteroperableAddress.formatV1(chainType, chainReference, hex\"\");\n    }\n}\n"
      },
      {
        "name": "ERC7786RecipientUpgradeable",
        "filePath": "crosschain/ERC7786RecipientUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "IERC7786Recipient"
        ],
        "implements": [],
        "category": "crosschain",
        "externalFunctions": [
          {
            "name": "receiveMessage",
            "signature": "receiveMessage(bytes32,bytes,bytes)",
            "selector": "",
            "visibility": "external",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "receiveId",
                "type": "bytes32"
              },
              {
                "name": "sender",
                "type": "bytes"
              },
              {
                "name": "payload",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes4"
              }
            ],
            "calls": [
              {
                "target": "_getERC7786RecipientStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_isAuthorizedGateway",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "BitMaps.get",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "BitMaps.set",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "_processMessage",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function receiveMessage(\n        bytes32 receiveId,\n        bytes calldata sender, // Binary Interoperable Address\n        bytes calldata payload\n    ) external payable returns (bytes4) {\n        ERC7786RecipientStorage storage $ = _getERC7786RecipientStorage();\n        // Check authorization\n        if (!_isAuthorizedGateway(msg.sender, sender)) {\n            revert ERC7786RecipientUnauthorizedGateway(msg.sender, sender);\n        }\n\n        // Prevent duplicate execution\n        if ($._received[msg.sender].get(uint256(receiveId))) {\n            revert ERC7786RecipientMessageAlreadyProcessed(msg.sender, receiveId);\n        }\n        $._received[msg.sender].set(uint256(receiveId));\n\n        _processMessage(msg.sender, receiveId, sender, payload);\n\n        return IERC7786Recipient.receiveMessage.selector;\n    }",
            "startLine": 51
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC7786RecipientStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC7786RecipientStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getERC7786RecipientStorage() private pure returns (ERC7786RecipientStorage storage $) {\n        assembly {\n            $.slot := ERC7786RecipientStorageLocation\n        }\n    }",
            "startLine": 36
          },
          {
            "name": "__ERC7786Recipient_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC7786Recipient_init() internal onlyInitializing {\n    }",
            "startLine": 45
          },
          {
            "name": "__ERC7786Recipient_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC7786Recipient_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 48
          },
          {
            "name": "_isAuthorizedGateway",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "gateway",
                "type": "address"
              },
              {
                "name": "sender",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _isAuthorizedGateway(address gateway, bytes calldata sender) internal view virtual returns (bool);",
            "startLine": 80
          },
          {
            "name": "_processMessage",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "gateway",
                "type": "address"
              },
              {
                "name": "receiveId",
                "type": "bytes32"
              },
              {
                "name": "sender",
                "type": "bytes"
              },
              {
                "name": "payload",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _processMessage(\n        address gateway,\n        bytes32 receiveId,\n        bytes calldata sender,\n        bytes calldata payload\n    ) internal virtual;",
            "startLine": 83
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ERC7786RecipientUnauthorizedGateway",
            "parameters": [
              {
                "name": "gateway",
                "type": "address"
              },
              {
                "name": "sender",
                "type": "bytes"
              }
            ],
            "startLine": 42
          },
          {
            "name": "ERC7786RecipientMessageAlreadyProcessed",
            "parameters": [
              {
                "name": "gateway",
                "type": "address"
              },
              {
                "name": "receiveId",
                "type": "bytes32"
              }
            ],
            "startLine": 43
          }
        ],
        "structs": [
          {
            "name": "ERC7786RecipientStorage",
            "members": [
              {
                "name": "_received",
                "type": "mapping(address => BitMaps.BitMap)"
              }
            ],
            "startLine": 29
          }
        ],
        "stateVariables": [
          {
            "name": "ERC7786RecipientStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 34
          }
        ],
        "usesLibraries": [
          "BitMaps"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/interfaces/draft-IERC7786.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/structs/BitMaps.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (crosschain/ERC7786Recipient.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC7786Recipient} from \"@openzeppelin/contracts/interfaces/draft-IERC7786.sol\";\nimport {BitMaps} from \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Base implementation of an ERC-7786 compliant cross-chain message receiver.\n *\n * This abstract contract exposes the `receiveMessage` function that is used for communication with (one or multiple)\n * destination gateways. This contract leaves two functions unimplemented:\n *\n * * {_isAuthorizedGateway}, an internal getter used to verify whether an address is recognised by the contract as a\n * valid ERC-7786 destination gateway. One or multiple gateway can be supported. Note that any malicious address for\n * which this function returns true would be able to impersonate any account on any other chain sending any message.\n *\n * * {_processMessage}, the internal function that will be called with any message that has been validated.\n *\n * This contract implements replay protection, meaning that if two messages are received from the same gateway with the\n * same `receiveId`, then the second one will NOT be executed, regardless of the result of {_isAuthorizedGateway}.\n */\nabstract contract ERC7786RecipientUpgradeable is Initializable, IERC7786Recipient {\n    using BitMaps for BitMaps.BitMap;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC7786Recipient\n    struct ERC7786RecipientStorage {\n        mapping(address gateway => BitMaps.BitMap) _received;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC7786Recipient\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC7786RecipientStorageLocation = 0x7d75506ec9b6d21d8b65a6ff14e8447c9f4ebcb3d04f3facb665dd26faeb5e00;\n\n    function _getERC7786RecipientStorage() private pure returns (ERC7786RecipientStorage storage $) {\n        assembly {\n            $.slot := ERC7786RecipientStorageLocation\n        }\n    }\n\n    error ERC7786RecipientUnauthorizedGateway(address gateway, bytes sender);\n    error ERC7786RecipientMessageAlreadyProcessed(address gateway, bytes32 receiveId);\n\n    function __ERC7786Recipient_init() internal onlyInitializing {\n    }\n\n    function __ERC7786Recipient_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC7786Recipient\n    function receiveMessage(\n        bytes32 receiveId,\n        bytes calldata sender, // Binary Interoperable Address\n        bytes calldata payload\n    ) external payable returns (bytes4) {\n        ERC7786RecipientStorage storage $ = _getERC7786RecipientStorage();\n        // Check authorization\n        if (!_isAuthorizedGateway(msg.sender, sender)) {\n            revert ERC7786RecipientUnauthorizedGateway(msg.sender, sender);\n        }\n\n        // Prevent duplicate execution\n        if ($._received[msg.sender].get(uint256(receiveId))) {\n            revert ERC7786RecipientMessageAlreadyProcessed(msg.sender, receiveId);\n        }\n        $._received[msg.sender].set(uint256(receiveId));\n\n        _processMessage(msg.sender, receiveId, sender, payload);\n\n        return IERC7786Recipient.receiveMessage.selector;\n    }\n\n    /**\n     * @dev Virtual getter that returns whether an address is a valid ERC-7786 gateway for a given sender.\n     *\n     * The `sender` parameter is an interoperable address that include the source chain. The chain part can be\n     * extracted using the {InteroperableAddress} library to selectively authorize gateways based on the origin chain\n     * of a message.\n     */\n    function _isAuthorizedGateway(address gateway, bytes calldata sender) internal view virtual returns (bool);\n\n    /// @dev Virtual function that should contain the logic to execute when a cross-chain message is received.\n    function _processMessage(\n        address gateway,\n        bytes32 receiveId,\n        bytes calldata sender,\n        bytes calldata payload\n    ) internal virtual;\n}\n"
      },
      {
        "name": "BridgeERC20CoreUpgradeable",
        "filePath": "crosschain/bridges/BridgeERC20CoreUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ContextUpgradeable",
          "CrosschainLinkedUpgradeable"
        ],
        "implements": [],
        "category": "crosschain",
        "externalFunctions": [
          {
            "name": "crosschainTransfer",
            "signature": "crosschainTransfer(bytes,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "bytes"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_crosschainTransfer",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function crosschainTransfer(bytes memory to, uint256 amount) public virtual returns (bytes32) {\n        return _crosschainTransfer(_msgSender(), to, amount);\n    }",
            "startLine": 38
          }
        ],
        "internalFunctions": [
          {
            "name": "__BridgeERC20Core_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __BridgeERC20Core_init() internal onlyInitializing {\n    }",
            "startLine": 28
          },
          {
            "name": "__BridgeERC20Core_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __BridgeERC20Core_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 31
          },
          {
            "name": "_crosschainTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "bytes"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_onSend",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "InteroperableAddress.parseV1",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "InteroperableAddress.formatV1",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "_sendMessageToCounterpart",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "InteroperableAddress.formatEvmV1",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _crosschainTransfer(address from, bytes memory to, uint256 amount) internal virtual returns (bytes32) {\n        _onSend(from, amount);\n\n        (bytes2 chainType, bytes memory chainReference, bytes memory addr) = to.parseV1();\n        bytes memory chain = InteroperableAddress.formatV1(chainType, chainReference, hex\"\");\n\n        bytes32 sendId = _sendMessageToCounterpart(\n            chain,\n            abi.encode(InteroperableAddress.formatEvmV1(block.chainid, from), addr, amount),\n            new bytes[](0)\n        );\n\n        emit CrosschainERC20TransferSent(sendId, from, to, amount);\n\n        return sendId;\n    }",
            "startLine": 47
          },
          {
            "name": "_processMessage",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "receiveId",
                "type": "bytes32"
              },
              {
                "name": "",
                "type": "bytes"
              },
              {
                "name": "payload",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_onReceive",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _processMessage(\n        address /*gateway*/,\n        bytes32 receiveId,\n        bytes calldata /*sender*/,\n        bytes calldata payload\n    ) internal virtual override {\n        // split payload\n        (bytes memory from, bytes memory toBinary, uint256 amount) = abi.decode(payload, (bytes, bytes, uint256));\n        address to = address(bytes20(toBinary));\n\n        _onReceive(to, amount);\n\n        emit CrosschainERC20TransferReceived(receiveId, from, to, amount);\n    }",
            "startLine": 65
          },
          {
            "name": "_onSend",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _onSend(address from, uint256 amount) internal virtual;",
            "startLine": 81
          },
          {
            "name": "_onReceive",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _onReceive(address to, uint256 amount) internal virtual;",
            "startLine": 84
          }
        ],
        "events": [
          {
            "name": "CrosschainERC20TransferSent",
            "parameters": [
              {
                "name": "sendId",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "bytes",
                "indexed": false
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 25
          },
          {
            "name": "CrosschainERC20TransferReceived",
            "parameters": [
              {
                "name": "receiveId",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "from",
                "type": "bytes",
                "indexed": false
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 26
          }
        ],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [
          "InteroperableAddress"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/utils/draft-InteroperableAddress.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../../utils/ContextUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../ERC7786RecipientUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../CrosschainLinkedUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.26;\n\nimport {InteroperableAddress} from \"@openzeppelin/contracts/utils/draft-InteroperableAddress.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {ERC7786RecipientUpgradeable} from \"../ERC7786RecipientUpgradeable.sol\";\nimport {CrosschainLinkedUpgradeable} from \"../CrosschainLinkedUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Base contract for bridging ERC-20 between chains using an ERC-7786 gateway.\n *\n * In order to use this contract, two functions must be implemented to link it to the token:\n * * {_onSend}: called when a crosschain transfer is going out. Must take the sender tokens or revert.\n * * {_onReceive}: called when a crosschain transfer is coming in. Must give tokens to the receiver.\n *\n * This base contract is used by the {BridgeERC20}, which interfaces with legacy ERC-20 tokens, and {BridgeERC7802},\n * which interface with ERC-7802 to provide an approve-free user experience. It is also used by the {ERC20Crosschain}\n * extension, which embeds the bridge logic directly in the token contract.\n */\nabstract contract BridgeERC20CoreUpgradeable is Initializable, ContextUpgradeable, CrosschainLinkedUpgradeable {\n    using InteroperableAddress for bytes;\n\n    event CrosschainERC20TransferSent(bytes32 indexed sendId, address indexed from, bytes to, uint256 amount);\n    event CrosschainERC20TransferReceived(bytes32 indexed receiveId, bytes from, address indexed to, uint256 amount);\n\n    function __BridgeERC20Core_init() internal onlyInitializing {\n    }\n\n    function __BridgeERC20Core_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Transfer `amount` tokens to a crosschain receiver.\n     *\n     * Note: The `to` parameter is the full InteroperableAddress (chain ref + address).\n     */\n    function crosschainTransfer(bytes memory to, uint256 amount) public virtual returns (bytes32) {\n        return _crosschainTransfer(_msgSender(), to, amount);\n    }\n\n    /**\n     * @dev Internal crosschain transfer function.\n     *\n     * Note: The `to` parameter is the full InteroperableAddress (chain ref + address).\n     */\n    function _crosschainTransfer(address from, bytes memory to, uint256 amount) internal virtual returns (bytes32) {\n        _onSend(from, amount);\n\n        (bytes2 chainType, bytes memory chainReference, bytes memory addr) = to.parseV1();\n        bytes memory chain = InteroperableAddress.formatV1(chainType, chainReference, hex\"\");\n\n        bytes32 sendId = _sendMessageToCounterpart(\n            chain,\n            abi.encode(InteroperableAddress.formatEvmV1(block.chainid, from), addr, amount),\n            new bytes[](0)\n        );\n\n        emit CrosschainERC20TransferSent(sendId, from, to, amount);\n\n        return sendId;\n    }\n\n    /// @inheritdoc ERC7786RecipientUpgradeable\n    function _processMessage(\n        address /*gateway*/,\n        bytes32 receiveId,\n        bytes calldata /*sender*/,\n        bytes calldata payload\n    ) internal virtual override {\n        // split payload\n        (bytes memory from, bytes memory toBinary, uint256 amount) = abi.decode(payload, (bytes, bytes, uint256));\n        address to = address(bytes20(toBinary));\n\n        _onReceive(to, amount);\n\n        emit CrosschainERC20TransferReceived(receiveId, from, to, amount);\n    }\n\n    /// @dev Virtual function: implementation is required to handle token being burnt or locked on the source chain.\n    function _onSend(address from, uint256 amount) internal virtual;\n\n    /// @dev Virtual function: implementation is required to handle token being minted or unlocked on the destination chain.\n    function _onReceive(address to, uint256 amount) internal virtual;\n}\n"
      },
      {
        "name": "BridgeERC20Upgradeable",
        "filePath": "crosschain/bridges/BridgeERC20Upgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "BridgeERC20CoreUpgradeable"
        ],
        "implements": [],
        "category": "crosschain",
        "externalFunctions": [
          {
            "name": "token",
            "signature": "token()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "IERC20"
              }
            ],
            "calls": [
              {
                "target": "_getBridgeERC20Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function token() public view virtual returns (IERC20) {\n        BridgeERC20Storage storage $ = _getBridgeERC20Storage();\n        return $._token;\n    }",
            "startLine": 42
          }
        ],
        "internalFunctions": [
          {
            "name": "_getBridgeERC20Storage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "BridgeERC20Storage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getBridgeERC20Storage() private pure returns (BridgeERC20Storage storage $) {\n        assembly {\n            $.slot := BridgeERC20StorageLocation\n        }\n    }",
            "startLine": 26
          },
          {
            "name": "__BridgeERC20_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token_",
                "type": "IERC20"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __BridgeERC20_init(IERC20 token_) internal onlyInitializing {\n        __BridgeERC20_init_unchained(token_);\n    }",
            "startLine": 32
          },
          {
            "name": "__BridgeERC20_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token_",
                "type": "IERC20"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getBridgeERC20Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __BridgeERC20_init_unchained(IERC20 token_) internal onlyInitializing {\n        BridgeERC20Storage storage $ = _getBridgeERC20Storage();\n        $._token = token_;\n    }",
            "startLine": 36
          },
          {
            "name": "_onSend",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "SafeERC20.safeTransferFrom",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "token",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _onSend(address from, uint256 amount) internal virtual override {\n        token().safeTransferFrom(from, address(this), amount);\n    }",
            "startLine": 48
          },
          {
            "name": "_onReceive",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "SafeERC20.safeTransfer",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "token",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _onReceive(address to, uint256 amount) internal virtual override {\n        token().safeTransfer(to, amount);\n    }",
            "startLine": 53
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "BridgeERC20Storage",
            "members": [
              {
                "name": "_token",
                "type": "IERC20"
              }
            ],
            "startLine": 19
          }
        ],
        "stateVariables": [
          {
            "name": "BridgeERC20StorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 24
          }
        ],
        "usesLibraries": [
          "SafeERC20"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/token/ERC20/IERC20.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "./BridgeERC20CoreUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.26;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {BridgeERC20CoreUpgradeable} from \"./BridgeERC20CoreUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev This is a variant of {BridgeERC20Core} that implements the bridge logic for ERC-20 tokens that do not expose a\n * crosschain mint and burn mechanism. Instead, it takes custody of bridged assets.\n */\n// slither-disable-next-line locked-ether\nabstract contract BridgeERC20Upgradeable is Initializable, BridgeERC20CoreUpgradeable {\n    using SafeERC20 for IERC20;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.BridgeERC20\n    struct BridgeERC20Storage {\n        IERC20 _token;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.BridgeERC20\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant BridgeERC20StorageLocation = 0x244b01c12a07f59148f0f6492b0cb67864481add66b2bb58fc6fb6ea2a07f700;\n\n    function _getBridgeERC20Storage() private pure returns (BridgeERC20Storage storage $) {\n        assembly {\n            $.slot := BridgeERC20StorageLocation\n        }\n    }\n\n    function __BridgeERC20_init(IERC20 token_) internal onlyInitializing {\n        __BridgeERC20_init_unchained(token_);\n    }\n\n    function __BridgeERC20_init_unchained(IERC20 token_) internal onlyInitializing {\n        BridgeERC20Storage storage $ = _getBridgeERC20Storage();\n        $._token = token_;\n    }\n\n    ///@dev Return the address of the ERC20 token this bridge operates on.\n    function token() public view virtual returns (IERC20) {\n        BridgeERC20Storage storage $ = _getBridgeERC20Storage();\n        return $._token;\n    }\n\n    /// @dev \"Locking\" tokens is done by taking custody\n    function _onSend(address from, uint256 amount) internal virtual override {\n        token().safeTransferFrom(from, address(this), amount);\n    }\n\n    /// @dev \"Unlocking\" tokens is done by releasing custody\n    function _onReceive(address to, uint256 amount) internal virtual override {\n        token().safeTransfer(to, amount);\n    }\n}\n"
      },
      {
        "name": "BridgeERC7802Upgradeable",
        "filePath": "crosschain/bridges/BridgeERC7802Upgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "BridgeERC20CoreUpgradeable"
        ],
        "implements": [],
        "category": "crosschain",
        "externalFunctions": [
          {
            "name": "token",
            "signature": "token()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "IERC7802"
              }
            ],
            "calls": [
              {
                "target": "_getBridgeERC7802Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function token() public view virtual returns (IERC7802) {\n        BridgeERC7802Storage storage $ = _getBridgeERC7802Storage();\n        return $._token;\n    }",
            "startLine": 38
          }
        ],
        "internalFunctions": [
          {
            "name": "_getBridgeERC7802Storage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "BridgeERC7802Storage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getBridgeERC7802Storage() private pure returns (BridgeERC7802Storage storage $) {\n        assembly {\n            $.slot := BridgeERC7802StorageLocation\n        }\n    }",
            "startLine": 22
          },
          {
            "name": "__BridgeERC7802_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token_",
                "type": "IERC7802"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __BridgeERC7802_init(IERC7802 token_) internal onlyInitializing {\n        __BridgeERC7802_init_unchained(token_);\n    }",
            "startLine": 28
          },
          {
            "name": "__BridgeERC7802_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token_",
                "type": "IERC7802"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getBridgeERC7802Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __BridgeERC7802_init_unchained(IERC7802 token_) internal onlyInitializing {\n        BridgeERC7802Storage storage $ = _getBridgeERC7802Storage();\n        $._token = token_;\n    }",
            "startLine": 32
          },
          {
            "name": "_onSend",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "token",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _onSend(address from, uint256 amount) internal virtual override {\n        token().crosschainBurn(from, amount);\n    }",
            "startLine": 44
          },
          {
            "name": "_onReceive",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "token",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _onReceive(address to, uint256 amount) internal virtual override {\n        token().crosschainMint(to, amount);\n    }",
            "startLine": 49
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "BridgeERC7802Storage",
            "members": [
              {
                "name": "_token",
                "type": "IERC7802"
              }
            ],
            "startLine": 15
          }
        ],
        "stateVariables": [
          {
            "name": "BridgeERC7802StorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 20
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/interfaces/draft-IERC7802.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "./BridgeERC20CoreUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.26;\n\nimport {IERC7802} from \"@openzeppelin/contracts/interfaces/draft-IERC7802.sol\";\nimport {BridgeERC20CoreUpgradeable} from \"./BridgeERC20CoreUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev This is a variant of {BridgeERC20Core} that implements the bridge logic for ERC-7802 compliant tokens.\n */\n// slither-disable-next-line locked-ether\nabstract contract BridgeERC7802Upgradeable is Initializable, BridgeERC20CoreUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.BridgeERC7802\n    struct BridgeERC7802Storage {\n        IERC7802 _token;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.BridgeERC7802\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant BridgeERC7802StorageLocation = 0xaa74a536d5c1ef957e103c5cd74a2d097ce13b7e0a555173bee99ce500fd4300;\n\n    function _getBridgeERC7802Storage() private pure returns (BridgeERC7802Storage storage $) {\n        assembly {\n            $.slot := BridgeERC7802StorageLocation\n        }\n    }\n\n    function __BridgeERC7802_init(IERC7802 token_) internal onlyInitializing {\n        __BridgeERC7802_init_unchained(token_);\n    }\n\n    function __BridgeERC7802_init_unchained(IERC7802 token_) internal onlyInitializing {\n        BridgeERC7802Storage storage $ = _getBridgeERC7802Storage();\n        $._token = token_;\n    }\n\n    ///@dev Return the address of the ERC20 token this bridge operates on.\n    function token() public view virtual returns (IERC7802) {\n        BridgeERC7802Storage storage $ = _getBridgeERC7802Storage();\n        return $._token;\n    }\n\n    /// @dev \"Locking\" tokens using an ERC-7802 crosschain burn\n    function _onSend(address from, uint256 amount) internal virtual override {\n        token().crosschainBurn(from, amount);\n    }\n\n    /// @dev \"Unlocking\" tokens using an ERC-7802 crosschain mint\n    function _onReceive(address to, uint256 amount) internal virtual override {\n        token().crosschainMint(to, amount);\n    }\n}\n"
      },
      {
        "name": "VestingWalletCliffUpgradeable",
        "filePath": "finance/VestingWalletCliffUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "VestingWalletUpgradeable"
        ],
        "implements": [],
        "category": "finance",
        "externalFunctions": [
          {
            "name": "cliff",
            "signature": "cliff()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getVestingWalletCliffStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function cliff() public view virtual returns (uint256) {\n        VestingWalletCliffStorage storage $ = _getVestingWalletCliffStorage();\n        return $._cliff;\n    }",
            "startLine": 54
          }
        ],
        "internalFunctions": [
          {
            "name": "_getVestingWalletCliffStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "VestingWalletCliffStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getVestingWalletCliffStorage() private pure returns (VestingWalletCliffStorage storage $) {\n        assembly {\n            $.slot := VestingWalletCliffStorageLocation\n        }\n    }",
            "startLine": 26
          },
          {
            "name": "__VestingWalletCliff_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "cliffSeconds",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __VestingWalletCliff_init(uint64 cliffSeconds) internal onlyInitializing {\n        __VestingWalletCliff_init_unchained(cliffSeconds);\n    }",
            "startLine": 39
          },
          {
            "name": "__VestingWalletCliff_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "cliffSeconds",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getVestingWalletCliffStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "duration",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "SafeCast.toUint64",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "start",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __VestingWalletCliff_init_unchained(uint64 cliffSeconds) internal onlyInitializing {\n        VestingWalletCliffStorage storage $ = _getVestingWalletCliffStorage();\n        if (cliffSeconds > duration()) {\n            revert InvalidCliffDuration(cliffSeconds, duration().toUint64());\n        }\n        $._cliff = start().toUint64() + cliffSeconds;\n    }",
            "startLine": 43
          },
          {
            "name": "_vestingSchedule",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "totalAllocation",
                "type": "uint256"
              },
              {
                "name": "timestamp",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "cliff",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_vestingSchedule",
                "type": "super",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _vestingSchedule(\n        uint256 totalAllocation,\n        uint64 timestamp\n    ) internal view virtual override returns (uint256) {\n        return timestamp < cliff() ? 0 : super._vestingSchedule(totalAllocation, timestamp);\n    }",
            "startLine": 67
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "InvalidCliffDuration",
            "parameters": [
              {
                "name": "cliffSeconds",
                "type": "uint64"
              },
              {
                "name": "durationSeconds",
                "type": "uint64"
              }
            ],
            "startLine": 33
          }
        ],
        "structs": [
          {
            "name": "VestingWalletCliffStorage",
            "members": [
              {
                "name": "_cliff",
                "type": "uint64"
              }
            ],
            "startLine": 19
          }
        ],
        "stateVariables": [
          {
            "name": "VestingWalletCliffStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 24
          }
        ],
        "usesLibraries": [
          "SafeCast"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/utils/math/SafeCast.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "./VestingWalletUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (finance/VestingWalletCliff.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {VestingWalletUpgradeable} from \"./VestingWalletUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {VestingWallet} that adds a cliff to the vesting schedule.\n *\n * _Available since v5.1._\n */\nabstract contract VestingWalletCliffUpgradeable is Initializable, VestingWalletUpgradeable {\n    using SafeCast for *;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.VestingWalletCliff\n    struct VestingWalletCliffStorage {\n        uint64 _cliff;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.VestingWalletCliff\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant VestingWalletCliffStorageLocation = 0x0a0ceb66c7c9aef32c0bfc43d3108868a39e95e96162520745e462557492f100;\n\n    function _getVestingWalletCliffStorage() private pure returns (VestingWalletCliffStorage storage $) {\n        assembly {\n            $.slot := VestingWalletCliffStorageLocation\n        }\n    }\n\n    /// @dev The specified cliff duration is larger than the vesting duration.\n    error InvalidCliffDuration(uint64 cliffSeconds, uint64 durationSeconds);\n\n    /**\n     * @dev Set the duration of the cliff, in seconds. The cliff starts vesting schedule (see {VestingWallet}'s\n     * constructor) and ends `cliffSeconds` later.\n     */\n    function __VestingWalletCliff_init(uint64 cliffSeconds) internal onlyInitializing {\n        __VestingWalletCliff_init_unchained(cliffSeconds);\n    }\n\n    function __VestingWalletCliff_init_unchained(uint64 cliffSeconds) internal onlyInitializing {\n        VestingWalletCliffStorage storage $ = _getVestingWalletCliffStorage();\n        if (cliffSeconds > duration()) {\n            revert InvalidCliffDuration(cliffSeconds, duration().toUint64());\n        }\n        $._cliff = start().toUint64() + cliffSeconds;\n    }\n\n    /**\n     * @dev Getter for the cliff timestamp.\n     */\n    function cliff() public view virtual returns (uint256) {\n        VestingWalletCliffStorage storage $ = _getVestingWalletCliffStorage();\n        return $._cliff;\n    }\n\n    /**\n     * @dev Virtual implementation of the vesting formula. This returns the amount vested, as a function of time, for\n     * an asset given its total historical allocation. Returns 0 if the {cliff} timestamp is not met.\n     *\n     * IMPORTANT: The cliff not only makes the schedule return 0, but it also ignores every possible side\n     * effect from calling the inherited implementation (i.e. `super._vestingSchedule`). Carefully consider\n     * this caveat if the overridden implementation of this function has any (e.g. writing to memory or reverting).\n     */\n    function _vestingSchedule(\n        uint256 totalAllocation,\n        uint64 timestamp\n    ) internal view virtual override returns (uint256) {\n        return timestamp < cliff() ? 0 : super._vestingSchedule(totalAllocation, timestamp);\n    }\n}\n"
      },
      {
        "name": "VestingWalletUpgradeable",
        "filePath": "finance/VestingWalletUpgradeable.sol",
        "kind": "contract",
        "inherits": [
          "Initializable",
          "ContextUpgradeable",
          "OwnableUpgradeable"
        ],
        "implements": [],
        "category": "finance",
        "externalFunctions": [
          {
            "name": "initialize",
            "signature": "initialize(address,uint64,uint64)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "beneficiary",
                "type": "address"
              },
              {
                "name": "startTimestamp",
                "type": "uint64"
              },
              {
                "name": "durationSeconds",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__VestingWallet_init",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function initialize(address beneficiary, uint64 startTimestamp, uint64 durationSeconds) public virtual initializer {\n        __VestingWallet_init(beneficiary, startTimestamp, durationSeconds);\n    }",
            "startLine": 58
          },
          {
            "name": "receive",
            "signature": "receive()",
            "selector": "",
            "visibility": "external",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "receive() external payable virtual {}",
            "startLine": 79
          },
          {
            "name": "start",
            "signature": "start()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getVestingWalletStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function start() public view virtual returns (uint256) {\n        VestingWalletStorage storage $ = _getVestingWalletStorage();\n        return $._start;\n    }",
            "startLine": 84
          },
          {
            "name": "duration",
            "signature": "duration()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getVestingWalletStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function duration() public view virtual returns (uint256) {\n        VestingWalletStorage storage $ = _getVestingWalletStorage();\n        return $._duration;\n    }",
            "startLine": 92
          },
          {
            "name": "end",
            "signature": "end()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "start",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "duration",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function end() public view virtual returns (uint256) {\n        return start() + duration();\n    }",
            "startLine": 100
          },
          {
            "name": "released",
            "signature": "released()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getVestingWalletStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function released() public view virtual returns (uint256) {\n        VestingWalletStorage storage $ = _getVestingWalletStorage();\n        return $._released;\n    }",
            "startLine": 107
          },
          {
            "name": "released",
            "signature": "released(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getVestingWalletStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function released(address token) public view virtual returns (uint256) {\n        VestingWalletStorage storage $ = _getVestingWalletStorage();\n        return $._erc20Released[token];\n    }",
            "startLine": 115
          },
          {
            "name": "releasable",
            "signature": "releasable()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "vestedAmount",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "released",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function releasable() public view virtual returns (uint256) {\n        return vestedAmount(uint64(block.timestamp)) - released();\n    }",
            "startLine": 123
          },
          {
            "name": "releasable",
            "signature": "releasable(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "vestedAmount",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "released",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function releasable(address token) public view virtual returns (uint256) {\n        return vestedAmount(token, uint64(block.timestamp)) - released(token);\n    }",
            "startLine": 131
          },
          {
            "name": "release",
            "signature": "release()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getVestingWalletStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "releasable",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Address.sendValue",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "owner",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function release() public virtual {\n        VestingWalletStorage storage $ = _getVestingWalletStorage();\n        uint256 amount = releasable();\n        $._released += amount;\n        emit EtherReleased(amount);\n        Address.sendValue(payable(owner()), amount);\n    }",
            "startLine": 140
          },
          {
            "name": "release",
            "signature": "release(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getVestingWalletStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "releasable",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "SafeERC20.safeTransfer",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "owner",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function release(address token) public virtual {\n        VestingWalletStorage storage $ = _getVestingWalletStorage();\n        uint256 amount = releasable(token);\n        $._erc20Released[token] += amount;\n        emit ERC20Released(token, amount);\n        SafeERC20.safeTransfer(IERC20(token), owner(), amount);\n    }",
            "startLine": 153
          },
          {
            "name": "vestedAmount",
            "signature": "vestedAmount(uint64)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "timestamp",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_vestingSchedule",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "released",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function vestedAmount(uint64 timestamp) public view virtual returns (uint256) {\n        return _vestingSchedule(address(this).balance + released(), timestamp);\n    }",
            "startLine": 164
          },
          {
            "name": "vestedAmount",
            "signature": "vestedAmount(address,uint64)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "timestamp",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_vestingSchedule",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "balanceOf",
                "type": "external",
                "targetType": "ERC20",
                "argCount": 1
              },
              {
                "target": "released",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function vestedAmount(address token, uint64 timestamp) public view virtual returns (uint256) {\n        return _vestingSchedule(IERC20(token).balanceOf(address(this)) + released(token), timestamp);\n    }",
            "startLine": 171
          }
        ],
        "internalFunctions": [
          {
            "name": "_getVestingWalletStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "VestingWalletStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getVestingWalletStorage() private pure returns (VestingWalletStorage storage $) {\n        assembly {\n            $.slot := VestingWalletStorageLocation\n        }\n    }",
            "startLine": 52
          },
          {
            "name": "__VestingWallet_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "beneficiary",
                "type": "address"
              },
              {
                "name": "startTimestamp",
                "type": "uint64"
              },
              {
                "name": "durationSeconds",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __VestingWallet_init(address beneficiary, uint64 startTimestamp, uint64 durationSeconds) internal onlyInitializing {\n        __Ownable_init_unchained(beneficiary);\n        __VestingWallet_init_unchained(beneficiary, startTimestamp, durationSeconds);\n    }",
            "startLine": 65
          },
          {
            "name": "__VestingWallet_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "startTimestamp",
                "type": "uint64"
              },
              {
                "name": "durationSeconds",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getVestingWalletStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __VestingWallet_init_unchained(address, uint64 startTimestamp, uint64 durationSeconds) internal onlyInitializing {\n        VestingWalletStorage storage $ = _getVestingWalletStorage();\n        $._start = startTimestamp;\n        $._duration = durationSeconds;\n    }",
            "startLine": 70
          },
          {
            "name": "_vestingSchedule",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "totalAllocation",
                "type": "uint256"
              },
              {
                "name": "timestamp",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "start",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "end",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "duration",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _vestingSchedule(uint256 totalAllocation, uint64 timestamp) internal view virtual returns (uint256) {\n        if (timestamp < start()) {\n            return 0;\n        } else if (timestamp >= end()) {\n            return totalAllocation;\n        } else {\n            return (totalAllocation * (timestamp - start())) / duration();\n        }\n    }",
            "startLine": 179
          }
        ],
        "events": [
          {
            "name": "EtherReleased",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 38
          },
          {
            "name": "ERC20Released",
            "parameters": [
              {
                "name": "token",
                "type": "address",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 39
          }
        ],
        "errors": [],
        "structs": [
          {
            "name": "VestingWalletStorage",
            "members": [
              {
                "name": "_released",
                "type": "uint256"
              },
              {
                "name": "_erc20Released",
                "type": "mapping(address => uint256)"
              },
              {
                "name": "_start",
                "type": "uint64"
              },
              {
                "name": "_duration",
                "type": "uint64"
              }
            ],
            "startLine": 42
          }
        ],
        "stateVariables": [
          {
            "name": "VestingWalletStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 50
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/token/ERC20/IERC20.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/Address.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../utils/ContextUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../access/OwnableUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (finance/VestingWallet.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"../access/OwnableUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev A vesting wallet is an ownable contract that can receive native currency and ERC-20 tokens, and release these\n * assets to the wallet owner, also referred to as \"beneficiary\", according to a vesting schedule.\n *\n * Any assets transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\n * be immediately releasable.\n *\n * By setting the duration to 0, one can configure this contract to behave like an asset timelock that holds tokens for\n * a beneficiary until a specified time.\n *\n * NOTE: Since the wallet is {Ownable}, and ownership can be transferred, it is possible to sell unvested tokens.\n * Preventing this in a smart contract is difficult, considering that: 1) a beneficiary address could be a\n * counterfactually deployed contract, 2) there is likely to be a migration path for EOAs to become contracts in the\n * near future.\n *\n * NOTE: When using this contract with any token whose balance is adjusted automatically (i.e. a rebase token), make\n * sure to account the supply/balance adjustment in the vesting schedule to ensure the vested amount is as intended.\n *\n * NOTE: Chains with support for native ERC20s may allow the vesting wallet to withdraw the underlying asset as both an\n * ERC20 and as native currency. For example, if chain C supports token A and the wallet gets deposited 100 A, then\n * at 50% of the vesting period, the beneficiary can withdraw 50 A as ERC20 and 25 A as native currency (totaling 75 A).\n * Consider disabling one of the withdrawal methods.\n */\ncontract VestingWalletUpgradeable is Initializable, ContextUpgradeable, OwnableUpgradeable {\n    event EtherReleased(uint256 amount);\n    event ERC20Released(address indexed token, uint256 amount);\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.VestingWallet\n    struct VestingWalletStorage {\n        uint256 _released;\n        mapping(address token => uint256) _erc20Released;\n        uint64 _start;\n        uint64 _duration;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.VestingWallet\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant VestingWalletStorageLocation = 0xa1eac494560f7591e4da38ed031587f09556afdfc4399dd2e205b935fdfa3900;\n\n    function _getVestingWalletStorage() private pure returns (VestingWalletStorage storage $) {\n        assembly {\n            $.slot := VestingWalletStorageLocation\n        }\n    }\n\n    function initialize(address beneficiary, uint64 startTimestamp, uint64 durationSeconds) public virtual initializer {\n        __VestingWallet_init(beneficiary, startTimestamp, durationSeconds);\n    }\n    /**\n     * @dev Sets the beneficiary (owner), the start timestamp and the vesting duration (in seconds) of the vesting\n     * wallet.\n     */\n    function __VestingWallet_init(address beneficiary, uint64 startTimestamp, uint64 durationSeconds) internal onlyInitializing {\n        __Ownable_init_unchained(beneficiary);\n        __VestingWallet_init_unchained(beneficiary, startTimestamp, durationSeconds);\n    }\n\n    function __VestingWallet_init_unchained(address, uint64 startTimestamp, uint64 durationSeconds) internal onlyInitializing {\n        VestingWalletStorage storage $ = _getVestingWalletStorage();\n        $._start = startTimestamp;\n        $._duration = durationSeconds;\n    }\n\n    /**\n     * @dev The contract should be able to receive Eth.\n     */\n    receive() external payable virtual {}\n\n    /**\n     * @dev Getter for the start timestamp.\n     */\n    function start() public view virtual returns (uint256) {\n        VestingWalletStorage storage $ = _getVestingWalletStorage();\n        return $._start;\n    }\n\n    /**\n     * @dev Getter for the vesting duration.\n     */\n    function duration() public view virtual returns (uint256) {\n        VestingWalletStorage storage $ = _getVestingWalletStorage();\n        return $._duration;\n    }\n\n    /**\n     * @dev Getter for the end timestamp.\n     */\n    function end() public view virtual returns (uint256) {\n        return start() + duration();\n    }\n\n    /**\n     * @dev Amount of eth already released\n     */\n    function released() public view virtual returns (uint256) {\n        VestingWalletStorage storage $ = _getVestingWalletStorage();\n        return $._released;\n    }\n\n    /**\n     * @dev Amount of token already released\n     */\n    function released(address token) public view virtual returns (uint256) {\n        VestingWalletStorage storage $ = _getVestingWalletStorage();\n        return $._erc20Released[token];\n    }\n\n    /**\n     * @dev Getter for the amount of releasable eth.\n     */\n    function releasable() public view virtual returns (uint256) {\n        return vestedAmount(uint64(block.timestamp)) - released();\n    }\n\n    /**\n     * @dev Getter for the amount of releasable `token` tokens. `token` should be the address of an\n     * {IERC20} contract.\n     */\n    function releasable(address token) public view virtual returns (uint256) {\n        return vestedAmount(token, uint64(block.timestamp)) - released(token);\n    }\n\n    /**\n     * @dev Release the native tokens (ether) that have already vested.\n     *\n     * Emits a {EtherReleased} event.\n     */\n    function release() public virtual {\n        VestingWalletStorage storage $ = _getVestingWalletStorage();\n        uint256 amount = releasable();\n        $._released += amount;\n        emit EtherReleased(amount);\n        Address.sendValue(payable(owner()), amount);\n    }\n\n    /**\n     * @dev Release the tokens that have already vested.\n     *\n     * Emits a {ERC20Released} event.\n     */\n    function release(address token) public virtual {\n        VestingWalletStorage storage $ = _getVestingWalletStorage();\n        uint256 amount = releasable(token);\n        $._erc20Released[token] += amount;\n        emit ERC20Released(token, amount);\n        SafeERC20.safeTransfer(IERC20(token), owner(), amount);\n    }\n\n    /**\n     * @dev Calculates the amount of ether that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(uint64 timestamp) public view virtual returns (uint256) {\n        return _vestingSchedule(address(this).balance + released(), timestamp);\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(address token, uint64 timestamp) public view virtual returns (uint256) {\n        return _vestingSchedule(IERC20(token).balanceOf(address(this)) + released(token), timestamp);\n    }\n\n    /**\n     * @dev Virtual implementation of the vesting formula. This returns the amount vested, as a function of time, for\n     * an asset given its total historical allocation.\n     */\n    function _vestingSchedule(uint256 totalAllocation, uint64 timestamp) internal view virtual returns (uint256) {\n        if (timestamp < start()) {\n            return 0;\n        } else if (timestamp >= end()) {\n            return totalAllocation;\n        } else {\n            return (totalAllocation * (timestamp - start())) / duration();\n        }\n    }\n}\n"
      },
      {
        "name": "GovernorUpgradeable",
        "filePath": "governance/GovernorUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ContextUpgradeable",
          "ERC165Upgradeable",
          "EIP712Upgradeable",
          "NoncesUpgradeable",
          "IGovernor",
          "IERC721Receiver",
          "IERC1155Receiver"
        ],
        "implements": [],
        "category": "governance",
        "externalFunctions": [
          {
            "name": "receive",
            "signature": "receive()",
            "selector": "",
            "visibility": "external",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_executor",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "receive() external payable virtual {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n    }",
            "startLine": 104
          },
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "supportsInterface",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IGovernor).interfaceId ||\n            interfaceId == type(IGovernor).interfaceId ^ IGovernor.getProposalId.selector ||\n            interfaceId == type(IERC1155Receiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }",
            "startLine": 111
          },
          {
            "name": "name",
            "signature": "name()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function name() public view virtual returns (string memory) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._name;\n    }",
            "startLine": 120
          },
          {
            "name": "version",
            "signature": "version()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function version() public view virtual returns (string memory) {\n        return \"1\";\n    }",
            "startLine": 126
          },
          {
            "name": "hashProposal",
            "signature": "hashProposal(address[],uint256[],bytes[],bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "descriptionHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual returns (uint256) {\n        return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));\n    }",
            "startLine": 143
          },
          {
            "name": "getProposalId",
            "signature": "getProposalId(address[],uint256[],bytes[],bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "descriptionHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "hashProposal",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getProposalId(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public view virtual returns (uint256) {\n        return hashProposal(targets, values, calldatas, descriptionHash);\n    }",
            "startLine": 153
          },
          {
            "name": "state",
            "signature": "state(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "ProposalState"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "proposalSnapshot",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "clock",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "proposalDeadline",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "proposalEta",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function state(uint256 proposalId) public view virtual returns (ProposalState) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        // We read the struct fields into the stack at once so Solidity emits a single SLOAD\n        ProposalCore storage proposal = $._proposals[proposalId];\n        bool proposalExecuted = proposal.executed;\n        bool proposalCanceled = proposal.canceled;\n\n        if (proposalExecuted) {\n            return ProposalState.Executed;\n        }\n\n        if (proposalCanceled) {\n            return ProposalState.Canceled;\n        }\n\n        uint256 snapshot = proposalSnapshot(proposalId);\n\n        if (snapshot == 0) {\n            revert GovernorNonexistentProposal(proposalId);\n        }\n\n        uint256 currentTimepoint = clock();\n\n        if (snapshot >= currentTimepoint) {\n            return ProposalState.Pending;\n        }\n\n        uint256 deadline = proposalDeadline(proposalId);\n\n        if (deadline >= currentTimepoint) {\n            return ProposalState.Active;\n        } else if (!_quorumReached(proposalId) || !_voteSucceeded(proposalId)) {\n            return ProposalState.Defeated;\n        } else if (proposalEta(proposalId) == 0) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Queued;\n        }\n    }",
            "startLine": 163
          },
          {
            "name": "proposalThreshold",
            "signature": "proposalThreshold()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalThreshold() public view virtual returns (uint256) {\n        return 0;\n    }",
            "startLine": 204
          },
          {
            "name": "proposalSnapshot",
            "signature": "proposalSnapshot(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._proposals[proposalId].voteStart;\n    }",
            "startLine": 209
          },
          {
            "name": "proposalDeadline",
            "signature": "proposalDeadline(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalDeadline(uint256 proposalId) public view virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._proposals[proposalId].voteStart + $._proposals[proposalId].voteDuration;\n    }",
            "startLine": 215
          },
          {
            "name": "proposalProposer",
            "signature": "proposalProposer(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalProposer(uint256 proposalId) public view virtual returns (address) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._proposals[proposalId].proposer;\n    }",
            "startLine": 221
          },
          {
            "name": "proposalEta",
            "signature": "proposalEta(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalEta(uint256 proposalId) public view virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._proposals[proposalId].etaSeconds;\n    }",
            "startLine": 227
          },
          {
            "name": "proposalNeedsQueuing",
            "signature": "proposalNeedsQueuing(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalNeedsQueuing(uint256) public view virtual returns (bool) {\n        return false;\n    }",
            "startLine": 233
          },
          {
            "name": "propose",
            "signature": "propose(address[],uint256[],bytes[],string)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "description",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_isValidDescriptionForProposer",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "proposalThreshold",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "getVotes",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "clock",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_propose",
                "type": "internal",
                "argCount": 5
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256) {\n        address proposer = _msgSender();\n\n        // check description restriction\n        if (!_isValidDescriptionForProposer(proposer, description)) {\n            revert GovernorRestrictedProposer(proposer);\n        }\n\n        // check proposal threshold\n        uint256 votesThreshold = proposalThreshold();\n        if (votesThreshold > 0) {\n            uint256 proposerVotes = getVotes(proposer, clock() - 1);\n            if (proposerVotes < votesThreshold) {\n                revert GovernorInsufficientProposerVotes(proposer, proposerVotes, votesThreshold);\n            }\n        }\n\n        return _propose(targets, values, calldatas, description, proposer);\n    }",
            "startLine": 302
          },
          {
            "name": "queue",
            "signature": "queue(address[],uint256[],bytes[],bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "descriptionHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "getProposalId",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_validateStateBitmap",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_encodeStateBitmap",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_queueOperations",
                "type": "internal",
                "argCount": 5
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);\n\n        _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Succeeded));\n\n        uint48 etaSeconds = _queueOperations(proposalId, targets, values, calldatas, descriptionHash);\n\n        if (etaSeconds != 0) {\n            $._proposals[proposalId].etaSeconds = etaSeconds;\n            emit ProposalQueued(proposalId, etaSeconds);\n        } else {\n            revert GovernorQueueNotImplemented();\n        }\n\n        return proposalId;\n    }",
            "startLine": 373
          },
          {
            "name": "execute",
            "signature": "execute(address[],uint256[],bytes[],bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "descriptionHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "getProposalId",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_validateStateBitmap",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_encodeStateBitmap",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_executor",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "DoubleEndedQueue.pushBack",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "_executeOperations",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "DoubleEndedQueue.empty",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "DoubleEndedQueue.clear",
                "type": "library",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);\n\n        _validateStateBitmap(\n            proposalId,\n            _encodeStateBitmap(ProposalState.Succeeded) | _encodeStateBitmap(ProposalState.Queued)\n        );\n\n        // mark as executed before calls to avoid reentrancy\n        $._proposals[proposalId].executed = true;\n\n        // before execute: register governance call in queue.\n        if (_executor() != address(this)) {\n            for (uint256 i = 0; i < targets.length; ++i) {\n                if (targets[i] == address(this)) {\n                    $._governanceCall.pushBack(keccak256(calldatas[i]));\n                }\n            }\n        }\n\n        _executeOperations(proposalId, targets, values, calldatas, descriptionHash);\n\n        // after execute: cleanup governance call queue.\n        if (_executor() != address(this) && !$._governanceCall.empty()) {\n            $._governanceCall.clear();\n        }\n\n        emit ProposalExecuted(proposalId);\n\n        return proposalId;\n    }",
            "startLine": 420
          },
          {
            "name": "cancel",
            "signature": "cancel(address[],uint256[],bytes[],bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "descriptionHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "getProposalId",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_validateCancel",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_cancel",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256) {\n        // The proposalId will be recomputed in the `_cancel` call further down. However we need the value before we\n        // do the internal call, because we need to check the proposal state BEFORE the internal `_cancel` call\n        // changes it. The `getProposalId` duplication has a cost that is limited, and that we accept.\n        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);\n\n        address caller = _msgSender();\n        if (!_validateCancel(proposalId, caller)) revert GovernorUnableToCancel(proposalId, caller);\n\n        return _cancel(targets, values, calldatas, descriptionHash);\n    }",
            "startLine": 479
          },
          {
            "name": "getVotes",
            "signature": "getVotes(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "timepoint",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getVotes",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_defaultParams",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getVotes(address account, uint256 timepoint) public view virtual returns (uint256) {\n        return _getVotes(account, timepoint, _defaultParams());\n    }",
            "startLine": 526
          },
          {
            "name": "getVotesWithParams",
            "signature": "getVotesWithParams(address,uint256,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "timepoint",
                "type": "uint256"
              },
              {
                "name": "params",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getVotes",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getVotesWithParams(\n        address account,\n        uint256 timepoint,\n        bytes memory params\n    ) public view virtual returns (uint256) {\n        return _getVotes(account, timepoint, params);\n    }",
            "startLine": 531
          },
          {
            "name": "castVote",
            "signature": "castVote(uint256,uint8)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "support",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_castVote",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, \"\");\n    }",
            "startLine": 540
          },
          {
            "name": "castVoteWithReason",
            "signature": "castVoteWithReason(uint256,uint8,string)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "support",
                "type": "uint8"
              },
              {
                "name": "reason",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_castVote",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason);\n    }",
            "startLine": 546
          },
          {
            "name": "castVoteWithReasonAndParams",
            "signature": "castVoteWithReasonAndParams(uint256,uint8,string,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "support",
                "type": "uint8"
              },
              {
                "name": "reason",
                "type": "string"
              },
              {
                "name": "params",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_castVote",
                "type": "internal",
                "argCount": 5
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason, params);\n    }",
            "startLine": 556
          },
          {
            "name": "castVoteBySig",
            "signature": "castVoteBySig(uint256,uint8,address,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "support",
                "type": "uint8"
              },
              {
                "name": "voter",
                "type": "address"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_validateVoteSig",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_castVote",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        bytes memory signature\n    ) public virtual returns (uint256) {\n        if (!_validateVoteSig(proposalId, support, voter, signature)) {\n            revert GovernorInvalidSignature(voter);\n        }\n        return _castVote(proposalId, voter, support, \"\");\n    }",
            "startLine": 567
          },
          {
            "name": "castVoteWithReasonAndParamsBySig",
            "signature": "castVoteWithReasonAndParamsBySig(uint256,uint8,address,string,bytes,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "support",
                "type": "uint8"
              },
              {
                "name": "voter",
                "type": "address"
              },
              {
                "name": "reason",
                "type": "string"
              },
              {
                "name": "params",
                "type": "bytes"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_validateExtendedVoteSig",
                "type": "internal",
                "argCount": 6
              },
              {
                "target": "_castVote",
                "type": "internal",
                "argCount": 5
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        string calldata reason,\n        bytes memory params,\n        bytes memory signature\n    ) public virtual returns (uint256) {\n        if (!_validateExtendedVoteSig(proposalId, support, voter, reason, params, signature)) {\n            revert GovernorInvalidSignature(voter);\n        }\n        return _castVote(proposalId, voter, support, reason, params);\n    }",
            "startLine": 580
          },
          {
            "name": "relay",
            "signature": "relay(address,uint256,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "Address.verifyCallResult",
                "type": "library",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function relay(address target, uint256 value, bytes calldata data) public payable virtual onlyGovernance {\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        Address.verifyCallResult(success, returndata);\n    }",
            "startLine": 688
          },
          {
            "name": "onERC721Received",
            "signature": "onERC721Received(address,address,uint256,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes4"
              }
            ],
            "calls": [
              {
                "target": "_executor",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n        return this.onERC721Received.selector;\n    }",
            "startLine": 705
          },
          {
            "name": "onERC1155Received",
            "signature": "onERC1155Received(address,address,uint256,uint256,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes4"
              }
            ],
            "calls": [
              {
                "target": "_executor",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual returns (bytes4) {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n        return this.onERC1155Received.selector;\n    }",
            "startLine": 716
          },
          {
            "name": "onERC1155BatchReceived",
            "signature": "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "",
                "type": "uint256[]"
              },
              {
                "name": "",
                "type": "uint256[]"
              },
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes4"
              }
            ],
            "calls": [
              {
                "target": "_executor",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual returns (bytes4) {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n        return this.onERC1155BatchReceived.selector;\n    }",
            "startLine": 727
          },
          {
            "name": "clock",
            "signature": "clock()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint48"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function clock() public view virtual returns (uint48);",
            "startLine": 824
          },
          {
            "name": "CLOCK_MODE",
            "signature": "CLOCK_MODE()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function CLOCK_MODE() public view virtual returns (string memory);",
            "startLine": 828
          },
          {
            "name": "votingDelay",
            "signature": "votingDelay()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function votingDelay() public view virtual returns (uint256);",
            "startLine": 831
          },
          {
            "name": "votingPeriod",
            "signature": "votingPeriod()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function votingPeriod() public view virtual returns (uint256);",
            "startLine": 834
          },
          {
            "name": "quorum",
            "signature": "quorum(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "timepoint",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function quorum(uint256 timepoint) public view virtual returns (uint256);",
            "startLine": 837
          }
        ],
        "internalFunctions": [
          {
            "name": "_getGovernorStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "GovernorStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getGovernorStorage() private pure returns (GovernorStorage storage $) {\n        assembly {\n            $.slot := GovernorStorageLocation\n        }\n    }",
            "startLine": 67
          },
          {
            "name": "__Governor_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name_",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "version",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __Governor_init(string memory name_) internal onlyInitializing {\n        __EIP712_init_unchained(name_, version());\n        __Governor_init_unchained(name_);\n    }",
            "startLine": 91
          },
          {
            "name": "__Governor_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name_",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __Governor_init_unchained(string memory name_) internal onlyInitializing {\n        GovernorStorage storage $ = _getGovernorStorage();\n        $._name = name_;\n    }",
            "startLine": 96
          },
          {
            "name": "_checkGovernance",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_executor",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_msgData",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "DoubleEndedQueue.popFront",
                "type": "library",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkGovernance() internal virtual {\n        GovernorStorage storage $ = _getGovernorStorage();\n        if (_executor() != _msgSender()) {\n            revert GovernorOnlyExecutor(_msgSender());\n        }\n        if (_executor() != address(this)) {\n            bytes32 msgDataHash = keccak256(_msgData());\n            // loop until popping the expected operation - throw if deque is empty (operation not authorized)\n            while ($._governanceCall.popFront() != msgDataHash) {}\n        }\n    }",
            "startLine": 242
          },
          {
            "name": "_quorumReached",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _quorumReached(uint256 proposalId) internal view virtual returns (bool);",
            "startLine": 257
          },
          {
            "name": "_voteSucceeded",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _voteSucceeded(uint256 proposalId) internal view virtual returns (bool);",
            "startLine": 262
          },
          {
            "name": "_getVotes",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "timepoint",
                "type": "uint256"
              },
              {
                "name": "params",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _getVotes(address account, uint256 timepoint, bytes memory params) internal view virtual returns (uint256);",
            "startLine": 267
          },
          {
            "name": "_countVote",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "support",
                "type": "uint8"
              },
              {
                "name": "totalWeight",
                "type": "uint256"
              },
              {
                "name": "params",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 totalWeight,\n        bytes memory params\n    ) internal virtual returns (uint256);",
            "startLine": 274
          },
          {
            "name": "_tallyUpdated",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _tallyUpdated(uint256 proposalId) internal virtual {}",
            "startLine": 287
          },
          {
            "name": "_defaultParams",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _defaultParams() internal view virtual returns (bytes memory) {\n        return \"\";\n    }",
            "startLine": 295
          },
          {
            "name": "_propose",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "description",
                "type": "string"
              },
              {
                "name": "proposer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "getProposalId",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "clock",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "votingDelay",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "votingPeriod",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "SafeCast.toUint48",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "SafeCast.toUint32",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description,\n        address proposer\n    ) internal virtual returns (uint256 proposalId) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        proposalId = getProposalId(targets, values, calldatas, keccak256(bytes(description)));\n\n        if (targets.length != values.length || targets.length != calldatas.length || targets.length == 0) {\n            revert GovernorInvalidProposalLength(targets.length, calldatas.length, values.length);\n        }\n        if ($._proposals[proposalId].voteStart != 0) {\n            revert GovernorUnexpectedProposalState(proposalId, state(proposalId), bytes32(0));\n        }\n\n        uint256 snapshot = clock() + votingDelay();\n        uint256 duration = votingPeriod();\n\n        ProposalCore storage proposal = $._proposals[proposalId];\n        proposal.proposer = proposer;\n        proposal.voteStart = SafeCast.toUint48(snapshot);\n        proposal.voteDuration = SafeCast.toUint32(duration);\n\n        emit ProposalCreated(\n            proposalId,\n            proposer,\n            targets,\n            values,\n            new string[](targets.length),\n            calldatas,\n            snapshot,\n            snapshot + duration,\n            description\n        );\n\n        // Using a named return variable to avoid stack too deep errors\n    }",
            "startLine": 332
          },
          {
            "name": "_queueOperations",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "address[]"
              },
              {
                "name": "",
                "type": "uint256[]"
              },
              {
                "name": "",
                "type": "bytes[]"
              },
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint48"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _queueOperations(\n        uint256 /*proposalId*/,\n        address[] memory /*targets*/,\n        uint256[] memory /*values*/,\n        bytes[] memory /*calldatas*/,\n        bytes32 /*descriptionHash*/\n    ) internal virtual returns (uint48) {\n        return 0;\n    }",
            "startLine": 409
          },
          {
            "name": "_executeOperations",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "Address.verifyCallResult",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _executeOperations(\n        uint256 /* proposalId */,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);\n            Address.verifyCallResult(success, returndata);\n        }\n    }",
            "startLine": 465
          },
          {
            "name": "_cancel",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "descriptionHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "getProposalId",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_validateStateBitmap",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_encodeStateBitmap",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);\n\n        _validateStateBitmap(\n            proposalId,\n            ALL_PROPOSAL_STATES_BITMAP ^\n                _encodeStateBitmap(ProposalState.Canceled) ^\n                _encodeStateBitmap(ProposalState.Expired) ^\n                _encodeStateBitmap(ProposalState.Executed)\n        );\n\n        $._proposals[proposalId].canceled = true;\n        emit ProposalCanceled(proposalId);\n\n        return proposalId;\n    }",
            "startLine": 502
          },
          {
            "name": "_validateVoteSig",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "support",
                "type": "uint8"
              },
              {
                "name": "voter",
                "type": "address"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "SignatureChecker.isValidSignatureNow",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "_hashTypedDataV4",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_useNonce",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _validateVoteSig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        bytes memory signature\n    ) internal virtual returns (bool) {\n        return\n            SignatureChecker.isValidSignatureNow(\n                voter,\n                _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support, voter, _useNonce(voter)))),\n                signature\n            );\n    }",
            "startLine": 595
          },
          {
            "name": "_validateExtendedVoteSig",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "support",
                "type": "uint8"
              },
              {
                "name": "voter",
                "type": "address"
              },
              {
                "name": "reason",
                "type": "string"
              },
              {
                "name": "params",
                "type": "bytes"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "SignatureChecker.isValidSignatureNow",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "_hashTypedDataV4",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_useNonce",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _validateExtendedVoteSig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        string memory reason,\n        bytes memory params,\n        bytes memory signature\n    ) internal virtual returns (bool) {\n        return\n            SignatureChecker.isValidSignatureNow(\n                voter,\n                _hashTypedDataV4(\n                    keccak256(\n                        abi.encode(\n                            EXTENDED_BALLOT_TYPEHASH,\n                            proposalId,\n                            support,\n                            voter,\n                            _useNonce(voter),\n                            keccak256(bytes(reason)),\n                            keccak256(params)\n                        )\n                    )\n                ),\n                signature\n            );\n    }",
            "startLine": 610
          },
          {
            "name": "_castVote",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "support",
                "type": "uint8"
              },
              {
                "name": "reason",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_castVote",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_defaultParams",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason\n    ) internal virtual returns (uint256) {\n        return _castVote(proposalId, account, support, reason, _defaultParams());\n    }",
            "startLine": 644
          },
          {
            "name": "_castVote",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "support",
                "type": "uint8"
              },
              {
                "name": "reason",
                "type": "string"
              },
              {
                "name": "params",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_validateStateBitmap",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_encodeStateBitmap",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_getVotes",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "proposalSnapshot",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_countVote",
                "type": "internal",
                "argCount": 5
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual returns (uint256) {\n        _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Active));\n\n        uint256 totalWeight = _getVotes(account, proposalSnapshot(proposalId), params);\n        uint256 votedWeight = _countVote(proposalId, account, support, totalWeight, params);\n\n        if (params.length == 0) {\n            emit VoteCast(account, proposalId, support, votedWeight, reason);\n        } else {\n            emit VoteCastWithParams(account, proposalId, support, votedWeight, reason, params);\n        }\n\n        _tallyUpdated(proposalId);\n\n        return votedWeight;\n    }",
            "startLine": 659
          },
          {
            "name": "_executor",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _executor() internal view virtual returns (address) {\n        return address(this);\n    }",
            "startLine": 697
          },
          {
            "name": "_encodeStateBitmap",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "proposalState",
                "type": "ProposalState"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _encodeStateBitmap(ProposalState proposalState) internal pure returns (bytes32) {\n        return bytes32(1 << uint8(proposalState));\n    }",
            "startLine": 752
          },
          {
            "name": "_validateStateBitmap",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "allowedStates",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "ProposalState"
              }
            ],
            "calls": [
              {
                "target": "state",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_encodeStateBitmap",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _validateStateBitmap(uint256 proposalId, bytes32 allowedStates) internal view returns (ProposalState) {\n        ProposalState currentState = state(proposalId);\n        if (_encodeStateBitmap(currentState) & allowedStates == bytes32(0)) {\n            revert GovernorUnexpectedProposalState(proposalId, currentState, allowedStates);\n        }\n        return currentState;\n    }",
            "startLine": 762
          },
          {
            "name": "_isValidDescriptionForProposer",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposer",
                "type": "address"
              },
              {
                "name": "description",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_unsafeReadBytesOffset",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "Strings.tryParseAddress",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _isValidDescriptionForProposer(\n        address proposer,\n        string memory description\n    ) internal view virtual returns (bool) {\n        unchecked {\n            uint256 length = bytes(description).length;\n\n            // Length is too short to contain a valid proposer suffix\n            if (length < 52) {\n                return true;\n            }\n\n            // Extract what would be the `#proposer=` marker beginning the suffix\n            bytes10 marker = bytes10(_unsafeReadBytesOffset(bytes(description), length - 52));\n\n            // If the marker is not found, there is no proposer suffix to check\n            if (marker != bytes10(\"#proposer=\")) {\n                return true;\n            }\n\n            // Check that the last 42 characters (after the marker) are a properly formatted address.\n            (bool success, address recovered) = Strings.tryParseAddress(description, length - 42, length);\n            return !success || recovered == proposer;\n        }\n    }",
            "startLine": 788
          },
          {
            "name": "_validateCancel",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "caller",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "state",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "proposalProposer",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _validateCancel(uint256 proposalId, address caller) internal view virtual returns (bool) {\n        return (state(proposalId) == ProposalState.Pending) && caller == proposalProposer(proposalId);\n    }",
            "startLine": 819
          },
          {
            "name": "_unsafeReadBytesOffset",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "buffer",
                "type": "bytes"
              },
              {
                "name": "offset",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "value",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(add(buffer, 0x20), offset))\n        }\n    }",
            "startLine": 845
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "ProposalCore",
            "members": [
              {
                "name": "proposer",
                "type": "address"
              },
              {
                "name": "voteStart",
                "type": "uint48"
              },
              {
                "name": "voteDuration",
                "type": "uint32"
              },
              {
                "name": "executed",
                "type": "bool"
              },
              {
                "name": "canceled",
                "type": "bool"
              },
              {
                "name": "etaSeconds",
                "type": "uint48"
              }
            ],
            "startLine": 41
          },
          {
            "name": "GovernorStorage",
            "members": [
              {
                "name": "_name",
                "type": "string"
              },
              {
                "name": "_proposals",
                "type": "mapping(uint256 => ProposalCore)"
              },
              {
                "name": "_governanceCall",
                "type": "DoubleEndedQueue.Bytes32Deque"
              }
            ],
            "startLine": 52
          }
        ],
        "stateVariables": [
          {
            "name": "BALLOT_TYPEHASH",
            "type": "bytes32",
            "visibility": "public",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 34
          },
          {
            "name": "EXTENDED_BALLOT_TYPEHASH",
            "type": "bytes32",
            "visibility": "public",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 36
          },
          {
            "name": "ALL_PROPOSAL_STATES_BITMAP",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 50
          },
          {
            "name": "GovernorStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 65
          }
        ],
        "usesLibraries": [
          "DoubleEndedQueue"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../utils/cryptography/EIP712Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/introspection/IERC165.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../utils/introspection/ERC165Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/math/SafeCast.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/structs/DoubleEndedQueue.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/Address.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../utils/ContextUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../utils/NoncesUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/Strings.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/governance/IGovernor.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/interfaces/IERC6372.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (governance/Governor.sol)\n\npragma solidity ^0.8.24;\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {EIP712Upgradeable} from \"../utils/cryptography/EIP712Upgradeable.sol\";\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {DoubleEndedQueue} from \"@openzeppelin/contracts/utils/structs/DoubleEndedQueue.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {NoncesUpgradeable} from \"../utils/NoncesUpgradeable.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {IGovernor} from \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport {IERC6372} from \"@openzeppelin/contracts/interfaces/IERC6372.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Core of the governance system, designed to be extended through various modules.\n *\n * This contract is abstract and requires several functions to be implemented in various modules:\n *\n * - A counting module must implement {_quorumReached}, {_voteSucceeded} and {_countVote}\n * - A voting module must implement {_getVotes}\n * - Additionally, {votingPeriod}, {votingDelay}, and {quorum} must also be implemented\n */\nabstract contract GovernorUpgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, EIP712Upgradeable, NoncesUpgradeable, IGovernor, IERC721Receiver, IERC1155Receiver {\n    using DoubleEndedQueue for DoubleEndedQueue.Bytes32Deque;\n\n    bytes32 public constant BALLOT_TYPEHASH =\n        keccak256(\"Ballot(uint256 proposalId,uint8 support,address voter,uint256 nonce)\");\n    bytes32 public constant EXTENDED_BALLOT_TYPEHASH =\n        keccak256(\n            \"ExtendedBallot(uint256 proposalId,uint8 support,address voter,uint256 nonce,string reason,bytes params)\"\n        );\n\n    struct ProposalCore {\n        address proposer;\n        uint48 voteStart;\n        uint32 voteDuration;\n        bool executed;\n        bool canceled;\n        uint48 etaSeconds;\n    }\n\n    bytes32 private constant ALL_PROPOSAL_STATES_BITMAP = bytes32((2 ** (uint8(type(ProposalState).max) + 1)) - 1);\n    /// @custom:storage-location erc7201:openzeppelin.storage.Governor\n    struct GovernorStorage {\n        string _name;\n\n        mapping(uint256 proposalId => ProposalCore) _proposals;\n\n        // This queue keeps track of the governor operating on itself. Calls to functions protected by the {onlyGovernance}\n        // modifier needs to be whitelisted in this queue. Whitelisting is set in {execute}, consumed by the\n        // {onlyGovernance} modifier and eventually reset after {_executeOperations} completes. This ensures that the\n        // execution of {onlyGovernance} protected calls can only be achieved through successful proposals.\n        DoubleEndedQueue.Bytes32Deque _governanceCall;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Governor\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorStorageLocation = 0x7c712897014dbe49c045ef1299aa2d5f9e67e48eea4403efa21f1e0f3ac0cb00;\n\n    function _getGovernorStorage() private pure returns (GovernorStorage storage $) {\n        assembly {\n            $.slot := GovernorStorageLocation\n        }\n    }\n\n    /**\n     * @dev Restricts a function so it can only be executed through governance proposals. For example, governance\n     * parameter setters in {GovernorSettings} are protected using this modifier.\n     *\n     * The governance executing address may be different from the Governor's own address, for example it could be a\n     * timelock. This can be customized by modules by overriding {_executor}. The executor is only able to invoke these\n     * functions during the execution of the governor's {execute} function, and not under any other circumstances. Thus,\n     * for example, additional timelock proposers are not able to change governance parameters without going through the\n     * governance protocol (since v4.6).\n     */\n    modifier onlyGovernance() {\n        _checkGovernance();\n        _;\n    }\n\n    /**\n     * @dev Sets the value for {name} and {version}\n     */\n    function __Governor_init(string memory name_) internal onlyInitializing {\n        __EIP712_init_unchained(name_, version());\n        __Governor_init_unchained(name_);\n    }\n\n    function __Governor_init_unchained(string memory name_) internal onlyInitializing {\n        GovernorStorage storage $ = _getGovernorStorage();\n        $._name = name_;\n    }\n\n    /**\n     * @dev Function to receive ETH that will be handled by the governor (disabled if executor is a third party contract)\n     */\n    receive() external payable virtual {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IGovernor).interfaceId ||\n            interfaceId == type(IGovernor).interfaceId ^ IGovernor.getProposalId.selector ||\n            interfaceId == type(IERC1155Receiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IGovernor\n    function name() public view virtual returns (string memory) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._name;\n    }\n\n    /// @inheritdoc IGovernor\n    function version() public view virtual returns (string memory) {\n        return \"1\";\n    }\n\n    /**\n     * @dev See {IGovernor-hashProposal}.\n     *\n     * The proposal id is produced by hashing the ABI encoded `targets` array, the `values` array, the `calldatas` array\n     * and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id\n     * can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in\n     * advance, before the proposal is submitted.\n     *\n     * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the\n     * same proposal (with same operation and same description) will have the same id if submitted on multiple governors\n     * across multiple networks. This also means that in order to execute the same operation twice (on the same\n     * governor) the proposer will have to change the description in order to avoid proposal id conflicts.\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual returns (uint256) {\n        return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));\n    }\n\n    /// @inheritdoc IGovernor\n    function getProposalId(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public view virtual returns (uint256) {\n        return hashProposal(targets, values, calldatas, descriptionHash);\n    }\n\n    /// @inheritdoc IGovernor\n    function state(uint256 proposalId) public view virtual returns (ProposalState) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        // We read the struct fields into the stack at once so Solidity emits a single SLOAD\n        ProposalCore storage proposal = $._proposals[proposalId];\n        bool proposalExecuted = proposal.executed;\n        bool proposalCanceled = proposal.canceled;\n\n        if (proposalExecuted) {\n            return ProposalState.Executed;\n        }\n\n        if (proposalCanceled) {\n            return ProposalState.Canceled;\n        }\n\n        uint256 snapshot = proposalSnapshot(proposalId);\n\n        if (snapshot == 0) {\n            revert GovernorNonexistentProposal(proposalId);\n        }\n\n        uint256 currentTimepoint = clock();\n\n        if (snapshot >= currentTimepoint) {\n            return ProposalState.Pending;\n        }\n\n        uint256 deadline = proposalDeadline(proposalId);\n\n        if (deadline >= currentTimepoint) {\n            return ProposalState.Active;\n        } else if (!_quorumReached(proposalId) || !_voteSucceeded(proposalId)) {\n            return ProposalState.Defeated;\n        } else if (proposalEta(proposalId) == 0) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalThreshold() public view virtual returns (uint256) {\n        return 0;\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._proposals[proposalId].voteStart;\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalDeadline(uint256 proposalId) public view virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._proposals[proposalId].voteStart + $._proposals[proposalId].voteDuration;\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalProposer(uint256 proposalId) public view virtual returns (address) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._proposals[proposalId].proposer;\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalEta(uint256 proposalId) public view virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        return $._proposals[proposalId].etaSeconds;\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalNeedsQueuing(uint256) public view virtual returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev Reverts if the `msg.sender` is not the executor. In case the executor is not this contract\n     * itself, the function reverts if `msg.data` is not whitelisted as a result of an {execute}\n     * operation. See {onlyGovernance}.\n     */\n    function _checkGovernance() internal virtual {\n        GovernorStorage storage $ = _getGovernorStorage();\n        if (_executor() != _msgSender()) {\n            revert GovernorOnlyExecutor(_msgSender());\n        }\n        if (_executor() != address(this)) {\n            bytes32 msgDataHash = keccak256(_msgData());\n            // loop until popping the expected operation - throw if deque is empty (operation not authorized)\n            while ($._governanceCall.popFront() != msgDataHash) {}\n        }\n    }\n\n    /**\n     * @dev Amount of votes already cast passes the threshold limit.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Is the proposal successful or not.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Get the voting weight of `account` at a specific `timepoint`, for a vote as described by `params`.\n     */\n    function _getVotes(address account, uint256 timepoint, bytes memory params) internal view virtual returns (uint256);\n\n    /**\n     * @dev Register a vote for `proposalId` by `account` with a given `support`, voting `weight` and voting `params`.\n     *\n     * Note: Support is generic and can represent various things depending on the voting system used.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 totalWeight,\n        bytes memory params\n    ) internal virtual returns (uint256);\n\n    /**\n     * @dev Hook that should be called every time the tally for a proposal is updated.\n     *\n     * Note: This function must run successfully. Reverts will result in the bricking of governance\n     */\n    function _tallyUpdated(uint256 proposalId) internal virtual {}\n\n    /**\n     * @dev Default additional encoded parameters used by castVote methods that don't include them\n     *\n     * Note: Should be overridden by specific implementations to use an appropriate value, the\n     * meaning of the additional params, in the context of that implementation\n     */\n    function _defaultParams() internal view virtual returns (bytes memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IGovernor-propose}. This function has opt-in frontrunning protection, described in {_isValidDescriptionForProposer}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256) {\n        address proposer = _msgSender();\n\n        // check description restriction\n        if (!_isValidDescriptionForProposer(proposer, description)) {\n            revert GovernorRestrictedProposer(proposer);\n        }\n\n        // check proposal threshold\n        uint256 votesThreshold = proposalThreshold();\n        if (votesThreshold > 0) {\n            uint256 proposerVotes = getVotes(proposer, clock() - 1);\n            if (proposerVotes < votesThreshold) {\n                revert GovernorInsufficientProposerVotes(proposer, proposerVotes, votesThreshold);\n            }\n        }\n\n        return _propose(targets, values, calldatas, description, proposer);\n    }\n\n    /**\n     * @dev Internal propose mechanism. Can be overridden to add more logic on proposal creation.\n     *\n     * Emits a {IGovernor-ProposalCreated} event.\n     */\n    function _propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description,\n        address proposer\n    ) internal virtual returns (uint256 proposalId) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        proposalId = getProposalId(targets, values, calldatas, keccak256(bytes(description)));\n\n        if (targets.length != values.length || targets.length != calldatas.length || targets.length == 0) {\n            revert GovernorInvalidProposalLength(targets.length, calldatas.length, values.length);\n        }\n        if ($._proposals[proposalId].voteStart != 0) {\n            revert GovernorUnexpectedProposalState(proposalId, state(proposalId), bytes32(0));\n        }\n\n        uint256 snapshot = clock() + votingDelay();\n        uint256 duration = votingPeriod();\n\n        ProposalCore storage proposal = $._proposals[proposalId];\n        proposal.proposer = proposer;\n        proposal.voteStart = SafeCast.toUint48(snapshot);\n        proposal.voteDuration = SafeCast.toUint32(duration);\n\n        emit ProposalCreated(\n            proposalId,\n            proposer,\n            targets,\n            values,\n            new string[](targets.length),\n            calldatas,\n            snapshot,\n            snapshot + duration,\n            description\n        );\n\n        // Using a named return variable to avoid stack too deep errors\n    }\n\n    /// @inheritdoc IGovernor\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);\n\n        _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Succeeded));\n\n        uint48 etaSeconds = _queueOperations(proposalId, targets, values, calldatas, descriptionHash);\n\n        if (etaSeconds != 0) {\n            $._proposals[proposalId].etaSeconds = etaSeconds;\n            emit ProposalQueued(proposalId, etaSeconds);\n        } else {\n            revert GovernorQueueNotImplemented();\n        }\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Internal queuing mechanism. Can be overridden (without a super call) to modify the way queuing is\n     * performed (for example adding a vault/timelock).\n     *\n     * This is empty by default, and must be overridden to implement queuing.\n     *\n     * This function returns a timestamp that describes the expected ETA for execution. If the returned value is 0\n     * (which is the default value), the core will consider queueing did not succeed, and the public {queue} function\n     * will revert.\n     *\n     * NOTE: Calling this function directly will NOT check the current state of the proposal, or emit the\n     * `ProposalQueued` event. Queuing a proposal should be done using {queue}.\n     */\n    function _queueOperations(\n        uint256 /*proposalId*/,\n        address[] memory /*targets*/,\n        uint256[] memory /*values*/,\n        bytes[] memory /*calldatas*/,\n        bytes32 /*descriptionHash*/\n    ) internal virtual returns (uint48) {\n        return 0;\n    }\n\n    /// @inheritdoc IGovernor\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);\n\n        _validateStateBitmap(\n            proposalId,\n            _encodeStateBitmap(ProposalState.Succeeded) | _encodeStateBitmap(ProposalState.Queued)\n        );\n\n        // mark as executed before calls to avoid reentrancy\n        $._proposals[proposalId].executed = true;\n\n        // before execute: register governance call in queue.\n        if (_executor() != address(this)) {\n            for (uint256 i = 0; i < targets.length; ++i) {\n                if (targets[i] == address(this)) {\n                    $._governanceCall.pushBack(keccak256(calldatas[i]));\n                }\n            }\n        }\n\n        _executeOperations(proposalId, targets, values, calldatas, descriptionHash);\n\n        // after execute: cleanup governance call queue.\n        if (_executor() != address(this) && !$._governanceCall.empty()) {\n            $._governanceCall.clear();\n        }\n\n        emit ProposalExecuted(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Internal execution mechanism. Can be overridden (without a super call) to modify the way execution is\n     * performed (for example adding a vault/timelock).\n     *\n     * NOTE: Calling this function directly will NOT check the current state of the proposal, set the executed flag to\n     * true or emit the `ProposalExecuted` event. Executing a proposal should be done using {execute}.\n     */\n    function _executeOperations(\n        uint256 /* proposalId */,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);\n            Address.verifyCallResult(success, returndata);\n        }\n    }\n\n    /// @inheritdoc IGovernor\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256) {\n        // The proposalId will be recomputed in the `_cancel` call further down. However we need the value before we\n        // do the internal call, because we need to check the proposal state BEFORE the internal `_cancel` call\n        // changes it. The `getProposalId` duplication has a cost that is limited, and that we accept.\n        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);\n\n        address caller = _msgSender();\n        if (!_validateCancel(proposalId, caller)) revert GovernorUnableToCancel(proposalId, caller);\n\n        return _cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * @dev Internal cancel mechanism with minimal restrictions. A proposal can be cancelled in any state other than\n     * Canceled, Expired, or Executed. Once cancelled a proposal can't be re-submitted.\n     *\n     * Emits a {IGovernor-ProposalCanceled} event.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual returns (uint256) {\n        GovernorStorage storage $ = _getGovernorStorage();\n        uint256 proposalId = getProposalId(targets, values, calldatas, descriptionHash);\n\n        _validateStateBitmap(\n            proposalId,\n            ALL_PROPOSAL_STATES_BITMAP ^\n                _encodeStateBitmap(ProposalState.Canceled) ^\n                _encodeStateBitmap(ProposalState.Expired) ^\n                _encodeStateBitmap(ProposalState.Executed)\n        );\n\n        $._proposals[proposalId].canceled = true;\n        emit ProposalCanceled(proposalId);\n\n        return proposalId;\n    }\n\n    /// @inheritdoc IGovernor\n    function getVotes(address account, uint256 timepoint) public view virtual returns (uint256) {\n        return _getVotes(account, timepoint, _defaultParams());\n    }\n\n    /// @inheritdoc IGovernor\n    function getVotesWithParams(\n        address account,\n        uint256 timepoint,\n        bytes memory params\n    ) public view virtual returns (uint256) {\n        return _getVotes(account, timepoint, params);\n    }\n\n    /// @inheritdoc IGovernor\n    function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /// @inheritdoc IGovernor\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason);\n    }\n\n    /// @inheritdoc IGovernor\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason, params);\n    }\n\n    /// @inheritdoc IGovernor\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        bytes memory signature\n    ) public virtual returns (uint256) {\n        if (!_validateVoteSig(proposalId, support, voter, signature)) {\n            revert GovernorInvalidSignature(voter);\n        }\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /// @inheritdoc IGovernor\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        string calldata reason,\n        bytes memory params,\n        bytes memory signature\n    ) public virtual returns (uint256) {\n        if (!_validateExtendedVoteSig(proposalId, support, voter, reason, params, signature)) {\n            revert GovernorInvalidSignature(voter);\n        }\n        return _castVote(proposalId, voter, support, reason, params);\n    }\n\n    /// @dev Validate the `signature` used in {castVoteBySig} function.\n    function _validateVoteSig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        bytes memory signature\n    ) internal virtual returns (bool) {\n        return\n            SignatureChecker.isValidSignatureNow(\n                voter,\n                _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support, voter, _useNonce(voter)))),\n                signature\n            );\n    }\n\n    /// @dev Validate the `signature` used in {castVoteWithReasonAndParamsBySig} function.\n    function _validateExtendedVoteSig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        string memory reason,\n        bytes memory params,\n        bytes memory signature\n    ) internal virtual returns (bool) {\n        return\n            SignatureChecker.isValidSignatureNow(\n                voter,\n                _hashTypedDataV4(\n                    keccak256(\n                        abi.encode(\n                            EXTENDED_BALLOT_TYPEHASH,\n                            proposalId,\n                            support,\n                            voter,\n                            _useNonce(voter),\n                            keccak256(bytes(reason)),\n                            keccak256(params)\n                        )\n                    )\n                ),\n                signature\n            );\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function. Uses the _defaultParams().\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason\n    ) internal virtual returns (uint256) {\n        return _castVote(proposalId, account, support, reason, _defaultParams());\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual returns (uint256) {\n        _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Active));\n\n        uint256 totalWeight = _getVotes(account, proposalSnapshot(proposalId), params);\n        uint256 votedWeight = _countVote(proposalId, account, support, totalWeight, params);\n\n        if (params.length == 0) {\n            emit VoteCast(account, proposalId, support, votedWeight, reason);\n        } else {\n            emit VoteCastWithParams(account, proposalId, support, votedWeight, reason, params);\n        }\n\n        _tallyUpdated(proposalId);\n\n        return votedWeight;\n    }\n\n    /**\n     * @dev Relays a transaction or function call to an arbitrary target. In cases where the governance executor\n     * is some contract other than the governor itself, like when using a timelock, this function can be invoked\n     * in a governance proposal to recover tokens or Ether that was sent to the governor contract by mistake.\n     * Note that if the executor is simply the governor itself, use of `relay` is redundant.\n     */\n    function relay(address target, uint256 value, bytes calldata data) public payable virtual onlyGovernance {\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        Address.verifyCallResult(success, returndata);\n    }\n\n    /**\n     * @dev Address through which the governor executes action. Will be overloaded by module that executes actions\n     * through another contract such as a timelock.\n     */\n    function _executor() internal view virtual returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).\n     */\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual returns (bytes4) {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual returns (bytes4) {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @dev Encodes a `ProposalState` into a `bytes32` representation where each bit enabled corresponds to\n     * the underlying position in the `ProposalState` enum. For example:\n     *\n     * 0x000...10000\n     *   ^^^^^^------ ...\n     *         ^----- Succeeded\n     *          ^---- Defeated\n     *           ^--- Canceled\n     *            ^-- Active\n     *             ^- Pending\n     */\n    function _encodeStateBitmap(ProposalState proposalState) internal pure returns (bytes32) {\n        return bytes32(1 << uint8(proposalState));\n    }\n\n    /**\n     * @dev Check that the current state of a proposal matches the requirements described by the `allowedStates` bitmap.\n     * This bitmap should be built using `_encodeStateBitmap`.\n     *\n     * If requirements are not met, reverts with a {GovernorUnexpectedProposalState} error.\n     */\n    function _validateStateBitmap(uint256 proposalId, bytes32 allowedStates) internal view returns (ProposalState) {\n        ProposalState currentState = state(proposalId);\n        if (_encodeStateBitmap(currentState) & allowedStates == bytes32(0)) {\n            revert GovernorUnexpectedProposalState(proposalId, currentState, allowedStates);\n        }\n        return currentState;\n    }\n\n    /**\n     * @dev Check if the proposer is authorized to submit a proposal with the given description.\n     *\n     * If the proposal description ends with `#proposer=0x???`, where `0x???` is an address written as a hex string\n     * (case insensitive), then the submission of this proposal will only be authorized to said address.\n     *\n     * This is used for frontrunning protection. By adding this pattern at the end of their proposal, one can ensure\n     * that no other address can submit the same proposal. An attacker would have to either remove or change that part,\n     * which would result in a different proposal id.\n     *\n     * If the description does not match this pattern, it is unrestricted and anyone can submit it. This includes:\n     *\n     * - If the `0x???` part is not a valid hex string.\n     * - If the `0x???` part is a valid hex string, but does not contain exactly 40 hex digits.\n     * - If it ends with the expected suffix followed by newlines or other whitespace.\n     * - If it ends with some other similar suffix, e.g. `#other=abc`.\n     * - If it does not end with any such suffix.\n     */\n    function _isValidDescriptionForProposer(\n        address proposer,\n        string memory description\n    ) internal view virtual returns (bool) {\n        unchecked {\n            uint256 length = bytes(description).length;\n\n            // Length is too short to contain a valid proposer suffix\n            if (length < 52) {\n                return true;\n            }\n\n            // Extract what would be the `#proposer=` marker beginning the suffix\n            bytes10 marker = bytes10(_unsafeReadBytesOffset(bytes(description), length - 52));\n\n            // If the marker is not found, there is no proposer suffix to check\n            if (marker != bytes10(\"#proposer=\")) {\n                return true;\n            }\n\n            // Check that the last 42 characters (after the marker) are a properly formatted address.\n            (bool success, address recovered) = Strings.tryParseAddress(description, length - 42, length);\n            return !success || recovered == proposer;\n        }\n    }\n\n    /**\n     * @dev Check if the `caller` can cancel the proposal with the given `proposalId`.\n     *\n     * The default implementation allows the proposal proposer to cancel the proposal during the pending state.\n     */\n    function _validateCancel(uint256 proposalId, address caller) internal view virtual returns (bool) {\n        return (state(proposalId) == ProposalState.Pending) && caller == proposalProposer(proposalId);\n    }\n\n    /// @inheritdoc IERC6372\n    function clock() public view virtual returns (uint48);\n\n    /// @inheritdoc IERC6372\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual returns (string memory);\n\n    /// @inheritdoc IGovernor\n    function votingDelay() public view virtual returns (uint256);\n\n    /// @inheritdoc IGovernor\n    function votingPeriod() public view virtual returns (uint256);\n\n    /// @inheritdoc IGovernor\n    function quorum(uint256 timepoint) public view virtual returns (uint256);\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(add(buffer, 0x20), offset))\n        }\n    }\n}\n"
      },
      {
        "name": "TimelockControllerUpgradeable",
        "filePath": "governance/TimelockControllerUpgradeable.sol",
        "kind": "contract",
        "inherits": [
          "Initializable",
          "AccessControlUpgradeable",
          "ERC721Holder",
          "ERC1155Holder"
        ],
        "implements": [],
        "category": "governance",
        "externalFunctions": [
          {
            "name": "initialize",
            "signature": "initialize(uint256,address[],address[],address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "minDelay",
                "type": "uint256"
              },
              {
                "name": "proposers",
                "type": "address[]"
              },
              {
                "name": "executors",
                "type": "address[]"
              },
              {
                "name": "admin",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TimelockController_init",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function initialize(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) public virtual initializer {\n        __TimelockController_init(minDelay, proposers, executors, admin);\n    }",
            "startLine": 115
          },
          {
            "name": "receive",
            "signature": "receive()",
            "selector": "",
            "visibility": "external",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "receive() external payable virtual {}",
            "startLine": 176
          },
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "supportsInterface",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControlUpgradeable, ERC1155Holder) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }",
            "startLine": 179
          },
          {
            "name": "isOperation",
            "signature": "isOperation(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "getOperationState",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function isOperation(bytes32 id) public view returns (bool) {\n        return getOperationState(id) != OperationState.Unset;\n    }",
            "startLine": 189
          },
          {
            "name": "isOperationPending",
            "signature": "isOperationPending(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "getOperationState",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function isOperationPending(bytes32 id) public view returns (bool) {\n        OperationState state = getOperationState(id);\n        return state == OperationState.Waiting || state == OperationState.Ready;\n    }",
            "startLine": 196
          },
          {
            "name": "isOperationReady",
            "signature": "isOperationReady(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "getOperationState",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function isOperationReady(bytes32 id) public view returns (bool) {\n        return getOperationState(id) == OperationState.Ready;\n    }",
            "startLine": 204
          },
          {
            "name": "isOperationDone",
            "signature": "isOperationDone(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "getOperationState",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function isOperationDone(bytes32 id) public view returns (bool) {\n        return getOperationState(id) == OperationState.Done;\n    }",
            "startLine": 211
          },
          {
            "name": "getTimestamp",
            "signature": "getTimestamp(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTimelockControllerStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getTimestamp(bytes32 id) public view virtual returns (uint256) {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        return $._timestamps[id];\n    }",
            "startLine": 219
          },
          {
            "name": "getOperationState",
            "signature": "getOperationState(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "OperationState"
              }
            ],
            "calls": [
              {
                "target": "getTimestamp",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getOperationState(bytes32 id) public view virtual returns (OperationState) {\n        uint256 timestamp = getTimestamp(id);\n        if (timestamp == 0) {\n            return OperationState.Unset;\n        } else if (timestamp == DONE_TIMESTAMP) {\n            return OperationState.Done;\n        } else if (timestamp > block.timestamp) {\n            return OperationState.Waiting;\n        } else {\n            return OperationState.Ready;\n        }\n    }",
            "startLine": 227
          },
          {
            "name": "getMinDelay",
            "signature": "getMinDelay()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTimelockControllerStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getMinDelay() public view virtual returns (uint256) {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        return $._minDelay;\n    }",
            "startLine": 245
          },
          {
            "name": "hashOperation",
            "signature": "hashOperation(address,uint256,bytes,bytes32,bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "predecessor",
                "type": "bytes32"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }",
            "startLine": 254
          },
          {
            "name": "hashOperationBatch",
            "signature": "hashOperationBatch(address[],uint256[],bytes[],bytes32,bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "payloads",
                "type": "bytes[]"
              },
              {
                "name": "predecessor",
                "type": "bytes32"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\n    }",
            "startLine": 268
          },
          {
            "name": "schedule",
            "signature": "schedule(address,uint256,bytes,bytes32,bytes32,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "predecessor",
                "type": "bytes32"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "delay",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "hashOperation",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_schedule",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n        if (salt != bytes32(0)) {\n            emit CallSalt(id, salt);\n        }\n    }",
            "startLine": 287
          },
          {
            "name": "scheduleBatch",
            "signature": "scheduleBatch(address[],uint256[],bytes[],bytes32,bytes32,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "payloads",
                "type": "bytes[]"
              },
              {
                "name": "predecessor",
                "type": "bytes32"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "delay",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "hashOperationBatch",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_schedule",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        if (targets.length != values.length || targets.length != payloads.length) {\n            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);\n        }\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\n        }\n        if (salt != bytes32(0)) {\n            emit CallSalt(id, salt);\n        }\n    }",
            "startLine": 312
          },
          {
            "name": "cancel",
            "signature": "cancel(bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTimelockControllerStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "isOperationPending",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        if (!isOperationPending(id)) {\n            revert TimelockUnexpectedOperationState(\n                id,\n                _encodeStateBitmap(OperationState.Waiting) | _encodeStateBitmap(OperationState.Ready)\n            );\n        }\n        delete $._timestamps[id];\n\n        emit Cancelled(id);\n    }",
            "startLine": 356
          },
          {
            "name": "execute",
            "signature": "execute(address,uint256,bytes,bytes32,bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "payload",
                "type": "bytes"
              },
              {
                "name": "predecessor",
                "type": "bytes32"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "hashOperation",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_beforeCall",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_execute",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_afterCall",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function execute(\n        address target,\n        uint256 value,\n        bytes calldata payload,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        _execute(target, value, payload);\n        emit CallExecuted(id, 0, target, value, payload);\n        _afterCall(id);\n    }",
            "startLine": 381
          },
          {
            "name": "executeBatch",
            "signature": "executeBatch(address[],uint256[],bytes[],bytes32,bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "payloads",
                "type": "bytes[]"
              },
              {
                "name": "predecessor",
                "type": "bytes32"
              },
              {
                "name": "salt",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "hashOperationBatch",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_beforeCall",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_execute",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_afterCall",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        if (targets.length != values.length || targets.length != payloads.length) {\n            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);\n        }\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes calldata payload = payloads[i];\n            _execute(target, value, payload);\n            emit CallExecuted(id, i, target, value, payload);\n        }\n        _afterCall(id);\n    }",
            "startLine": 408
          },
          {
            "name": "updateDelay",
            "signature": "updateDelay(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newDelay",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTimelockControllerStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function updateDelay(uint256 newDelay) public virtual {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        address sender = _msgSender();\n        if (sender != address(this)) {\n            revert TimelockUnauthorizedCaller(sender);\n        }\n        emit MinDelayChange($._minDelay, newDelay);\n        $._minDelay = newDelay;\n    }",
            "startLine": 473
          }
        ],
        "internalFunctions": [
          {
            "name": "_getTimelockControllerStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "TimelockControllerStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getTimelockControllerStorage() private pure returns (TimelockControllerStorage storage $) {\n        assembly {\n            $.slot := TimelockControllerStorageLocation\n        }\n    }",
            "startLine": 40
          },
          {
            "name": "__TimelockController_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "minDelay",
                "type": "uint256"
              },
              {
                "name": "proposers",
                "type": "address[]"
              },
              {
                "name": "executors",
                "type": "address[]"
              },
              {
                "name": "admin",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __TimelockController_init(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {\n        __TimelockController_init_unchained(minDelay, proposers, executors, admin);\n    }",
            "startLine": 131
          },
          {
            "name": "__TimelockController_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "minDelay",
                "type": "uint256"
              },
              {
                "name": "proposers",
                "type": "address[]"
              },
              {
                "name": "executors",
                "type": "address[]"
              },
              {
                "name": "admin",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTimelockControllerStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_grantRole",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __TimelockController_init_unchained(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        // self administration\n        _grantRole(DEFAULT_ADMIN_ROLE, address(this));\n\n        // optional admin\n        if (admin != address(0)) {\n            _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        }\n\n        // register proposers and cancellers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _grantRole(PROPOSER_ROLE, proposers[i]);\n            _grantRole(CANCELLER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _grantRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        $._minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }",
            "startLine": 135
          },
          {
            "name": "_schedule",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              },
              {
                "name": "delay",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTimelockControllerStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "isOperation",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "getMinDelay",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _schedule(bytes32 id, uint256 delay) private {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        if (isOperation(id)) {\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Unset));\n        }\n        uint256 minDelay = getMinDelay();\n        if (delay < minDelay) {\n            revert TimelockInsufficientDelay(delay, minDelay);\n        }\n        $._timestamps[id] = block.timestamp + delay;\n    }",
            "startLine": 337
          },
          {
            "name": "_execute",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "Address.verifyCallResult",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _execute(address target, uint256 value, bytes calldata data) internal virtual {\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        Address.verifyCallResult(success, returndata);\n    }",
            "startLine": 435
          },
          {
            "name": "_beforeCall",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              },
              {
                "name": "predecessor",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "isOperationReady",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "isOperationDone",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        if (!isOperationReady(id)) {\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));\n        }\n        if (predecessor != bytes32(0) && !isOperationDone(predecessor)) {\n            revert TimelockUnexecutedPredecessor(predecessor);\n        }\n    }",
            "startLine": 443
          },
          {
            "name": "_afterCall",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTimelockControllerStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "isOperationReady",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _afterCall(bytes32 id) private {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        if (!isOperationReady(id)) {\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));\n        }\n        $._timestamps[id] = DONE_TIMESTAMP;\n    }",
            "startLine": 455
          },
          {
            "name": "_encodeStateBitmap",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "operationState",
                "type": "OperationState"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _encodeStateBitmap(OperationState operationState) internal pure returns (bytes32) {\n        return bytes32(1 << uint8(operationState));\n    }",
            "startLine": 494
          }
        ],
        "events": [
          {
            "name": "CallScheduled",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "index",
                "type": "uint256",
                "indexed": true
              },
              {
                "name": "target",
                "type": "address",
                "indexed": false
              },
              {
                "name": "value",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "data",
                "type": "bytes",
                "indexed": false
              },
              {
                "name": "predecessor",
                "type": "bytes32",
                "indexed": false
              },
              {
                "name": "delay",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 85
          },
          {
            "name": "CallExecuted",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "index",
                "type": "uint256",
                "indexed": true
              },
              {
                "name": "target",
                "type": "address",
                "indexed": false
              },
              {
                "name": "value",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "data",
                "type": "bytes",
                "indexed": false
              }
            ],
            "startLine": 98
          },
          {
            "name": "CallSalt",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "salt",
                "type": "bytes32",
                "indexed": false
              }
            ],
            "startLine": 103
          },
          {
            "name": "Cancelled",
            "parameters": [
              {
                "name": "id",
                "type": "bytes32",
                "indexed": true
              }
            ],
            "startLine": 108
          },
          {
            "name": "MinDelayChange",
            "parameters": [
              {
                "name": "oldDuration",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "newDuration",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 113
          }
        ],
        "errors": [
          {
            "name": "TimelockInvalidOperationLength",
            "parameters": [
              {
                "name": "targets",
                "type": "uint256"
              },
              {
                "name": "payloads",
                "type": "uint256"
              },
              {
                "name": "values",
                "type": "uint256"
              }
            ],
            "startLine": 56
          },
          {
            "name": "TimelockInsufficientDelay",
            "parameters": [
              {
                "name": "delay",
                "type": "uint256"
              },
              {
                "name": "minDelay",
                "type": "uint256"
              }
            ],
            "startLine": 61
          },
          {
            "name": "TimelockUnexpectedOperationState",
            "parameters": [
              {
                "name": "operationId",
                "type": "bytes32"
              },
              {
                "name": "expectedStates",
                "type": "bytes32"
              }
            ],
            "startLine": 70
          },
          {
            "name": "TimelockUnexecutedPredecessor",
            "parameters": [
              {
                "name": "predecessorId",
                "type": "bytes32"
              }
            ],
            "startLine": 75
          },
          {
            "name": "TimelockUnauthorizedCaller",
            "parameters": [
              {
                "name": "caller",
                "type": "address"
              }
            ],
            "startLine": 80
          }
        ],
        "structs": [
          {
            "name": "TimelockControllerStorage",
            "members": [
              {
                "name": "_timestamps",
                "type": "mapping(bytes32 => uint256)"
              },
              {
                "name": "_minDelay",
                "type": "uint256"
              }
            ],
            "startLine": 32
          }
        ],
        "stateVariables": [
          {
            "name": "PROPOSER_ROLE",
            "type": "bytes32",
            "visibility": "public",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 26
          },
          {
            "name": "EXECUTOR_ROLE",
            "type": "bytes32",
            "visibility": "public",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 27
          },
          {
            "name": "CANCELLER_ROLE",
            "type": "bytes32",
            "visibility": "public",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 28
          },
          {
            "name": "DONE_TIMESTAMP",
            "type": "uint256",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 29
          },
          {
            "name": "TimelockControllerStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 38
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../access/AccessControlUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/Address.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (governance/TimelockController.sol)\n\npragma solidity ^0.8.20;\n\nimport {AccessControlUpgradeable} from \"../access/AccessControlUpgradeable.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {ERC1155Holder} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n */\ncontract TimelockControllerUpgradeable is Initializable, AccessControlUpgradeable, ERC721Holder, ERC1155Holder {\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\");\n    uint256 internal constant DONE_TIMESTAMP = uint256(1);\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.TimelockController\n    struct TimelockControllerStorage {\n        mapping(bytes32 id => uint256) _timestamps;\n        uint256 _minDelay;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.TimelockController\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant TimelockControllerStorageLocation = 0x9a37c2aa9d186a0969ff8a8267bf4e07e864c2f2768f5040949e28a624fb3600;\n\n    function _getTimelockControllerStorage() private pure returns (TimelockControllerStorage storage $) {\n        assembly {\n            $.slot := TimelockControllerStorageLocation\n        }\n    }\n\n    enum OperationState {\n        Unset,\n        Waiting,\n        Ready,\n        Done\n    }\n\n    /**\n     * @dev Mismatch between the parameters length for an operation call.\n     */\n    error TimelockInvalidOperationLength(uint256 targets, uint256 payloads, uint256 values);\n\n    /**\n     * @dev The schedule operation doesn't meet the minimum delay.\n     */\n    error TimelockInsufficientDelay(uint256 delay, uint256 minDelay);\n\n    /**\n     * @dev The current state of an operation is not as required.\n     * The `expectedStates` is a bitmap with the bits enabled for each OperationState enum position\n     * counting from right to left.\n     *\n     * See {_encodeStateBitmap}.\n     */\n    error TimelockUnexpectedOperationState(bytes32 operationId, bytes32 expectedStates);\n\n    /**\n     * @dev The predecessor to an operation not yet done.\n     */\n    error TimelockUnexecutedPredecessor(bytes32 predecessorId);\n\n    /**\n     * @dev The caller account is not authorized.\n     */\n    error TimelockUnauthorizedCaller(address caller);\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when new proposal is scheduled with non-zero salt.\n     */\n    event CallSalt(bytes32 indexed id, bytes32 salt);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    function initialize(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) public virtual initializer {\n        __TimelockController_init(minDelay, proposers, executors, admin);\n    }\n    /**\n     * @dev Initializes the contract with the following parameters:\n     *\n     * - `minDelay`: initial minimum delay in seconds for operations\n     * - `proposers`: accounts to be granted proposer and canceller roles\n     * - `executors`: accounts to be granted executor role\n     * - `admin`: optional account to be granted admin role; disable with zero address\n     *\n     * IMPORTANT: The optional admin can aid with initial configuration of roles after deployment\n     * without being subject to delay, but this role should be subsequently renounced in favor of\n     * administration through timelocked proposals. Previous versions of this contract would assign\n     * this admin to the deployer automatically and should be renounced as well.\n     */\n    function __TimelockController_init(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {\n        __TimelockController_init_unchained(minDelay, proposers, executors, admin);\n    }\n\n    function __TimelockController_init_unchained(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        // self administration\n        _grantRole(DEFAULT_ADMIN_ROLE, address(this));\n\n        // optional admin\n        if (admin != address(0)) {\n            _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        }\n\n        // register proposers and cancellers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _grantRole(PROPOSER_ROLE, proposers[i]);\n            _grantRole(CANCELLER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _grantRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        $._minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable virtual {}\n\n    /// @inheritdoc AccessControlUpgradeable\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControlUpgradeable, ERC1155Holder) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns whether an id corresponds to a registered operation. This\n     * includes both Waiting, Ready, and Done operations.\n     */\n    function isOperation(bytes32 id) public view returns (bool) {\n        return getOperationState(id) != OperationState.Unset;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not. Note that a \"pending\" operation may also be \"ready\".\n     */\n    function isOperationPending(bytes32 id) public view returns (bool) {\n        OperationState state = getOperationState(id);\n        return state == OperationState.Waiting || state == OperationState.Ready;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready for execution. Note that a \"ready\" operation is also \"pending\".\n     */\n    function isOperationReady(bytes32 id) public view returns (bool) {\n        return getOperationState(id) == OperationState.Ready;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view returns (bool) {\n        return getOperationState(id) == OperationState.Done;\n    }\n\n    /**\n     * @dev Returns the timestamp at which an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256) {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        return $._timestamps[id];\n    }\n\n    /**\n     * @dev Returns operation state.\n     */\n    function getOperationState(bytes32 id) public view virtual returns (OperationState) {\n        uint256 timestamp = getTimestamp(id);\n        if (timestamp == 0) {\n            return OperationState.Unset;\n        } else if (timestamp == DONE_TIMESTAMP) {\n            return OperationState.Done;\n        } else if (timestamp > block.timestamp) {\n            return OperationState.Waiting;\n        } else {\n            return OperationState.Ready;\n        }\n    }\n\n    /**\n     * @dev Returns the minimum delay in seconds for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256) {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        return $._minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits {CallSalt} if salt is nonzero, and {CallScheduled}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n        if (salt != bytes32(0)) {\n            emit CallSalt(id, salt);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits {CallSalt} if salt is nonzero, and one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        if (targets.length != values.length || targets.length != payloads.length) {\n            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);\n        }\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\n        }\n        if (salt != bytes32(0)) {\n            emit CallSalt(id, salt);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to become valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        if (isOperation(id)) {\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Unset));\n        }\n        uint256 minDelay = getMinDelay();\n        if (delay < minDelay) {\n            revert TimelockInsufficientDelay(delay, minDelay);\n        }\n        $._timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'canceller' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        if (!isOperationPending(id)) {\n            revert TimelockUnexpectedOperationState(\n                id,\n                _encodeStateBitmap(OperationState.Waiting) | _encodeStateBitmap(OperationState.Ready)\n            );\n        }\n        delete $._timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute a ready operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata payload,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        _execute(target, value, payload);\n        emit CallExecuted(id, 0, target, value, payload);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute a ready operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        if (targets.length != values.length || targets.length != payloads.length) {\n            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);\n        }\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes calldata payload = payloads[i];\n            _execute(target, value, payload);\n            emit CallExecuted(id, i, target, value, payload);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     */\n    function _execute(address target, uint256 value, bytes calldata data) internal virtual {\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        Address.verifyCallResult(success, returndata);\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        if (!isOperationReady(id)) {\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));\n        }\n        if (predecessor != bytes32(0) && !isOperationDone(predecessor)) {\n            revert TimelockUnexecutedPredecessor(predecessor);\n        }\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        if (!isOperationReady(id)) {\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));\n        }\n        $._timestamps[id] = DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) public virtual {\n        TimelockControllerStorage storage $ = _getTimelockControllerStorage();\n        address sender = _msgSender();\n        if (sender != address(this)) {\n            revert TimelockUnauthorizedCaller(sender);\n        }\n        emit MinDelayChange($._minDelay, newDelay);\n        $._minDelay = newDelay;\n    }\n\n    /**\n     * @dev Encodes a `OperationState` into a `bytes32` representation where each bit enabled corresponds to\n     * the underlying position in the `OperationState` enum. For example:\n     *\n     * 0x000...1000\n     *   ^^^^^^----- ...\n     *         ^---- Done\n     *          ^--- Ready\n     *           ^-- Waiting\n     *            ^- Unset\n     */\n    function _encodeStateBitmap(OperationState operationState) internal pure returns (bytes32) {\n        return bytes32(1 << uint8(operationState));\n    }\n}\n"
      },
      {
        "name": "GovernorCountingFractionalUpgradeable",
        "filePath": "governance/extensions/GovernorCountingFractionalUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "GovernorUpgradeable"
        ],
        "implements": [],
        "category": "governance/extensions",
        "externalFunctions": [
          {
            "name": "COUNTING_MODE",
            "signature": "COUNTING_MODE()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo,fractional&quorum=for,abstain&params=fractional\";\n    }",
            "startLine": 77
          },
          {
            "name": "hasVoted",
            "signature": "hasVoted(uint256,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "usedVotes",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return usedVotes(proposalId, account) > 0;\n    }",
            "startLine": 82
          },
          {
            "name": "usedVotes",
            "signature": "usedVotes(uint256,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorCountingFractionalStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function usedVotes(uint256 proposalId, address account) public view virtual returns (uint256) {\n        GovernorCountingFractionalStorage storage $ = _getGovernorCountingFractionalStorage();\n        return $._proposalVotes[proposalId].usedVotes[account];\n    }",
            "startLine": 90
          },
          {
            "name": "proposalVotes",
            "signature": "proposalVotes(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "againstVotes",
                "type": "uint256"
              },
              {
                "name": "forVotes",
                "type": "uint256"
              },
              {
                "name": "abstainVotes",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorCountingFractionalStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalVotes(\n        uint256 proposalId\n    ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) {\n        GovernorCountingFractionalStorage storage $ = _getGovernorCountingFractionalStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n        return (proposalVote.againstVotes, proposalVote.forVotes, proposalVote.abstainVotes);\n    }",
            "startLine": 98
          }
        ],
        "internalFunctions": [
          {
            "name": "_getGovernorCountingFractionalStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "GovernorCountingFractionalStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getGovernorCountingFractionalStorage() private pure returns (GovernorCountingFractionalStorage storage $) {\n        assembly {\n            $.slot := GovernorCountingFractionalStorageLocation\n        }\n    }",
            "startLine": 59
          },
          {
            "name": "__GovernorCountingFractional_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorCountingFractional_init() internal onlyInitializing {\n    }",
            "startLine": 70
          },
          {
            "name": "__GovernorCountingFractional_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorCountingFractional_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 73
          },
          {
            "name": "_quorumReached",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorCountingFractionalStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "quorum",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "proposalSnapshot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        GovernorCountingFractionalStorage storage $ = _getGovernorCountingFractionalStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n        return quorum(proposalSnapshot(proposalId)) <= proposalVote.forVotes + proposalVote.abstainVotes;\n    }",
            "startLine": 107
          },
          {
            "name": "_voteSucceeded",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorCountingFractionalStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        GovernorCountingFractionalStorage storage $ = _getGovernorCountingFractionalStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n        return proposalVote.forVotes > proposalVote.againstVotes;\n    }",
            "startLine": 116
          },
          {
            "name": "_countVote",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "support",
                "type": "uint8"
              },
              {
                "name": "totalWeight",
                "type": "uint256"
              },
              {
                "name": "params",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorCountingFractionalStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Math.trySub",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "usedVotes",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 totalWeight,\n        bytes memory params\n    ) internal virtual override returns (uint256) {\n        GovernorCountingFractionalStorage storage $ = _getGovernorCountingFractionalStorage();\n        // Compute number of remaining votes. Returns 0 on overflow.\n        (, uint256 remainingWeight) = totalWeight.trySub(usedVotes(proposalId, account));\n        if (remainingWeight == 0) {\n            revert GovernorAlreadyCastVote(account);\n        }\n\n        uint256 againstVotes = 0;\n        uint256 forVotes = 0;\n        uint256 abstainVotes = 0;\n        uint256 usedWeight = 0;\n\n        // For clarity of event indexing, fractional voting must be clearly advertised in the \"support\" field.\n        //\n        // Supported `support` value must be:\n        // - \"Full\" voting: `support = 0` (Against), `1` (For) or `2` (Abstain), with empty params.\n        // - \"Fractional\" voting: `support = 255`, with 48 bytes params.\n        if (support == uint8(GovernorCountingSimpleUpgradeable.VoteType.Against)) {\n            if (params.length != 0) revert GovernorInvalidVoteParams();\n            usedWeight = againstVotes = remainingWeight;\n        } else if (support == uint8(GovernorCountingSimpleUpgradeable.VoteType.For)) {\n            if (params.length != 0) revert GovernorInvalidVoteParams();\n            usedWeight = forVotes = remainingWeight;\n        } else if (support == uint8(GovernorCountingSimpleUpgradeable.VoteType.Abstain)) {\n            if (params.length != 0) revert GovernorInvalidVoteParams();\n            usedWeight = abstainVotes = remainingWeight;\n        } else if (support == VOTE_TYPE_FRACTIONAL) {\n            // The `params` argument is expected to be three packed `uint128`:\n            // `abi.encodePacked(uint128(againstVotes), uint128(forVotes), uint128(abstainVotes))`\n            if (params.length != 0x30) revert GovernorInvalidVoteParams();\n\n            assembly (\"memory-safe\") {\n                againstVotes := shr(128, mload(add(params, 0x20)))\n                forVotes := shr(128, mload(add(params, 0x30)))\n                abstainVotes := shr(128, mload(add(params, 0x40)))\n                usedWeight := add(add(againstVotes, forVotes), abstainVotes) // inputs are uint128: cannot overflow\n            }\n\n            // check parsed arguments are valid\n            if (usedWeight > remainingWeight) {\n                revert GovernorExceedRemainingWeight(account, usedWeight, remainingWeight);\n            }\n        } else {\n            revert GovernorInvalidVoteType();\n        }\n\n        // update votes tracking\n        ProposalVote storage details = $._proposalVotes[proposalId];\n        if (againstVotes > 0) details.againstVotes += againstVotes;\n        if (forVotes > 0) details.forVotes += forVotes;\n        if (abstainVotes > 0) details.abstainVotes += abstainVotes;\n        details.usedVotes[account] += usedWeight;\n\n        return usedWeight;\n    }",
            "startLine": 152
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "GovernorExceedRemainingWeight",
            "parameters": [
              {
                "name": "voter",
                "type": "address"
              },
              {
                "name": "usedVotes",
                "type": "uint256"
              },
              {
                "name": "remainingWeight",
                "type": "uint256"
              }
            ],
            "startLine": 68
          }
        ],
        "structs": [
          {
            "name": "ProposalVote",
            "members": [
              {
                "name": "againstVotes",
                "type": "uint256"
              },
              {
                "name": "forVotes",
                "type": "uint256"
              },
              {
                "name": "abstainVotes",
                "type": "uint256"
              },
              {
                "name": "usedVotes",
                "type": "mapping(address => uint256)"
              }
            ],
            "startLine": 41
          },
          {
            "name": "GovernorCountingFractionalStorage",
            "members": [
              {
                "name": "_proposalVotes",
                "type": "mapping(uint256 => ProposalVote)"
              }
            ],
            "startLine": 49
          }
        ],
        "stateVariables": [
          {
            "name": "VOTE_TYPE_FRACTIONAL",
            "type": "uint8",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 39
          },
          {
            "name": "GovernorCountingFractionalStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 57
          }
        ],
        "usesLibraries": [
          "Math"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/governance/IGovernor.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../GovernorUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./GovernorCountingSimpleUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/math/Math.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorCountingFractional.sol)\n\npragma solidity ^0.8.24;\n\nimport {IGovernor} from \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {GovernorCountingSimpleUpgradeable} from \"./GovernorCountingSimpleUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for fractional voting.\n *\n * Similar to {GovernorCountingSimple}, this contract is a votes counting module for {Governor} that supports 3 options:\n * Against, For, Abstain. Additionally, it includes a fourth option: Fractional, which allows voters to split their voting\n * power amongst the other 3 options.\n *\n * Votes cast with the Fractional support must be accompanied by a `params` argument that is three packed `uint128` values\n * representing the weight the delegate assigns to Against, For, and Abstain respectively. For those votes cast for the other\n * 3 options, the `params` argument must be empty.\n *\n * This is mostly useful when the delegate is a contract that implements its own rules for voting. These delegate-contracts\n * can cast fractional votes according to the preferences of multiple entities delegating their voting power.\n *\n * Some example use cases include:\n *\n * * Voting from tokens that are held by a DeFi pool\n * * Voting from an L2 with tokens held by a bridge\n * * Voting privately from a shielded pool using zero knowledge proofs.\n *\n * Based on ScopeLift's https://github.com/ScopeLift/flexible-voting/blob/e5de2efd1368387b840931f19f3c184c85842761/src/GovernorCountingFractional.sol[`GovernorCountingFractional`]\n *\n * _Available since v5.1._\n */\nabstract contract GovernorCountingFractionalUpgradeable is Initializable, GovernorUpgradeable {\n    using Math for *;\n\n    uint8 internal constant VOTE_TYPE_FRACTIONAL = 255;\n\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address voter => uint256) usedVotes;\n    }\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorCountingFractional\n    struct GovernorCountingFractionalStorage {\n        /**\n         * @dev Mapping from proposal ID to vote tallies for that proposal.\n         */\n        mapping(uint256 proposalId => ProposalVote) _proposalVotes;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorCountingFractional\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorCountingFractionalStorageLocation = 0xd073797d8f9d07d835a3fc13195afeafd2f137da609f97a44f7a3aa434170800;\n\n    function _getGovernorCountingFractionalStorage() private pure returns (GovernorCountingFractionalStorage storage $) {\n        assembly {\n            $.slot := GovernorCountingFractionalStorageLocation\n        }\n    }\n\n    /**\n     * @dev A fractional vote params uses more votes than are available for that user.\n     */\n    error GovernorExceedRemainingWeight(address voter, uint256 usedVotes, uint256 remainingWeight);\n\n    function __GovernorCountingFractional_init() internal onlyInitializing {\n    }\n\n    function __GovernorCountingFractional_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IGovernor\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo,fractional&quorum=for,abstain&params=fractional\";\n    }\n\n    /// @inheritdoc IGovernor\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return usedVotes(proposalId, account) > 0;\n    }\n\n    /**\n     * @dev Get the number of votes already cast by `account` for a proposal with `proposalId`. Useful for\n     * integrations that allow delegates to cast rolling, partial votes.\n     */\n    function usedVotes(uint256 proposalId, address account) public view virtual returns (uint256) {\n        GovernorCountingFractionalStorage storage $ = _getGovernorCountingFractionalStorage();\n        return $._proposalVotes[proposalId].usedVotes[account];\n    }\n\n    /**\n     * @dev Get current distribution of votes for a given proposal.\n     */\n    function proposalVotes(\n        uint256 proposalId\n    ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) {\n        GovernorCountingFractionalStorage storage $ = _getGovernorCountingFractionalStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n        return (proposalVote.againstVotes, proposalVote.forVotes, proposalVote.abstainVotes);\n    }\n\n    /// @inheritdoc GovernorUpgradeable\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        GovernorCountingFractionalStorage storage $ = _getGovernorCountingFractionalStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n        return quorum(proposalSnapshot(proposalId)) <= proposalVote.forVotes + proposalVote.abstainVotes;\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, forVotes must be > againstVotes.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        GovernorCountingFractionalStorage storage $ = _getGovernorCountingFractionalStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n        return proposalVote.forVotes > proposalVote.againstVotes;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. Function that records the delegate's votes.\n     *\n     * Executing this function consumes (part of) the delegate's weight on the proposal. This weight can be\n     * distributed amongst the 3 options (Against, For, Abstain) by specifying a fractional `support`.\n     *\n     * This counting module supports two vote casting modes: nominal and fractional.\n     *\n     * - Nominal: A nominal vote is cast by setting `support` to one of the 3 bravo options (Against, For, Abstain).\n     * - Fractional: A fractional vote is cast by setting `support` to `type(uint8).max` (255).\n     *\n     * Casting a nominal vote requires `params` to be empty and consumes the delegate's full remaining weight on the\n     * proposal for the specified `support` option. This is similar to the {GovernorCountingSimple} module and follows\n     * the `VoteType` enum from Governor Bravo. As a consequence, no vote weight remains unspent so no further voting\n     * is possible (for this `proposalId` and this `account`).\n     *\n     * Casting a fractional vote consumes a fraction of the delegate's remaining weight on the proposal according to the\n     * weights the delegate assigns to each support option (Against, For, Abstain respectively). The sum total of the\n     * three decoded vote weights _must_ be less than or equal to the delegate's remaining weight on the proposal (i.e.\n     * their checkpointed total weight minus votes already cast on the proposal). This format can be produced using:\n     *\n     * `abi.encodePacked(uint128(againstVotes), uint128(forVotes), uint128(abstainVotes))`\n     *\n     * NOTE: Consider that fractional voting restricts the number of casted votes (in each category) to 128 bits.\n     * Depending on how many decimals the underlying token has, a single voter may require to split their vote into\n     * multiple vote operations. For precision higher than ~30 decimals, large token holders may require a\n     * potentially large number of calls to cast all their votes. The voter has the possibility to cast all the\n     * remaining votes in a single operation using the traditional \"bravo\" vote.\n     */\n    // slither-disable-next-line cyclomatic-complexity\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 totalWeight,\n        bytes memory params\n    ) internal virtual override returns (uint256) {\n        GovernorCountingFractionalStorage storage $ = _getGovernorCountingFractionalStorage();\n        // Compute number of remaining votes. Returns 0 on overflow.\n        (, uint256 remainingWeight) = totalWeight.trySub(usedVotes(proposalId, account));\n        if (remainingWeight == 0) {\n            revert GovernorAlreadyCastVote(account);\n        }\n\n        uint256 againstVotes = 0;\n        uint256 forVotes = 0;\n        uint256 abstainVotes = 0;\n        uint256 usedWeight = 0;\n\n        // For clarity of event indexing, fractional voting must be clearly advertised in the \"support\" field.\n        //\n        // Supported `support` value must be:\n        // - \"Full\" voting: `support = 0` (Against), `1` (For) or `2` (Abstain), with empty params.\n        // - \"Fractional\" voting: `support = 255`, with 48 bytes params.\n        if (support == uint8(GovernorCountingSimpleUpgradeable.VoteType.Against)) {\n            if (params.length != 0) revert GovernorInvalidVoteParams();\n            usedWeight = againstVotes = remainingWeight;\n        } else if (support == uint8(GovernorCountingSimpleUpgradeable.VoteType.For)) {\n            if (params.length != 0) revert GovernorInvalidVoteParams();\n            usedWeight = forVotes = remainingWeight;\n        } else if (support == uint8(GovernorCountingSimpleUpgradeable.VoteType.Abstain)) {\n            if (params.length != 0) revert GovernorInvalidVoteParams();\n            usedWeight = abstainVotes = remainingWeight;\n        } else if (support == VOTE_TYPE_FRACTIONAL) {\n            // The `params` argument is expected to be three packed `uint128`:\n            // `abi.encodePacked(uint128(againstVotes), uint128(forVotes), uint128(abstainVotes))`\n            if (params.length != 0x30) revert GovernorInvalidVoteParams();\n\n            assembly (\"memory-safe\") {\n                againstVotes := shr(128, mload(add(params, 0x20)))\n                forVotes := shr(128, mload(add(params, 0x30)))\n                abstainVotes := shr(128, mload(add(params, 0x40)))\n                usedWeight := add(add(againstVotes, forVotes), abstainVotes) // inputs are uint128: cannot overflow\n            }\n\n            // check parsed arguments are valid\n            if (usedWeight > remainingWeight) {\n                revert GovernorExceedRemainingWeight(account, usedWeight, remainingWeight);\n            }\n        } else {\n            revert GovernorInvalidVoteType();\n        }\n\n        // update votes tracking\n        ProposalVote storage details = $._proposalVotes[proposalId];\n        if (againstVotes > 0) details.againstVotes += againstVotes;\n        if (forVotes > 0) details.forVotes += forVotes;\n        if (abstainVotes > 0) details.abstainVotes += abstainVotes;\n        details.usedVotes[account] += usedWeight;\n\n        return usedWeight;\n    }\n}\n"
      },
      {
        "name": "GovernorCountingOverridableUpgradeable",
        "filePath": "governance/extensions/GovernorCountingOverridableUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "GovernorVotesUpgradeable"
        ],
        "implements": [],
        "category": "governance/extensions",
        "externalFunctions": [
          {
            "name": "COUNTING_MODE",
            "signature": "COUNTING_MODE()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo,override&quorum=for,abstain&overridable=true\";\n    }",
            "startLine": 71
          },
          {
            "name": "hasVoted",
            "signature": "hasVoted(uint256,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorCountingOverridableStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        GovernorCountingOverridableStorage storage $ = _getGovernorCountingOverridableStorage();\n        return $._proposalVotes[proposalId].voteReceipt[account].casted != 0;\n    }",
            "startLine": 83
          },
          {
            "name": "hasVotedOverride",
            "signature": "hasVotedOverride(uint256,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorCountingOverridableStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function hasVotedOverride(uint256 proposalId, address account) public view virtual returns (bool) {\n        GovernorCountingOverridableStorage storage $ = _getGovernorCountingOverridableStorage();\n        return $._proposalVotes[proposalId].voteReceipt[account].hasOverridden;\n    }",
            "startLine": 91
          },
          {
            "name": "proposalVotes",
            "signature": "proposalVotes(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "againstVotes",
                "type": "uint256"
              },
              {
                "name": "forVotes",
                "type": "uint256"
              },
              {
                "name": "abstainVotes",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorCountingOverridableStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalVotes(\n        uint256 proposalId\n    ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) {\n        GovernorCountingOverridableStorage storage $ = _getGovernorCountingOverridableStorage();\n        uint256[3] storage votes = $._proposalVotes[proposalId].votes;\n        return (votes[uint8(VoteType.Against)], votes[uint8(VoteType.For)], votes[uint8(VoteType.Abstain)]);\n    }",
            "startLine": 99
          },
          {
            "name": "castOverrideVote",
            "signature": "castOverrideVote(uint256,uint8,string)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "support",
                "type": "uint8"
              },
              {
                "name": "reason",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_castOverride",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function castOverrideVote(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256) {\n        address voter = _msgSender();\n        return _castOverride(proposalId, voter, support, reason);\n    }",
            "startLine": 208
          },
          {
            "name": "castOverrideVoteBySig",
            "signature": "castOverrideVoteBySig(uint256,uint8,address,string,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "support",
                "type": "uint8"
              },
              {
                "name": "voter",
                "type": "address"
              },
              {
                "name": "reason",
                "type": "string"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "SignatureChecker.isValidSignatureNow",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "_hashTypedDataV4",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_useNonce",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_castOverride",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function castOverrideVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        string calldata reason,\n        bytes calldata signature\n    ) public virtual returns (uint256) {\n        bool valid = SignatureChecker.isValidSignatureNow(\n            voter,\n            _hashTypedDataV4(\n                keccak256(\n                    abi.encode(\n                        OVERRIDE_BALLOT_TYPEHASH,\n                        proposalId,\n                        support,\n                        voter,\n                        _useNonce(voter),\n                        keccak256(bytes(reason))\n                    )\n                )\n            ),\n            signature\n        );\n\n        if (!valid) {\n            revert GovernorInvalidSignature(voter);\n        }\n\n        return _castOverride(proposalId, voter, support, reason);\n    }",
            "startLine": 218
          }
        ],
        "internalFunctions": [
          {
            "name": "_getGovernorCountingOverridableStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "GovernorCountingOverridableStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getGovernorCountingOverridableStorage() private pure returns (GovernorCountingOverridableStorage storage $) {\n        assembly {\n            $.slot := GovernorCountingOverridableStorageLocation\n        }\n    }",
            "startLine": 58
          },
          {
            "name": "__GovernorCountingOverridable_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorCountingOverridable_init() internal onlyInitializing {\n    }",
            "startLine": 64
          },
          {
            "name": "__GovernorCountingOverridable_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorCountingOverridable_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 67
          },
          {
            "name": "_quorumReached",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorCountingOverridableStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "quorum",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "proposalSnapshot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        GovernorCountingOverridableStorage storage $ = _getGovernorCountingOverridableStorage();\n        uint256[3] storage votes = $._proposalVotes[proposalId].votes;\n        return quorum(proposalSnapshot(proposalId)) <= votes[uint8(VoteType.For)] + votes[uint8(VoteType.Abstain)];\n    }",
            "startLine": 108
          },
          {
            "name": "_voteSucceeded",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorCountingOverridableStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        GovernorCountingOverridableStorage storage $ = _getGovernorCountingOverridableStorage();\n        uint256[3] storage votes = $._proposalVotes[proposalId].votes;\n        return votes[uint8(VoteType.For)] > votes[uint8(VoteType.Against)];\n    }",
            "startLine": 117
          },
          {
            "name": "_countVote",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "support",
                "type": "uint8"
              },
              {
                "name": "totalWeight",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorCountingOverridableStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 totalWeight,\n        bytes memory /*params*/\n    ) internal virtual override returns (uint256) {\n        GovernorCountingOverridableStorage storage $ = _getGovernorCountingOverridableStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n\n        if (support > uint8(VoteType.Abstain)) {\n            revert GovernorInvalidVoteType();\n        }\n\n        if (proposalVote.voteReceipt[account].casted != 0) {\n            revert GovernorAlreadyCastVote(account);\n        }\n\n        totalWeight -= proposalVote.voteReceipt[account].overriddenWeight;\n        proposalVote.votes[support] += totalWeight;\n        proposalVote.voteReceipt[account].casted = support + 1;\n\n        return totalWeight;\n    }",
            "startLine": 129
          },
          {
            "name": "_countOverride",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "support",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorCountingOverridableStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "proposalSnapshot",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "getPastBalanceOf",
                "type": "external",
                "targetType": "VotesExtendedUpgradeable",
                "argCount": 2
              },
              {
                "target": "VotesExtendedUpgradeable",
                "type": "external",
                "argCount": 1
              },
              {
                "target": "token",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "getPastDelegate",
                "type": "external",
                "targetType": "VotesExtendedUpgradeable",
                "argCount": 2
              },
              {
                "target": "SafeCast.toUint208",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _countOverride(uint256 proposalId, address account, uint8 support) internal virtual returns (uint256) {\n        GovernorCountingOverridableStorage storage $ = _getGovernorCountingOverridableStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n\n        if (support > uint8(VoteType.Abstain)) {\n            revert GovernorInvalidVoteType();\n        }\n\n        if (proposalVote.voteReceipt[account].hasOverridden) {\n            revert GovernorAlreadyOverriddenVote(account);\n        }\n\n        uint256 snapshot = proposalSnapshot(proposalId);\n        uint256 overriddenWeight = VotesExtendedUpgradeable(address(token())).getPastBalanceOf(account, snapshot);\n        address delegate = VotesExtendedUpgradeable(address(token())).getPastDelegate(account, snapshot);\n        uint8 delegateCasted = proposalVote.voteReceipt[delegate].casted;\n\n        proposalVote.voteReceipt[account].hasOverridden = true;\n        proposalVote.votes[support] += overriddenWeight;\n        if (delegateCasted == 0) {\n            proposalVote.voteReceipt[delegate].overriddenWeight += SafeCast.toUint208(overriddenWeight);\n        } else {\n            uint8 delegateSupport = delegateCasted - 1;\n            proposalVote.votes[delegateSupport] -= overriddenWeight;\n            emit VoteReduced(delegate, proposalId, delegateSupport, overriddenWeight);\n        }\n\n        return overriddenWeight;\n    }",
            "startLine": 159
          },
          {
            "name": "_castOverride",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "support",
                "type": "uint8"
              },
              {
                "name": "reason",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_validateStateBitmap",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_encodeStateBitmap",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_countOverride",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _castOverride(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string calldata reason\n    ) internal virtual returns (uint256) {\n        _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Active));\n\n        uint256 overriddenWeight = _countOverride(proposalId, account, support);\n\n        emit OverrideVoteCast(account, proposalId, support, overriddenWeight, reason);\n\n        _tallyUpdated(proposalId);\n\n        return overriddenWeight;\n    }",
            "startLine": 190
          }
        ],
        "events": [
          {
            "name": "VoteReduced",
            "parameters": [
              {
                "name": "delegate",
                "type": "address",
                "indexed": true
              },
              {
                "name": "proposalId",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "support",
                "type": "uint8",
                "indexed": false
              },
              {
                "name": "weight",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 43
          },
          {
            "name": "OverrideVoteCast",
            "parameters": [
              {
                "name": "voter",
                "type": "address",
                "indexed": true
              },
              {
                "name": "proposalId",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "support",
                "type": "uint8",
                "indexed": false
              },
              {
                "name": "weight",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "reason",
                "type": "string",
                "indexed": false
              }
            ],
            "startLine": 46
          }
        ],
        "errors": [
          {
            "name": "GovernorAlreadyOverriddenVote",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "startLine": 48
          }
        ],
        "structs": [
          {
            "name": "VoteReceipt",
            "members": [
              {
                "name": "casted",
                "type": "uint8"
              },
              {
                "name": "hasOverridden",
                "type": "bool"
              },
              {
                "name": "overriddenWeight",
                "type": "uint208"
              }
            ],
            "startLine": 31
          },
          {
            "name": "ProposalVote",
            "members": [
              {
                "name": "votes",
                "type": "uint256[]"
              },
              {
                "name": "voteReceipt",
                "type": "mapping(address => VoteReceipt)"
              }
            ],
            "startLine": 37
          },
          {
            "name": "GovernorCountingOverridableStorage",
            "members": [
              {
                "name": "_proposalVotes",
                "type": "mapping(uint256 => ProposalVote)"
              }
            ],
            "startLine": 51
          }
        ],
        "stateVariables": [
          {
            "name": "OVERRIDE_BALLOT_TYPEHASH",
            "type": "bytes32",
            "visibility": "public",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 19
          },
          {
            "name": "GovernorCountingOverridableStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 56
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/math/SafeCast.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../utils/VotesExtendedUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./GovernorVotesUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/governance/IGovernor.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../GovernorUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorCountingOverridable.sol)\n\npragma solidity ^0.8.24;\n\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {VotesExtendedUpgradeable} from \"../utils/VotesExtendedUpgradeable.sol\";\nimport {GovernorVotesUpgradeable} from \"./GovernorVotesUpgradeable.sol\";\nimport {IGovernor} from \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} which enables delegators to override the vote of their delegates. This module requires a\n * token that inherits {VotesExtended}.\n */\nabstract contract GovernorCountingOverridableUpgradeable is Initializable, GovernorVotesUpgradeable {\n    bytes32 public constant OVERRIDE_BALLOT_TYPEHASH =\n        keccak256(\"OverrideBallot(uint256 proposalId,uint8 support,address voter,uint256 nonce,string reason)\");\n\n    /**\n     * @dev Supported vote types. Matches Governor Bravo ordering.\n     */\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct VoteReceipt {\n        uint8 casted; // 0 if vote was not casted. Otherwise: support + 1\n        bool hasOverridden;\n        uint208 overriddenWeight;\n    }\n\n    struct ProposalVote {\n        uint256[3] votes;\n        mapping(address voter => VoteReceipt) voteReceipt;\n    }\n\n    /// @dev The votes casted by `delegate` were reduced by `weight` after an override vote was casted by the original token holder\n    event VoteReduced(address indexed delegate, uint256 proposalId, uint8 support, uint256 weight);\n\n    /// @dev A delegated vote on `proposalId` was overridden by `weight`\n    event OverrideVoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason);\n\n    error GovernorAlreadyOverriddenVote(address account);\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorCountingOverridable\n    struct GovernorCountingOverridableStorage {\n        mapping(uint256 proposalId => ProposalVote) _proposalVotes;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorCountingOverridable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorCountingOverridableStorageLocation = 0xbffde6e7ca736efb3d8171f99b09abc076e81f804bf1703dc71fb0b1f7715100;\n\n    function _getGovernorCountingOverridableStorage() private pure returns (GovernorCountingOverridableStorage storage $) {\n        assembly {\n            $.slot := GovernorCountingOverridableStorageLocation\n        }\n    }\n\n    function __GovernorCountingOverridable_init() internal onlyInitializing {\n    }\n\n    function __GovernorCountingOverridable_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IGovernor\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo,override&quorum=for,abstain&overridable=true\";\n    }\n\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     *\n     * NOTE: Calling {castVote} (or similar) casts a vote using the voting power that is delegated to the voter.\n     * Conversely, calling {castOverrideVote} (or similar) uses the voting power of the account itself, from its asset\n     * balances. Casting an \"override vote\" does not count as voting and won't be reflected by this getter. Consider\n     * using {hasVotedOverride} to check if an account has casted an \"override vote\" for a given proposal id.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        GovernorCountingOverridableStorage storage $ = _getGovernorCountingOverridableStorage();\n        return $._proposalVotes[proposalId].voteReceipt[account].casted != 0;\n    }\n\n    /**\n     * @dev Check if an `account` has overridden their delegate for a proposal.\n     */\n    function hasVotedOverride(uint256 proposalId, address account) public view virtual returns (bool) {\n        GovernorCountingOverridableStorage storage $ = _getGovernorCountingOverridableStorage();\n        return $._proposalVotes[proposalId].voteReceipt[account].hasOverridden;\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(\n        uint256 proposalId\n    ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) {\n        GovernorCountingOverridableStorage storage $ = _getGovernorCountingOverridableStorage();\n        uint256[3] storage votes = $._proposalVotes[proposalId].votes;\n        return (votes[uint8(VoteType.Against)], votes[uint8(VoteType.For)], votes[uint8(VoteType.Abstain)]);\n    }\n\n    /// @inheritdoc GovernorUpgradeable\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        GovernorCountingOverridableStorage storage $ = _getGovernorCountingOverridableStorage();\n        uint256[3] storage votes = $._proposalVotes[proposalId].votes;\n        return quorum(proposalSnapshot(proposalId)) <= votes[uint8(VoteType.For)] + votes[uint8(VoteType.Abstain)];\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be strictly over the againstVotes.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        GovernorCountingOverridableStorage storage $ = _getGovernorCountingOverridableStorage();\n        uint256[3] storage votes = $._proposalVotes[proposalId].votes;\n        return votes[uint8(VoteType.For)] > votes[uint8(VoteType.Against)];\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\n     *\n     * NOTE: called by {Governor-_castVote} which emits the {IGovernor-VoteCast} (or {IGovernor-VoteCastWithParams})\n     * event.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 totalWeight,\n        bytes memory /*params*/\n    ) internal virtual override returns (uint256) {\n        GovernorCountingOverridableStorage storage $ = _getGovernorCountingOverridableStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n\n        if (support > uint8(VoteType.Abstain)) {\n            revert GovernorInvalidVoteType();\n        }\n\n        if (proposalVote.voteReceipt[account].casted != 0) {\n            revert GovernorAlreadyCastVote(account);\n        }\n\n        totalWeight -= proposalVote.voteReceipt[account].overriddenWeight;\n        proposalVote.votes[support] += totalWeight;\n        proposalVote.voteReceipt[account].casted = support + 1;\n\n        return totalWeight;\n    }\n\n    /**\n     * @dev Variant of {Governor-_countVote} that deals with vote overrides.\n     *\n     * NOTE: See {hasVoted} for more details about the difference between {castVote} and {castOverrideVote}.\n     */\n    function _countOverride(uint256 proposalId, address account, uint8 support) internal virtual returns (uint256) {\n        GovernorCountingOverridableStorage storage $ = _getGovernorCountingOverridableStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n\n        if (support > uint8(VoteType.Abstain)) {\n            revert GovernorInvalidVoteType();\n        }\n\n        if (proposalVote.voteReceipt[account].hasOverridden) {\n            revert GovernorAlreadyOverriddenVote(account);\n        }\n\n        uint256 snapshot = proposalSnapshot(proposalId);\n        uint256 overriddenWeight = VotesExtendedUpgradeable(address(token())).getPastBalanceOf(account, snapshot);\n        address delegate = VotesExtendedUpgradeable(address(token())).getPastDelegate(account, snapshot);\n        uint8 delegateCasted = proposalVote.voteReceipt[delegate].casted;\n\n        proposalVote.voteReceipt[account].hasOverridden = true;\n        proposalVote.votes[support] += overriddenWeight;\n        if (delegateCasted == 0) {\n            proposalVote.voteReceipt[delegate].overriddenWeight += SafeCast.toUint208(overriddenWeight);\n        } else {\n            uint8 delegateSupport = delegateCasted - 1;\n            proposalVote.votes[delegateSupport] -= overriddenWeight;\n            emit VoteReduced(delegate, proposalId, delegateSupport, overriddenWeight);\n        }\n\n        return overriddenWeight;\n    }\n\n    /// @dev Variant of {Governor-_castVote} that deals with vote overrides. Returns the overridden weight.\n    function _castOverride(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string calldata reason\n    ) internal virtual returns (uint256) {\n        _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Active));\n\n        uint256 overriddenWeight = _countOverride(proposalId, account, support);\n\n        emit OverrideVoteCast(account, proposalId, support, overriddenWeight, reason);\n\n        _tallyUpdated(proposalId);\n\n        return overriddenWeight;\n    }\n\n    /// @dev Public function for casting an override vote. Returns the overridden weight.\n    function castOverrideVote(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256) {\n        address voter = _msgSender();\n        return _castOverride(proposalId, voter, support, reason);\n    }\n\n    /// @dev Public function for casting an override vote using a voter's signature. Returns the overridden weight.\n    function castOverrideVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        string calldata reason,\n        bytes calldata signature\n    ) public virtual returns (uint256) {\n        bool valid = SignatureChecker.isValidSignatureNow(\n            voter,\n            _hashTypedDataV4(\n                keccak256(\n                    abi.encode(\n                        OVERRIDE_BALLOT_TYPEHASH,\n                        proposalId,\n                        support,\n                        voter,\n                        _useNonce(voter),\n                        keccak256(bytes(reason))\n                    )\n                )\n            ),\n            signature\n        );\n\n        if (!valid) {\n            revert GovernorInvalidSignature(voter);\n        }\n\n        return _castOverride(proposalId, voter, support, reason);\n    }\n}\n"
      },
      {
        "name": "GovernorCountingSimpleUpgradeable",
        "filePath": "governance/extensions/GovernorCountingSimpleUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "GovernorUpgradeable"
        ],
        "implements": [],
        "category": "governance/extensions",
        "externalFunctions": [
          {
            "name": "COUNTING_MODE",
            "signature": "COUNTING_MODE()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }",
            "startLine": 51
          },
          {
            "name": "hasVoted",
            "signature": "hasVoted(uint256,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorCountingSimpleStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        return $._proposalVotes[proposalId].hasVoted[account];\n    }",
            "startLine": 56
          },
          {
            "name": "proposalVotes",
            "signature": "proposalVotes(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "againstVotes",
                "type": "uint256"
              },
              {
                "name": "forVotes",
                "type": "uint256"
              },
              {
                "name": "abstainVotes",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorCountingSimpleStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalVotes(\n        uint256 proposalId\n    ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n        return (proposalVote.againstVotes, proposalVote.forVotes, proposalVote.abstainVotes);\n    }",
            "startLine": 64
          }
        ],
        "internalFunctions": [
          {
            "name": "_getGovernorCountingSimpleStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "GovernorCountingSimpleStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getGovernorCountingSimpleStorage() private pure returns (GovernorCountingSimpleStorage storage $) {\n        assembly {\n            $.slot := GovernorCountingSimpleStorageLocation\n        }\n    }",
            "startLine": 38
          },
          {
            "name": "__GovernorCountingSimple_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorCountingSimple_init() internal onlyInitializing {\n    }",
            "startLine": 44
          },
          {
            "name": "__GovernorCountingSimple_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorCountingSimple_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 47
          },
          {
            "name": "_quorumReached",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorCountingSimpleStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "quorum",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "proposalSnapshot",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n\n        return quorum(proposalSnapshot(proposalId)) <= proposalVote.forVotes + proposalVote.abstainVotes;\n    }",
            "startLine": 73
          },
          {
            "name": "_voteSucceeded",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorCountingSimpleStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n\n        return proposalVote.forVotes > proposalVote.againstVotes;\n    }",
            "startLine": 83
          },
          {
            "name": "_countVote",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "support",
                "type": "uint8"
              },
              {
                "name": "totalWeight",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorCountingSimpleStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 totalWeight,\n        bytes memory // params\n    ) internal virtual override returns (uint256) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n\n        if (proposalVote.hasVoted[account]) {\n            revert GovernorAlreadyCastVote(account);\n        }\n        proposalVote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalVote.againstVotes += totalWeight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalVote.forVotes += totalWeight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalVote.abstainVotes += totalWeight;\n        } else {\n            revert GovernorInvalidVoteType();\n        }\n\n        return totalWeight;\n    }",
            "startLine": 93
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "ProposalVote",
            "members": [
              {
                "name": "againstVotes",
                "type": "uint256"
              },
              {
                "name": "forVotes",
                "type": "uint256"
              },
              {
                "name": "abstainVotes",
                "type": "uint256"
              },
              {
                "name": "hasVoted",
                "type": "mapping(address => bool)"
              }
            ],
            "startLine": 23
          },
          {
            "name": "GovernorCountingSimpleStorage",
            "members": [
              {
                "name": "_proposalVotes",
                "type": "mapping(uint256 => ProposalVote)"
              }
            ],
            "startLine": 31
          }
        ],
        "stateVariables": [
          {
            "name": "GovernorCountingSimpleStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 36
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/governance/IGovernor.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../GovernorUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorCountingSimple.sol)\n\npragma solidity ^0.8.24;\n\nimport {IGovernor} from \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for simple, 3 options, vote counting.\n */\nabstract contract GovernorCountingSimpleUpgradeable is Initializable, GovernorUpgradeable {\n    /**\n     * @dev Supported vote types. Matches Governor Bravo ordering.\n     */\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address voter => bool) hasVoted;\n    }\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorCountingSimple\n    struct GovernorCountingSimpleStorage {\n        mapping(uint256 proposalId => ProposalVote) _proposalVotes;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorCountingSimple\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorCountingSimpleStorageLocation = 0xa1cefa0f43667ef127a258e673c94202a79b656e62899531c4376d87a7f39800;\n\n    function _getGovernorCountingSimpleStorage() private pure returns (GovernorCountingSimpleStorage storage $) {\n        assembly {\n            $.slot := GovernorCountingSimpleStorageLocation\n        }\n    }\n\n    function __GovernorCountingSimple_init() internal onlyInitializing {\n    }\n\n    function __GovernorCountingSimple_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IGovernor\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    /// @inheritdoc IGovernor\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        return $._proposalVotes[proposalId].hasVoted[account];\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(\n        uint256 proposalId\n    ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n        return (proposalVote.againstVotes, proposalVote.forVotes, proposalVote.abstainVotes);\n    }\n\n    /// @inheritdoc GovernorUpgradeable\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n\n        return quorum(proposalSnapshot(proposalId)) <= proposalVote.forVotes + proposalVote.abstainVotes;\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be strictly over the againstVotes.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n\n        return proposalVote.forVotes > proposalVote.againstVotes;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 totalWeight,\n        bytes memory // params\n    ) internal virtual override returns (uint256) {\n        GovernorCountingSimpleStorage storage $ = _getGovernorCountingSimpleStorage();\n        ProposalVote storage proposalVote = $._proposalVotes[proposalId];\n\n        if (proposalVote.hasVoted[account]) {\n            revert GovernorAlreadyCastVote(account);\n        }\n        proposalVote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalVote.againstVotes += totalWeight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalVote.forVotes += totalWeight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalVote.abstainVotes += totalWeight;\n        } else {\n            revert GovernorInvalidVoteType();\n        }\n\n        return totalWeight;\n    }\n}\n"
      },
      {
        "name": "GovernorNoncesKeyedUpgradeable",
        "filePath": "governance/extensions/GovernorNoncesKeyedUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "GovernorUpgradeable",
          "NoncesKeyedUpgradeable"
        ],
        "implements": [],
        "category": "governance/extensions",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "__GovernorNoncesKeyed_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorNoncesKeyed_init() internal onlyInitializing {\n    }",
            "startLine": 19
          },
          {
            "name": "__GovernorNoncesKeyed_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorNoncesKeyed_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 22
          },
          {
            "name": "_useCheckedNonce",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "nonce",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useCheckedNonce",
                "type": "super",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _useCheckedNonce(address owner, uint256 nonce) internal virtual override(NoncesUpgradeable, NoncesKeyedUpgradeable) {\n        super._useCheckedNonce(owner, nonce);\n    }",
            "startLine": 24
          },
          {
            "name": "_validateVoteSig",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "support",
                "type": "uint8"
              },
              {
                "name": "voter",
                "type": "address"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "SignatureChecker.isValidSignatureNow",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "_hashTypedDataV4",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "nonces",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_useNonce",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_validateVoteSig",
                "type": "super",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _validateVoteSig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        bytes memory signature\n    ) internal virtual override returns (bool) {\n        if (\n            SignatureChecker.isValidSignatureNow(\n                voter,\n                _hashTypedDataV4(\n                    keccak256(\n                        abi.encode(BALLOT_TYPEHASH, proposalId, support, voter, nonces(voter, uint192(proposalId)))\n                    )\n                ),\n                signature\n            )\n        ) {\n            _useNonce(voter, uint192(proposalId));\n            return true;\n        } else {\n            return super._validateVoteSig(proposalId, support, voter, signature);\n        }\n    }",
            "startLine": 34
          },
          {
            "name": "_validateExtendedVoteSig",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "support",
                "type": "uint8"
              },
              {
                "name": "voter",
                "type": "address"
              },
              {
                "name": "reason",
                "type": "string"
              },
              {
                "name": "params",
                "type": "bytes"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "SignatureChecker.isValidSignatureNow",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "_hashTypedDataV4",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "nonces",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_useNonce",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_validateExtendedVoteSig",
                "type": "super",
                "argCount": 6
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _validateExtendedVoteSig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        string memory reason,\n        bytes memory params,\n        bytes memory signature\n    ) internal virtual override returns (bool) {\n        if (\n            SignatureChecker.isValidSignatureNow(\n                voter,\n                _hashTypedDataV4(\n                    keccak256(\n                        abi.encode(\n                            EXTENDED_BALLOT_TYPEHASH,\n                            proposalId,\n                            support,\n                            voter,\n                            nonces(voter, uint192(proposalId)),\n                            keccak256(bytes(reason)),\n                            keccak256(params)\n                        )\n                    )\n                ),\n                signature\n            )\n        ) {\n            _useNonce(voter, uint192(proposalId));\n            return true;\n        } else {\n            return super._validateExtendedVoteSig(proposalId, support, voter, reason, params, signature);\n        }\n    }",
            "startLine": 64
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../GovernorUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../../utils/NoncesUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../../utils/NoncesKeyedUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorNoncesKeyed.sol)\n\npragma solidity ^0.8.24;\n\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {NoncesUpgradeable} from \"../../utils/NoncesUpgradeable.sol\";\nimport {NoncesKeyedUpgradeable} from \"../../utils/NoncesKeyedUpgradeable.sol\";\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev An extension of {Governor} that extends existing nonce management to use {NoncesKeyed}, where the key is the low-order 192 bits of the `proposalId`.\n * This is useful for voting by signature while maintaining separate sequences of nonces for each proposal.\n *\n * NOTE: Traditional (un-keyed) nonces are still supported and can continue to be used as if this extension was not present.\n */\nabstract contract GovernorNoncesKeyedUpgradeable is Initializable, GovernorUpgradeable, NoncesKeyedUpgradeable {\n    function __GovernorNoncesKeyed_init() internal onlyInitializing {\n    }\n\n    function __GovernorNoncesKeyed_init_unchained() internal onlyInitializing {\n    }\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual override(NoncesUpgradeable, NoncesKeyedUpgradeable) {\n        super._useCheckedNonce(owner, nonce);\n    }\n\n    /**\n     * @dev Check the signature against keyed nonce and falls back to the traditional nonce.\n     *\n     * NOTE: This function won't call `super._validateVoteSig` if the keyed nonce is valid.\n     * Side effects may be skipped depending on the linearization of the function.\n     */\n    function _validateVoteSig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        bytes memory signature\n    ) internal virtual override returns (bool) {\n        if (\n            SignatureChecker.isValidSignatureNow(\n                voter,\n                _hashTypedDataV4(\n                    keccak256(\n                        abi.encode(BALLOT_TYPEHASH, proposalId, support, voter, nonces(voter, uint192(proposalId)))\n                    )\n                ),\n                signature\n            )\n        ) {\n            _useNonce(voter, uint192(proposalId));\n            return true;\n        } else {\n            return super._validateVoteSig(proposalId, support, voter, signature);\n        }\n    }\n\n    /**\n     * @dev Check the signature against keyed nonce and falls back to the traditional nonce.\n     *\n     * NOTE: This function won't call `super._validateExtendedVoteSig` if the keyed nonce is valid.\n     * Side effects may be skipped depending on the linearization of the function.\n     */\n    function _validateExtendedVoteSig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        string memory reason,\n        bytes memory params,\n        bytes memory signature\n    ) internal virtual override returns (bool) {\n        if (\n            SignatureChecker.isValidSignatureNow(\n                voter,\n                _hashTypedDataV4(\n                    keccak256(\n                        abi.encode(\n                            EXTENDED_BALLOT_TYPEHASH,\n                            proposalId,\n                            support,\n                            voter,\n                            nonces(voter, uint192(proposalId)),\n                            keccak256(bytes(reason)),\n                            keccak256(params)\n                        )\n                    )\n                ),\n                signature\n            )\n        ) {\n            _useNonce(voter, uint192(proposalId));\n            return true;\n        } else {\n            return super._validateExtendedVoteSig(proposalId, support, voter, reason, params, signature);\n        }\n    }\n}\n"
      },
      {
        "name": "GovernorPreventLateQuorumUpgradeable",
        "filePath": "governance/extensions/GovernorPreventLateQuorumUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "GovernorUpgradeable"
        ],
        "implements": [],
        "category": "governance/extensions",
        "externalFunctions": [
          {
            "name": "proposalDeadline",
            "signature": "proposalDeadline(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorPreventLateQuorumStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Math.max",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "proposalDeadline",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        GovernorPreventLateQuorumStorage storage $ = _getGovernorPreventLateQuorumStorage();\n        return Math.max(super.proposalDeadline(proposalId), $._extendedDeadlines[proposalId]);\n    }",
            "startLine": 59
          },
          {
            "name": "lateQuorumVoteExtension",
            "signature": "lateQuorumVoteExtension()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint48"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorPreventLateQuorumStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function lateQuorumVoteExtension() public view virtual returns (uint48) {\n        GovernorPreventLateQuorumStorage storage $ = _getGovernorPreventLateQuorumStorage();\n        return $._voteExtension;\n    }",
            "startLine": 87
          },
          {
            "name": "setLateQuorumVoteExtension",
            "signature": "setLateQuorumVoteExtension(uint48)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newVoteExtension",
                "type": "uint48"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setLateQuorumVoteExtension",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setLateQuorumVoteExtension(uint48 newVoteExtension) public virtual onlyGovernance {\n        _setLateQuorumVoteExtension(newVoteExtension);\n    }",
            "startLine": 98
          }
        ],
        "internalFunctions": [
          {
            "name": "_getGovernorPreventLateQuorumStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "GovernorPreventLateQuorumStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getGovernorPreventLateQuorumStorage() private pure returns (GovernorPreventLateQuorumStorage storage $) {\n        assembly {\n            $.slot := GovernorPreventLateQuorumStorageLocation\n        }\n    }",
            "startLine": 30
          },
          {
            "name": "__GovernorPreventLateQuorum_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialVoteExtension",
                "type": "uint48"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorPreventLateQuorum_init(uint48 initialVoteExtension) internal onlyInitializing {\n        __GovernorPreventLateQuorum_init_unchained(initialVoteExtension);\n    }",
            "startLine": 47
          },
          {
            "name": "__GovernorPreventLateQuorum_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialVoteExtension",
                "type": "uint48"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setLateQuorumVoteExtension",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __GovernorPreventLateQuorum_init_unchained(uint48 initialVoteExtension) internal onlyInitializing {\n        _setLateQuorumVoteExtension(initialVoteExtension);\n    }",
            "startLine": 51
          },
          {
            "name": "_tallyUpdated",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorPreventLateQuorumStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_tallyUpdated",
                "type": "super",
                "argCount": 1
              },
              {
                "target": "clock",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "lateQuorumVoteExtension",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "proposalDeadline",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _tallyUpdated(uint256 proposalId) internal virtual override {\n        GovernorPreventLateQuorumStorage storage $ = _getGovernorPreventLateQuorumStorage();\n        super._tallyUpdated(proposalId);\n        if ($._extendedDeadlines[proposalId] == 0 && _quorumReached(proposalId)) {\n            uint48 extendedDeadline = clock() + lateQuorumVoteExtension();\n\n            if (extendedDeadline > proposalDeadline(proposalId)) {\n                emit ProposalExtended(proposalId, extendedDeadline);\n            }\n\n            $._extendedDeadlines[proposalId] = extendedDeadline;\n        }\n    }",
            "startLine": 69
          },
          {
            "name": "_setLateQuorumVoteExtension",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newVoteExtension",
                "type": "uint48"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorPreventLateQuorumStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setLateQuorumVoteExtension(uint48 newVoteExtension) internal virtual {\n        GovernorPreventLateQuorumStorage storage $ = _getGovernorPreventLateQuorumStorage();\n        emit LateQuorumVoteExtensionSet($._voteExtension, newVoteExtension);\n        $._voteExtension = newVoteExtension;\n    }",
            "startLine": 108
          }
        ],
        "events": [
          {
            "name": "ProposalExtended",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256",
                "indexed": true
              },
              {
                "name": "extendedDeadline",
                "type": "uint64",
                "indexed": false
              }
            ],
            "startLine": 37
          },
          {
            "name": "LateQuorumVoteExtensionSet",
            "parameters": [
              {
                "name": "oldVoteExtension",
                "type": "uint64",
                "indexed": false
              },
              {
                "name": "newVoteExtension",
                "type": "uint64",
                "indexed": false
              }
            ],
            "startLine": 40
          }
        ],
        "errors": [],
        "structs": [
          {
            "name": "GovernorPreventLateQuorumStorage",
            "members": [
              {
                "name": "_voteExtension",
                "type": "uint48"
              },
              {
                "name": "_extendedDeadlines",
                "type": "mapping(uint256 => uint48)"
              }
            ],
            "startLine": 21
          }
        ],
        "stateVariables": [
          {
            "name": "GovernorPreventLateQuorumStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 28
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../GovernorUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/math/Math.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorPreventLateQuorum.sol)\n\npragma solidity ^0.8.24;\n\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev A module that ensures there is a minimum voting period after quorum is reached. This prevents a large voter from\n * swaying a vote and triggering quorum at the last minute, by ensuring there is always time for other voters to react\n * and try to oppose the decision.\n *\n * If a vote causes quorum to be reached, the proposal's voting period may be extended so that it does not end before at\n * least a specified time has passed (the \"vote extension\" parameter). This parameter can be set through a governance\n * proposal.\n */\nabstract contract GovernorPreventLateQuorumUpgradeable is Initializable, GovernorUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorPreventLateQuorum\n    struct GovernorPreventLateQuorumStorage {\n        uint48 _voteExtension;\n\n        mapping(uint256 proposalId => uint48) _extendedDeadlines;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorPreventLateQuorum\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorPreventLateQuorumStorageLocation = 0x042f525fd47e44d02e065dd7bb464f47b4f926fbd05b5e087891ebd756adf100;\n\n    function _getGovernorPreventLateQuorumStorage() private pure returns (GovernorPreventLateQuorumStorage storage $) {\n        assembly {\n            $.slot := GovernorPreventLateQuorumStorageLocation\n        }\n    }\n\n    /// @dev Emitted when a proposal deadline is pushed back due to reaching quorum late in its voting period.\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n\n    /// @dev Emitted when the {lateQuorumVoteExtension} parameter is changed.\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n\n    /**\n     * @dev Initializes the vote extension parameter: the time in either number of blocks or seconds (depending on the\n     * governor clock mode) that is required to pass since the moment a proposal reaches quorum until its voting period\n     * ends. If necessary the voting period will be extended beyond the one set during proposal creation.\n     */\n    function __GovernorPreventLateQuorum_init(uint48 initialVoteExtension) internal onlyInitializing {\n        __GovernorPreventLateQuorum_init_unchained(initialVoteExtension);\n    }\n\n    function __GovernorPreventLateQuorum_init_unchained(uint48 initialVoteExtension) internal onlyInitializing {\n        _setLateQuorumVoteExtension(initialVoteExtension);\n    }\n\n    /**\n     * @dev Returns the proposal deadline, which may have been extended beyond that set at proposal creation, if the\n     * proposal reached quorum late in the voting period. See {Governor-proposalDeadline}.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        GovernorPreventLateQuorumStorage storage $ = _getGovernorPreventLateQuorumStorage();\n        return Math.max(super.proposalDeadline(proposalId), $._extendedDeadlines[proposalId]);\n    }\n\n    /**\n     * @dev Vote tally updated and detects if it caused quorum to be reached, potentially extending the voting period.\n     *\n     * May emit a {ProposalExtended} event.\n     */\n    function _tallyUpdated(uint256 proposalId) internal virtual override {\n        GovernorPreventLateQuorumStorage storage $ = _getGovernorPreventLateQuorumStorage();\n        super._tallyUpdated(proposalId);\n        if ($._extendedDeadlines[proposalId] == 0 && _quorumReached(proposalId)) {\n            uint48 extendedDeadline = clock() + lateQuorumVoteExtension();\n\n            if (extendedDeadline > proposalDeadline(proposalId)) {\n                emit ProposalExtended(proposalId, extendedDeadline);\n            }\n\n            $._extendedDeadlines[proposalId] = extendedDeadline;\n        }\n    }\n\n    /**\n     * @dev Returns the current value of the vote extension parameter: the number of blocks that are required to pass\n     * from the time a proposal reaches quorum until its voting period ends.\n     */\n    function lateQuorumVoteExtension() public view virtual returns (uint48) {\n        GovernorPreventLateQuorumStorage storage $ = _getGovernorPreventLateQuorumStorage();\n        return $._voteExtension;\n    }\n\n    /**\n     * @dev Changes the {lateQuorumVoteExtension}. This operation can only be performed by the governance executor,\n     * generally through a governance proposal.\n     *\n     * Emits a {LateQuorumVoteExtensionSet} event.\n     */\n    function setLateQuorumVoteExtension(uint48 newVoteExtension) public virtual onlyGovernance {\n        _setLateQuorumVoteExtension(newVoteExtension);\n    }\n\n    /**\n     * @dev Changes the {lateQuorumVoteExtension}. This is an internal function that can be exposed in a public function\n     * like {setLateQuorumVoteExtension} if another access control mechanism is needed.\n     *\n     * Emits a {LateQuorumVoteExtensionSet} event.\n     */\n    function _setLateQuorumVoteExtension(uint48 newVoteExtension) internal virtual {\n        GovernorPreventLateQuorumStorage storage $ = _getGovernorPreventLateQuorumStorage();\n        emit LateQuorumVoteExtensionSet($._voteExtension, newVoteExtension);\n        $._voteExtension = newVoteExtension;\n    }\n}\n"
      },
      {
        "name": "GovernorProposalGuardianUpgradeable",
        "filePath": "governance/extensions/GovernorProposalGuardianUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "GovernorUpgradeable"
        ],
        "implements": [],
        "category": "governance/extensions",
        "externalFunctions": [
          {
            "name": "proposalGuardian",
            "signature": "proposalGuardian()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorProposalGuardianStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalGuardian() public view virtual returns (address) {\n        GovernorProposalGuardianStorage storage $ = _getGovernorProposalGuardianStorage();\n        return $._proposalGuardian;\n    }",
            "startLine": 39
          },
          {
            "name": "setProposalGuardian",
            "signature": "setProposalGuardian(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newProposalGuardian",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setProposalGuardian",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setProposalGuardian(address newProposalGuardian) public virtual onlyGovernance {\n        _setProposalGuardian(newProposalGuardian);\n    }",
            "startLine": 49
          }
        ],
        "internalFunctions": [
          {
            "name": "_getGovernorProposalGuardianStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "GovernorProposalGuardianStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getGovernorProposalGuardianStorage() private pure returns (GovernorProposalGuardianStorage storage $) {\n        assembly {\n            $.slot := GovernorProposalGuardianStorageLocation\n        }\n    }",
            "startLine": 23
          },
          {
            "name": "__GovernorProposalGuardian_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorProposalGuardian_init() internal onlyInitializing {\n    }",
            "startLine": 31
          },
          {
            "name": "__GovernorProposalGuardian_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorProposalGuardian_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 34
          },
          {
            "name": "_setProposalGuardian",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newProposalGuardian",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorProposalGuardianStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setProposalGuardian(address newProposalGuardian) internal virtual {\n        GovernorProposalGuardianStorage storage $ = _getGovernorProposalGuardianStorage();\n        emit ProposalGuardianSet($._proposalGuardian, newProposalGuardian);\n        $._proposalGuardian = newProposalGuardian;\n    }",
            "startLine": 58
          },
          {
            "name": "_validateCancel",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "caller",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "proposalGuardian",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "proposalProposer",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_validateCancel",
                "type": "super",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _validateCancel(uint256 proposalId, address caller) internal view virtual override returns (bool) {\n        address guardian = proposalGuardian();\n\n        return\n            guardian == caller ||\n            (guardian == address(0) && caller == proposalProposer(proposalId)) ||\n            super._validateCancel(proposalId, caller);\n    }",
            "startLine": 71
          }
        ],
        "events": [
          {
            "name": "ProposalGuardianSet",
            "parameters": [
              {
                "name": "oldProposalGuardian",
                "type": "address",
                "indexed": false
              },
              {
                "name": "newProposalGuardian",
                "type": "address",
                "indexed": false
              }
            ],
            "startLine": 29
          }
        ],
        "errors": [],
        "structs": [
          {
            "name": "GovernorProposalGuardianStorage",
            "members": [
              {
                "name": "_proposalGuardian",
                "type": "address"
              }
            ],
            "startLine": 16
          }
        ],
        "stateVariables": [
          {
            "name": "GovernorProposalGuardianStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 21
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../GovernorUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (governance/extensions/GovernorProposalGuardian.sol)\n\npragma solidity ^0.8.24;\n\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} which adds a proposal guardian that can cancel proposals at any stage in the proposal's lifecycle.\n *\n * NOTE: if the proposal guardian is not configured, then proposers take this role for their proposals.\n */\nabstract contract GovernorProposalGuardianUpgradeable is Initializable, GovernorUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorProposalGuardian\n    struct GovernorProposalGuardianStorage {\n        address _proposalGuardian;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorProposalGuardian\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorProposalGuardianStorageLocation = 0x2953e0c334ced07e397f02d0e9b450dbfd92be015e93a9c249855132826e0300;\n\n    function _getGovernorProposalGuardianStorage() private pure returns (GovernorProposalGuardianStorage storage $) {\n        assembly {\n            $.slot := GovernorProposalGuardianStorageLocation\n        }\n    }\n\n    event ProposalGuardianSet(address oldProposalGuardian, address newProposalGuardian);\n\n    function __GovernorProposalGuardian_init() internal onlyInitializing {\n    }\n\n    function __GovernorProposalGuardian_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Getter that returns the address of the proposal guardian.\n     */\n    function proposalGuardian() public view virtual returns (address) {\n        GovernorProposalGuardianStorage storage $ = _getGovernorProposalGuardianStorage();\n        return $._proposalGuardian;\n    }\n\n    /**\n     * @dev Update the proposal guardian's address. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {ProposalGuardianSet} event.\n     */\n    function setProposalGuardian(address newProposalGuardian) public virtual onlyGovernance {\n        _setProposalGuardian(newProposalGuardian);\n    }\n\n    /**\n     * @dev Internal setter for the proposal guardian.\n     *\n     * Emits a {ProposalGuardianSet} event.\n     */\n    function _setProposalGuardian(address newProposalGuardian) internal virtual {\n        GovernorProposalGuardianStorage storage $ = _getGovernorProposalGuardianStorage();\n        emit ProposalGuardianSet($._proposalGuardian, newProposalGuardian);\n        $._proposalGuardian = newProposalGuardian;\n    }\n\n    /**\n     * @dev Override {Governor-_validateCancel} to implement the extended cancellation logic.\n     *\n     * * The {proposalGuardian} can cancel any proposal at any point.\n     * * If no proposal guardian is set, the {IGovernor-proposalProposer} can cancel their proposals at any point.\n     * * In any case, permissions defined in {Governor-_validateCancel} (or another override) remains valid.\n     */\n    function _validateCancel(uint256 proposalId, address caller) internal view virtual override returns (bool) {\n        address guardian = proposalGuardian();\n\n        return\n            guardian == caller ||\n            (guardian == address(0) && caller == proposalProposer(proposalId)) ||\n            super._validateCancel(proposalId, caller);\n    }\n}\n"
      },
      {
        "name": "GovernorSequentialProposalIdUpgradeable",
        "filePath": "governance/extensions/GovernorSequentialProposalIdUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "GovernorUpgradeable"
        ],
        "implements": [],
        "category": "governance/extensions",
        "externalFunctions": [
          {
            "name": "getProposalId",
            "signature": "getProposalId(address[],uint256[],bytes[],bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "descriptionHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorSequentialProposalIdStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "hashProposal",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getProposalId(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public view virtual override returns (uint256) {\n        GovernorSequentialProposalIdStorage storage $ = _getGovernorSequentialProposalIdStorage();\n        uint256 proposalHash = hashProposal(targets, values, calldatas, descriptionHash);\n        uint256 storedProposalId = $._proposalIds[proposalHash];\n        if (storedProposalId == 0) {\n            revert GovernorNonexistentProposal(0);\n        }\n        return storedProposalId;\n    }",
            "startLine": 42
          },
          {
            "name": "latestProposalId",
            "signature": "latestProposalId()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorSequentialProposalIdStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function latestProposalId() public view virtual returns (uint256) {\n        GovernorSequentialProposalIdStorage storage $ = _getGovernorSequentialProposalIdStorage();\n        return $._latestProposalId;\n    }",
            "startLine": 60
          }
        ],
        "internalFunctions": [
          {
            "name": "_getGovernorSequentialProposalIdStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "GovernorSequentialProposalIdStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getGovernorSequentialProposalIdStorage() private pure returns (GovernorSequentialProposalIdStorage storage $) {\n        assembly {\n            $.slot := GovernorSequentialProposalIdStorageLocation\n        }\n    }",
            "startLine": 24
          },
          {
            "name": "__GovernorSequentialProposalId_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorSequentialProposalId_init() internal onlyInitializing {\n    }",
            "startLine": 36
          },
          {
            "name": "__GovernorSequentialProposalId_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorSequentialProposalId_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 39
          },
          {
            "name": "_propose",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "description",
                "type": "string"
              },
              {
                "name": "proposer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorSequentialProposalIdStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "hashProposal",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_propose",
                "type": "super",
                "argCount": 5
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description,\n        address proposer\n    ) internal virtual override returns (uint256) {\n        GovernorSequentialProposalIdStorage storage $ = _getGovernorSequentialProposalIdStorage();\n        uint256 proposalHash = hashProposal(targets, values, calldatas, keccak256(bytes(description)));\n        uint256 storedProposalId = $._proposalIds[proposalHash];\n        if (storedProposalId == 0) {\n            $._proposalIds[proposalHash] = ++$._latestProposalId;\n        }\n        return super._propose(targets, values, calldatas, description, proposer);\n    }",
            "startLine": 69
          },
          {
            "name": "_initializeLatestProposalId",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newLatestProposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorSequentialProposalIdStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _initializeLatestProposalId(uint256 newLatestProposalId) internal virtual {\n        GovernorSequentialProposalIdStorage storage $ = _getGovernorSequentialProposalIdStorage();\n        if ($._latestProposalId != 0) {\n            revert GovernorAlreadyInitializedLatestProposalId();\n        }\n        $._latestProposalId = newLatestProposalId;\n    }",
            "startLine": 91
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "GovernorAlreadyInitializedLatestProposalId",
            "parameters": [],
            "startLine": 34
          }
        ],
        "structs": [
          {
            "name": "GovernorSequentialProposalIdStorage",
            "members": [
              {
                "name": "_latestProposalId",
                "type": "uint256"
              },
              {
                "name": "_proposalIds",
                "type": "mapping(uint256 => uint256)"
              }
            ],
            "startLine": 16
          }
        ],
        "stateVariables": [
          {
            "name": "GovernorSequentialProposalIdStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 22
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/governance/IGovernor.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../GovernorUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorSequentialProposalId.sol)\n\npragma solidity ^0.8.24;\n\nimport {IGovernor} from \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} that changes the numbering of proposal ids from the default hash-based approach to\n * sequential ids.\n */\nabstract contract GovernorSequentialProposalIdUpgradeable is Initializable, GovernorUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorSequentialProposalId\n    struct GovernorSequentialProposalIdStorage {\n        uint256 _latestProposalId;\n        mapping(uint256 proposalHash => uint256 proposalId) _proposalIds;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorSequentialProposalId\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorSequentialProposalIdStorageLocation = 0x4b8c47b641115bbb755a0530712d89d8042b41728d36570a6119c90ae1b76800;\n\n    function _getGovernorSequentialProposalIdStorage() private pure returns (GovernorSequentialProposalIdStorage storage $) {\n        assembly {\n            $.slot := GovernorSequentialProposalIdStorageLocation\n        }\n    }\n\n    /**\n     * @dev The {latestProposalId} may only be initialized if it hasn't been set yet\n     * (through initialization or the creation of a proposal).\n     */\n    error GovernorAlreadyInitializedLatestProposalId();\n\n    function __GovernorSequentialProposalId_init() internal onlyInitializing {\n    }\n\n    function __GovernorSequentialProposalId_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IGovernor\n    function getProposalId(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public view virtual override returns (uint256) {\n        GovernorSequentialProposalIdStorage storage $ = _getGovernorSequentialProposalIdStorage();\n        uint256 proposalHash = hashProposal(targets, values, calldatas, descriptionHash);\n        uint256 storedProposalId = $._proposalIds[proposalHash];\n        if (storedProposalId == 0) {\n            revert GovernorNonexistentProposal(0);\n        }\n        return storedProposalId;\n    }\n\n    /**\n     * @dev Returns the latest proposal id. A return value of 0 means no proposals have been created yet.\n     */\n    function latestProposalId() public view virtual returns (uint256) {\n        GovernorSequentialProposalIdStorage storage $ = _getGovernorSequentialProposalIdStorage();\n        return $._latestProposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-_propose}.\n     * Hook into the proposing mechanism to increment proposal count.\n     */\n    function _propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description,\n        address proposer\n    ) internal virtual override returns (uint256) {\n        GovernorSequentialProposalIdStorage storage $ = _getGovernorSequentialProposalIdStorage();\n        uint256 proposalHash = hashProposal(targets, values, calldatas, keccak256(bytes(description)));\n        uint256 storedProposalId = $._proposalIds[proposalHash];\n        if (storedProposalId == 0) {\n            $._proposalIds[proposalHash] = ++$._latestProposalId;\n        }\n        return super._propose(targets, values, calldatas, description, proposer);\n    }\n\n    /**\n     * @dev Internal function to set the {latestProposalId}. This function is helpful when transitioning\n     * from another governance system. The next proposal id will be `newLatestProposalId` + 1.\n     *\n     * May only call this function if the current value of {latestProposalId} is 0.\n     */\n    function _initializeLatestProposalId(uint256 newLatestProposalId) internal virtual {\n        GovernorSequentialProposalIdStorage storage $ = _getGovernorSequentialProposalIdStorage();\n        if ($._latestProposalId != 0) {\n            revert GovernorAlreadyInitializedLatestProposalId();\n        }\n        $._latestProposalId = newLatestProposalId;\n    }\n}\n"
      },
      {
        "name": "GovernorSettingsUpgradeable",
        "filePath": "governance/extensions/GovernorSettingsUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "GovernorUpgradeable"
        ],
        "implements": [],
        "category": "governance/extensions",
        "externalFunctions": [
          {
            "name": "votingDelay",
            "signature": "votingDelay()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorSettingsStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function votingDelay() public view virtual override returns (uint256) {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        return $._votingDelay;\n    }",
            "startLine": 51
          },
          {
            "name": "votingPeriod",
            "signature": "votingPeriod()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorSettingsStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function votingPeriod() public view virtual override returns (uint256) {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        return $._votingPeriod;\n    }",
            "startLine": 57
          },
          {
            "name": "proposalThreshold",
            "signature": "proposalThreshold()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorSettingsStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalThreshold() public view virtual override returns (uint256) {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        return $._proposalThreshold;\n    }",
            "startLine": 63
          },
          {
            "name": "setVotingDelay",
            "signature": "setVotingDelay(uint48)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newVotingDelay",
                "type": "uint48"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setVotingDelay",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setVotingDelay(uint48 newVotingDelay) public virtual onlyGovernance {\n        _setVotingDelay(newVotingDelay);\n    }",
            "startLine": 73
          },
          {
            "name": "setVotingPeriod",
            "signature": "setVotingPeriod(uint32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newVotingPeriod",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setVotingPeriod",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setVotingPeriod(uint32 newVotingPeriod) public virtual onlyGovernance {\n        _setVotingPeriod(newVotingPeriod);\n    }",
            "startLine": 82
          },
          {
            "name": "setProposalThreshold",
            "signature": "setProposalThreshold(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newProposalThreshold",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setProposalThreshold",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setProposalThreshold(uint256 newProposalThreshold) public virtual onlyGovernance {\n        _setProposalThreshold(newProposalThreshold);\n    }",
            "startLine": 91
          }
        ],
        "internalFunctions": [
          {
            "name": "_getGovernorSettingsStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "GovernorSettingsStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getGovernorSettingsStorage() private pure returns (GovernorSettingsStorage storage $) {\n        assembly {\n            $.slot := GovernorSettingsStorageLocation\n        }\n    }",
            "startLine": 27
          },
          {
            "name": "__GovernorSettings_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialVotingDelay",
                "type": "uint48"
              },
              {
                "name": "initialVotingPeriod",
                "type": "uint32"
              },
              {
                "name": "initialProposalThreshold",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorSettings_init(uint48 initialVotingDelay, uint32 initialVotingPeriod, uint256 initialProposalThreshold) internal onlyInitializing {\n        __GovernorSettings_init_unchained(initialVotingDelay, initialVotingPeriod, initialProposalThreshold);\n    }",
            "startLine": 40
          },
          {
            "name": "__GovernorSettings_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialVotingDelay",
                "type": "uint48"
              },
              {
                "name": "initialVotingPeriod",
                "type": "uint32"
              },
              {
                "name": "initialProposalThreshold",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setVotingDelay",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_setVotingPeriod",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_setProposalThreshold",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __GovernorSettings_init_unchained(uint48 initialVotingDelay, uint32 initialVotingPeriod, uint256 initialProposalThreshold) internal onlyInitializing {\n        _setVotingDelay(initialVotingDelay);\n        _setVotingPeriod(initialVotingPeriod);\n        _setProposalThreshold(initialProposalThreshold);\n    }",
            "startLine": 44
          },
          {
            "name": "_setVotingDelay",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newVotingDelay",
                "type": "uint48"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorSettingsStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setVotingDelay(uint48 newVotingDelay) internal virtual {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        emit VotingDelaySet($._votingDelay, newVotingDelay);\n        $._votingDelay = newVotingDelay;\n    }",
            "startLine": 100
          },
          {
            "name": "_setVotingPeriod",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newVotingPeriod",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorSettingsStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setVotingPeriod(uint32 newVotingPeriod) internal virtual {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        if (newVotingPeriod == 0) {\n            revert GovernorInvalidVotingPeriod(0);\n        }\n        emit VotingPeriodSet($._votingPeriod, newVotingPeriod);\n        $._votingPeriod = newVotingPeriod;\n    }",
            "startLine": 111
          },
          {
            "name": "_setProposalThreshold",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newProposalThreshold",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorSettingsStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setProposalThreshold(uint256 newProposalThreshold) internal virtual {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        emit ProposalThresholdSet($._proposalThreshold, newProposalThreshold);\n        $._proposalThreshold = newProposalThreshold;\n    }",
            "startLine": 125
          }
        ],
        "events": [
          {
            "name": "VotingDelaySet",
            "parameters": [
              {
                "name": "oldVotingDelay",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "newVotingDelay",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 33
          },
          {
            "name": "VotingPeriodSet",
            "parameters": [
              {
                "name": "oldVotingPeriod",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "newVotingPeriod",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 34
          },
          {
            "name": "ProposalThresholdSet",
            "parameters": [
              {
                "name": "oldProposalThreshold",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "newProposalThreshold",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 35
          }
        ],
        "errors": [],
        "structs": [
          {
            "name": "GovernorSettingsStorage",
            "members": [
              {
                "name": "_proposalThreshold",
                "type": "uint256"
              },
              {
                "name": "_votingDelay",
                "type": "uint48"
              },
              {
                "name": "_votingPeriod",
                "type": "uint32"
              }
            ],
            "startLine": 15
          }
        ],
        "stateVariables": [
          {
            "name": "GovernorSettingsStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 25
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/governance/IGovernor.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../GovernorUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorSettings.sol)\n\npragma solidity ^0.8.24;\n\nimport {IGovernor} from \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for settings updatable through governance.\n */\nabstract contract GovernorSettingsUpgradeable is Initializable, GovernorUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorSettings\n    struct GovernorSettingsStorage {\n        // amount of token\n        uint256 _proposalThreshold;\n        // timepoint: limited to uint48 in core (same as clock() type)\n        uint48 _votingDelay;\n        // duration: limited to uint32 in core\n        uint32 _votingPeriod;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorSettings\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorSettingsStorageLocation = 0x00d7616c8fe29c6c2fbe1d0c5bc8f2faa4c35b43746e70b24b4d532752affd00;\n\n    function _getGovernorSettingsStorage() private pure returns (GovernorSettingsStorage storage $) {\n        assembly {\n            $.slot := GovernorSettingsStorageLocation\n        }\n    }\n\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n    event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold);\n\n    /**\n     * @dev Initialize the governance parameters.\n     */\n    function __GovernorSettings_init(uint48 initialVotingDelay, uint32 initialVotingPeriod, uint256 initialProposalThreshold) internal onlyInitializing {\n        __GovernorSettings_init_unchained(initialVotingDelay, initialVotingPeriod, initialProposalThreshold);\n    }\n\n    function __GovernorSettings_init_unchained(uint48 initialVotingDelay, uint32 initialVotingPeriod, uint256 initialProposalThreshold) internal onlyInitializing {\n        _setVotingDelay(initialVotingDelay);\n        _setVotingPeriod(initialVotingPeriod);\n        _setProposalThreshold(initialProposalThreshold);\n    }\n\n    /// @inheritdoc IGovernor\n    function votingDelay() public view virtual override returns (uint256) {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        return $._votingDelay;\n    }\n\n    /// @inheritdoc IGovernor\n    function votingPeriod() public view virtual override returns (uint256) {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        return $._votingPeriod;\n    }\n\n    /// @inheritdoc GovernorUpgradeable\n    function proposalThreshold() public view virtual override returns (uint256) {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        return $._proposalThreshold;\n    }\n\n    /**\n     * @dev Update the voting delay. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function setVotingDelay(uint48 newVotingDelay) public virtual onlyGovernance {\n        _setVotingDelay(newVotingDelay);\n    }\n\n    /**\n     * @dev Update the voting period. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function setVotingPeriod(uint32 newVotingPeriod) public virtual onlyGovernance {\n        _setVotingPeriod(newVotingPeriod);\n    }\n\n    /**\n     * @dev Update the proposal threshold. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function setProposalThreshold(uint256 newProposalThreshold) public virtual onlyGovernance {\n        _setProposalThreshold(newProposalThreshold);\n    }\n\n    /**\n     * @dev Internal setter for the voting delay.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function _setVotingDelay(uint48 newVotingDelay) internal virtual {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        emit VotingDelaySet($._votingDelay, newVotingDelay);\n        $._votingDelay = newVotingDelay;\n    }\n\n    /**\n     * @dev Internal setter for the voting period.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function _setVotingPeriod(uint32 newVotingPeriod) internal virtual {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        if (newVotingPeriod == 0) {\n            revert GovernorInvalidVotingPeriod(0);\n        }\n        emit VotingPeriodSet($._votingPeriod, newVotingPeriod);\n        $._votingPeriod = newVotingPeriod;\n    }\n\n    /**\n     * @dev Internal setter for the proposal threshold.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function _setProposalThreshold(uint256 newProposalThreshold) internal virtual {\n        GovernorSettingsStorage storage $ = _getGovernorSettingsStorage();\n        emit ProposalThresholdSet($._proposalThreshold, newProposalThreshold);\n        $._proposalThreshold = newProposalThreshold;\n    }\n}\n"
      },
      {
        "name": "GovernorStorageUpgradeable",
        "filePath": "governance/extensions/GovernorStorageUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "GovernorUpgradeable"
        ],
        "implements": [],
        "category": "governance/extensions",
        "externalFunctions": [
          {
            "name": "queue",
            "signature": "queue(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorStorageStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "queue",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function queue(uint256 proposalId) public virtual {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        // here, using storage is more efficient than memory\n        ProposalDetails storage details = $._proposalDetails[proposalId];\n        if (details.descriptionHash == 0) {\n            revert GovernorNonexistentProposal(proposalId);\n        }\n        queue(details.targets, details.values, details.calldatas, details.descriptionHash);\n    }",
            "startLine": 74
          },
          {
            "name": "execute",
            "signature": "execute(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorStorageStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "execute",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function execute(uint256 proposalId) public payable virtual {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        // here, using storage is more efficient than memory\n        ProposalDetails storage details = $._proposalDetails[proposalId];\n        if (details.descriptionHash == 0) {\n            revert GovernorNonexistentProposal(proposalId);\n        }\n        execute(details.targets, details.values, details.calldatas, details.descriptionHash);\n    }",
            "startLine": 87
          },
          {
            "name": "cancel",
            "signature": "cancel(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorStorageStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "cancel",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function cancel(uint256 proposalId) public virtual {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        // here, using storage is more efficient than memory\n        ProposalDetails storage details = $._proposalDetails[proposalId];\n        if (details.descriptionHash == 0) {\n            revert GovernorNonexistentProposal(proposalId);\n        }\n        cancel(details.targets, details.values, details.calldatas, details.descriptionHash);\n    }",
            "startLine": 100
          },
          {
            "name": "proposalCount",
            "signature": "proposalCount()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorStorageStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalCount() public view virtual returns (uint256) {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        return $._proposalIds.length;\n    }",
            "startLine": 113
          },
          {
            "name": "proposalDetails",
            "signature": "proposalDetails(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "descriptionHash",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorStorageStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalDetails(\n        uint256 proposalId\n    )\n        public\n        view\n        virtual\n        returns (address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)\n    {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        // here, using memory is more efficient than storage\n        ProposalDetails memory details = $._proposalDetails[proposalId];\n        if (details.descriptionHash == 0) {\n            revert GovernorNonexistentProposal(proposalId);\n        }\n        return (details.targets, details.values, details.calldatas, details.descriptionHash);\n    }",
            "startLine": 121
          },
          {
            "name": "proposalDetailsAt",
            "signature": "proposalDetailsAt(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "descriptionHash",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorStorageStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "proposalDetails",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalDetailsAt(\n        uint256 index\n    )\n        public\n        view\n        virtual\n        returns (\n            uint256 proposalId,\n            address[] memory targets,\n            uint256[] memory values,\n            bytes[] memory calldatas,\n            bytes32 descriptionHash\n        )\n    {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        proposalId = $._proposalIds[index];\n        (targets, values, calldatas, descriptionHash) = proposalDetails(proposalId);\n    }",
            "startLine": 141
          }
        ],
        "internalFunctions": [
          {
            "name": "_getGovernorStorageStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "GovernorStorageStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getGovernorStorageStorage() private pure returns (GovernorStorageStorage storage $) {\n        assembly {\n            $.slot := GovernorStorageStorageLocation\n        }\n    }",
            "startLine": 35
          },
          {
            "name": "__GovernorStorage_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorStorage_init() internal onlyInitializing {\n    }",
            "startLine": 41
          },
          {
            "name": "__GovernorStorage_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorStorage_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 44
          },
          {
            "name": "_propose",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "description",
                "type": "string"
              },
              {
                "name": "proposer",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorStorageStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_propose",
                "type": "super",
                "argCount": 5
              },
              {
                "target": "ProposalDetails",
                "type": "external",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description,\n        address proposer\n    ) internal virtual override returns (uint256) {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        uint256 proposalId = super._propose(targets, values, calldatas, description, proposer);\n\n        // store\n        $._proposalIds.push(proposalId);\n        $._proposalDetails[proposalId] = ProposalDetails({\n            targets: targets,\n            values: values,\n            calldatas: calldatas,\n            descriptionHash: keccak256(bytes(description))\n        });\n\n        return proposalId;\n    }",
            "startLine": 49
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "ProposalDetails",
            "members": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "descriptionHash",
                "type": "bytes32"
              }
            ],
            "startLine": 19
          },
          {
            "name": "GovernorStorageStorage",
            "members": [
              {
                "name": "_proposalIds",
                "type": "uint256[]"
              },
              {
                "name": "_proposalDetails",
                "type": "mapping(uint256 => ProposalDetails)"
              }
            ],
            "startLine": 27
          }
        ],
        "stateVariables": [
          {
            "name": "GovernorStorageStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 33
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../GovernorUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (governance/extensions/GovernorStorage.sol)\n\npragma solidity ^0.8.24;\n\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} that implements storage of proposal details. This module also provides primitives for\n * the enumerability of proposals.\n *\n * Use cases for this module include:\n * - UIs that explore the proposal state without relying on event indexing.\n * - Using only the proposalId as an argument in the {Governor-queue} and {Governor-execute} functions for L2 chains\n *   where storage is cheap compared to calldata.\n */\nabstract contract GovernorStorageUpgradeable is Initializable, GovernorUpgradeable {\n    struct ProposalDetails {\n        address[] targets;\n        uint256[] values;\n        bytes[] calldatas;\n        bytes32 descriptionHash;\n    }\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorStorage\n    struct GovernorStorageStorage {\n        uint256[] _proposalIds;\n        mapping(uint256 proposalId => ProposalDetails) _proposalDetails;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorStorage\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorStorageStorageLocation = 0x7fd223d3380145bd26132714391e777c488a0df7ac2dd4b66419d8549fb3a600;\n\n    function _getGovernorStorageStorage() private pure returns (GovernorStorageStorage storage $) {\n        assembly {\n            $.slot := GovernorStorageStorageLocation\n        }\n    }\n\n    function __GovernorStorage_init() internal onlyInitializing {\n    }\n\n    function __GovernorStorage_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Hook into the proposing mechanism\n     */\n    function _propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description,\n        address proposer\n    ) internal virtual override returns (uint256) {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        uint256 proposalId = super._propose(targets, values, calldatas, description, proposer);\n\n        // store\n        $._proposalIds.push(proposalId);\n        $._proposalDetails[proposalId] = ProposalDetails({\n            targets: targets,\n            values: values,\n            calldatas: calldatas,\n            descriptionHash: keccak256(bytes(description))\n        });\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Version of {IGovernor-queue} with only `proposalId` as an argument.\n     */\n    function queue(uint256 proposalId) public virtual {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        // here, using storage is more efficient than memory\n        ProposalDetails storage details = $._proposalDetails[proposalId];\n        if (details.descriptionHash == 0) {\n            revert GovernorNonexistentProposal(proposalId);\n        }\n        queue(details.targets, details.values, details.calldatas, details.descriptionHash);\n    }\n\n    /**\n     * @dev Version of {IGovernor-execute} with only `proposalId` as an argument.\n     */\n    function execute(uint256 proposalId) public payable virtual {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        // here, using storage is more efficient than memory\n        ProposalDetails storage details = $._proposalDetails[proposalId];\n        if (details.descriptionHash == 0) {\n            revert GovernorNonexistentProposal(proposalId);\n        }\n        execute(details.targets, details.values, details.calldatas, details.descriptionHash);\n    }\n\n    /**\n     * @dev ProposalId version of {IGovernor-cancel}.\n     */\n    function cancel(uint256 proposalId) public virtual {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        // here, using storage is more efficient than memory\n        ProposalDetails storage details = $._proposalDetails[proposalId];\n        if (details.descriptionHash == 0) {\n            revert GovernorNonexistentProposal(proposalId);\n        }\n        cancel(details.targets, details.values, details.calldatas, details.descriptionHash);\n    }\n\n    /**\n     * @dev Returns the number of stored proposals.\n     */\n    function proposalCount() public view virtual returns (uint256) {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        return $._proposalIds.length;\n    }\n\n    /**\n     * @dev Returns the details of a proposalId. Reverts if `proposalId` is not a known proposal.\n     */\n    function proposalDetails(\n        uint256 proposalId\n    )\n        public\n        view\n        virtual\n        returns (address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)\n    {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        // here, using memory is more efficient than storage\n        ProposalDetails memory details = $._proposalDetails[proposalId];\n        if (details.descriptionHash == 0) {\n            revert GovernorNonexistentProposal(proposalId);\n        }\n        return (details.targets, details.values, details.calldatas, details.descriptionHash);\n    }\n\n    /**\n     * @dev Returns the details (including the proposalId) of a proposal given its sequential index.\n     */\n    function proposalDetailsAt(\n        uint256 index\n    )\n        public\n        view\n        virtual\n        returns (\n            uint256 proposalId,\n            address[] memory targets,\n            uint256[] memory values,\n            bytes[] memory calldatas,\n            bytes32 descriptionHash\n        )\n    {\n        GovernorStorageStorage storage $ = _getGovernorStorageStorage();\n        proposalId = $._proposalIds[index];\n        (targets, values, calldatas, descriptionHash) = proposalDetails(proposalId);\n    }\n}\n"
      },
      {
        "name": "GovernorSuperQuorumUpgradeable",
        "filePath": "governance/extensions/GovernorSuperQuorumUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "GovernorUpgradeable"
        ],
        "implements": [],
        "category": "governance/extensions",
        "externalFunctions": [
          {
            "name": "superQuorum",
            "signature": "superQuorum(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "timepoint",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function superQuorum(uint256 timepoint) public view virtual returns (uint256);",
            "startLine": 31
          },
          {
            "name": "proposalVotes",
            "signature": "proposalVotes(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "againstVotes",
                "type": "uint256"
              },
              {
                "name": "forVotes",
                "type": "uint256"
              },
              {
                "name": "abstainVotes",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalVotes(\n        uint256 proposalId\n    ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes);",
            "startLine": 37
          },
          {
            "name": "state",
            "signature": "state(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "ProposalState"
              }
            ],
            "calls": [
              {
                "target": "state",
                "type": "super",
                "argCount": 1
              },
              {
                "target": "proposalVotes",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "superQuorum",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "proposalSnapshot",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "proposalEta",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function state(uint256 proposalId) public view virtual override returns (ProposalState) {\n        ProposalState currentState = super.state(proposalId);\n        if (currentState != ProposalState.Active) return currentState;\n\n        (, uint256 forVotes, ) = proposalVotes(proposalId);\n        if (forVotes < superQuorum(proposalSnapshot(proposalId)) || !_voteSucceeded(proposalId)) {\n            return ProposalState.Active;\n        } else if (proposalEta(proposalId) == 0) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Queued;\n        }\n    }",
            "startLine": 52
          }
        ],
        "internalFunctions": [
          {
            "name": "__GovernorSuperQuorum_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorSuperQuorum_init() internal onlyInitializing {\n    }",
            "startLine": 15
          },
          {
            "name": "__GovernorSuperQuorum_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorSuperQuorum_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 18
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../GovernorUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (governance/extensions/GovernorSuperQuorum.sol)\n\npragma solidity ^0.8.24;\n\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} with a super quorum. Proposals that meet the super quorum (and have a majority of for\n * votes) advance to the `Succeeded` state before the proposal deadline. Counting modules that want to use this\n * extension must implement {proposalVotes}.\n */\nabstract contract GovernorSuperQuorumUpgradeable is Initializable, GovernorUpgradeable {\n    function __GovernorSuperQuorum_init() internal onlyInitializing {\n    }\n\n    function __GovernorSuperQuorum_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Minimum number of cast votes required for a proposal to reach super quorum. Only FOR votes are counted\n     * towards the super quorum. Once the super quorum is reached, an active proposal can proceed to the next state\n     * without waiting for the proposal deadline.\n     *\n     * NOTE: The `timepoint` parameter corresponds to the snapshot used for counting the vote. This enables scaling of the\n     * quorum depending on values such as the `totalSupply` of a token at this timepoint (see {ERC20Votes}).\n     *\n     * NOTE: Make sure the value specified for the super quorum is greater than {quorum}, otherwise, it may be\n     * possible to pass a proposal with less votes than the default quorum.\n     */\n    function superQuorum(uint256 timepoint) public view virtual returns (uint256);\n\n    /**\n     * @dev Accessor to the internal vote counts. This must be implemented by the counting module. Counting modules\n     * that don't implement this function are incompatible with this module\n     */\n    function proposalVotes(\n        uint256 proposalId\n    ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes);\n\n    /**\n     * @dev Overridden version of the {Governor-state} function that checks if the proposal has reached the super\n     * quorum.\n     *\n     * NOTE: If the proposal reaches super quorum but {_voteSucceeded} returns false, eg, assuming the super quorum\n     * has been set low enough that both FOR and AGAINST votes have exceeded it and AGAINST votes exceed FOR votes,\n     * the proposal continues to be active until {_voteSucceeded} returns true or the proposal deadline is reached.\n     * This means that with a low super quorum it is also possible that a vote can succeed prematurely before enough\n     * AGAINST voters have a chance to vote. Hence, it is recommended to set a high enough super quorum to avoid these\n     * types of scenarios.\n     */\n    function state(uint256 proposalId) public view virtual override returns (ProposalState) {\n        ProposalState currentState = super.state(proposalId);\n        if (currentState != ProposalState.Active) return currentState;\n\n        (, uint256 forVotes, ) = proposalVotes(proposalId);\n        if (forVotes < superQuorum(proposalSnapshot(proposalId)) || !_voteSucceeded(proposalId)) {\n            return ProposalState.Active;\n        } else if (proposalEta(proposalId) == 0) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n}\n"
      },
      {
        "name": "GovernorTimelockAccessUpgradeable",
        "filePath": "governance/extensions/GovernorTimelockAccessUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "GovernorUpgradeable"
        ],
        "implements": [],
        "category": "governance/extensions",
        "externalFunctions": [
          {
            "name": "accessManager",
            "signature": "accessManager()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "IAccessManager"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorTimelockAccessStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function accessManager() public view virtual returns (IAccessManager) {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        return $._manager;\n    }",
            "startLine": 104
          },
          {
            "name": "baseDelaySeconds",
            "signature": "baseDelaySeconds()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint32"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorTimelockAccessStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function baseDelaySeconds() public view virtual returns (uint32) {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        return $._baseDelay;\n    }",
            "startLine": 117
          },
          {
            "name": "setBaseDelaySeconds",
            "signature": "setBaseDelaySeconds(uint32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newBaseDelay",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setBaseDelaySeconds",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setBaseDelaySeconds(uint32 newBaseDelay) public virtual onlyGovernance {\n        _setBaseDelaySeconds(newBaseDelay);\n    }",
            "startLine": 125
          },
          {
            "name": "isAccessManagerIgnored",
            "signature": "isAccessManagerIgnored(address,bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "selector",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorTimelockAccessStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function isAccessManagerIgnored(address target, bytes4 selector) public view virtual returns (bool) {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        bool isGovernor = target == address(this);\n        return $._ignoreToggle[target][selector] != isGovernor; // equivalent to: isGovernor ? !toggle : toggle\n    }",
            "startLine": 143
          },
          {
            "name": "setAccessManagerIgnored",
            "signature": "setAccessManagerIgnored(address,bytes4[],bool)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "selectors",
                "type": "bytes4[]"
              },
              {
                "name": "ignored",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setAccessManagerIgnored(\n        address target,\n        bytes4[] calldata selectors,\n        bool ignored\n    ) public virtual onlyGovernance {\n        for (uint256 i = 0; i < selectors.length; ++i) {\n            _setAccessManagerIgnored(target, selectors[i], ignored);\n        }\n    }",
            "startLine": 153
          },
          {
            "name": "proposalExecutionPlan",
            "signature": "proposalExecutionPlan(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "delay",
                "type": "uint32"
              },
              {
                "name": "indirect",
                "type": "bool[]"
              },
              {
                "name": "withDelay",
                "type": "bool[]"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorTimelockAccessStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_getManagerData",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function proposalExecutionPlan(\n        uint256 proposalId\n    ) public view returns (uint32 delay, bool[] memory indirect, bool[] memory withDelay) {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        ExecutionPlan storage plan = $._executionPlan[proposalId];\n\n        uint32 length = plan.length;\n        delay = plan.delay;\n        indirect = new bool[](length);\n        withDelay = new bool[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            (indirect[i], withDelay[i], ) = _getManagerData(plan, i);\n        }\n\n        return (delay, indirect, withDelay);\n    }",
            "startLine": 182
          },
          {
            "name": "proposalNeedsQueuing",
            "signature": "proposalNeedsQueuing(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorTimelockAccessStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalNeedsQueuing(uint256 proposalId) public view virtual override returns (bool) {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        return $._executionPlan[proposalId].delay > 0;\n    }",
            "startLine": 200
          },
          {
            "name": "propose",
            "signature": "propose(address[],uint256[],bytes[],string)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "description",
                "type": "string"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorTimelockAccessStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "propose",
                "type": "super",
                "argCount": 4
              },
              {
                "target": "baseDelaySeconds",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "SafeCast.toUint16",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "AuthorityUtils.canCallWithDelay",
                "type": "library",
                "argCount": 4
              },
              {
                "target": "isAccessManagerIgnored",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_setManagerData",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "Math.max",
                "type": "library",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        uint256 proposalId = super.propose(targets, values, calldatas, description);\n\n        uint32 neededDelay = baseDelaySeconds();\n\n        ExecutionPlan storage plan = $._executionPlan[proposalId];\n        plan.length = SafeCast.toUint16(targets.length);\n\n        for (uint256 i = 0; i < targets.length; ++i) {\n            if (calldatas[i].length < 4) {\n                continue;\n            }\n            address target = targets[i];\n            bytes4 selector = bytes4(calldatas[i]);\n            (bool immediate, uint32 delay) = AuthorityUtils.canCallWithDelay(\n                address($._manager),\n                address(this),\n                target,\n                selector\n            );\n            if ((immediate || delay > 0) && !isAccessManagerIgnored(target, selector)) {\n                _setManagerData(plan, i, !immediate, 0);\n                // downcast is safe because both arguments are uint32\n                neededDelay = uint32(Math.max(delay, neededDelay));\n            }\n        }\n\n        plan.delay = neededDelay;\n\n        return proposalId;\n    }",
            "startLine": 206
          }
        ],
        "internalFunctions": [
          {
            "name": "_getGovernorTimelockAccessStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "GovernorTimelockAccessStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getGovernorTimelockAccessStorage() private pure returns (GovernorTimelockAccessStorage storage $) {\n        assembly {\n            $.slot := GovernorTimelockAccessStorageLocation\n        }\n    }",
            "startLine": 75
          },
          {
            "name": "__GovernorTimelockAccess_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "manager",
                "type": "address"
              },
              {
                "name": "initialBaseDelay",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorTimelockAccess_init(address manager, uint32 initialBaseDelay) internal onlyInitializing {\n        __GovernorTimelockAccess_init_unchained(manager, initialBaseDelay);\n    }",
            "startLine": 91
          },
          {
            "name": "__GovernorTimelockAccess_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "manager",
                "type": "address"
              },
              {
                "name": "initialBaseDelay",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorTimelockAccessStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_setBaseDelaySeconds",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __GovernorTimelockAccess_init_unchained(address manager, uint32 initialBaseDelay) internal onlyInitializing {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        $._manager = IAccessManager(manager);\n        _setBaseDelaySeconds(initialBaseDelay);\n    }",
            "startLine": 95
          },
          {
            "name": "_setBaseDelaySeconds",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newBaseDelay",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorTimelockAccessStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setBaseDelaySeconds(uint32 newBaseDelay) internal virtual {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        emit BaseDelaySet($._baseDelay, newBaseDelay);\n        $._baseDelay = newBaseDelay;\n    }",
            "startLine": 132
          },
          {
            "name": "_setAccessManagerIgnored",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "selector",
                "type": "bytes4"
              },
              {
                "name": "ignored",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorTimelockAccessStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setAccessManagerIgnored(address target, bytes4 selector, bool ignored) internal virtual {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        bool isGovernor = target == address(this);\n        if (isGovernor && selector == this.setAccessManagerIgnored.selector) {\n            revert GovernorLockedIgnore();\n        }\n        $._ignoreToggle[target][selector] = ignored != isGovernor; // equivalent to: isGovernor ? !ignored : ignored\n        emit AccessManagerIgnoredSet(target, selector, ignored);\n    }",
            "startLine": 166
          },
          {
            "name": "_queueOperations",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint48"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorTimelockAccessStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Time.timestamp",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "_getManagerData",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_setManagerData",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _queueOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory /* values */,\n        bytes[] memory calldatas,\n        bytes32 /* descriptionHash */\n    ) internal virtual override returns (uint48) {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        ExecutionPlan storage plan = $._executionPlan[proposalId];\n        uint48 etaSeconds = Time.timestamp() + plan.delay;\n\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (, bool withDelay, ) = _getManagerData(plan, i);\n            if (withDelay) {\n                // This function can reenter when calling `_manager.schedule` before performing state updates in `_setManagerData`.\n                // However, the `manager` is a trusted contract in the current context's security model (e.g. an `AccessManager`).\n                // slither-disable-next-line reentrancy-no-eth\n                (, uint32 nonce) = $._manager.schedule(targets[i], calldatas[i], etaSeconds);\n                _setManagerData(plan, i, true, nonce);\n            }\n        }\n\n        return etaSeconds;\n    }",
            "startLine": 250
          },
          {
            "name": "_executeOperations",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorTimelockAccessStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "SafeCast.toUint48",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "proposalEta",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_getManagerData",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "Address.verifyCallResult",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _executeOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /* descriptionHash */\n    ) internal virtual override {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        uint48 etaSeconds = SafeCast.toUint48(proposalEta(proposalId));\n        if (block.timestamp < etaSeconds) {\n            revert GovernorUnmetDelay(proposalId, etaSeconds);\n        }\n\n        ExecutionPlan storage plan = $._executionPlan[proposalId];\n\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (bool controlled, bool withDelay, uint32 nonce) = _getManagerData(plan, i);\n            if (controlled) {\n                uint32 executedNonce = $._manager.execute{value: values[i]}(targets[i], calldatas[i]);\n                if (withDelay && executedNonce != nonce) {\n                    revert GovernorMismatchedNonce(proposalId, nonce, executedNonce);\n                }\n            } else {\n                (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);\n                Address.verifyCallResult(success, returndata);\n            }\n        }\n    }",
            "startLine": 278
          },
          {
            "name": "_cancel",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "descriptionHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorTimelockAccessStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_cancel",
                "type": "super",
                "argCount": 4
              },
              {
                "target": "SafeCast.toUint48",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "proposalEta",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_getManagerData",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint256) {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);\n\n        uint48 etaSeconds = SafeCast.toUint48(proposalEta(proposalId));\n\n        ExecutionPlan storage plan = $._executionPlan[proposalId];\n\n        // If the proposal has been scheduled it will have an ETA and we may have to externally cancel\n        if (etaSeconds != 0) {\n            for (uint256 i = 0; i < targets.length; ++i) {\n                (, bool withDelay, uint32 nonce) = _getManagerData(plan, i);\n                // Only attempt to cancel if the execution plan included a delay\n                if (withDelay) {\n                    bytes32 operationId = $._manager.hashOperation(address(this), targets[i], calldatas[i]);\n                    // Check first if the current operation nonce is the one that we observed previously. It could\n                    // already have been cancelled and rescheduled. We don't want to cancel unless it is exactly the\n                    // instance that we previously scheduled.\n                    if (nonce == $._manager.getNonce(operationId)) {\n                        // It is important that all calls have an opportunity to be cancelled. We chose to ignore\n                        // potential failures of some of the cancel operations to give the other operations a chance to\n                        // be properly cancelled. In particular cancel might fail if the operation was already cancelled\n                        // by guardians previously. We don't match on the revert reason to avoid encoding assumptions\n                        // about specific errors.\n                        try $._manager.cancel(address(this), targets[i], calldatas[i]) {} catch {}\n                    }\n                }\n            }\n        }\n\n        return proposalId;\n    }",
            "startLine": 308
          },
          {
            "name": "_getManagerData",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "plan",
                "type": "ExecutionPlan"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "controlled",
                "type": "bool"
              },
              {
                "name": "withDelay",
                "type": "bool"
              },
              {
                "name": "nonce",
                "type": "uint32"
              }
            ],
            "calls": [
              {
                "target": "_getManagerDataIndices",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _getManagerData(\n        ExecutionPlan storage plan,\n        uint256 index\n    ) private view returns (bool controlled, bool withDelay, uint32 nonce) {\n        (uint256 bucket, uint256 subindex) = _getManagerDataIndices(index);\n        uint32 value = plan.managerData[bucket][subindex];\n        unchecked {\n            return (value > 0, value > 1, value > 1 ? value - 2 : 0);\n        }\n    }",
            "startLine": 349
          },
          {
            "name": "_setManagerData",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "plan",
                "type": "ExecutionPlan"
              },
              {
                "name": "index",
                "type": "uint256"
              },
              {
                "name": "withDelay",
                "type": "bool"
              },
              {
                "name": "nonce",
                "type": "uint32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getManagerDataIndices",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _setManagerData(ExecutionPlan storage plan, uint256 index, bool withDelay, uint32 nonce) private {\n        (uint256 bucket, uint256 subindex) = _getManagerDataIndices(index);\n        plan.managerData[bucket][subindex] = withDelay ? nonce + 2 : 1;\n    }",
            "startLine": 364
          },
          {
            "name": "_getManagerDataIndices",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "bucket",
                "type": "uint256"
              },
              {
                "name": "subindex",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getManagerDataIndices(uint256 index) private pure returns (uint256 bucket, uint256 subindex) {\n        bucket = index >> 3; // index / 8\n        subindex = index & 7; // index % 8\n    }",
            "startLine": 372
          }
        ],
        "events": [
          {
            "name": "BaseDelaySet",
            "parameters": [
              {
                "name": "oldBaseDelaySeconds",
                "type": "uint32",
                "indexed": false
              },
              {
                "name": "newBaseDelaySeconds",
                "type": "uint32",
                "indexed": false
              }
            ],
            "startLine": 85
          },
          {
            "name": "AccessManagerIgnoredSet",
            "parameters": [
              {
                "name": "target",
                "type": "address",
                "indexed": false
              },
              {
                "name": "selector",
                "type": "bytes4",
                "indexed": false
              },
              {
                "name": "ignored",
                "type": "bool",
                "indexed": false
              }
            ],
            "startLine": 86
          }
        ],
        "errors": [
          {
            "name": "GovernorUnmetDelay",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "neededTimestamp",
                "type": "uint256"
              }
            ],
            "startLine": 81
          },
          {
            "name": "GovernorMismatchedNonce",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "expectedNonce",
                "type": "uint256"
              },
              {
                "name": "actualNonce",
                "type": "uint256"
              }
            ],
            "startLine": 82
          },
          {
            "name": "GovernorLockedIgnore",
            "parameters": [],
            "startLine": 83
          }
        ],
        "structs": [
          {
            "name": "ExecutionPlan",
            "members": [
              {
                "name": "length",
                "type": "uint16"
              },
              {
                "name": "delay",
                "type": "uint32"
              },
              {
                "name": "managerData",
                "type": "mapping(uint256 => uint32[])"
              }
            ],
            "startLine": 47
          },
          {
            "name": "GovernorTimelockAccessStorage",
            "members": [
              {
                "name": "_ignoreToggle",
                "type": "mapping(address => mapping(bytes4 => bool))"
              },
              {
                "name": "_executionPlan",
                "type": "mapping(uint256 => ExecutionPlan)"
              },
              {
                "name": "_baseDelay",
                "type": "uint32"
              },
              {
                "name": "_manager",
                "type": "IAccessManager"
              }
            ],
            "startLine": 59
          }
        ],
        "stateVariables": [
          {
            "name": "GovernorTimelockAccessStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 73
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/governance/IGovernor.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../GovernorUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/access/manager/AuthorityUtils.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/access/manager/IAccessManager.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/Address.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/math/Math.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/math/SafeCast.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/types/Time.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorTimelockAccess.sol)\n\npragma solidity ^0.8.24;\n\nimport {IGovernor} from \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {AuthorityUtils} from \"@openzeppelin/contracts/access/manager/AuthorityUtils.sol\";\nimport {IAccessManager} from \"@openzeppelin/contracts/access/manager/IAccessManager.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Time} from \"@openzeppelin/contracts/utils/types/Time.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev This module connects a {Governor} instance to an {AccessManager} instance, allowing the governor to make calls\n * that are delay-restricted by the manager using the normal {queue} workflow. An optional base delay is applied to\n * operations that are not delayed externally by the manager. Execution of a proposal will be delayed as much as\n * necessary to meet the required delays of all of its operations.\n *\n * This extension allows the governor to hold and use its own assets and permissions, unlike {GovernorTimelockControl}\n * and {GovernorTimelockCompound}, where the timelock is a separate contract that must be the one to hold assets and\n * permissions. Operations that are delay-restricted by the manager, however, will be executed through the\n * {AccessManager-execute} function.\n *\n * ==== Security Considerations\n *\n * Some operations may be cancelable in the `AccessManager` by the admin or a set of guardians, depending on the\n * restricted function being invoked. Since proposals are atomic, the cancellation by a guardian of a single operation\n * in a proposal will cause all of the proposal to become unable to execute. Consider proposing cancellable operations\n * separately.\n *\n * By default, function calls will be routed through the associated `AccessManager` whenever it claims the target\n * function to be restricted by it. However, admins may configure the manager to make that claim for functions that a\n * governor would want to call directly (e.g., token transfers) in an attempt to deny it access to those functions. To\n * mitigate this attack vector, the governor is able to ignore the restrictions claimed by the `AccessManager` using\n * {setAccessManagerIgnored}. While permanent denial of service is mitigated, temporary DoS may still be technically\n * possible. All of the governor's own functions (e.g., {setBaseDelaySeconds}) ignore the `AccessManager` by default.\n *\n * NOTE: `AccessManager` does not support scheduling more than one operation with the same target and calldata at\n * the same time. See {AccessManager-schedule} for a workaround.\n */\nabstract contract GovernorTimelockAccessUpgradeable is Initializable, GovernorUpgradeable {\n    // An execution plan is produced at the moment a proposal is created, in order to fix at that point the exact\n    // execution semantics of the proposal, namely whether a call will go through {AccessManager-execute}.\n    struct ExecutionPlan {\n        uint16 length;\n        uint32 delay;\n        // We use mappings instead of arrays because it allows us to pack values in storage more tightly without\n        // storing the length redundantly.\n        // We pack 8 operations' data in each bucket. Each uint32 value is set to 1 upon proposal creation if it has\n        // to be scheduled and executed through the manager. Upon queuing, the value is set to nonce + 2, where the\n        // nonce is received from the manager when scheduling the operation.\n        mapping(uint256 operationBucket => uint32[8]) managerData;\n    }\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorTimelockAccess\n    struct GovernorTimelockAccessStorage {\n        // The meaning of the \"toggle\" set to true depends on the target contract.\n        // If target == address(this), the manager is ignored by default, and a true toggle means it won't be ignored.\n        // For all other target contracts, the manager is used by default, and a true toggle means it will be ignored.\n        mapping(address target => mapping(bytes4 selector => bool)) _ignoreToggle;\n\n        mapping(uint256 proposalId => ExecutionPlan) _executionPlan;\n\n        uint32 _baseDelay;\n\n        IAccessManager _manager;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorTimelockAccess\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorTimelockAccessStorageLocation = 0xb26e23d38df572f5669f6310d407229c15b4fb320cb19bf5e8c38856d28d0800;\n\n    function _getGovernorTimelockAccessStorage() private pure returns (GovernorTimelockAccessStorage storage $) {\n        assembly {\n            $.slot := GovernorTimelockAccessStorageLocation\n        }\n    }\n\n    error GovernorUnmetDelay(uint256 proposalId, uint256 neededTimestamp);\n    error GovernorMismatchedNonce(uint256 proposalId, uint256 expectedNonce, uint256 actualNonce);\n    error GovernorLockedIgnore();\n\n    event BaseDelaySet(uint32 oldBaseDelaySeconds, uint32 newBaseDelaySeconds);\n    event AccessManagerIgnoredSet(address target, bytes4 selector, bool ignored);\n\n    /**\n     * @dev Initialize the governor with an {AccessManager} and initial base delay.\n     */\n    function __GovernorTimelockAccess_init(address manager, uint32 initialBaseDelay) internal onlyInitializing {\n        __GovernorTimelockAccess_init_unchained(manager, initialBaseDelay);\n    }\n\n    function __GovernorTimelockAccess_init_unchained(address manager, uint32 initialBaseDelay) internal onlyInitializing {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        $._manager = IAccessManager(manager);\n        _setBaseDelaySeconds(initialBaseDelay);\n    }\n\n    /**\n     * @dev Returns the {AccessManager} instance associated to this governor.\n     */\n    function accessManager() public view virtual returns (IAccessManager) {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        return $._manager;\n    }\n\n    /**\n     * @dev Base delay that will be applied to all function calls. Some may be further delayed by their associated\n     * `AccessManager` authority; in this case the final delay will be the maximum of the base delay and the one\n     * demanded by the authority.\n     *\n     * NOTE: Execution delays are processed by the `AccessManager` contracts, and according to that contract are\n     * expressed in seconds. Therefore, the base delay is also in seconds, regardless of the governor's clock mode.\n     */\n    function baseDelaySeconds() public view virtual returns (uint32) {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        return $._baseDelay;\n    }\n\n    /**\n     * @dev Change the value of {baseDelaySeconds}. This operation can only be invoked through a governance proposal.\n     */\n    function setBaseDelaySeconds(uint32 newBaseDelay) public virtual onlyGovernance {\n        _setBaseDelaySeconds(newBaseDelay);\n    }\n\n    /**\n     * @dev Change the value of {baseDelaySeconds}. Internal function without access control.\n     */\n    function _setBaseDelaySeconds(uint32 newBaseDelay) internal virtual {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        emit BaseDelaySet($._baseDelay, newBaseDelay);\n        $._baseDelay = newBaseDelay;\n    }\n\n    /**\n     * @dev Check if restrictions from the associated {AccessManager} are ignored for a target function. Returns true\n     * when the target function will be invoked directly regardless of `AccessManager` settings for the function.\n     * See {setAccessManagerIgnored} and Security Considerations above.\n     */\n    function isAccessManagerIgnored(address target, bytes4 selector) public view virtual returns (bool) {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        bool isGovernor = target == address(this);\n        return $._ignoreToggle[target][selector] != isGovernor; // equivalent to: isGovernor ? !toggle : toggle\n    }\n\n    /**\n     * @dev Configure whether restrictions from the associated {AccessManager} are ignored for a target function.\n     * See Security Considerations above.\n     */\n    function setAccessManagerIgnored(\n        address target,\n        bytes4[] calldata selectors,\n        bool ignored\n    ) public virtual onlyGovernance {\n        for (uint256 i = 0; i < selectors.length; ++i) {\n            _setAccessManagerIgnored(target, selectors[i], ignored);\n        }\n    }\n\n    /**\n     * @dev Internal version of {setAccessManagerIgnored} without access restriction.\n     */\n    function _setAccessManagerIgnored(address target, bytes4 selector, bool ignored) internal virtual {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        bool isGovernor = target == address(this);\n        if (isGovernor && selector == this.setAccessManagerIgnored.selector) {\n            revert GovernorLockedIgnore();\n        }\n        $._ignoreToggle[target][selector] = ignored != isGovernor; // equivalent to: isGovernor ? !ignored : ignored\n        emit AccessManagerIgnoredSet(target, selector, ignored);\n    }\n\n    /**\n     * @dev Public accessor to check the execution plan, including the number of seconds that the proposal will be\n     * delayed since queuing, an array indicating which of the proposal actions will be executed indirectly through\n     * the associated {AccessManager}, and another indicating which will be scheduled in {queue}. Note that\n     * those that must be scheduled are cancellable by `AccessManager` guardians.\n     */\n    function proposalExecutionPlan(\n        uint256 proposalId\n    ) public view returns (uint32 delay, bool[] memory indirect, bool[] memory withDelay) {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        ExecutionPlan storage plan = $._executionPlan[proposalId];\n\n        uint32 length = plan.length;\n        delay = plan.delay;\n        indirect = new bool[](length);\n        withDelay = new bool[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            (indirect[i], withDelay[i], ) = _getManagerData(plan, i);\n        }\n\n        return (delay, indirect, withDelay);\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalNeedsQueuing(uint256 proposalId) public view virtual override returns (bool) {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        return $._executionPlan[proposalId].delay > 0;\n    }\n\n    /// @inheritdoc IGovernor\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        uint256 proposalId = super.propose(targets, values, calldatas, description);\n\n        uint32 neededDelay = baseDelaySeconds();\n\n        ExecutionPlan storage plan = $._executionPlan[proposalId];\n        plan.length = SafeCast.toUint16(targets.length);\n\n        for (uint256 i = 0; i < targets.length; ++i) {\n            if (calldatas[i].length < 4) {\n                continue;\n            }\n            address target = targets[i];\n            bytes4 selector = bytes4(calldatas[i]);\n            (bool immediate, uint32 delay) = AuthorityUtils.canCallWithDelay(\n                address($._manager),\n                address(this),\n                target,\n                selector\n            );\n            if ((immediate || delay > 0) && !isAccessManagerIgnored(target, selector)) {\n                _setManagerData(plan, i, !immediate, 0);\n                // downcast is safe because both arguments are uint32\n                neededDelay = uint32(Math.max(delay, neededDelay));\n            }\n        }\n\n        plan.delay = neededDelay;\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Mechanism to queue a proposal, potentially scheduling some of its operations in the AccessManager.\n     *\n     * NOTE: The execution delay is chosen based on the delay information retrieved in {propose}. This value may be\n     * off if the delay was updated since proposal creation. In this case, the proposal needs to be recreated.\n     */\n    function _queueOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory /* values */,\n        bytes[] memory calldatas,\n        bytes32 /* descriptionHash */\n    ) internal virtual override returns (uint48) {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        ExecutionPlan storage plan = $._executionPlan[proposalId];\n        uint48 etaSeconds = Time.timestamp() + plan.delay;\n\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (, bool withDelay, ) = _getManagerData(plan, i);\n            if (withDelay) {\n                // This function can reenter when calling `_manager.schedule` before performing state updates in `_setManagerData`.\n                // However, the `manager` is a trusted contract in the current context's security model (e.g. an `AccessManager`).\n                // slither-disable-next-line reentrancy-no-eth\n                (, uint32 nonce) = $._manager.schedule(targets[i], calldatas[i], etaSeconds);\n                _setManagerData(plan, i, true, nonce);\n            }\n        }\n\n        return etaSeconds;\n    }\n\n    /**\n     * @dev Mechanism to execute a proposal, potentially going through {AccessManager-execute} for delayed operations.\n     */\n    function _executeOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /* descriptionHash */\n    ) internal virtual override {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        uint48 etaSeconds = SafeCast.toUint48(proposalEta(proposalId));\n        if (block.timestamp < etaSeconds) {\n            revert GovernorUnmetDelay(proposalId, etaSeconds);\n        }\n\n        ExecutionPlan storage plan = $._executionPlan[proposalId];\n\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (bool controlled, bool withDelay, uint32 nonce) = _getManagerData(plan, i);\n            if (controlled) {\n                uint32 executedNonce = $._manager.execute{value: values[i]}(targets[i], calldatas[i]);\n                if (withDelay && executedNonce != nonce) {\n                    revert GovernorMismatchedNonce(proposalId, nonce, executedNonce);\n                }\n            } else {\n                (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);\n                Address.verifyCallResult(success, returndata);\n            }\n        }\n    }\n\n    /// @inheritdoc GovernorUpgradeable\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint256) {\n        GovernorTimelockAccessStorage storage $ = _getGovernorTimelockAccessStorage();\n        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);\n\n        uint48 etaSeconds = SafeCast.toUint48(proposalEta(proposalId));\n\n        ExecutionPlan storage plan = $._executionPlan[proposalId];\n\n        // If the proposal has been scheduled it will have an ETA and we may have to externally cancel\n        if (etaSeconds != 0) {\n            for (uint256 i = 0; i < targets.length; ++i) {\n                (, bool withDelay, uint32 nonce) = _getManagerData(plan, i);\n                // Only attempt to cancel if the execution plan included a delay\n                if (withDelay) {\n                    bytes32 operationId = $._manager.hashOperation(address(this), targets[i], calldatas[i]);\n                    // Check first if the current operation nonce is the one that we observed previously. It could\n                    // already have been cancelled and rescheduled. We don't want to cancel unless it is exactly the\n                    // instance that we previously scheduled.\n                    if (nonce == $._manager.getNonce(operationId)) {\n                        // It is important that all calls have an opportunity to be cancelled. We chose to ignore\n                        // potential failures of some of the cancel operations to give the other operations a chance to\n                        // be properly cancelled. In particular cancel might fail if the operation was already cancelled\n                        // by guardians previously. We don't match on the revert reason to avoid encoding assumptions\n                        // about specific errors.\n                        try $._manager.cancel(address(this), targets[i], calldatas[i]) {} catch {}\n                    }\n                }\n            }\n        }\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Returns whether the operation at an index is delayed by the manager, and its scheduling nonce once queued.\n     */\n    function _getManagerData(\n        ExecutionPlan storage plan,\n        uint256 index\n    ) private view returns (bool controlled, bool withDelay, uint32 nonce) {\n        (uint256 bucket, uint256 subindex) = _getManagerDataIndices(index);\n        uint32 value = plan.managerData[bucket][subindex];\n        unchecked {\n            return (value > 0, value > 1, value > 1 ? value - 2 : 0);\n        }\n    }\n\n    /**\n     * @dev Marks an operation at an index as permissioned by the manager, potentially delayed, and\n     * when delayed sets its scheduling nonce.\n     */\n    function _setManagerData(ExecutionPlan storage plan, uint256 index, bool withDelay, uint32 nonce) private {\n        (uint256 bucket, uint256 subindex) = _getManagerDataIndices(index);\n        plan.managerData[bucket][subindex] = withDelay ? nonce + 2 : 1;\n    }\n\n    /**\n     * @dev Returns bucket and subindex for reading manager data from the packed array mapping.\n     */\n    function _getManagerDataIndices(uint256 index) private pure returns (uint256 bucket, uint256 subindex) {\n        bucket = index >> 3; // index / 8\n        subindex = index & 7; // index % 8\n    }\n}\n"
      },
      {
        "name": "GovernorTimelockCompoundUpgradeable",
        "filePath": "governance/extensions/GovernorTimelockCompoundUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "GovernorUpgradeable"
        ],
        "implements": [],
        "category": "governance/extensions",
        "externalFunctions": [
          {
            "name": "state",
            "signature": "state(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "ProposalState"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorTimelockCompoundStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "state",
                "type": "super",
                "argCount": 1
              },
              {
                "target": "proposalEta",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function state(uint256 proposalId) public view virtual override returns (ProposalState) {\n        GovernorTimelockCompoundStorage storage $ = _getGovernorTimelockCompoundStorage();\n        ProposalState currentState = super.state(proposalId);\n\n        return\n            (currentState == ProposalState.Queued &&\n                block.timestamp >= proposalEta(proposalId) + $._timelock.GRACE_PERIOD())\n                ? ProposalState.Expired\n                : currentState;\n    }",
            "startLine": 57
          },
          {
            "name": "timelock",
            "signature": "timelock()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorTimelockCompoundStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function timelock() public view virtual returns (address) {\n        GovernorTimelockCompoundStorage storage $ = _getGovernorTimelockCompoundStorage();\n        return address($._timelock);\n    }",
            "startLine": 71
          },
          {
            "name": "proposalNeedsQueuing",
            "signature": "proposalNeedsQueuing(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalNeedsQueuing(uint256) public view virtual override returns (bool) {\n        return true;\n    }",
            "startLine": 77
          },
          {
            "name": "__acceptAdmin",
            "signature": "__acceptAdmin()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorTimelockCompoundStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function __acceptAdmin() public {\n        GovernorTimelockCompoundStorage storage $ = _getGovernorTimelockCompoundStorage();\n        $._timelock.acceptAdmin();\n    }",
            "startLine": 164
          },
          {
            "name": "updateTimelock",
            "signature": "updateTimelock(ICompoundTimelock)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newTimelock",
                "type": "ICompoundTimelock"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_updateTimelock",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function updateTimelock(ICompoundTimelock newTimelock) public virtual onlyGovernance {\n        _updateTimelock(newTimelock);\n    }",
            "startLine": 182
          }
        ],
        "internalFunctions": [
          {
            "name": "_getGovernorTimelockCompoundStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "GovernorTimelockCompoundStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getGovernorTimelockCompoundStorage() private pure returns (GovernorTimelockCompoundStorage storage $) {\n        assembly {\n            $.slot := GovernorTimelockCompoundStorageLocation\n        }\n    }",
            "startLine": 32
          },
          {
            "name": "__GovernorTimelockCompound_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "timelockAddress",
                "type": "ICompoundTimelock"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorTimelockCompound_init(ICompoundTimelock timelockAddress) internal onlyInitializing {\n        __GovernorTimelockCompound_init_unchained(timelockAddress);\n    }",
            "startLine": 46
          },
          {
            "name": "__GovernorTimelockCompound_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "timelockAddress",
                "type": "ICompoundTimelock"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_updateTimelock",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __GovernorTimelockCompound_init_unchained(ICompoundTimelock timelockAddress) internal onlyInitializing {\n        _updateTimelock(timelockAddress);\n    }",
            "startLine": 50
          },
          {
            "name": "_queueOperations",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint48"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorTimelockCompoundStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "SafeCast.toUint48",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _queueOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual override returns (uint48) {\n        GovernorTimelockCompoundStorage storage $ = _getGovernorTimelockCompoundStorage();\n        uint48 etaSeconds = SafeCast.toUint48(block.timestamp + $._timelock.delay());\n\n        for (uint256 i = 0; i < targets.length; ++i) {\n            if (\n                $._timelock.queuedTransactions(keccak256(abi.encode(targets[i], values[i], \"\", calldatas[i], etaSeconds)))\n            ) {\n                revert GovernorAlreadyQueuedProposal(proposalId);\n            }\n            $._timelock.queueTransaction(targets[i], values[i], \"\", calldatas[i], etaSeconds);\n        }\n\n        return etaSeconds;\n    }",
            "startLine": 84
          },
          {
            "name": "_executeOperations",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorTimelockCompoundStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "proposalEta",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "Address.sendValue",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _executeOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual override {\n        GovernorTimelockCompoundStorage storage $ = _getGovernorTimelockCompoundStorage();\n        uint256 etaSeconds = proposalEta(proposalId);\n        if (etaSeconds == 0) {\n            revert GovernorNotQueuedProposal(proposalId);\n        }\n        Address.sendValue(payable($._timelock), msg.value);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            $._timelock.executeTransaction(targets[i], values[i], \"\", calldatas[i], etaSeconds);\n        }\n    }",
            "startLine": 110
          },
          {
            "name": "_cancel",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "descriptionHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorTimelockCompoundStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_cancel",
                "type": "super",
                "argCount": 4
              },
              {
                "target": "proposalEta",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint256) {\n        GovernorTimelockCompoundStorage storage $ = _getGovernorTimelockCompoundStorage();\n        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);\n\n        uint256 etaSeconds = proposalEta(proposalId);\n        if (etaSeconds > 0) {\n            // do external call later\n            for (uint256 i = 0; i < targets.length; ++i) {\n                $._timelock.cancelTransaction(targets[i], values[i], \"\", calldatas[i], etaSeconds);\n            }\n        }\n\n        return proposalId;\n    }",
            "startLine": 132
          },
          {
            "name": "_executor",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorTimelockCompoundStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _executor() internal view virtual override returns (address) {\n        GovernorTimelockCompoundStorage storage $ = _getGovernorTimelockCompoundStorage();\n        return address($._timelock);\n    }",
            "startLine": 155
          },
          {
            "name": "_updateTimelock",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newTimelock",
                "type": "ICompoundTimelock"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorTimelockCompoundStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _updateTimelock(ICompoundTimelock newTimelock) private {\n        GovernorTimelockCompoundStorage storage $ = _getGovernorTimelockCompoundStorage();\n        emit TimelockChange(address($._timelock), address(newTimelock));\n        $._timelock = newTimelock;\n    }",
            "startLine": 186
          }
        ],
        "events": [
          {
            "name": "TimelockChange",
            "parameters": [
              {
                "name": "oldTimelock",
                "type": "address",
                "indexed": false
              },
              {
                "name": "newTimelock",
                "type": "address",
                "indexed": false
              }
            ],
            "startLine": 41
          }
        ],
        "errors": [],
        "structs": [
          {
            "name": "GovernorTimelockCompoundStorage",
            "members": [
              {
                "name": "_timelock",
                "type": "ICompoundTimelock"
              }
            ],
            "startLine": 25
          }
        ],
        "stateVariables": [
          {
            "name": "GovernorTimelockCompoundStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 30
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/governance/IGovernor.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../GovernorUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/vendor/compound/ICompoundTimelock.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/Address.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/math/SafeCast.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (governance/extensions/GovernorTimelockCompound.sol)\n\npragma solidity ^0.8.24;\n\nimport {IGovernor} from \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {ICompoundTimelock} from \"@openzeppelin/contracts/vendor/compound/ICompoundTimelock.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} that binds the execution process to a Compound Timelock. This adds a delay, enforced by\n * the external timelock to all successful proposals (in addition to the voting duration). The {Governor} needs to be\n * the admin of the timelock for any operation to be performed. A public, unrestricted,\n * {GovernorTimelockCompound-__acceptAdmin} is available to accept ownership of the timelock.\n *\n * Using this model means the proposal will be operated by the {TimelockController} and not by the {Governor}. Thus,\n * the assets and permissions must be attached to the {TimelockController}. Any asset sent to the {Governor} will be\n * inaccessible from a proposal, unless executed via {Governor-relay}.\n */\nabstract contract GovernorTimelockCompoundUpgradeable is Initializable, GovernorUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorTimelockCompound\n    struct GovernorTimelockCompoundStorage {\n        ICompoundTimelock _timelock;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorTimelockCompound\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorTimelockCompoundStorageLocation = 0x7d1501d734d0ca30b8d26751a7fae89646767b24afe11265192d56e5fe515b00;\n\n    function _getGovernorTimelockCompoundStorage() private pure returns (GovernorTimelockCompoundStorage storage $) {\n        assembly {\n            $.slot := GovernorTimelockCompoundStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the timelock controller used for proposal execution is modified.\n     */\n    event TimelockChange(address oldTimelock, address newTimelock);\n\n    /**\n     * @dev Set the timelock.\n     */\n    function __GovernorTimelockCompound_init(ICompoundTimelock timelockAddress) internal onlyInitializing {\n        __GovernorTimelockCompound_init_unchained(timelockAddress);\n    }\n\n    function __GovernorTimelockCompound_init_unchained(ICompoundTimelock timelockAddress) internal onlyInitializing {\n        _updateTimelock(timelockAddress);\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-state} function with added support for the `Expired` state.\n     */\n    function state(uint256 proposalId) public view virtual override returns (ProposalState) {\n        GovernorTimelockCompoundStorage storage $ = _getGovernorTimelockCompoundStorage();\n        ProposalState currentState = super.state(proposalId);\n\n        return\n            (currentState == ProposalState.Queued &&\n                block.timestamp >= proposalEta(proposalId) + $._timelock.GRACE_PERIOD())\n                ? ProposalState.Expired\n                : currentState;\n    }\n\n    /**\n     * @dev Public accessor to check the address of the timelock\n     */\n    function timelock() public view virtual returns (address) {\n        GovernorTimelockCompoundStorage storage $ = _getGovernorTimelockCompoundStorage();\n        return address($._timelock);\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalNeedsQueuing(uint256) public view virtual override returns (bool) {\n        return true;\n    }\n\n    /**\n     * @dev Function to queue a proposal to the timelock.\n     */\n    function _queueOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual override returns (uint48) {\n        GovernorTimelockCompoundStorage storage $ = _getGovernorTimelockCompoundStorage();\n        uint48 etaSeconds = SafeCast.toUint48(block.timestamp + $._timelock.delay());\n\n        for (uint256 i = 0; i < targets.length; ++i) {\n            if (\n                $._timelock.queuedTransactions(keccak256(abi.encode(targets[i], values[i], \"\", calldatas[i], etaSeconds)))\n            ) {\n                revert GovernorAlreadyQueuedProposal(proposalId);\n            }\n            $._timelock.queueTransaction(targets[i], values[i], \"\", calldatas[i], etaSeconds);\n        }\n\n        return etaSeconds;\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-_executeOperations} function that run the already queued proposal\n     * through the timelock.\n     */\n    function _executeOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual override {\n        GovernorTimelockCompoundStorage storage $ = _getGovernorTimelockCompoundStorage();\n        uint256 etaSeconds = proposalEta(proposalId);\n        if (etaSeconds == 0) {\n            revert GovernorNotQueuedProposal(proposalId);\n        }\n        Address.sendValue(payable($._timelock), msg.value);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            $._timelock.executeTransaction(targets[i], values[i], \"\", calldatas[i], etaSeconds);\n        }\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-_cancel} function to cancel the timelocked proposal if it has already\n     * been queued.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint256) {\n        GovernorTimelockCompoundStorage storage $ = _getGovernorTimelockCompoundStorage();\n        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);\n\n        uint256 etaSeconds = proposalEta(proposalId);\n        if (etaSeconds > 0) {\n            // do external call later\n            for (uint256 i = 0; i < targets.length; ++i) {\n                $._timelock.cancelTransaction(targets[i], values[i], \"\", calldatas[i], etaSeconds);\n            }\n        }\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Address through which the governor executes action. In this case, the timelock.\n     */\n    function _executor() internal view virtual override returns (address) {\n        GovernorTimelockCompoundStorage storage $ = _getGovernorTimelockCompoundStorage();\n        return address($._timelock);\n    }\n\n    /**\n     * @dev Accept admin right over the timelock.\n     */\n    // solhint-disable-next-line openzeppelin/leading-underscore\n    function __acceptAdmin() public {\n        GovernorTimelockCompoundStorage storage $ = _getGovernorTimelockCompoundStorage();\n        $._timelock.acceptAdmin();\n    }\n\n    /**\n     * @dev Public endpoint to update the underlying timelock instance. Restricted to the timelock itself, so updates\n     * must be proposed, scheduled, and executed through governance proposals.\n     *\n     * For security reasons, the timelock must be handed over to another admin before setting up a new one. The two\n     * operations (hand over the timelock) and do the update can be batched in a single proposal.\n     *\n     * Note that if the timelock admin has been handed over in a previous operation, we refuse updates made through the\n     * timelock if admin of the timelock has already been accepted and the operation is executed outside the scope of\n     * governance.\n\n     * CAUTION: It is not recommended to change the timelock while there are other queued governance proposals.\n     */\n    function updateTimelock(ICompoundTimelock newTimelock) public virtual onlyGovernance {\n        _updateTimelock(newTimelock);\n    }\n\n    function _updateTimelock(ICompoundTimelock newTimelock) private {\n        GovernorTimelockCompoundStorage storage $ = _getGovernorTimelockCompoundStorage();\n        emit TimelockChange(address($._timelock), address(newTimelock));\n        $._timelock = newTimelock;\n    }\n}\n"
      },
      {
        "name": "GovernorTimelockControlUpgradeable",
        "filePath": "governance/extensions/GovernorTimelockControlUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "GovernorUpgradeable"
        ],
        "implements": [],
        "category": "governance/extensions",
        "externalFunctions": [
          {
            "name": "state",
            "signature": "state(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "ProposalState"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorTimelockControlStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "state",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function state(uint256 proposalId) public view virtual override returns (ProposalState) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        ProposalState currentState = super.state(proposalId);\n\n        if (currentState != ProposalState.Queued) {\n            return currentState;\n        }\n\n        bytes32 queueId = $._timelockIds[proposalId];\n        if ($._timelock.isOperationPending(queueId)) {\n            return ProposalState.Queued;\n        } else if ($._timelock.isOperationDone(queueId)) {\n            // This can happen if the proposal is executed directly on the timelock.\n            return ProposalState.Executed;\n        } else {\n            // This can happen if the proposal is canceled directly on the timelock.\n            return ProposalState.Canceled;\n        }\n    }",
            "startLine": 61
          },
          {
            "name": "timelock",
            "signature": "timelock()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorTimelockControlStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function timelock() public view virtual returns (address) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        return address($._timelock);\n    }",
            "startLine": 84
          },
          {
            "name": "proposalNeedsQueuing",
            "signature": "proposalNeedsQueuing(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function proposalNeedsQueuing(uint256) public view virtual override returns (bool) {\n        return true;\n    }",
            "startLine": 90
          },
          {
            "name": "updateTimelock",
            "signature": "updateTimelock(TimelockControllerUpgradeable)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newTimelock",
                "type": "TimelockControllerUpgradeable"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_updateTimelock",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function updateTimelock(TimelockControllerUpgradeable newTimelock) public virtual onlyGovernance {\n        _updateTimelock(newTimelock);\n    }",
            "startLine": 173
          }
        ],
        "internalFunctions": [
          {
            "name": "_getGovernorTimelockControlStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "GovernorTimelockControlStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getGovernorTimelockControlStorage() private pure returns (GovernorTimelockControlStorage storage $) {\n        assembly {\n            $.slot := GovernorTimelockControlStorageLocation\n        }\n    }",
            "startLine": 36
          },
          {
            "name": "__GovernorTimelockControl_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "timelockAddress",
                "type": "TimelockControllerUpgradeable"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorTimelockControl_init(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {\n        __GovernorTimelockControl_init_unchained(timelockAddress);\n    }",
            "startLine": 50
          },
          {
            "name": "__GovernorTimelockControl_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "timelockAddress",
                "type": "TimelockControllerUpgradeable"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_updateTimelock",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __GovernorTimelockControl_init_unchained(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {\n        _updateTimelock(timelockAddress);\n    }",
            "startLine": 54
          },
          {
            "name": "_queueOperations",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "descriptionHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint48"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorTimelockControlStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_timelockSalt",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "SafeCast.toUint48",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _queueOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint48) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        uint256 delay = $._timelock.getMinDelay();\n\n        bytes32 salt = _timelockSalt(descriptionHash);\n        $._timelockIds[proposalId] = $._timelock.hashOperationBatch(targets, values, calldatas, 0, salt);\n        $._timelock.scheduleBatch(targets, values, calldatas, 0, salt, delay);\n\n        return SafeCast.toUint48(block.timestamp + delay);\n    }",
            "startLine": 97
          },
          {
            "name": "_executeOperations",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              },
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "descriptionHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorTimelockControlStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_timelockSalt",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _executeOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        // execute\n        $._timelock.executeBatch{value: msg.value}(targets, values, calldatas, 0, _timelockSalt(descriptionHash));\n        // cleanup for refund\n        delete $._timelockIds[proposalId];\n    }",
            "startLine": 118
          },
          {
            "name": "_cancel",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "targets",
                "type": "address[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "calldatas",
                "type": "bytes[]"
              },
              {
                "name": "descriptionHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorTimelockControlStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_cancel",
                "type": "super",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint256) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);\n\n        bytes32 timelockId = $._timelockIds[proposalId];\n        if (timelockId != 0) {\n            // cancel\n            $._timelock.cancel(timelockId);\n            // cleanup\n            delete $._timelockIds[proposalId];\n        }\n\n        return proposalId;\n    }",
            "startLine": 139
          },
          {
            "name": "_executor",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorTimelockControlStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _executor() internal view virtual override returns (address) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        return address($._timelock);\n    }",
            "startLine": 162
          },
          {
            "name": "_updateTimelock",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newTimelock",
                "type": "TimelockControllerUpgradeable"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorTimelockControlStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _updateTimelock(TimelockControllerUpgradeable newTimelock) private {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        emit TimelockChange(address($._timelock), address(newTimelock));\n        $._timelock = newTimelock;\n    }",
            "startLine": 177
          },
          {
            "name": "_timelockSalt",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "descriptionHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _timelockSalt(bytes32 descriptionHash) private view returns (bytes32) {\n        return bytes20(address(this)) ^ descriptionHash;\n    }",
            "startLine": 189
          }
        ],
        "events": [
          {
            "name": "TimelockChange",
            "parameters": [
              {
                "name": "oldTimelock",
                "type": "address",
                "indexed": false
              },
              {
                "name": "newTimelock",
                "type": "address",
                "indexed": false
              }
            ],
            "startLine": 45
          }
        ],
        "errors": [],
        "structs": [
          {
            "name": "GovernorTimelockControlStorage",
            "members": [
              {
                "name": "_timelock",
                "type": "TimelockControllerUpgradeable"
              },
              {
                "name": "_timelockIds",
                "type": "mapping(uint256 => bytes32)"
              }
            ],
            "startLine": 28
          }
        ],
        "stateVariables": [
          {
            "name": "GovernorTimelockControlStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 34
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/governance/IGovernor.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../GovernorUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../TimelockControllerUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/math/SafeCast.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (governance/extensions/GovernorTimelockControl.sol)\n\npragma solidity ^0.8.24;\n\nimport {IGovernor} from \"@openzeppelin/contracts/governance/IGovernor.sol\";\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {TimelockControllerUpgradeable} from \"../TimelockControllerUpgradeable.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} that binds the execution process to an instance of {TimelockController}. This adds a\n * delay, enforced by the {TimelockController} to all successful proposals (in addition to the voting duration). The\n * {Governor} needs the proposer (and ideally the executor and canceller) roles for the {Governor} to work properly.\n *\n * Using this model means the proposal will be operated by the {TimelockController} and not by the {Governor}. Thus,\n * the assets and permissions must be attached to the {TimelockController}. Any asset sent to the {Governor} will be\n * inaccessible from a proposal, unless executed via {Governor-relay}.\n *\n * WARNING: Setting up the TimelockController to have additional proposers or cancelers besides the governor is very\n * risky, as it grants them the ability to: 1) execute operations as the timelock, and thus possibly performing\n * operations or accessing funds that are expected to only be accessible through a vote, and 2) block governance\n * proposals that have been approved by the voters, effectively executing a Denial of Service attack.\n */\nabstract contract GovernorTimelockControlUpgradeable is Initializable, GovernorUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorTimelockControl\n    struct GovernorTimelockControlStorage {\n        TimelockControllerUpgradeable _timelock;\n        mapping(uint256 proposalId => bytes32) _timelockIds;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorTimelockControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorTimelockControlStorageLocation = 0x0d5829787b8befdbc6044ef7457d8a95c2a04bc99235349f1a212c063e59d400;\n\n    function _getGovernorTimelockControlStorage() private pure returns (GovernorTimelockControlStorage storage $) {\n        assembly {\n            $.slot := GovernorTimelockControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the timelock controller used for proposal execution is modified.\n     */\n    event TimelockChange(address oldTimelock, address newTimelock);\n\n    /**\n     * @dev Set the timelock.\n     */\n    function __GovernorTimelockControl_init(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {\n        __GovernorTimelockControl_init_unchained(timelockAddress);\n    }\n\n    function __GovernorTimelockControl_init_unchained(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {\n        _updateTimelock(timelockAddress);\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-state} function that considers the status reported by the timelock.\n     */\n    function state(uint256 proposalId) public view virtual override returns (ProposalState) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        ProposalState currentState = super.state(proposalId);\n\n        if (currentState != ProposalState.Queued) {\n            return currentState;\n        }\n\n        bytes32 queueId = $._timelockIds[proposalId];\n        if ($._timelock.isOperationPending(queueId)) {\n            return ProposalState.Queued;\n        } else if ($._timelock.isOperationDone(queueId)) {\n            // This can happen if the proposal is executed directly on the timelock.\n            return ProposalState.Executed;\n        } else {\n            // This can happen if the proposal is canceled directly on the timelock.\n            return ProposalState.Canceled;\n        }\n    }\n\n    /**\n     * @dev Public accessor to check the address of the timelock\n     */\n    function timelock() public view virtual returns (address) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        return address($._timelock);\n    }\n\n    /// @inheritdoc IGovernor\n    function proposalNeedsQueuing(uint256) public view virtual override returns (bool) {\n        return true;\n    }\n\n    /**\n     * @dev Function to queue a proposal to the timelock.\n     */\n    function _queueOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint48) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        uint256 delay = $._timelock.getMinDelay();\n\n        bytes32 salt = _timelockSalt(descriptionHash);\n        $._timelockIds[proposalId] = $._timelock.hashOperationBatch(targets, values, calldatas, 0, salt);\n        $._timelock.scheduleBatch(targets, values, calldatas, 0, salt, delay);\n\n        return SafeCast.toUint48(block.timestamp + delay);\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-_executeOperations} function that runs the already queued proposal\n     * through the timelock.\n     */\n    function _executeOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        // execute\n        $._timelock.executeBatch{value: msg.value}(targets, values, calldatas, 0, _timelockSalt(descriptionHash));\n        // cleanup for refund\n        delete $._timelockIds[proposalId];\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-_cancel} function to cancel the timelocked proposal if it has already\n     * been queued.\n     */\n    // This function can reenter through the external call to the timelock, but we assume the timelock is trusted and\n    // well behaved (according to TimelockController) and this will not happen.\n    // slither-disable-next-line reentrancy-no-eth\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint256) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);\n\n        bytes32 timelockId = $._timelockIds[proposalId];\n        if (timelockId != 0) {\n            // cancel\n            $._timelock.cancel(timelockId);\n            // cleanup\n            delete $._timelockIds[proposalId];\n        }\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Address through which the governor executes action. In this case, the timelock.\n     */\n    function _executor() internal view virtual override returns (address) {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        return address($._timelock);\n    }\n\n    /**\n     * @dev Public endpoint to update the underlying timelock instance. Restricted to the timelock itself, so updates\n     * must be proposed, scheduled, and executed through governance proposals.\n     *\n     * CAUTION: It is not recommended to change the timelock while there are other queued governance proposals.\n     */\n    function updateTimelock(TimelockControllerUpgradeable newTimelock) public virtual onlyGovernance {\n        _updateTimelock(newTimelock);\n    }\n\n    function _updateTimelock(TimelockControllerUpgradeable newTimelock) private {\n        GovernorTimelockControlStorage storage $ = _getGovernorTimelockControlStorage();\n        emit TimelockChange(address($._timelock), address(newTimelock));\n        $._timelock = newTimelock;\n    }\n\n    /**\n     * @dev Computes the {TimelockController} operation salt.\n     *\n     * It is computed with the governor address itself to avoid collisions across governor instances using the\n     * same timelock.\n     */\n    function _timelockSalt(bytes32 descriptionHash) private view returns (bytes32) {\n        return bytes20(address(this)) ^ descriptionHash;\n    }\n}\n"
      },
      {
        "name": "GovernorVotesQuorumFractionUpgradeable",
        "filePath": "governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "GovernorVotesUpgradeable"
        ],
        "implements": [],
        "category": "governance/extensions",
        "externalFunctions": [
          {
            "name": "quorumNumerator",
            "signature": "quorumNumerator()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorVotesQuorumFractionStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Checkpoints.latest",
                "type": "library",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function quorumNumerator() public view virtual returns (uint256) {\n        GovernorVotesQuorumFractionStorage storage $ = _getGovernorVotesQuorumFractionStorage();\n        return $._quorumNumeratorHistory.latest();\n    }",
            "startLine": 58
          },
          {
            "name": "quorumNumerator",
            "signature": "quorumNumerator(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "timepoint",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorVotesQuorumFractionStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_optimisticUpperLookupRecent",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function quorumNumerator(uint256 timepoint) public view virtual returns (uint256) {\n        GovernorVotesQuorumFractionStorage storage $ = _getGovernorVotesQuorumFractionStorage();\n        return _optimisticUpperLookupRecent($._quorumNumeratorHistory, timepoint);\n    }",
            "startLine": 66
          },
          {
            "name": "quorumDenominator",
            "signature": "quorumDenominator()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function quorumDenominator() public view virtual returns (uint256) {\n        return 100;\n    }",
            "startLine": 74
          },
          {
            "name": "quorum",
            "signature": "quorum(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "timepoint",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "Math.mulDiv",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "Checkpoints.getPastTotalSupply",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "token",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "quorumNumerator",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "quorumDenominator",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function quorum(uint256 timepoint) public view virtual override returns (uint256) {\n        return Math.mulDiv(token().getPastTotalSupply(timepoint), quorumNumerator(timepoint), quorumDenominator());\n    }",
            "startLine": 81
          },
          {
            "name": "updateQuorumNumerator",
            "signature": "updateQuorumNumerator(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newQuorumNumerator",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_updateQuorumNumerator",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function updateQuorumNumerator(uint256 newQuorumNumerator) public virtual onlyGovernance {\n        _updateQuorumNumerator(newQuorumNumerator);\n    }",
            "startLine": 95
          }
        ],
        "internalFunctions": [
          {
            "name": "_getGovernorVotesQuorumFractionStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "GovernorVotesQuorumFractionStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getGovernorVotesQuorumFractionStorage() private pure returns (GovernorVotesQuorumFractionStorage storage $) {\n        assembly {\n            $.slot := GovernorVotesQuorumFractionStorageLocation\n        }\n    }",
            "startLine": 27
          },
          {
            "name": "__GovernorVotesQuorumFraction_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "quorumNumeratorValue",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorVotesQuorumFraction_init(uint256 quorumNumeratorValue) internal onlyInitializing {\n        __GovernorVotesQuorumFraction_init_unchained(quorumNumeratorValue);\n    }",
            "startLine": 47
          },
          {
            "name": "__GovernorVotesQuorumFraction_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "quorumNumeratorValue",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_updateQuorumNumerator",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __GovernorVotesQuorumFraction_init_unchained(uint256 quorumNumeratorValue) internal onlyInitializing {\n        _updateQuorumNumerator(quorumNumeratorValue);\n    }",
            "startLine": 51
          },
          {
            "name": "_updateQuorumNumerator",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newQuorumNumerator",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorVotesQuorumFractionStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "quorumDenominator",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "quorumNumerator",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Checkpoints.push",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "clock",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "SafeCast.toUint208",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _updateQuorumNumerator(uint256 newQuorumNumerator) internal virtual {\n        GovernorVotesQuorumFractionStorage storage $ = _getGovernorVotesQuorumFractionStorage();\n        uint256 denominator = quorumDenominator();\n        if (newQuorumNumerator > denominator) {\n            revert GovernorInvalidQuorumFraction(newQuorumNumerator, denominator);\n        }\n\n        uint256 oldQuorumNumerator = quorumNumerator();\n        $._quorumNumeratorHistory.push(clock(), SafeCast.toUint208(newQuorumNumerator));\n\n        emit QuorumNumeratorUpdated(oldQuorumNumerator, newQuorumNumerator);\n    }",
            "startLine": 108
          },
          {
            "name": "_optimisticUpperLookupRecent",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "ckpts",
                "type": "Checkpoints.Trace208"
              },
              {
                "name": "timepoint",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "Checkpoints.latestCheckpoint",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "Checkpoints.upperLookupRecent",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "SafeCast.toUint48",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _optimisticUpperLookupRecent(\n        Checkpoints.Trace208 storage ckpts,\n        uint256 timepoint\n    ) internal view returns (uint256) {\n        // If trace is empty, key and value are both equal to 0.\n        // In that case `key <= timepoint` is true, and it is ok to return 0.\n        (, uint48 key, uint208 value) = ckpts.latestCheckpoint();\n        return key <= timepoint ? value : ckpts.upperLookupRecent(SafeCast.toUint48(timepoint));\n    }",
            "startLine": 124
          }
        ],
        "events": [
          {
            "name": "QuorumNumeratorUpdated",
            "parameters": [
              {
                "name": "oldQuorumNumerator",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "newQuorumNumerator",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 33
          }
        ],
        "errors": [
          {
            "name": "GovernorInvalidQuorumFraction",
            "parameters": [
              {
                "name": "quorumNumerator",
                "type": "uint256"
              },
              {
                "name": "quorumDenominator",
                "type": "uint256"
              }
            ],
            "startLine": 38
          }
        ],
        "structs": [
          {
            "name": "GovernorVotesQuorumFractionStorage",
            "members": [
              {
                "name": "_quorumNumeratorHistory",
                "type": "Checkpoints.Trace208"
              }
            ],
            "startLine": 20
          }
        ],
        "stateVariables": [
          {
            "name": "GovernorVotesQuorumFractionStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 25
          }
        ],
        "usesLibraries": [
          "Checkpoints"
        ],
        "imports": [
          {
            "path": "./GovernorVotesUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/math/Math.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/math/SafeCast.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/structs/Checkpoints.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (governance/extensions/GovernorVotesQuorumFraction.sol)\n\npragma solidity ^0.8.24;\n\nimport {GovernorVotesUpgradeable} from \"./GovernorVotesUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Checkpoints} from \"@openzeppelin/contracts/utils/structs/Checkpoints.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token and a quorum expressed as a\n * fraction of the total supply.\n */\nabstract contract GovernorVotesQuorumFractionUpgradeable is Initializable, GovernorVotesUpgradeable {\n    using Checkpoints for Checkpoints.Trace208;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorVotesQuorumFraction\n    struct GovernorVotesQuorumFractionStorage {\n        Checkpoints.Trace208 _quorumNumeratorHistory;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorVotesQuorumFraction\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorVotesQuorumFractionStorageLocation = 0xe770710421fd2cad75ad828c61aa98f2d77d423a440b67872d0f65554148e000;\n\n    function _getGovernorVotesQuorumFractionStorage() private pure returns (GovernorVotesQuorumFractionStorage storage $) {\n        assembly {\n            $.slot := GovernorVotesQuorumFractionStorageLocation\n        }\n    }\n\n    event QuorumNumeratorUpdated(uint256 oldQuorumNumerator, uint256 newQuorumNumerator);\n\n    /**\n     * @dev The quorum set is not a valid fraction.\n     */\n    error GovernorInvalidQuorumFraction(uint256 quorumNumerator, uint256 quorumDenominator);\n\n    /**\n     * @dev Initialize quorum as a fraction of the token's total supply.\n     *\n     * The fraction is specified as `numerator / denominator`. By default the denominator is 100, so quorum is\n     * specified as a percent: a numerator of 10 corresponds to quorum being 10% of total supply. The denominator can be\n     * customized by overriding {quorumDenominator}.\n     */\n    function __GovernorVotesQuorumFraction_init(uint256 quorumNumeratorValue) internal onlyInitializing {\n        __GovernorVotesQuorumFraction_init_unchained(quorumNumeratorValue);\n    }\n\n    function __GovernorVotesQuorumFraction_init_unchained(uint256 quorumNumeratorValue) internal onlyInitializing {\n        _updateQuorumNumerator(quorumNumeratorValue);\n    }\n\n    /**\n     * @dev Returns the current quorum numerator. See {quorumDenominator}.\n     */\n    function quorumNumerator() public view virtual returns (uint256) {\n        GovernorVotesQuorumFractionStorage storage $ = _getGovernorVotesQuorumFractionStorage();\n        return $._quorumNumeratorHistory.latest();\n    }\n\n    /**\n     * @dev Returns the quorum numerator at a specific timepoint. See {quorumDenominator}.\n     */\n    function quorumNumerator(uint256 timepoint) public view virtual returns (uint256) {\n        GovernorVotesQuorumFractionStorage storage $ = _getGovernorVotesQuorumFractionStorage();\n        return _optimisticUpperLookupRecent($._quorumNumeratorHistory, timepoint);\n    }\n\n    /**\n     * @dev Returns the quorum denominator. Defaults to 100, but may be overridden.\n     */\n    function quorumDenominator() public view virtual returns (uint256) {\n        return 100;\n    }\n\n    /**\n     * @dev Returns the quorum for a timepoint, in terms of number of votes: `supply * numerator / denominator`.\n     */\n    function quorum(uint256 timepoint) public view virtual override returns (uint256) {\n        return Math.mulDiv(token().getPastTotalSupply(timepoint), quorumNumerator(timepoint), quorumDenominator());\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - Must be called through a governance proposal.\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function updateQuorumNumerator(uint256 newQuorumNumerator) public virtual onlyGovernance {\n        _updateQuorumNumerator(newQuorumNumerator);\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function _updateQuorumNumerator(uint256 newQuorumNumerator) internal virtual {\n        GovernorVotesQuorumFractionStorage storage $ = _getGovernorVotesQuorumFractionStorage();\n        uint256 denominator = quorumDenominator();\n        if (newQuorumNumerator > denominator) {\n            revert GovernorInvalidQuorumFraction(newQuorumNumerator, denominator);\n        }\n\n        uint256 oldQuorumNumerator = quorumNumerator();\n        $._quorumNumeratorHistory.push(clock(), SafeCast.toUint208(newQuorumNumerator));\n\n        emit QuorumNumeratorUpdated(oldQuorumNumerator, newQuorumNumerator);\n    }\n\n    /**\n     * @dev Returns the numerator at a specific timepoint.\n     */\n    function _optimisticUpperLookupRecent(\n        Checkpoints.Trace208 storage ckpts,\n        uint256 timepoint\n    ) internal view returns (uint256) {\n        // If trace is empty, key and value are both equal to 0.\n        // In that case `key <= timepoint` is true, and it is ok to return 0.\n        (, uint48 key, uint208 value) = ckpts.latestCheckpoint();\n        return key <= timepoint ? value : ckpts.upperLookupRecent(SafeCast.toUint48(timepoint));\n    }\n}\n"
      },
      {
        "name": "GovernorVotesSuperQuorumFractionUpgradeable",
        "filePath": "governance/extensions/GovernorVotesSuperQuorumFractionUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "GovernorVotesQuorumFractionUpgradeable",
          "GovernorSuperQuorumUpgradeable"
        ],
        "implements": [],
        "category": "governance/extensions",
        "externalFunctions": [
          {
            "name": "superQuorumNumerator",
            "signature": "superQuorumNumerator()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorVotesSuperQuorumFractionStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Checkpoints.latest",
                "type": "library",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function superQuorumNumerator() public view virtual returns (uint256) {\n        GovernorVotesSuperQuorumFractionStorage storage $ = _getGovernorVotesSuperQuorumFractionStorage();\n        return $._superQuorumNumeratorHistory.latest();\n    }",
            "startLine": 70
          },
          {
            "name": "superQuorumNumerator",
            "signature": "superQuorumNumerator(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "timepoint",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorVotesSuperQuorumFractionStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_optimisticUpperLookupRecent",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function superQuorumNumerator(uint256 timepoint) public view virtual returns (uint256) {\n        GovernorVotesSuperQuorumFractionStorage storage $ = _getGovernorVotesSuperQuorumFractionStorage();\n        return _optimisticUpperLookupRecent($._superQuorumNumeratorHistory, timepoint);\n    }",
            "startLine": 78
          },
          {
            "name": "superQuorum",
            "signature": "superQuorum(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "timepoint",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "Math.mulDiv",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "Checkpoints.getPastTotalSupply",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "token",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "superQuorumNumerator",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "quorumDenominator",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function superQuorum(uint256 timepoint) public view virtual override returns (uint256) {\n        return Math.mulDiv(token().getPastTotalSupply(timepoint), superQuorumNumerator(timepoint), quorumDenominator());\n    }",
            "startLine": 87
          },
          {
            "name": "updateSuperQuorumNumerator",
            "signature": "updateSuperQuorumNumerator(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newSuperQuorumNumerator",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_updateSuperQuorumNumerator",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function updateSuperQuorumNumerator(uint256 newSuperQuorumNumerator) public virtual onlyGovernance {\n        _updateSuperQuorumNumerator(newSuperQuorumNumerator);\n    }",
            "startLine": 102
          },
          {
            "name": "state",
            "signature": "state(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "proposalId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "ProposalState"
              }
            ],
            "calls": [
              {
                "target": "state",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function state(\n        uint256 proposalId\n    ) public view virtual override(GovernorUpgradeable, GovernorSuperQuorumUpgradeable) returns (ProposalState) {\n        return super.state(proposalId);\n    }",
            "startLine": 151
          }
        ],
        "internalFunctions": [
          {
            "name": "_getGovernorVotesSuperQuorumFractionStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "GovernorVotesSuperQuorumFractionStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getGovernorVotesSuperQuorumFractionStorage() private pure returns (GovernorVotesSuperQuorumFractionStorage storage $) {\n        assembly {\n            $.slot := GovernorVotesSuperQuorumFractionStorageLocation\n        }\n    }",
            "startLine": 30
          },
          {
            "name": "__GovernorVotesSuperQuorumFraction_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "superQuorumNumeratorValue",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorVotesSuperQuorumFraction_init(uint256 superQuorumNumeratorValue) internal onlyInitializing {\n        __GovernorVotesSuperQuorumFraction_init_unchained(superQuorumNumeratorValue);\n    }",
            "startLine": 59
          },
          {
            "name": "__GovernorVotesSuperQuorumFraction_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "superQuorumNumeratorValue",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_updateSuperQuorumNumerator",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __GovernorVotesSuperQuorumFraction_init_unchained(uint256 superQuorumNumeratorValue) internal onlyInitializing {\n        _updateSuperQuorumNumerator(superQuorumNumeratorValue);\n    }",
            "startLine": 63
          },
          {
            "name": "_updateSuperQuorumNumerator",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newSuperQuorumNumerator",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorVotesSuperQuorumFractionStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "quorumDenominator",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "quorumNumerator",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Checkpoints.latest",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "Checkpoints.push",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "clock",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "SafeCast.toUint208",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _updateSuperQuorumNumerator(uint256 newSuperQuorumNumerator) internal virtual {\n        GovernorVotesSuperQuorumFractionStorage storage $ = _getGovernorVotesSuperQuorumFractionStorage();\n        uint256 denominator = quorumDenominator();\n        if (newSuperQuorumNumerator > denominator) {\n            revert GovernorInvalidSuperQuorumFraction(newSuperQuorumNumerator, denominator);\n        }\n\n        uint256 quorumNumerator = quorumNumerator();\n        if (newSuperQuorumNumerator < quorumNumerator) {\n            revert GovernorInvalidSuperQuorumTooSmall(newSuperQuorumNumerator, quorumNumerator);\n        }\n\n        uint256 oldSuperQuorumNumerator = $._superQuorumNumeratorHistory.latest();\n        $._superQuorumNumeratorHistory.push(clock(), SafeCast.toUint208(newSuperQuorumNumerator));\n\n        emit SuperQuorumNumeratorUpdated(oldSuperQuorumNumerator, newSuperQuorumNumerator);\n    }",
            "startLine": 116
          },
          {
            "name": "_updateQuorumNumerator",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newQuorumNumerator",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorVotesSuperQuorumFractionStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Checkpoints.length",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "superQuorumNumerator",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_updateQuorumNumerator",
                "type": "super",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _updateQuorumNumerator(uint256 newQuorumNumerator) internal virtual override {\n        GovernorVotesSuperQuorumFractionStorage storage $ = _getGovernorVotesSuperQuorumFractionStorage();\n        // Ignoring check when the superQuorum was never set (construction sets quorum before superQuorum)\n        if ($._superQuorumNumeratorHistory.length() > 0) {\n            uint256 superQuorumNumerator_ = superQuorumNumerator();\n            if (newQuorumNumerator > superQuorumNumerator_) {\n                revert GovernorInvalidQuorumTooLarge(newQuorumNumerator, superQuorumNumerator_);\n            }\n        }\n        super._updateQuorumNumerator(newQuorumNumerator);\n    }",
            "startLine": 138
          }
        ],
        "events": [
          {
            "name": "SuperQuorumNumeratorUpdated",
            "parameters": [
              {
                "name": "oldSuperQuorumNumerator",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "newSuperQuorumNumerator",
                "type": "uint256",
                "indexed": false
              }
            ],
            "startLine": 36
          }
        ],
        "errors": [
          {
            "name": "GovernorInvalidSuperQuorumFraction",
            "parameters": [
              {
                "name": "superQuorumNumerator",
                "type": "uint256"
              },
              {
                "name": "denominator",
                "type": "uint256"
              }
            ],
            "startLine": 41
          },
          {
            "name": "GovernorInvalidSuperQuorumTooSmall",
            "parameters": [
              {
                "name": "superQuorumNumerator",
                "type": "uint256"
              },
              {
                "name": "quorumNumerator",
                "type": "uint256"
              }
            ],
            "startLine": 46
          },
          {
            "name": "GovernorInvalidQuorumTooLarge",
            "parameters": [
              {
                "name": "quorumNumerator",
                "type": "uint256"
              },
              {
                "name": "superQuorumNumerator",
                "type": "uint256"
              }
            ],
            "startLine": 51
          }
        ],
        "structs": [
          {
            "name": "GovernorVotesSuperQuorumFractionStorage",
            "members": [
              {
                "name": "_superQuorumNumeratorHistory",
                "type": "Checkpoints.Trace208"
              }
            ],
            "startLine": 23
          }
        ],
        "stateVariables": [
          {
            "name": "GovernorVotesSuperQuorumFractionStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 28
          }
        ],
        "usesLibraries": [
          "Checkpoints"
        ],
        "imports": [
          {
            "path": "../GovernorUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./GovernorSuperQuorumUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "./GovernorVotesQuorumFractionUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/math/Math.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/math/SafeCast.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/structs/Checkpoints.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (governance/extensions/GovernorVotesSuperQuorumFraction.sol)\n\npragma solidity ^0.8.24;\n\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {GovernorSuperQuorumUpgradeable} from \"./GovernorSuperQuorumUpgradeable.sol\";\nimport {GovernorVotesQuorumFractionUpgradeable} from \"./GovernorVotesQuorumFractionUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Checkpoints} from \"@openzeppelin/contracts/utils/structs/Checkpoints.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {GovernorVotesQuorumFraction} with a super quorum expressed as a\n * fraction of the total supply. Proposals that meet the super quorum (and have a majority of for votes) advance to\n * the `Succeeded` state before the proposal deadline.\n */\nabstract contract GovernorVotesSuperQuorumFractionUpgradeable is Initializable, GovernorVotesQuorumFractionUpgradeable, GovernorSuperQuorumUpgradeable {\n    using Checkpoints for Checkpoints.Trace208;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorVotesSuperQuorumFraction\n    struct GovernorVotesSuperQuorumFractionStorage {\n        Checkpoints.Trace208 _superQuorumNumeratorHistory;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorVotesSuperQuorumFraction\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorVotesSuperQuorumFractionStorageLocation = 0x31eabc8444b313223279a7cb4d22bce9201d463789f695e0a51f91d19ec31000;\n\n    function _getGovernorVotesSuperQuorumFractionStorage() private pure returns (GovernorVotesSuperQuorumFractionStorage storage $) {\n        assembly {\n            $.slot := GovernorVotesSuperQuorumFractionStorageLocation\n        }\n    }\n\n    event SuperQuorumNumeratorUpdated(uint256 oldSuperQuorumNumerator, uint256 newSuperQuorumNumerator);\n\n    /**\n     * @dev The super quorum set is not valid as it exceeds the quorum denominator.\n     */\n    error GovernorInvalidSuperQuorumFraction(uint256 superQuorumNumerator, uint256 denominator);\n\n    /**\n     * @dev The super quorum set is not valid as it is smaller or equal to the quorum.\n     */\n    error GovernorInvalidSuperQuorumTooSmall(uint256 superQuorumNumerator, uint256 quorumNumerator);\n\n    /**\n     * @dev The quorum set is not valid as it exceeds the super quorum.\n     */\n    error GovernorInvalidQuorumTooLarge(uint256 quorumNumerator, uint256 superQuorumNumerator);\n\n    /**\n     * @dev Initialize super quorum as a fraction of the token's total supply.\n     *\n     * The super quorum is specified as a fraction of the token's total supply and has to\n     * be greater than the quorum.\n     */\n    function __GovernorVotesSuperQuorumFraction_init(uint256 superQuorumNumeratorValue) internal onlyInitializing {\n        __GovernorVotesSuperQuorumFraction_init_unchained(superQuorumNumeratorValue);\n    }\n\n    function __GovernorVotesSuperQuorumFraction_init_unchained(uint256 superQuorumNumeratorValue) internal onlyInitializing {\n        _updateSuperQuorumNumerator(superQuorumNumeratorValue);\n    }\n\n    /**\n     * @dev Returns the current super quorum numerator.\n     */\n    function superQuorumNumerator() public view virtual returns (uint256) {\n        GovernorVotesSuperQuorumFractionStorage storage $ = _getGovernorVotesSuperQuorumFractionStorage();\n        return $._superQuorumNumeratorHistory.latest();\n    }\n\n    /**\n     * @dev Returns the super quorum numerator at a specific `timepoint`.\n     */\n    function superQuorumNumerator(uint256 timepoint) public view virtual returns (uint256) {\n        GovernorVotesSuperQuorumFractionStorage storage $ = _getGovernorVotesSuperQuorumFractionStorage();\n        return _optimisticUpperLookupRecent($._superQuorumNumeratorHistory, timepoint);\n    }\n\n    /**\n     * @dev Returns the super quorum for a `timepoint`, in terms of number of votes: `supply * numerator / denominator`.\n     * See {GovernorSuperQuorum-superQuorum} for more details.\n     */\n    function superQuorum(uint256 timepoint) public view virtual override returns (uint256) {\n        return Math.mulDiv(token().getPastTotalSupply(timepoint), superQuorumNumerator(timepoint), quorumDenominator());\n    }\n\n    /**\n     * @dev Changes the super quorum numerator.\n     *\n     * Emits a {SuperQuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - Must be called through a governance proposal.\n     * - New super quorum numerator must be smaller or equal to the denominator.\n     * - New super quorum numerator must be greater than or equal to the quorum numerator.\n     */\n    function updateSuperQuorumNumerator(uint256 newSuperQuorumNumerator) public virtual onlyGovernance {\n        _updateSuperQuorumNumerator(newSuperQuorumNumerator);\n    }\n\n    /**\n     * @dev Changes the super quorum numerator.\n     *\n     * Emits a {SuperQuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - New super quorum numerator must be smaller or equal to the denominator.\n     * - New super quorum numerator must be greater than or equal to the quorum numerator.\n     */\n    function _updateSuperQuorumNumerator(uint256 newSuperQuorumNumerator) internal virtual {\n        GovernorVotesSuperQuorumFractionStorage storage $ = _getGovernorVotesSuperQuorumFractionStorage();\n        uint256 denominator = quorumDenominator();\n        if (newSuperQuorumNumerator > denominator) {\n            revert GovernorInvalidSuperQuorumFraction(newSuperQuorumNumerator, denominator);\n        }\n\n        uint256 quorumNumerator = quorumNumerator();\n        if (newSuperQuorumNumerator < quorumNumerator) {\n            revert GovernorInvalidSuperQuorumTooSmall(newSuperQuorumNumerator, quorumNumerator);\n        }\n\n        uint256 oldSuperQuorumNumerator = $._superQuorumNumeratorHistory.latest();\n        $._superQuorumNumeratorHistory.push(clock(), SafeCast.toUint208(newSuperQuorumNumerator));\n\n        emit SuperQuorumNumeratorUpdated(oldSuperQuorumNumerator, newSuperQuorumNumerator);\n    }\n\n    /**\n     * @dev Overrides {GovernorVotesQuorumFraction-_updateQuorumNumerator} to ensure the super\n     * quorum numerator is greater than or equal to the quorum numerator.\n     */\n    function _updateQuorumNumerator(uint256 newQuorumNumerator) internal virtual override {\n        GovernorVotesSuperQuorumFractionStorage storage $ = _getGovernorVotesSuperQuorumFractionStorage();\n        // Ignoring check when the superQuorum was never set (construction sets quorum before superQuorum)\n        if ($._superQuorumNumeratorHistory.length() > 0) {\n            uint256 superQuorumNumerator_ = superQuorumNumerator();\n            if (newQuorumNumerator > superQuorumNumerator_) {\n                revert GovernorInvalidQuorumTooLarge(newQuorumNumerator, superQuorumNumerator_);\n            }\n        }\n        super._updateQuorumNumerator(newQuorumNumerator);\n    }\n\n    /// @inheritdoc GovernorSuperQuorumUpgradeable\n    function state(\n        uint256 proposalId\n    ) public view virtual override(GovernorUpgradeable, GovernorSuperQuorumUpgradeable) returns (ProposalState) {\n        return super.state(proposalId);\n    }\n}\n"
      },
      {
        "name": "GovernorVotesUpgradeable",
        "filePath": "governance/extensions/GovernorVotesUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "GovernorUpgradeable"
        ],
        "implements": [],
        "category": "governance/extensions",
        "externalFunctions": [
          {
            "name": "token",
            "signature": "token()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "IERC5805"
              }
            ],
            "calls": [
              {
                "target": "_getGovernorVotesStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function token() public view virtual returns (IERC5805) {\n        GovernorVotesStorage storage $ = _getGovernorVotesStorage();\n        return $._token;\n    }",
            "startLine": 43
          },
          {
            "name": "clock",
            "signature": "clock()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint48"
              }
            ],
            "calls": [
              {
                "target": "token",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Time.blockNumber",
                "type": "library",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function clock() public view virtual override returns (uint48) {\n        try token().clock() returns (uint48 timepoint) {\n            return timepoint;\n        } catch {\n            return Time.blockNumber();\n        }\n    }",
            "startLine": 52
          },
          {
            "name": "CLOCK_MODE",
            "signature": "CLOCK_MODE()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "token",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function CLOCK_MODE() public view virtual override returns (string memory) {\n        try token().CLOCK_MODE() returns (string memory clockmode) {\n            return clockmode;\n        } catch {\n            return \"mode=blocknumber&from=default\";\n        }\n    }",
            "startLine": 64
          }
        ],
        "internalFunctions": [
          {
            "name": "_getGovernorVotesStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "GovernorVotesStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getGovernorVotesStorage() private pure returns (GovernorVotesStorage storage $) {\n        assembly {\n            $.slot := GovernorVotesStorageLocation\n        }\n    }",
            "startLine": 25
          },
          {
            "name": "__GovernorVotes_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenAddress",
                "type": "IVotes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __GovernorVotes_init(IVotes tokenAddress) internal onlyInitializing {\n        __GovernorVotes_init_unchained(tokenAddress);\n    }",
            "startLine": 31
          },
          {
            "name": "__GovernorVotes_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenAddress",
                "type": "IVotes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getGovernorVotesStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __GovernorVotes_init_unchained(IVotes tokenAddress) internal onlyInitializing {\n        GovernorVotesStorage storage $ = _getGovernorVotesStorage();\n        $._token = IERC5805(address(tokenAddress));\n    }",
            "startLine": 35
          },
          {
            "name": "_getVotes",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "timepoint",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "token",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _getVotes(\n        address account,\n        uint256 timepoint,\n        bytes memory /*params*/\n    ) internal view virtual override returns (uint256) {\n        return token().getPastVotes(account, timepoint);\n    }",
            "startLine": 75
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "GovernorVotesStorage",
            "members": [
              {
                "name": "_token",
                "type": "IERC5805"
              }
            ],
            "startLine": 18
          }
        ],
        "stateVariables": [
          {
            "name": "GovernorVotesStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 23
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../GovernorUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/governance/utils/IVotes.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/interfaces/IERC5805.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/types/Time.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (governance/extensions/GovernorVotes.sol)\n\npragma solidity ^0.8.24;\n\nimport {GovernorUpgradeable} from \"../GovernorUpgradeable.sol\";\nimport {IVotes} from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\nimport {IERC5805} from \"@openzeppelin/contracts/interfaces/IERC5805.sol\";\nimport {Time} from \"@openzeppelin/contracts/utils/types/Time.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token, or since v4.5 an {ERC721Votes}\n * token.\n */\nabstract contract GovernorVotesUpgradeable is Initializable, GovernorUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.GovernorVotes\n    struct GovernorVotesStorage {\n        IERC5805 _token;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.GovernorVotes\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GovernorVotesStorageLocation = 0x3ba4977254e415696610a40ebf2258dbfa0ec6a2ff64e84bfe715ff16977cc00;\n\n    function _getGovernorVotesStorage() private pure returns (GovernorVotesStorage storage $) {\n        assembly {\n            $.slot := GovernorVotesStorageLocation\n        }\n    }\n\n    function __GovernorVotes_init(IVotes tokenAddress) internal onlyInitializing {\n        __GovernorVotes_init_unchained(tokenAddress);\n    }\n\n    function __GovernorVotes_init_unchained(IVotes tokenAddress) internal onlyInitializing {\n        GovernorVotesStorage storage $ = _getGovernorVotesStorage();\n        $._token = IERC5805(address(tokenAddress));\n    }\n\n    /**\n     * @dev The token that voting power is sourced from.\n     */\n    function token() public view virtual returns (IERC5805) {\n        GovernorVotesStorage storage $ = _getGovernorVotesStorage();\n        return $._token;\n    }\n\n    /**\n     * @dev Clock (as specified in ERC-6372) is set to match the token's clock. Fallback to block numbers if the token\n     * does not implement ERC-6372.\n     */\n    function clock() public view virtual override returns (uint48) {\n        try token().clock() returns (uint48 timepoint) {\n            return timepoint;\n        } catch {\n            return Time.blockNumber();\n        }\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in ERC-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory) {\n        try token().CLOCK_MODE() returns (string memory clockmode) {\n            return clockmode;\n        } catch {\n            return \"mode=blocknumber&from=default\";\n        }\n    }\n\n    /**\n     * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).\n     */\n    function _getVotes(\n        address account,\n        uint256 timepoint,\n        bytes memory /*params*/\n    ) internal view virtual override returns (uint256) {\n        return token().getPastVotes(account, timepoint);\n    }\n}\n"
      },
      {
        "name": "VotesExtendedUpgradeable",
        "filePath": "governance/utils/VotesExtendedUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "VotesUpgradeable"
        ],
        "implements": [],
        "category": "utils",
        "externalFunctions": [
          {
            "name": "getPastDelegate",
            "signature": "getPastDelegate(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "timepoint",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getVotesExtendedStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Checkpoints.upperLookupRecent",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "_validateTimepoint",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getPastDelegate(address account, uint256 timepoint) public view virtual returns (address) {\n        VotesExtendedStorage storage $ = _getVotesExtendedStorage();\n        return address($._userDelegationCheckpoints[account].upperLookupRecent(_validateTimepoint(timepoint)));\n    }",
            "startLine": 68
          },
          {
            "name": "getPastBalanceOf",
            "signature": "getPastBalanceOf(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "timepoint",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getVotesExtendedStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Checkpoints.upperLookupRecent",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "_validateTimepoint",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getPastBalanceOf(address account, uint256 timepoint) public view virtual returns (uint256) {\n        VotesExtendedStorage storage $ = _getVotesExtendedStorage();\n        return $._userVotingUnitsCheckpoints[account].upperLookupRecent(_validateTimepoint(timepoint));\n    }",
            "startLine": 81
          }
        ],
        "internalFunctions": [
          {
            "name": "_getVotesExtendedStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "VotesExtendedStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getVotesExtendedStorage() private pure returns (VotesExtendedStorage storage $) {\n        assembly {\n            $.slot := VotesExtendedStorageLocation\n        }\n    }",
            "startLine": 49
          },
          {
            "name": "__VotesExtended_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __VotesExtended_init() internal onlyInitializing {\n    }",
            "startLine": 55
          },
          {
            "name": "__VotesExtended_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __VotesExtended_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 58
          },
          {
            "name": "_delegate",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "delegatee",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getVotesExtendedStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_delegate",
                "type": "super",
                "argCount": 2
              },
              {
                "target": "Checkpoints.push",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "clock",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _delegate(address account, address delegatee) internal virtual override {\n        VotesExtendedStorage storage $ = _getVotesExtendedStorage();\n        super._delegate(account, delegatee);\n\n        $._userDelegationCheckpoints[account].push(clock(), uint160(delegatee));\n    }",
            "startLine": 87
          },
          {
            "name": "_transferVotingUnits",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getVotesExtendedStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_transferVotingUnits",
                "type": "super",
                "argCount": 3
              },
              {
                "target": "Checkpoints.push",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "clock",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "SafeCast.toUint208",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "_getVotingUnits",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _transferVotingUnits(address from, address to, uint256 amount) internal virtual override {\n        VotesExtendedStorage storage $ = _getVotesExtendedStorage();\n        super._transferVotingUnits(from, to, amount);\n        if (from != to) {\n            if (from != address(0)) {\n                $._userVotingUnitsCheckpoints[from].push(clock(), SafeCast.toUint208(_getVotingUnits(from)));\n            }\n            if (to != address(0)) {\n                $._userVotingUnitsCheckpoints[to].push(clock(), SafeCast.toUint208(_getVotingUnits(to)));\n            }\n        }\n    }",
            "startLine": 95
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "VotesExtendedStorage",
            "members": [
              {
                "name": "_userDelegationCheckpoints",
                "type": "mapping(address => Checkpoints.Trace160)"
              },
              {
                "name": "_userVotingUnitsCheckpoints",
                "type": "mapping(address => Checkpoints.Trace208)"
              }
            ],
            "startLine": 41
          }
        ],
        "stateVariables": [
          {
            "name": "VotesExtendedStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 47
          }
        ],
        "usesLibraries": [
          "Checkpoints",
          "Checkpoints"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/utils/structs/Checkpoints.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "./VotesUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/math/SafeCast.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (governance/utils/VotesExtended.sol)\n\npragma solidity ^0.8.24;\n\nimport {Checkpoints} from \"@openzeppelin/contracts/utils/structs/Checkpoints.sol\";\nimport {VotesUpgradeable} from \"./VotesUpgradeable.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Votes} that adds checkpoints for delegations and balances.\n *\n * WARNING: While this contract extends {Votes}, valid uses of {Votes} may not be compatible with\n * {VotesExtended} without additional considerations. This implementation of {_transferVotingUnits} must\n * run AFTER the voting weight movement is registered, such that it is reflected on {_getVotingUnits}.\n *\n * Said differently, {VotesExtended} MUST be integrated in a way that calls {_transferVotingUnits} AFTER the\n * asset transfer is registered and balances are updated:\n *\n * ```solidity\n * contract VotingToken is Token, VotesExtended {\n *   function transfer(address from, address to, uint256 tokenId) public override {\n *     super.transfer(from, to, tokenId); // <- Perform the transfer first ...\n *     _transferVotingUnits(from, to, 1); // <- ... then call _transferVotingUnits.\n *   }\n *\n *   function _getVotingUnits(address account) internal view override returns (uint256) {\n *      return balanceOf(account);\n *   }\n * }\n * ```\n *\n * {ERC20Votes} and {ERC721Votes} follow this pattern and are thus safe to use with {VotesExtended}.\n */\nabstract contract VotesExtendedUpgradeable is Initializable, VotesUpgradeable {\n    using Checkpoints for Checkpoints.Trace160;\n    using Checkpoints for Checkpoints.Trace208;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.VotesExtended\n    struct VotesExtendedStorage {\n        mapping(address delegator => Checkpoints.Trace160) _userDelegationCheckpoints;\n        mapping(address account => Checkpoints.Trace208) _userVotingUnitsCheckpoints;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.VotesExtended\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant VotesExtendedStorageLocation = 0x4a7bc7aabb540021543c1f28dd259f8776612c96fd248bdcc6fdf56c7778d900;\n\n    function _getVotesExtendedStorage() private pure returns (VotesExtendedStorage storage $) {\n        assembly {\n            $.slot := VotesExtendedStorageLocation\n        }\n    }\n\n    function __VotesExtended_init() internal onlyInitializing {\n    }\n\n    function __VotesExtended_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the delegate of an `account` at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastDelegate(address account, uint256 timepoint) public view virtual returns (address) {\n        VotesExtendedStorage storage $ = _getVotesExtendedStorage();\n        return address($._userDelegationCheckpoints[account].upperLookupRecent(_validateTimepoint(timepoint)));\n    }\n\n    /**\n     * @dev Returns the `balanceOf` of an `account` at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastBalanceOf(address account, uint256 timepoint) public view virtual returns (uint256) {\n        VotesExtendedStorage storage $ = _getVotesExtendedStorage();\n        return $._userVotingUnitsCheckpoints[account].upperLookupRecent(_validateTimepoint(timepoint));\n    }\n\n    /// @inheritdoc VotesUpgradeable\n    function _delegate(address account, address delegatee) internal virtual override {\n        VotesExtendedStorage storage $ = _getVotesExtendedStorage();\n        super._delegate(account, delegatee);\n\n        $._userDelegationCheckpoints[account].push(clock(), uint160(delegatee));\n    }\n\n    /// @inheritdoc VotesUpgradeable\n    function _transferVotingUnits(address from, address to, uint256 amount) internal virtual override {\n        VotesExtendedStorage storage $ = _getVotesExtendedStorage();\n        super._transferVotingUnits(from, to, amount);\n        if (from != to) {\n            if (from != address(0)) {\n                $._userVotingUnitsCheckpoints[from].push(clock(), SafeCast.toUint208(_getVotingUnits(from)));\n            }\n            if (to != address(0)) {\n                $._userVotingUnitsCheckpoints[to].push(clock(), SafeCast.toUint208(_getVotingUnits(to)));\n            }\n        }\n    }\n}\n"
      },
      {
        "name": "VotesUpgradeable",
        "filePath": "governance/utils/VotesUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ContextUpgradeable",
          "EIP712Upgradeable",
          "NoncesUpgradeable",
          "IERC5805"
        ],
        "implements": [],
        "category": "utils",
        "externalFunctions": [
          {
            "name": "clock",
            "signature": "clock()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint48"
              }
            ],
            "calls": [
              {
                "target": "Time.blockNumber",
                "type": "library",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function clock() public view virtual returns (uint48) {\n        return Time.blockNumber();\n    }",
            "startLine": 77
          },
          {
            "name": "CLOCK_MODE",
            "signature": "CLOCK_MODE()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "clock",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Time.blockNumber",
                "type": "library",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function CLOCK_MODE() public view virtual returns (string memory) {\n        // Check that the clock was not modified\n        if (clock() != Time.blockNumber()) {\n            revert ERC6372InconsistentClock();\n        }\n        return \"mode=blocknumber&from=default\";\n    }",
            "startLine": 85
          },
          {
            "name": "getVotes",
            "signature": "getVotes(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getVotesStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Checkpoints.latest",
                "type": "library",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getVotes(address account) public view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegateCheckpoints[account].latest();\n    }",
            "startLine": 105
          },
          {
            "name": "getPastVotes",
            "signature": "getPastVotes(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "timepoint",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getVotesStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Checkpoints.upperLookupRecent",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "_validateTimepoint",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getPastVotes(address account, uint256 timepoint) public view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegateCheckpoints[account].upperLookupRecent(_validateTimepoint(timepoint));\n    }",
            "startLine": 118
          },
          {
            "name": "getPastTotalSupply",
            "signature": "getPastTotalSupply(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "timepoint",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getVotesStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Checkpoints.upperLookupRecent",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "_validateTimepoint",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getPastTotalSupply(uint256 timepoint) public view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._totalCheckpoints.upperLookupRecent(_validateTimepoint(timepoint));\n    }",
            "startLine": 135
          },
          {
            "name": "delegates",
            "signature": "delegates(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getVotesStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function delegates(address account) public view virtual returns (address) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegatee[account];\n    }",
            "startLine": 151
          },
          {
            "name": "delegate",
            "signature": "delegate(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegatee",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_delegate",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function delegate(address delegatee) public virtual {\n        address account = _msgSender();\n        _delegate(account, delegatee);\n    }",
            "startLine": 159
          },
          {
            "name": "delegateBySig",
            "signature": "delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "delegatee",
                "type": "address"
              },
              {
                "name": "nonce",
                "type": "uint256"
              },
              {
                "name": "expiry",
                "type": "uint256"
              },
              {
                "name": "v",
                "type": "uint8"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "ECDSA.recover",
                "type": "library",
                "argCount": 4
              },
              {
                "target": "_hashTypedDataV4",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_useCheckedNonce",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_delegate",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > expiry) {\n            revert VotesExpiredSignature(expiry);\n        }\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        _useCheckedNonce(signer, nonce);\n        _delegate(signer, delegatee);\n    }",
            "startLine": 167
          }
        ],
        "internalFunctions": [
          {
            "name": "_getVotesStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "VotesStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getVotesStorage() private pure returns (VotesStorage storage $) {\n        assembly {\n            $.slot := VotesStorageLocation\n        }\n    }",
            "startLine": 52
          },
          {
            "name": "__Votes_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __Votes_init() internal onlyInitializing {\n    }",
            "startLine": 68
          },
          {
            "name": "__Votes_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __Votes_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 71
          },
          {
            "name": "_validateTimepoint",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "timepoint",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint48"
              }
            ],
            "calls": [
              {
                "target": "clock",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "SafeCast.toUint48",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _validateTimepoint(uint256 timepoint) internal view returns (uint48) {\n        uint48 currentTimepoint = clock();\n        if (timepoint >= currentTimepoint) revert ERC5805FutureLookup(timepoint, currentTimepoint);\n        return SafeCast.toUint48(timepoint);\n    }",
            "startLine": 96
          },
          {
            "name": "_getTotalSupply",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getVotesStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Checkpoints.latest",
                "type": "library",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _getTotalSupply() internal view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._totalCheckpoints.latest();\n    }",
            "startLine": 143
          },
          {
            "name": "_delegate",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "delegatee",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getVotesStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "delegates",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_moveDelegateVotes",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_getVotingUnits",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _delegate(address account, address delegatee) internal virtual {\n        VotesStorage storage $ = _getVotesStorage();\n        address oldDelegate = delegates(account);\n        $._delegatee[account] = delegatee;\n\n        emit DelegateChanged(account, oldDelegate, delegatee);\n        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));\n    }",
            "startLine": 193
          },
          {
            "name": "_transferVotingUnits",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getVotesStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_push",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "SafeCast.toUint208",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "_moveDelegateVotes",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "delegates",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _transferVotingUnits(address from, address to, uint256 amount) internal virtual {\n        VotesStorage storage $ = _getVotesStorage();\n        if (from == address(0)) {\n            _push($._totalCheckpoints, _add, SafeCast.toUint208(amount));\n        }\n        if (to == address(0)) {\n            _push($._totalCheckpoints, _subtract, SafeCast.toUint208(amount));\n        }\n        _moveDelegateVotes(delegates(from), delegates(to), amount);\n    }",
            "startLine": 206
          },
          {
            "name": "_moveDelegateVotes",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getVotesStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_push",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "SafeCast.toUint208",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _moveDelegateVotes(address from, address to, uint256 amount) internal virtual {\n        VotesStorage storage $ = _getVotesStorage();\n        if (from != to && amount > 0) {\n            if (from != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    $._delegateCheckpoints[from],\n                    _subtract,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(from, oldValue, newValue);\n            }\n            if (to != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    $._delegateCheckpoints[to],\n                    _add,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(to, oldValue, newValue);\n            }\n        }\n    }",
            "startLine": 220
          },
          {
            "name": "_numCheckpoints",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint32"
              }
            ],
            "calls": [
              {
                "target": "_getVotesStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "SafeCast.toUint32",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "Checkpoints.length",
                "type": "library",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _numCheckpoints(address account) internal view virtual returns (uint32) {\n        VotesStorage storage $ = _getVotesStorage();\n        return SafeCast.toUint32($._delegateCheckpoints[account].length());\n    }",
            "startLine": 245
          },
          {
            "name": "_checkpoints",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "pos",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "Checkpoints.Checkpoint208"
              }
            ],
            "calls": [
              {
                "target": "_getVotesStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Checkpoints.at",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkpoints(\n        address account,\n        uint32 pos\n    ) internal view virtual returns (Checkpoints.Checkpoint208 memory) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegateCheckpoints[account].at(pos);\n    }",
            "startLine": 253
          },
          {
            "name": "_push",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "store",
                "type": "Checkpoints.Trace208"
              },
              {
                "name": "op",
                "type": "function"
              },
              {
                "name": "delta",
                "type": "uint208"
              }
            ],
            "returnValues": [
              {
                "name": "oldValue",
                "type": "uint208"
              },
              {
                "name": "newValue",
                "type": "uint208"
              }
            ],
            "calls": [
              {
                "target": "Checkpoints.push",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "clock",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "op",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "Checkpoints.latest",
                "type": "library",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _push(\n        Checkpoints.Trace208 storage store,\n        function(uint208, uint208) view returns (uint208) op,\n        uint208 delta\n    ) private returns (uint208 oldValue, uint208 newValue) {\n        return store.push(clock(), op(store.latest(), delta));\n    }",
            "startLine": 261
          },
          {
            "name": "_add",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint208"
              },
              {
                "name": "b",
                "type": "uint208"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint208"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _add(uint208 a, uint208 b) private pure returns (uint208) {\n        return a + b;\n    }",
            "startLine": 269
          },
          {
            "name": "_subtract",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "a",
                "type": "uint208"
              },
              {
                "name": "b",
                "type": "uint208"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint208"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _subtract(uint208 a, uint208 b) private pure returns (uint208) {\n        return a - b;\n    }",
            "startLine": 273
          },
          {
            "name": "_getVotingUnits",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _getVotingUnits(address) internal view virtual returns (uint256);",
            "startLine": 280
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ERC6372InconsistentClock",
            "parameters": [],
            "startLine": 61
          },
          {
            "name": "ERC5805FutureLookup",
            "parameters": [
              {
                "name": "timepoint",
                "type": "uint256"
              },
              {
                "name": "clock",
                "type": "uint48"
              }
            ],
            "startLine": 66
          }
        ],
        "structs": [
          {
            "name": "VotesStorage",
            "members": [
              {
                "name": "_delegatee",
                "type": "mapping(address => address)"
              },
              {
                "name": "_delegateCheckpoints",
                "type": "mapping(address => Checkpoints.Trace208)"
              },
              {
                "name": "_totalCheckpoints",
                "type": "Checkpoints.Trace208"
              }
            ],
            "startLine": 41
          }
        ],
        "stateVariables": [
          {
            "name": "DELEGATION_TYPEHASH",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 37
          },
          {
            "name": "VotesStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 50
          }
        ],
        "usesLibraries": [
          "Checkpoints"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/interfaces/IERC5805.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../../utils/ContextUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../../utils/NoncesUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../../utils/cryptography/EIP712Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/structs/Checkpoints.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/math/SafeCast.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/cryptography/ECDSA.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/types/Time.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (governance/utils/Votes.sol)\n\npragma solidity ^0.8.24;\n\nimport {IERC5805} from \"@openzeppelin/contracts/interfaces/IERC5805.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {NoncesUpgradeable} from \"../../utils/NoncesUpgradeable.sol\";\nimport {EIP712Upgradeable} from \"../../utils/cryptography/EIP712Upgradeable.sol\";\nimport {Checkpoints} from \"@openzeppelin/contracts/utils/structs/Checkpoints.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Time} from \"@openzeppelin/contracts/utils/types/Time.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev This is a base abstract contract that tracks voting units, which are a measure of voting power that can be\n * transferred, and provides a system of vote delegation, where an account can delegate its voting units to a sort of\n * \"representative\" that will pool delegated voting units from different accounts and can then use it to vote in\n * decisions. In fact, voting units _must_ be delegated in order to count as actual votes, and an account has to\n * delegate those votes to itself if it wishes to participate in decisions and does not have a trusted representative.\n *\n * This contract is often combined with a token contract such that voting units correspond to token units. For an\n * example, see {ERC721Votes}.\n *\n * The full history of delegate votes is tracked on-chain so that governance protocols can consider votes as distributed\n * at a particular block number to protect against flash loans and double voting. The opt-in delegate system makes the\n * cost of this history tracking optional.\n *\n * When using this module the derived contract must implement {_getVotingUnits} (for example, make it return\n * {ERC721-balanceOf}), and can use {_transferVotingUnits} to track a change in the distribution of those units (in the\n * previous example, it would be included in {ERC721-_update}).\n */\nabstract contract VotesUpgradeable is Initializable, ContextUpgradeable, EIP712Upgradeable, NoncesUpgradeable, IERC5805 {\n    using Checkpoints for Checkpoints.Trace208;\n\n    bytes32 private constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.Votes\n    struct VotesStorage {\n        mapping(address account => address) _delegatee;\n\n        mapping(address delegatee => Checkpoints.Trace208) _delegateCheckpoints;\n\n        Checkpoints.Trace208 _totalCheckpoints;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Votes\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant VotesStorageLocation = 0xe8b26c30fad74198956032a3533d903385d56dd795af560196f9c78d4af40d00;\n\n    function _getVotesStorage() private pure returns (VotesStorage storage $) {\n        assembly {\n            $.slot := VotesStorageLocation\n        }\n    }\n\n    /**\n     * @dev The clock was incorrectly modified.\n     */\n    error ERC6372InconsistentClock();\n\n    /**\n     * @dev Lookup to future votes is not available.\n     */\n    error ERC5805FutureLookup(uint256 timepoint, uint48 clock);\n\n    function __Votes_init() internal onlyInitializing {\n    }\n\n    function __Votes_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based\n     * checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match.\n     */\n    function clock() public view virtual returns (uint48) {\n        return Time.blockNumber();\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in ERC-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual returns (string memory) {\n        // Check that the clock was not modified\n        if (clock() != Time.blockNumber()) {\n            revert ERC6372InconsistentClock();\n        }\n        return \"mode=blocknumber&from=default\";\n    }\n\n    /**\n     * @dev Validate that a timepoint is in the past, and return it as a uint48.\n     */\n    function _validateTimepoint(uint256 timepoint) internal view returns (uint48) {\n        uint48 currentTimepoint = clock();\n        if (timepoint >= currentTimepoint) revert ERC5805FutureLookup(timepoint, currentTimepoint);\n        return SafeCast.toUint48(timepoint);\n    }\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) public view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegateCheckpoints[account].latest();\n    }\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastVotes(address account, uint256 timepoint) public view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegateCheckpoints[account].upperLookupRecent(_validateTimepoint(timepoint));\n    }\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastTotalSupply(uint256 timepoint) public view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._totalCheckpoints.upperLookupRecent(_validateTimepoint(timepoint));\n    }\n\n    /**\n     * @dev Returns the current total supply of votes.\n     */\n    function _getTotalSupply() internal view virtual returns (uint256) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._totalCheckpoints.latest();\n    }\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegatee[account];\n    }\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        address account = _msgSender();\n        _delegate(account, delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > expiry) {\n            revert VotesExpiredSignature(expiry);\n        }\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        _useCheckedNonce(signer, nonce);\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Delegate all of `account`'s voting units to `delegatee`.\n     *\n     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.\n     */\n    function _delegate(address account, address delegatee) internal virtual {\n        VotesStorage storage $ = _getVotesStorage();\n        address oldDelegate = delegates(account);\n        $._delegatee[account] = delegatee;\n\n        emit DelegateChanged(account, oldDelegate, delegatee);\n        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));\n    }\n\n    /**\n     * @dev Transfers, mints, or burns voting units. To register a mint, `from` should be zero. To register a burn, `to`\n     * should be zero. Total supply of voting units will be adjusted with mints and burns.\n     */\n    function _transferVotingUnits(address from, address to, uint256 amount) internal virtual {\n        VotesStorage storage $ = _getVotesStorage();\n        if (from == address(0)) {\n            _push($._totalCheckpoints, _add, SafeCast.toUint208(amount));\n        }\n        if (to == address(0)) {\n            _push($._totalCheckpoints, _subtract, SafeCast.toUint208(amount));\n        }\n        _moveDelegateVotes(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Moves delegated votes from one delegate to another.\n     */\n    function _moveDelegateVotes(address from, address to, uint256 amount) internal virtual {\n        VotesStorage storage $ = _getVotesStorage();\n        if (from != to && amount > 0) {\n            if (from != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    $._delegateCheckpoints[from],\n                    _subtract,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(from, oldValue, newValue);\n            }\n            if (to != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    $._delegateCheckpoints[to],\n                    _add,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(to, oldValue, newValue);\n            }\n        }\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function _numCheckpoints(address account) internal view virtual returns (uint32) {\n        VotesStorage storage $ = _getVotesStorage();\n        return SafeCast.toUint32($._delegateCheckpoints[account].length());\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function _checkpoints(\n        address account,\n        uint32 pos\n    ) internal view virtual returns (Checkpoints.Checkpoint208 memory) {\n        VotesStorage storage $ = _getVotesStorage();\n        return $._delegateCheckpoints[account].at(pos);\n    }\n\n    function _push(\n        Checkpoints.Trace208 storage store,\n        function(uint208, uint208) view returns (uint208) op,\n        uint208 delta\n    ) private returns (uint208 oldValue, uint208 newValue) {\n        return store.push(clock(), op(store.latest(), delta));\n    }\n\n    function _add(uint208 a, uint208 b) private pure returns (uint208) {\n        return a + b;\n    }\n\n    function _subtract(uint208 a, uint208 b) private pure returns (uint208) {\n        return a - b;\n    }\n\n    /**\n     * @dev Must return the voting units held by an account.\n     */\n    function _getVotingUnits(address) internal view virtual returns (uint256);\n}\n"
      },
      {
        "name": "ERC2771ContextUpgradeable",
        "filePath": "metatx/ERC2771ContextUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ContextUpgradeable"
        ],
        "implements": [],
        "category": "metatx",
        "externalFunctions": [
          {
            "name": "trustedForwarder",
            "signature": "trustedForwarder()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function trustedForwarder() public view virtual returns (address) {\n        return _trustedForwarder;\n    }",
            "startLine": 40
          },
          {
            "name": "isTrustedForwarder",
            "signature": "isTrustedForwarder(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "forwarder",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "trustedForwarder",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == trustedForwarder();\n    }",
            "startLine": 47
          }
        ],
        "internalFunctions": [
          {
            "name": "constructor",
            "visibility": "default",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "trustedForwarder_",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "constructor(address trustedForwarder_) {\n        _trustedForwarder = trustedForwarder_;\n    }",
            "startLine": 33
          },
          {
            "name": "_msgSender",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_contextSuffixLength",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "isTrustedForwarder",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_msgSender",
                "type": "super",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _msgSender() internal view virtual override returns (address) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (calldataLength >= contextSuffixLength && isTrustedForwarder(msg.sender)) {\n            unchecked {\n                return address(bytes20(msg.data[calldataLength - contextSuffixLength:]));\n            }\n        } else {\n            return super._msgSender();\n        }\n    }",
            "startLine": 56
          },
          {
            "name": "_msgData",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "_contextSuffixLength",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "isTrustedForwarder",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_msgData",
                "type": "super",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _msgData() internal view virtual override returns (bytes calldata) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (calldataLength >= contextSuffixLength && isTrustedForwarder(msg.sender)) {\n            unchecked {\n                return msg.data[:calldataLength - contextSuffixLength];\n            }\n        } else {\n            return super._msgData();\n        }\n    }",
            "startLine": 73
          },
          {
            "name": "_contextSuffixLength",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _contextSuffixLength() internal view virtual override returns (uint256) {\n        return 20;\n    }",
            "startLine": 88
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "_trustedForwarder",
            "type": "address",
            "visibility": "private",
            "isConstant": false,
            "isImmutable": true,
            "startLine": 24
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../utils/ContextUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Context variant with ERC-2771 support. See {_msgSender} for the calldata format.\n *\n * WARNING: Avoid using this pattern in contracts that rely on a specific calldata length as they'll\n * be affected by any forwarder whose `msg.data` is suffixed with the `from` address according to the ERC-2771\n * specification adding the address size in bytes (20) to the calldata size. An example of an unexpected\n * behavior could be an unintended fallback (or another function) invocation while trying to invoke the `receive`\n * function only accessible if `msg.data.length == 0`.\n *\n * WARNING: The usage of `delegatecall` in this contract is dangerous and may result in context corruption.\n * Any forwarded request to this contract triggering a `delegatecall` to itself will result in an invalid {_msgSender}\n * recovery.\n */\nabstract contract ERC2771ContextUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /**\n     * @dev Initializes the contract with a trusted forwarder, which will be able to\n     * invoke functions on this contract on behalf of other accounts.\n     *\n     * NOTE: The trusted forwarder can be replaced by overriding {trustedForwarder}.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder_) {\n        _trustedForwarder = trustedForwarder_;\n    }\n\n    /**\n     * @dev Returns the address of the trusted forwarder.\n     */\n    function trustedForwarder() public view virtual returns (address) {\n        return _trustedForwarder;\n    }\n\n    /**\n     * @dev Indicates whether any particular address is the trusted forwarder.\n     */\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == trustedForwarder();\n    }\n\n    /**\n     * @dev Override for `msg.sender`. Defaults to the original `msg.sender` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgSender() internal view virtual override returns (address) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (calldataLength >= contextSuffixLength && isTrustedForwarder(msg.sender)) {\n            unchecked {\n                return address(bytes20(msg.data[calldataLength - contextSuffixLength:]));\n            }\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    /**\n     * @dev Override for `msg.data`. Defaults to the original `msg.data` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (calldataLength >= contextSuffixLength && isTrustedForwarder(msg.sender)) {\n            unchecked {\n                return msg.data[:calldataLength - contextSuffixLength];\n            }\n        } else {\n            return super._msgData();\n        }\n    }\n\n    /**\n     * @dev ERC-2771 specifies the context as being a single address (20 bytes).\n     */\n    function _contextSuffixLength() internal view virtual override returns (uint256) {\n        return 20;\n    }\n}\n"
      },
      {
        "name": "ERC2771ForwarderUpgradeable",
        "filePath": "metatx/ERC2771ForwarderUpgradeable.sol",
        "kind": "contract",
        "inherits": [
          "Initializable",
          "EIP712Upgradeable",
          "NoncesUpgradeable"
        ],
        "implements": [],
        "category": "metatx",
        "externalFunctions": [
          {
            "name": "initialize",
            "signature": "initialize(string)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ERC2771Forwarder_init",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function initialize(string memory name) public virtual initializer {\n        __ERC2771Forwarder_init(name);\n    }",
            "startLine": 99
          },
          {
            "name": "verify",
            "signature": "verify(ForwardRequestData)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "request",
                "type": "ForwardRequestData"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_validate",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function verify(ForwardRequestData calldata request) public view virtual returns (bool) {\n        (bool isTrustedForwarder, bool active, bool signerMatch, ) = _validate(request);\n        return isTrustedForwarder && active && signerMatch;\n    }",
            "startLine": 120
          },
          {
            "name": "execute",
            "signature": "execute(ForwardRequestData)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "request",
                "type": "ForwardRequestData"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_execute",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function execute(ForwardRequestData calldata request) public payable virtual {\n        // We make sure that msg.value and request.value match exactly.\n        // If the request is invalid or the call reverts, this whole function\n        // will revert, ensuring value isn't stuck.\n        if (msg.value != request.value) {\n            revert ERC2771ForwarderMismatchedValue(request.value, msg.value);\n        }\n\n        if (!_execute(request, true)) {\n            revert Errors.FailedCall();\n        }\n    }",
            "startLine": 135
          },
          {
            "name": "executeBatch",
            "signature": "executeBatch(ForwardRequestData[],address payable)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "requests",
                "type": "ForwardRequestData[]"
              },
              {
                "name": "refundReceiver",
                "type": "address payable"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_execute",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "Address.sendValue",
                "type": "library",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function executeBatch(\n        ForwardRequestData[] calldata requests,\n        address payable refundReceiver\n    ) public payable virtual {\n        bool atomic = refundReceiver == address(0);\n\n        uint256 requestsValue;\n        uint256 refundValue;\n\n        for (uint256 i; i < requests.length; ++i) {\n            requestsValue += requests[i].value;\n            bool success = _execute(requests[i], atomic);\n            if (!success) {\n                refundValue += requests[i].value;\n            }\n        }\n\n        // The batch should revert if there's a mismatched msg.value provided\n        // to avoid request value tampering\n        if (requestsValue != msg.value) {\n            revert ERC2771ForwarderMismatchedValue(requestsValue, msg.value);\n        }\n\n        // Some requests with value were invalid (possibly due to frontrunning).\n        // To avoid leaving ETH in the contract this value is refunded.\n        if (refundValue != 0) {\n            // We know refundReceiver != address(0) && requestsValue == msg.value\n            // meaning we can ensure refundValue is not taken from the original contract's balance\n            // and refundReceiver is a known account.\n            Address.sendValue(refundReceiver, refundValue);\n        }\n    }",
            "startLine": 171
          }
        ],
        "internalFunctions": [
          {
            "name": "__ERC2771Forwarder_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC2771Forwarder_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }",
            "startLine": 105
          },
          {
            "name": "__ERC2771Forwarder_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC2771Forwarder_init_unchained(string memory) internal onlyInitializing {}",
            "startLine": 109
          },
          {
            "name": "_validate",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "request",
                "type": "ForwardRequestData"
              }
            ],
            "returnValues": [
              {
                "name": "isTrustedForwarder",
                "type": "bool"
              },
              {
                "name": "active",
                "type": "bool"
              },
              {
                "name": "signerMatch",
                "type": "bool"
              },
              {
                "name": "signer",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_recoverForwardRequestSigner",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_isTrustedByTarget",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _validate(\n        ForwardRequestData calldata request\n    ) internal view virtual returns (bool isTrustedForwarder, bool active, bool signerMatch, address signer) {\n        (bool isValid, address recovered) = _recoverForwardRequestSigner(request);\n\n        return (\n            _isTrustedByTarget(request.to),\n            request.deadline >= block.timestamp,\n            isValid && recovered == request.from,\n            recovered\n        );\n    }",
            "startLine": 208
          },
          {
            "name": "_recoverForwardRequestSigner",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "request",
                "type": "ForwardRequestData"
              }
            ],
            "returnValues": [
              {
                "name": "isValid",
                "type": "bool"
              },
              {
                "name": "signer",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "tryRecoverCalldata",
                "type": "external",
                "targetType": "_hashTypedDataV4",
                "argCount": 1
              },
              {
                "target": "_hashTypedDataV4",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "nonces",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _recoverForwardRequestSigner(\n        ForwardRequestData calldata request\n    ) internal view virtual returns (bool isValid, address signer) {\n        (address recovered, ECDSA.RecoverError err, ) = _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    FORWARD_REQUEST_TYPEHASH,\n                    request.from,\n                    request.to,\n                    request.value,\n                    request.gas,\n                    nonces(request.from),\n                    request.deadline,\n                    keccak256(request.data)\n                )\n            )\n        ).tryRecoverCalldata(request.signature);\n\n        return (err == ECDSA.RecoverError.NoError, recovered);\n    }",
            "startLine": 227
          },
          {
            "name": "_execute",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "request",
                "type": "ForwardRequestData"
              },
              {
                "name": "requireValidRequest",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "success",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_validate",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_useNonce",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_checkForwardedGas",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _execute(\n        ForwardRequestData calldata request,\n        bool requireValidRequest\n    ) internal virtual returns (bool success) {\n        (bool isTrustedForwarder, bool active, bool signerMatch, address signer) = _validate(request);\n\n        // Need to explicitly specify if a revert is required since non-reverting is default for\n        // batches and reversion is opt-in since it could be useful in some scenarios\n        if (requireValidRequest) {\n            if (!isTrustedForwarder) {\n                revert ERC2771UntrustfulTarget(request.to, address(this));\n            }\n\n            if (!active) {\n                revert ERC2771ForwarderExpiredRequest(request.deadline);\n            }\n\n            if (!signerMatch) {\n                revert ERC2771ForwarderInvalidSigner(signer, request.from);\n            }\n        }\n\n        // Ignore an invalid request because requireValidRequest = false\n        if (isTrustedForwarder && signerMatch && active) {\n            // Nonce should be used before the call to prevent reusing by reentrancy\n            uint256 currentNonce = _useNonce(signer);\n\n            uint256 reqGas = request.gas;\n            address to = request.to;\n            uint256 value = request.value;\n            bytes memory data = abi.encodePacked(request.data, request.from);\n\n            uint256 gasLeft;\n\n            assembly (\"memory-safe\") {\n                success := call(reqGas, to, value, add(data, 0x20), mload(data), 0x00, 0x00)\n                gasLeft := gas()\n            }\n\n            _checkForwardedGas(gasLeft, request);\n\n            emit ExecutedForwardRequest(signer, currentNonce, success);\n        }\n    }",
            "startLine": 263
          },
          {
            "name": "_isTrustedByTarget",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _isTrustedByTarget(address target) internal view virtual returns (bool) {\n        bytes memory encodedParams = abi.encodeCall(ERC2771ContextUpgradeable.isTrustedForwarder, (address(this)));\n\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            // Perform the staticcall and save the result in the scratch space.\n            // | Location  | Content  | Content (Hex)                                                      |\n            // |-----------|----------|--------------------------------------------------------------------|\n            // |           |          |                                                           result  |\n            // | 0x00:0x1F | selector | 0x0000000000000000000000000000000000000000000000000000000000000001 |\n            success := staticcall(gas(), target, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }",
            "startLine": 317
          },
          {
            "name": "_checkForwardedGas",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "gasLeft",
                "type": "uint256"
              },
              {
                "name": "request",
                "type": "ForwardRequestData"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _checkForwardedGas(uint256 gasLeft, ForwardRequestData calldata request) private pure {\n        // To avoid insufficient gas griefing attacks, as referenced in https://ronan.eth.limo/blog/ethereum-gas-dangers/\n        //\n        // A malicious relayer can attempt to shrink the gas forwarded so that the underlying call reverts out-of-gas\n        // but the forwarding itself still succeeds. In order to make sure that the subcall received sufficient gas,\n        // we will inspect gasleft() after the forwarding.\n        //\n        // Let X be the gas available before the subcall, such that the subcall gets at most X * 63 / 64.\n        // We can't know X after CALL dynamic costs, but we want it to be such that X * 63 / 64 >= req.gas.\n        // Let Y be the gas used in the subcall. gasleft() measured immediately after the subcall will be gasleft() = X - Y.\n        // If the subcall ran out of gas, then Y = X * 63 / 64 and gasleft() = X - Y = X / 64.\n        // Under this assumption req.gas / 63 > gasleft() is true if and only if\n        // req.gas / 63 > X / 64, or equivalently req.gas > X * 63 / 64.\n        // This means that if the subcall runs out of gas we are able to detect that insufficient gas was passed.\n        //\n        // We will now also see that req.gas / 63 > gasleft() implies that req.gas >= X * 63 / 64.\n        // The contract guarantees Y <= req.gas, thus gasleft() = X - Y >= X - req.gas.\n        // -    req.gas / 63 > gasleft()\n        // -    req.gas / 63 >= X - req.gas\n        // -    req.gas >= X * 63 / 64\n        // In other words if req.gas < X * 63 / 64 then req.gas / 63 <= gasleft(), thus if the relayer behaves honestly\n        // the forwarding does not revert.\n        if (gasLeft < request.gas / 63) {\n            // We explicitly trigger invalid opcode to consume all gas and bubble-up the effects, since\n            // neither revert or assert consume all gas since Solidity 0.8.20\n            // https://docs.soliditylang.org/en/v0.8.20/control-structures.html#panic-via-assert-and-error-via-require\n            assembly (\"memory-safe\") {\n                invalid()\n            }\n        }\n    }",
            "startLine": 349
          }
        ],
        "events": [
          {
            "name": "ExecutedForwardRequest",
            "parameters": [
              {
                "name": "signer",
                "type": "address",
                "indexed": true
              },
              {
                "name": "nonce",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "success",
                "type": "bool",
                "indexed": false
              }
            ],
            "startLine": 77
          }
        ],
        "errors": [
          {
            "name": "ERC2771ForwarderInvalidSigner",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              }
            ],
            "startLine": 82
          },
          {
            "name": "ERC2771ForwarderMismatchedValue",
            "parameters": [
              {
                "name": "requestedValue",
                "type": "uint256"
              },
              {
                "name": "msgValue",
                "type": "uint256"
              }
            ],
            "startLine": 87
          },
          {
            "name": "ERC2771ForwarderExpiredRequest",
            "parameters": [
              {
                "name": "deadline",
                "type": "uint48"
              }
            ],
            "startLine": 92
          },
          {
            "name": "ERC2771UntrustfulTarget",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "forwarder",
                "type": "address"
              }
            ],
            "startLine": 97
          }
        ],
        "structs": [
          {
            "name": "ForwardRequestData",
            "members": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "gas",
                "type": "uint256"
              },
              {
                "name": "deadline",
                "type": "uint48"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "startLine": 55
          }
        ],
        "stateVariables": [
          {
            "name": "FORWARD_REQUEST_TYPEHASH",
            "type": "bytes32",
            "visibility": "internal",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 65
          }
        ],
        "usesLibraries": [
          "ECDSA"
        ],
        "imports": [
          {
            "path": "./ERC2771ContextUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/cryptography/ECDSA.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../utils/cryptography/EIP712Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../utils/NoncesUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/Address.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/Errors.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (metatx/ERC2771Forwarder.sol)\n\npragma solidity ^0.8.24;\n\nimport {ERC2771ContextUpgradeable} from \"./ERC2771ContextUpgradeable.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {EIP712Upgradeable} from \"../utils/cryptography/EIP712Upgradeable.sol\";\nimport {NoncesUpgradeable} from \"../utils/NoncesUpgradeable.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {Errors} from \"@openzeppelin/contracts/utils/Errors.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev A forwarder compatible with ERC-2771 contracts. See {ERC2771Context}.\n *\n * This forwarder operates on forward requests that include:\n *\n * * `from`: An address to operate on behalf of. It is required to be equal to the request signer.\n * * `to`: The address that should be called.\n * * `value`: The amount of native token to attach with the requested call.\n * * `gas`: The amount of gas limit that will be forwarded with the requested call.\n * * `nonce` (implicit): Taken from {Nonces} for `from` and included in the signed typed data.\n * * `deadline`: A timestamp after which the request is not executable anymore.\n * * `data`: Encoded `msg.data` to send with the requested call.\n *\n * Relayers are able to submit batches if they are processing a high volume of requests. With high\n * throughput, relayers may run into limitations of the chain such as limits on the number of\n * transactions in the mempool. In these cases the recommendation is to distribute the load among\n * multiple accounts.\n *\n * NOTE: Batching requests includes an optional refund for unused `msg.value` that is achieved by\n * performing a call with empty calldata. While this is within the bounds of ERC-2771 compliance,\n * if the refund receiver happens to consider the forwarder a trusted forwarder, it MUST properly\n * handle `msg.data.length == 0`. `ERC2771Context` in OpenZeppelin Contracts versions prior to 4.9.3\n * do not handle this properly.\n *\n * ==== Security Considerations\n *\n * If a relayer submits a forward request, it should be willing to pay up to 100% of the gas amount\n * specified in the request. This contract does not implement any kind of retribution for this gas,\n * and it is assumed that there is an out of band incentive for relayers to pay for execution on\n * behalf of signers. Often, the relayer is operated by a project that will consider it a user\n * acquisition cost.\n *\n * By offering to pay for gas, relayers are at risk of having that gas used by an attacker toward\n * some other purpose that is not aligned with the expected out of band incentives. If you operate a\n * relayer, consider whitelisting target contracts and function selectors. When relaying ERC-721 or\n * ERC-1155 transfers specifically, consider rejecting the use of the `data` field, since it can be\n * used to execute arbitrary code.\n */\ncontract ERC2771ForwarderUpgradeable is Initializable, EIP712Upgradeable, NoncesUpgradeable {\n    using ECDSA for bytes32;\n\n    struct ForwardRequestData {\n        address from;\n        address to;\n        uint256 value;\n        uint256 gas;\n        uint48 deadline;\n        bytes data;\n        bytes signature;\n    }\n\n    bytes32 internal constant FORWARD_REQUEST_TYPEHASH =\n        keccak256(\n            \"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,uint48 deadline,bytes data)\"\n        );\n\n    /**\n     * @dev Emitted when a `ForwardRequest` is executed.\n     *\n     * NOTE: An unsuccessful forward request could be due to an invalid signature, an expired deadline,\n     * or simply a revert in the requested call. The contract guarantees that the relayer is not able to force\n     * the requested call to run out of gas.\n     */\n    event ExecutedForwardRequest(address indexed signer, uint256 nonce, bool success);\n\n    /**\n     * @dev The request `from` doesn't match with the recovered `signer`.\n     */\n    error ERC2771ForwarderInvalidSigner(address signer, address from);\n\n    /**\n     * @dev The `requestedValue` doesn't match with the available `msgValue`.\n     */\n    error ERC2771ForwarderMismatchedValue(uint256 requestedValue, uint256 msgValue);\n\n    /**\n     * @dev The request `deadline` has expired.\n     */\n    error ERC2771ForwarderExpiredRequest(uint48 deadline);\n\n    /**\n     * @dev The request target doesn't trust the `forwarder`.\n     */\n    error ERC2771UntrustfulTarget(address target, address forwarder);\n\n    function initialize(string memory name) public virtual initializer {\n        __ERC2771Forwarder_init(name);\n    }\n    /**\n     * @dev See {EIP712-constructor}.\n     */\n    function __ERC2771Forwarder_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }\n\n    function __ERC2771Forwarder_init_unchained(string memory) internal onlyInitializing {}\n\n    /**\n     * @dev Returns `true` if a request is valid for a provided `signature` at the current block timestamp.\n     *\n     * A transaction is considered valid when the target trusts this forwarder, the request hasn't expired\n     * (deadline is not met), and the signer matches the `from` parameter of the signed request.\n     *\n     * NOTE: A request may return false here but it won't cause {executeBatch} to revert if a refund\n     * receiver is provided.\n     */\n    function verify(ForwardRequestData calldata request) public view virtual returns (bool) {\n        (bool isTrustedForwarder, bool active, bool signerMatch, ) = _validate(request);\n        return isTrustedForwarder && active && signerMatch;\n    }\n\n    /**\n     * @dev Executes a `request` on behalf of `signature`'s signer using the ERC-2771 protocol. The gas\n     * provided to the requested call may not be exactly the amount requested, but the call will not run\n     * out of gas. Will revert if the request is invalid or the call reverts, in this case the nonce is not consumed.\n     *\n     * Requirements:\n     *\n     * - The request value should be equal to the provided `msg.value`.\n     * - The request should be valid according to {verify}.\n     */\n    function execute(ForwardRequestData calldata request) public payable virtual {\n        // We make sure that msg.value and request.value match exactly.\n        // If the request is invalid or the call reverts, this whole function\n        // will revert, ensuring value isn't stuck.\n        if (msg.value != request.value) {\n            revert ERC2771ForwarderMismatchedValue(request.value, msg.value);\n        }\n\n        if (!_execute(request, true)) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Batch version of {execute} with optional refunding and atomic execution.\n     *\n     * In case a batch contains at least one invalid request (see {verify}), the\n     * request will be skipped and the `refundReceiver` parameter will receive back the\n     * unused requested value at the end of the execution. This is done to prevent reverting\n     * the entire batch when a request is invalid or has already been submitted.\n     *\n     * If the `refundReceiver` is the `address(0)`, this function will revert when at least\n     * one of the requests was not valid instead of skipping it. This could be useful if\n     * a batch is required to get executed atomically (at least at the top-level). For example,\n     * refunding (and thus atomicity) can be opt-out if the relayer is using a service that avoids\n     * including reverted transactions.\n     *\n     * Requirements:\n     *\n     * - The sum of the requests' values should be equal to the provided `msg.value`.\n     * - All of the requests should be valid (see {verify}) when `refundReceiver` is the zero address.\n     *\n     * NOTE: Setting a zero `refundReceiver` guarantees an all-or-nothing requests execution only for\n     * the first-level forwarded calls. In case a forwarded request calls to a contract with another\n     * subcall, the second-level call may revert without the top-level call reverting.\n     */\n    function executeBatch(\n        ForwardRequestData[] calldata requests,\n        address payable refundReceiver\n    ) public payable virtual {\n        bool atomic = refundReceiver == address(0);\n\n        uint256 requestsValue;\n        uint256 refundValue;\n\n        for (uint256 i; i < requests.length; ++i) {\n            requestsValue += requests[i].value;\n            bool success = _execute(requests[i], atomic);\n            if (!success) {\n                refundValue += requests[i].value;\n            }\n        }\n\n        // The batch should revert if there's a mismatched msg.value provided\n        // to avoid request value tampering\n        if (requestsValue != msg.value) {\n            revert ERC2771ForwarderMismatchedValue(requestsValue, msg.value);\n        }\n\n        // Some requests with value were invalid (possibly due to frontrunning).\n        // To avoid leaving ETH in the contract this value is refunded.\n        if (refundValue != 0) {\n            // We know refundReceiver != address(0) && requestsValue == msg.value\n            // meaning we can ensure refundValue is not taken from the original contract's balance\n            // and refundReceiver is a known account.\n            Address.sendValue(refundReceiver, refundValue);\n        }\n    }\n\n    /**\n     * @dev Validates if the provided request can be executed at current block timestamp with\n     * the given `request.signature` on behalf of `request.from`.\n     */\n    function _validate(\n        ForwardRequestData calldata request\n    ) internal view virtual returns (bool isTrustedForwarder, bool active, bool signerMatch, address signer) {\n        (bool isValid, address recovered) = _recoverForwardRequestSigner(request);\n\n        return (\n            _isTrustedByTarget(request.to),\n            request.deadline >= block.timestamp,\n            isValid && recovered == request.from,\n            recovered\n        );\n    }\n\n    /**\n     * @dev Returns a tuple with the recovered the signer of an EIP712 forward request message hash\n     * and a boolean indicating if the signature is valid.\n     *\n     * NOTE: The signature is considered valid if {ECDSA-tryRecover} indicates no recover error for it.\n     */\n    function _recoverForwardRequestSigner(\n        ForwardRequestData calldata request\n    ) internal view virtual returns (bool isValid, address signer) {\n        (address recovered, ECDSA.RecoverError err, ) = _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    FORWARD_REQUEST_TYPEHASH,\n                    request.from,\n                    request.to,\n                    request.value,\n                    request.gas,\n                    nonces(request.from),\n                    request.deadline,\n                    keccak256(request.data)\n                )\n            )\n        ).tryRecoverCalldata(request.signature);\n\n        return (err == ECDSA.RecoverError.NoError, recovered);\n    }\n\n    /**\n     * @dev Validates and executes a signed request returning the request call `success` value.\n     *\n     * Internal function without msg.value validation.\n     *\n     * Requirements:\n     *\n     * - The caller must have provided enough gas to forward with the call.\n     * - The request must be valid (see {verify}) if the `requireValidRequest` is true.\n     *\n     * Emits an {ExecutedForwardRequest} event.\n     *\n     * IMPORTANT: Using this function doesn't check that all the `msg.value` was sent, potentially\n     * leaving value stuck in the contract.\n     */\n    function _execute(\n        ForwardRequestData calldata request,\n        bool requireValidRequest\n    ) internal virtual returns (bool success) {\n        (bool isTrustedForwarder, bool active, bool signerMatch, address signer) = _validate(request);\n\n        // Need to explicitly specify if a revert is required since non-reverting is default for\n        // batches and reversion is opt-in since it could be useful in some scenarios\n        if (requireValidRequest) {\n            if (!isTrustedForwarder) {\n                revert ERC2771UntrustfulTarget(request.to, address(this));\n            }\n\n            if (!active) {\n                revert ERC2771ForwarderExpiredRequest(request.deadline);\n            }\n\n            if (!signerMatch) {\n                revert ERC2771ForwarderInvalidSigner(signer, request.from);\n            }\n        }\n\n        // Ignore an invalid request because requireValidRequest = false\n        if (isTrustedForwarder && signerMatch && active) {\n            // Nonce should be used before the call to prevent reusing by reentrancy\n            uint256 currentNonce = _useNonce(signer);\n\n            uint256 reqGas = request.gas;\n            address to = request.to;\n            uint256 value = request.value;\n            bytes memory data = abi.encodePacked(request.data, request.from);\n\n            uint256 gasLeft;\n\n            assembly (\"memory-safe\") {\n                success := call(reqGas, to, value, add(data, 0x20), mload(data), 0x00, 0x00)\n                gasLeft := gas()\n            }\n\n            _checkForwardedGas(gasLeft, request);\n\n            emit ExecutedForwardRequest(signer, currentNonce, success);\n        }\n    }\n\n    /**\n     * @dev Returns whether the target trusts this forwarder.\n     *\n     * This function performs a static call to the target contract calling the\n     * {ERC2771Context-isTrustedForwarder} function.\n     *\n     * NOTE: Consider the execution of this forwarder is permissionless. Without this check, anyone may transfer assets\n     * that are owned by, or are approved to this forwarder.\n     */\n    function _isTrustedByTarget(address target) internal view virtual returns (bool) {\n        bytes memory encodedParams = abi.encodeCall(ERC2771ContextUpgradeable.isTrustedForwarder, (address(this)));\n\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            // Perform the staticcall and save the result in the scratch space.\n            // | Location  | Content  | Content (Hex)                                                      |\n            // |-----------|----------|--------------------------------------------------------------------|\n            // |           |          |                                                           result  |\n            // | 0x00:0x1F | selector | 0x0000000000000000000000000000000000000000000000000000000000000001 |\n            success := staticcall(gas(), target, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n\n    /**\n     * @dev Checks if the requested gas was correctly forwarded to the callee.\n     *\n     * As a consequence of https://eips.ethereum.org/EIPS/eip-150[EIP-150]:\n     * - At most `gasleft() - floor(gasleft() / 64)` is forwarded to the callee.\n     * - At least `floor(gasleft() / 64)` is kept in the caller.\n     *\n     * It reverts consuming all the available gas if the forwarded gas is not the requested gas.\n     *\n     * IMPORTANT: The `gasLeft` parameter should be measured exactly at the end of the forwarded call.\n     * Any gas consumed in between will make room for bypassing this check.\n     */\n    function _checkForwardedGas(uint256 gasLeft, ForwardRequestData calldata request) private pure {\n        // To avoid insufficient gas griefing attacks, as referenced in https://ronan.eth.limo/blog/ethereum-gas-dangers/\n        //\n        // A malicious relayer can attempt to shrink the gas forwarded so that the underlying call reverts out-of-gas\n        // but the forwarding itself still succeeds. In order to make sure that the subcall received sufficient gas,\n        // we will inspect gasleft() after the forwarding.\n        //\n        // Let X be the gas available before the subcall, such that the subcall gets at most X * 63 / 64.\n        // We can't know X after CALL dynamic costs, but we want it to be such that X * 63 / 64 >= req.gas.\n        // Let Y be the gas used in the subcall. gasleft() measured immediately after the subcall will be gasleft() = X - Y.\n        // If the subcall ran out of gas, then Y = X * 63 / 64 and gasleft() = X - Y = X / 64.\n        // Under this assumption req.gas / 63 > gasleft() is true if and only if\n        // req.gas / 63 > X / 64, or equivalently req.gas > X * 63 / 64.\n        // This means that if the subcall runs out of gas we are able to detect that insufficient gas was passed.\n        //\n        // We will now also see that req.gas / 63 > gasleft() implies that req.gas >= X * 63 / 64.\n        // The contract guarantees Y <= req.gas, thus gasleft() = X - Y >= X - req.gas.\n        // -    req.gas / 63 > gasleft()\n        // -    req.gas / 63 >= X - req.gas\n        // -    req.gas >= X * 63 / 64\n        // In other words if req.gas < X * 63 / 64 then req.gas / 63 <= gasleft(), thus if the relayer behaves honestly\n        // the forwarding does not revert.\n        if (gasLeft < request.gas / 63) {\n            // We explicitly trigger invalid opcode to consume all gas and bubble-up the effects, since\n            // neither revert or assert consume all gas since Solidity 0.8.20\n            // https://docs.soliditylang.org/en/v0.8.20/control-structures.html#panic-via-assert-and-error-via-require\n            assembly (\"memory-safe\") {\n                invalid()\n            }\n        }\n    }\n}\n"
      },
      {
        "name": "ERC1155Upgradeable",
        "filePath": "token/ERC1155/ERC1155Upgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ContextUpgradeable",
          "ERC165Upgradeable",
          "IERC1155",
          "IERC1155MetadataURI",
          "IERC1155Errors"
        ],
        "implements": [],
        "category": "token/ERC1155",
        "externalFunctions": [
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "supportsInterface",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }",
            "startLine": 56
          },
          {
            "name": "uri",
            "signature": "uri(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC1155Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function uri(uint256 /* id */) public view virtual returns (string memory) {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        return $._uri;\n    }",
            "startLine": 73
          },
          {
            "name": "balanceOf",
            "signature": "balanceOf(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC1155Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address account, uint256 id) public view virtual returns (uint256) {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        return $._balances[id][account];\n    }",
            "startLine": 79
          },
          {
            "name": "balanceOfBatch",
            "signature": "balanceOfBatch(address[],uint256[])",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "accounts",
                "type": "address[]"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "balanceOf",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "Arrays.unsafeMemoryAccess",
                "type": "library",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual returns (uint256[] memory) {\n        if (accounts.length != ids.length) {\n            revert ERC1155InvalidArrayLength(ids.length, accounts.length);\n        }\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));\n        }\n\n        return batchBalances;\n    }",
            "startLine": 91
          },
          {
            "name": "setApprovalForAll",
            "signature": "setApprovalForAll(address,bool)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "approved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setApprovalForAll",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }",
            "startLine": 109
          },
          {
            "name": "isApprovedForAll",
            "signature": "isApprovedForAll(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getERC1155Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function isApprovedForAll(address account, address operator) public view virtual returns (bool) {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        return $._operatorApprovals[account][operator];\n    }",
            "startLine": 114
          },
          {
            "name": "safeTransferFrom",
            "signature": "safeTransferFrom(address,address,uint256,uint256,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_safeTransferFrom",
                "type": "internal",
                "argCount": 5
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public virtual {\n        _checkAuthorized(_msgSender(), from);\n        _safeTransferFrom(from, to, id, value, data);\n    }",
            "startLine": 120
          },
          {
            "name": "safeBatchTransferFrom",
            "signature": "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_safeBatchTransferFrom",
                "type": "internal",
                "argCount": 5
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public virtual {\n        _checkAuthorized(_msgSender(), from);\n        _safeBatchTransferFrom(from, to, ids, values, data);\n    }",
            "startLine": 126
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC1155Storage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC1155Storage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getERC1155Storage() private pure returns (ERC1155Storage storage $) {\n        assembly {\n            $.slot := ERC1155StorageLocation\n        }\n    }",
            "startLine": 38
          },
          {
            "name": "__ERC1155_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "uri_",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC1155_init(string memory uri_) internal onlyInitializing {\n        __ERC1155_init_unchained(uri_);\n    }",
            "startLine": 47
          },
          {
            "name": "__ERC1155_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "uri_",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setURI",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\n        _setURI(uri_);\n    }",
            "startLine": 51
          },
          {
            "name": "_checkAuthorized",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "isApprovedForAll",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _checkAuthorized(address operator, address owner) internal view virtual {\n        if (owner != operator && !isApprovedForAll(owner, operator)) {\n            revert ERC1155MissingApprovalForAll(operator, owner);\n        }\n    }",
            "startLine": 138
          },
          {
            "name": "_update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC1155Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Arrays.unsafeMemoryAccess",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _update(address from, address to, uint256[] memory ids, uint256[] memory values) internal virtual {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        if (ids.length != values.length) {\n            revert ERC1155InvalidArrayLength(ids.length, values.length);\n        }\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids.unsafeMemoryAccess(i);\n            uint256 value = values.unsafeMemoryAccess(i);\n\n            if (from != address(0)) {\n                uint256 fromBalance = $._balances[id][from];\n                if (fromBalance < value) {\n                    revert ERC1155InsufficientBalance(from, fromBalance, value, id);\n                }\n                unchecked {\n                    // Overflow not possible: value <= fromBalance\n                    $._balances[id][from] = fromBalance - value;\n                }\n            }\n\n            if (to != address(0)) {\n                $._balances[id][to] += value;\n            }\n        }\n\n        if (ids.length == 1) {\n            uint256 id = ids.unsafeMemoryAccess(0);\n            uint256 value = values.unsafeMemoryAccess(0);\n            emit TransferSingle(operator, from, to, id, value);\n        } else {\n            emit TransferBatch(operator, from, to, ids, values);\n        }\n    }",
            "startLine": 158
          },
          {
            "name": "_updateWithAcceptanceCheck",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_updateWithAcceptanceCheck",
                "type": "internal",
                "argCount": 6
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _updateWithAcceptanceCheck(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal virtual {\n        _updateWithAcceptanceCheck(from, to, ids, values, data, ids.length != 1);\n    }",
            "startLine": 207
          },
          {
            "name": "_updateWithAcceptanceCheck",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "batch",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "ERC1155Utils.checkOnERC1155BatchReceived",
                "type": "library",
                "argCount": 6
              },
              {
                "target": "Arrays.unsafeMemoryAccess",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "ERC1155Utils.checkOnERC1155Received",
                "type": "library",
                "argCount": 6
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _updateWithAcceptanceCheck(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data,\n        bool batch\n    ) internal virtual {\n        _update(from, to, ids, values);\n        if (to != address(0)) {\n            address operator = _msgSender();\n            if (batch) {\n                ERC1155Utils.checkOnERC1155BatchReceived(operator, from, to, ids, values, data);\n            } else {\n                uint256 id = ids.unsafeMemoryAccess(0);\n                uint256 value = values.unsafeMemoryAccess(0);\n                ERC1155Utils.checkOnERC1155Received(operator, from, to, id, value, data);\n            }\n        }\n    }",
            "startLine": 226
          },
          {
            "name": "_safeTransferFrom",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_asSingletonArrays",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_updateWithAcceptanceCheck",
                "type": "internal",
                "argCount": 6
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, to, ids, values, data, false);\n    }",
            "startLine": 259
          },
          {
            "name": "_safeBatchTransferFrom",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_updateWithAcceptanceCheck",
                "type": "internal",
                "argCount": 6
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, to, ids, values, data, true);\n    }",
            "startLine": 281
          },
          {
            "name": "_setURI",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newuri",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC1155Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setURI(string memory newuri) internal virtual {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        $._uri = newuri;\n    }",
            "startLine": 316
          },
          {
            "name": "_mint",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_asSingletonArrays",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_updateWithAcceptanceCheck",
                "type": "internal",
                "argCount": 6
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _mint(address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data, false);\n    }",
            "startLine": 332
          },
          {
            "name": "_mintBatch",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_updateWithAcceptanceCheck",
                "type": "internal",
                "argCount": 6
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data, true);\n    }",
            "startLine": 352
          },
          {
            "name": "_burn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_asSingletonArrays",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_updateWithAcceptanceCheck",
                "type": "internal",
                "argCount": 6
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _burn(address from, uint256 id, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\", false);\n    }",
            "startLine": 369
          },
          {
            "name": "_burnBatch",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_updateWithAcceptanceCheck",
                "type": "internal",
                "argCount": 6
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _burnBatch(address from, uint256[] memory ids, uint256[] memory values) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\", true);\n    }",
            "startLine": 388
          },
          {
            "name": "_setApprovalForAll",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "approved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC1155Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        if (owner == address(0)) {\n            revert ERC1155InvalidApprover(address(0));\n        }\n        if (operator == address(0)) {\n            revert ERC1155InvalidOperator(address(0));\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }",
            "startLine": 404
          },
          {
            "name": "_asSingletonArrays",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "element1",
                "type": "uint256"
              },
              {
                "name": "element2",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "array1",
                "type": "uint256[]"
              },
              {
                "name": "array2",
                "type": "uint256[]"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _asSingletonArrays(\n        uint256 element1,\n        uint256 element2\n    ) private pure returns (uint256[] memory array1, uint256[] memory array2) {\n        assembly (\"memory-safe\") {\n            // Load the free memory pointer\n            array1 := mload(0x40)\n            // Set array length to 1\n            mstore(array1, 1)\n            // Store the single element at the next word after the length (where content starts)\n            mstore(add(array1, 0x20), element1)\n\n            // Repeat for next array locating it right after the first array\n            array2 := add(array1, 0x40)\n            mstore(array2, 1)\n            mstore(add(array2, 0x20), element2)\n\n            // Update the free memory pointer by pointing after the second array\n            mstore(0x40, add(array2, 0x40))\n        }\n    }",
            "startLine": 419
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "ERC1155Storage",
            "members": [
              {
                "name": "_balances",
                "type": "mapping(uint256 => mapping(address => uint256))"
              },
              {
                "name": "_operatorApprovals",
                "type": "mapping(address => mapping(address => bool))"
              },
              {
                "name": "_uri",
                "type": "string"
              }
            ],
            "startLine": 26
          }
        ],
        "stateVariables": [
          {
            "name": "ERC1155StorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 36
          }
        ],
        "usesLibraries": [
          "Arrays",
          "Arrays"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/token/ERC1155/IERC1155.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Utils.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../../utils/ContextUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/introspection/IERC165.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../../utils/introspection/ERC165Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/Arrays.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/interfaces/draft-IERC6093.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.24;\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC1155MetadataURI} from \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport {ERC1155Utils} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Utils.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport {Arrays} from \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport {IERC1155Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n */\nabstract contract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155, IERC1155MetadataURI, IERC1155Errors {\n    using Arrays for uint256[];\n    using Arrays for address[];\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC1155\n    struct ERC1155Storage {\n        mapping(uint256 id => mapping(address account => uint256)) _balances;\n\n        mapping(address account => mapping(address operator => bool)) _operatorApprovals;\n\n        // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n        string _uri;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC1155\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC1155StorageLocation = 0x88be536d5240c274a3b1d3a1be54482fd9caa294f08c62a7cde569f49a3c4500;\n\n    function _getERC1155Storage() private pure returns (ERC1155Storage storage $) {\n        assembly {\n            $.slot := ERC1155StorageLocation\n        }\n    }\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\n        _setURI(uri_);\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the ERC].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256 /* id */) public view virtual returns (string memory) {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        return $._uri;\n    }\n\n    /// @inheritdoc IERC1155\n    function balanceOf(address account, uint256 id) public view virtual returns (uint256) {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        return $._balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual returns (uint256[] memory) {\n        if (accounts.length != ids.length) {\n            revert ERC1155InvalidArrayLength(ids.length, accounts.length);\n        }\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));\n        }\n\n        return batchBalances;\n    }\n\n    /// @inheritdoc IERC1155\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /// @inheritdoc IERC1155\n    function isApprovedForAll(address account, address operator) public view virtual returns (bool) {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        return $._operatorApprovals[account][operator];\n    }\n\n    /// @inheritdoc IERC1155\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public virtual {\n        _checkAuthorized(_msgSender(), from);\n        _safeTransferFrom(from, to, id, value, data);\n    }\n\n    /// @inheritdoc IERC1155\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public virtual {\n        _checkAuthorized(_msgSender(), from);\n        _safeBatchTransferFrom(from, to, ids, values, data);\n    }\n\n    /// @dev Checks if `operator` is authorized to transfer tokens owned by `owner`. Reverts with {ERC1155MissingApprovalForAll} if not.\n    function _checkAuthorized(address operator, address owner) internal view virtual {\n        if (owner != operator && !isApprovedForAll(owner, operator)) {\n            revert ERC1155MissingApprovalForAll(operator, owner);\n        }\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`. Will mint (or burn) if `from`\n     * (or `to`) is the zero address.\n     *\n     * Emits a {TransferSingle} event if the arrays contain one element, and {TransferBatch} otherwise.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement either {IERC1155Receiver-onERC1155Received}\n     *   or {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.\n     * - `ids` and `values` must have the same length.\n     *\n     * NOTE: The ERC-1155 acceptance check is not performed in this function. See {_updateWithAcceptanceCheck} instead.\n     */\n    function _update(address from, address to, uint256[] memory ids, uint256[] memory values) internal virtual {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        if (ids.length != values.length) {\n            revert ERC1155InvalidArrayLength(ids.length, values.length);\n        }\n\n        address operator = _msgSender();\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids.unsafeMemoryAccess(i);\n            uint256 value = values.unsafeMemoryAccess(i);\n\n            if (from != address(0)) {\n                uint256 fromBalance = $._balances[id][from];\n                if (fromBalance < value) {\n                    revert ERC1155InsufficientBalance(from, fromBalance, value, id);\n                }\n                unchecked {\n                    // Overflow not possible: value <= fromBalance\n                    $._balances[id][from] = fromBalance - value;\n                }\n            }\n\n            if (to != address(0)) {\n                $._balances[id][to] += value;\n            }\n        }\n\n        if (ids.length == 1) {\n            uint256 id = ids.unsafeMemoryAccess(0);\n            uint256 value = values.unsafeMemoryAccess(0);\n            emit TransferSingle(operator, from, to, id, value);\n        } else {\n            emit TransferBatch(operator, from, to, ids, values);\n        }\n    }\n\n    /**\n     * @dev Version of {_update} that performs the token acceptance check by calling\n     * {IERC1155Receiver-onERC1155Received} or {IERC1155Receiver-onERC1155BatchReceived} on the receiver address if it\n     * contains code (eg. is a smart contract at the moment of execution).\n     *\n     * IMPORTANT: Overriding this function is discouraged because it poses a reentrancy risk from the receiver. So any\n     * update to the contract state after this function would break the check-effect-interaction pattern. Consider\n     * overriding {_update} instead.\n     *\n     * NOTE: This version is kept for backward compatibility. We recommend calling the alternative version with a boolean\n     * flag in order to achieve better control over which hook to call.\n     */\n    function _updateWithAcceptanceCheck(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal virtual {\n        _updateWithAcceptanceCheck(from, to, ids, values, data, ids.length != 1);\n    }\n\n    /**\n     * @dev Version of {_update} that performs the token acceptance check by calling\n     * {IERC1155Receiver-onERC1155Received} or {IERC1155Receiver-onERC1155BatchReceived} on the receiver address if it\n     * contains code (eg. is a smart contract at the moment of execution).\n     *\n     * IMPORTANT: Overriding this function is discouraged because it poses a reentrancy risk from the receiver. So any\n     * update to the contract state after this function would break the check-effect-interaction pattern. Consider\n     * overriding {_update} instead.\n     */\n    function _updateWithAcceptanceCheck(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data,\n        bool batch\n    ) internal virtual {\n        _update(from, to, ids, values);\n        if (to != address(0)) {\n            address operator = _msgSender();\n            if (batch) {\n                ERC1155Utils.checkOnERC1155BatchReceived(operator, from, to, ids, values, data);\n            } else {\n                uint256 id = ids.unsafeMemoryAccess(0);\n                uint256 value = values.unsafeMemoryAccess(0);\n                ERC1155Utils.checkOnERC1155Received(operator, from, to, id, value, data);\n            }\n        }\n    }\n\n    /**\n     * @dev Transfers a `value` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, to, ids, values, data, false);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     * - `ids` and `values` must have the same length.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, to, ids, values, data, true);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the ERC].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the values in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        $._uri = newuri;\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens of type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data, false);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal {\n        if (to == address(0)) {\n            revert ERC1155InvalidReceiver(address(0));\n        }\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data, true);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens of type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `value` amount of tokens of type `id`.\n     */\n    function _burn(address from, uint256 id, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\", false);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `value` amount of tokens of type `id`.\n     * - `ids` and `values` must have the same length.\n     */\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory values) internal {\n        if (from == address(0)) {\n            revert ERC1155InvalidSender(address(0));\n        }\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \"\", true);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the zero address.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC1155Storage storage $ = _getERC1155Storage();\n        if (owner == address(0)) {\n            revert ERC1155InvalidApprover(address(0));\n        }\n        if (operator == address(0)) {\n            revert ERC1155InvalidOperator(address(0));\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Creates an array in memory with only one value for each of the elements provided.\n     */\n    function _asSingletonArrays(\n        uint256 element1,\n        uint256 element2\n    ) private pure returns (uint256[] memory array1, uint256[] memory array2) {\n        assembly (\"memory-safe\") {\n            // Load the free memory pointer\n            array1 := mload(0x40)\n            // Set array length to 1\n            mstore(array1, 1)\n            // Store the single element at the next word after the length (where content starts)\n            mstore(add(array1, 0x20), element1)\n\n            // Repeat for next array locating it right after the first array\n            array2 := add(array1, 0x40)\n            mstore(array2, 1)\n            mstore(add(array2, 0x20), element2)\n\n            // Update the free memory pointer by pointing after the second array\n            mstore(0x40, add(array2, 0x40))\n        }\n    }\n}\n"
      },
      {
        "name": "ERC1155BurnableUpgradeable",
        "filePath": "token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC1155Upgradeable"
        ],
        "implements": [],
        "category": "token/ERC1155",
        "externalFunctions": [
          {
            "name": "burn",
            "signature": "burn(address,uint256,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "isApprovedForAll",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_burn",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function burn(address account, uint256 id, uint256 value) public virtual {\n        if (account != _msgSender() && !isApprovedForAll(account, _msgSender())) {\n            revert ERC1155MissingApprovalForAll(_msgSender(), account);\n        }\n\n        _burn(account, id, value);\n    }",
            "startLine": 19
          },
          {
            "name": "burnBatch",
            "signature": "burnBatch(address,uint256[],uint256[])",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "isApprovedForAll",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_burnBatch",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function burnBatch(address account, uint256[] memory ids, uint256[] memory values) public virtual {\n        if (account != _msgSender() && !isApprovedForAll(account, _msgSender())) {\n            revert ERC1155MissingApprovalForAll(_msgSender(), account);\n        }\n\n        _burnBatch(account, ids, values);\n    }",
            "startLine": 27
          }
        ],
        "internalFunctions": [
          {
            "name": "__ERC1155Burnable_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC1155Burnable_init() internal onlyInitializing {\n    }",
            "startLine": 14
          },
          {
            "name": "__ERC1155Burnable_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC1155Burnable_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 17
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC1155Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.24;\n\nimport {ERC1155Upgradeable} from \"../ERC1155Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\n * own tokens and those that they have been approved to use.\n */\nabstract contract ERC1155BurnableUpgradeable is Initializable, ERC1155Upgradeable {\n    function __ERC1155Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Burnable_init_unchained() internal onlyInitializing {\n    }\n    function burn(address account, uint256 id, uint256 value) public virtual {\n        if (account != _msgSender() && !isApprovedForAll(account, _msgSender())) {\n            revert ERC1155MissingApprovalForAll(_msgSender(), account);\n        }\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(address account, uint256[] memory ids, uint256[] memory values) public virtual {\n        if (account != _msgSender() && !isApprovedForAll(account, _msgSender())) {\n            revert ERC1155MissingApprovalForAll(_msgSender(), account);\n        }\n\n        _burnBatch(account, ids, values);\n    }\n}\n"
      },
      {
        "name": "ERC1155PausableUpgradeable",
        "filePath": "token/ERC1155/extensions/ERC1155PausableUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC1155Upgradeable",
          "PausableUpgradeable"
        ],
        "implements": [],
        "category": "token/ERC1155",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "__ERC1155Pausable_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC1155Pausable_init() internal onlyInitializing {\n    }",
            "startLine": 24
          },
          {
            "name": "__ERC1155Pausable_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC1155Pausable_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 27
          },
          {
            "name": "_update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "super",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _update(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) internal virtual override whenNotPaused {\n        super._update(from, to, ids, values);\n    }",
            "startLine": 36
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC1155Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../../../utils/PausableUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.24;\n\nimport {ERC1155Upgradeable} from \"../ERC1155Upgradeable.sol\";\nimport {PausableUpgradeable} from \"../../../utils/PausableUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC-1155 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract pause mechanism of the contract unreachable, and thus unusable.\n */\nabstract contract ERC1155PausableUpgradeable is Initializable, ERC1155Upgradeable, PausableUpgradeable {\n    function __ERC1155Pausable_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC1155-_update}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _update(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) internal virtual override whenNotPaused {\n        super._update(from, to, ids, values);\n    }\n}\n"
      },
      {
        "name": "ERC1155SupplyUpgradeable",
        "filePath": "token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC1155Upgradeable"
        ],
        "implements": [],
        "category": "token/ERC1155",
        "externalFunctions": [
          {
            "name": "totalSupply",
            "signature": "totalSupply(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC1155SupplyStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function totalSupply(uint256 id) public view virtual returns (uint256) {\n        ERC1155SupplyStorage storage $ = _getERC1155SupplyStorage();\n        return $._totalSupply[id];\n    }",
            "startLine": 49
          },
          {
            "name": "totalSupply",
            "signature": "totalSupply()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC1155SupplyStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function totalSupply() public view virtual returns (uint256) {\n        ERC1155SupplyStorage storage $ = _getERC1155SupplyStorage();\n        return $._totalSupplyAll;\n    }",
            "startLine": 57
          },
          {
            "name": "exists",
            "signature": "exists(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "totalSupply",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function exists(uint256 id) public view virtual returns (bool) {\n        return totalSupply(id) > 0;\n    }",
            "startLine": 65
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC1155SupplyStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC1155SupplyStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getERC1155SupplyStorage() private pure returns (ERC1155SupplyStorage storage $) {\n        assembly {\n            $.slot := ERC1155SupplyStorageLocation\n        }\n    }",
            "startLine": 35
          },
          {
            "name": "__ERC1155Supply_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC1155Supply_init() internal onlyInitializing {\n    }",
            "startLine": 41
          },
          {
            "name": "__ERC1155Supply_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC1155Supply_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 44
          },
          {
            "name": "_update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "ids",
                "type": "uint256[]"
              },
              {
                "name": "values",
                "type": "uint256[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC1155SupplyStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_update",
                "type": "super",
                "argCount": 4
              },
              {
                "target": "Arrays.unsafeMemoryAccess",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _update(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) internal virtual override {\n        ERC1155SupplyStorage storage $ = _getERC1155SupplyStorage();\n        super._update(from, to, ids, values);\n\n        if (from == address(0)) {\n            uint256 totalMintValue = 0;\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 value = values.unsafeMemoryAccess(i);\n                // Overflow check required: The rest of the code assumes that totalSupply never overflows\n                $._totalSupply[ids.unsafeMemoryAccess(i)] += value;\n                totalMintValue += value;\n            }\n            // Overflow check required: The rest of the code assumes that totalSupplyAll never overflows\n            $._totalSupplyAll += totalMintValue;\n        }\n\n        if (to == address(0)) {\n            uint256 totalBurnValue = 0;\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 value = values.unsafeMemoryAccess(i);\n\n                unchecked {\n                    // Overflow not possible: values[i] <= balanceOf(from, ids[i]) <= totalSupply(ids[i])\n                    $._totalSupply[ids.unsafeMemoryAccess(i)] -= value;\n                    // Overflow not possible: sum_i(values[i]) <= sum_i(totalSupply(ids[i])) <= totalSupplyAll\n                    totalBurnValue += value;\n                }\n            }\n            unchecked {\n                // Overflow not possible: totalBurnValue = sum_i(values[i]) <= sum_i(totalSupply(ids[i])) <= totalSupplyAll\n                $._totalSupplyAll -= totalBurnValue;\n            }\n        }\n    }",
            "startLine": 70
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "ERC1155SupplyStorage",
            "members": [
              {
                "name": "_totalSupply",
                "type": "mapping(uint256 => uint256)"
              },
              {
                "name": "_totalSupplyAll",
                "type": "uint256"
              }
            ],
            "startLine": 27
          }
        ],
        "stateVariables": [
          {
            "name": "ERC1155SupplyStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 33
          }
        ],
        "usesLibraries": [
          "Arrays"
        ],
        "imports": [
          {
            "path": "../ERC1155Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/Arrays.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC1155/extensions/ERC1155Supply.sol)\n\npragma solidity ^0.8.24;\n\nimport {ERC1155Upgradeable} from \"../ERC1155Upgradeable.sol\";\nimport {Arrays} from \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC-1155 that adds tracking of total supply per id.\n *\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\n * clearly identified. Note: While a `totalSupply` of 1 may mean the\n * corresponding token is an NFT, there are no inherent guarantees that\n * no more tokens with the same id will be minted in future.\n *\n * NOTE: This contract implies a global limit of 2**256 - 1 to the number of tokens\n * that can be minted.\n *\n * CAUTION: This extension should not be added in an upgrade to an already deployed contract.\n */\nabstract contract ERC1155SupplyUpgradeable is Initializable, ERC1155Upgradeable {\n    using Arrays for uint256[];\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC1155Supply\n    struct ERC1155SupplyStorage {\n        mapping(uint256 id => uint256) _totalSupply;\n        uint256 _totalSupplyAll;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC1155Supply\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC1155SupplyStorageLocation = 0x4a593662ee04d27b6a00ebb31be7fe0c102c2ade82a7c5d764f2df05dc4e2800;\n\n    function _getERC1155SupplyStorage() private pure returns (ERC1155SupplyStorage storage $) {\n        assembly {\n            $.slot := ERC1155SupplyStorageLocation\n        }\n    }\n\n    function __ERC1155Supply_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Supply_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Total value of tokens with a given id.\n     */\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        ERC1155SupplyStorage storage $ = _getERC1155SupplyStorage();\n        return $._totalSupply[id];\n    }\n\n    /**\n     * @dev Total value of tokens.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        ERC1155SupplyStorage storage $ = _getERC1155SupplyStorage();\n        return $._totalSupplyAll;\n    }\n\n    /**\n     * @dev Indicates whether any tokens exist with a given id, or not.\n     */\n    function exists(uint256 id) public view virtual returns (bool) {\n        return totalSupply(id) > 0;\n    }\n\n    /// @inheritdoc ERC1155Upgradeable\n    function _update(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) internal virtual override {\n        ERC1155SupplyStorage storage $ = _getERC1155SupplyStorage();\n        super._update(from, to, ids, values);\n\n        if (from == address(0)) {\n            uint256 totalMintValue = 0;\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 value = values.unsafeMemoryAccess(i);\n                // Overflow check required: The rest of the code assumes that totalSupply never overflows\n                $._totalSupply[ids.unsafeMemoryAccess(i)] += value;\n                totalMintValue += value;\n            }\n            // Overflow check required: The rest of the code assumes that totalSupplyAll never overflows\n            $._totalSupplyAll += totalMintValue;\n        }\n\n        if (to == address(0)) {\n            uint256 totalBurnValue = 0;\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 value = values.unsafeMemoryAccess(i);\n\n                unchecked {\n                    // Overflow not possible: values[i] <= balanceOf(from, ids[i]) <= totalSupply(ids[i])\n                    $._totalSupply[ids.unsafeMemoryAccess(i)] -= value;\n                    // Overflow not possible: sum_i(values[i]) <= sum_i(totalSupply(ids[i])) <= totalSupplyAll\n                    totalBurnValue += value;\n                }\n            }\n            unchecked {\n                // Overflow not possible: totalBurnValue = sum_i(values[i]) <= sum_i(totalSupply(ids[i])) <= totalSupplyAll\n                $._totalSupplyAll -= totalBurnValue;\n            }\n        }\n    }\n}\n"
      },
      {
        "name": "ERC1155URIStorageUpgradeable",
        "filePath": "token/ERC1155/extensions/ERC1155URIStorageUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC1155Upgradeable"
        ],
        "implements": [],
        "category": "token/ERC1155",
        "externalFunctions": [
          {
            "name": "uri",
            "signature": "uri(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC1155URIStorageStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "uri",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function uri(uint256 tokenId) public view virtual override returns (string memory) {\n        ERC1155URIStorageStorage storage $ = _getERC1155URIStorageStorage();\n        string memory tokenURI = $._tokenURIs[tokenId];\n\n        // If token URI is set, concatenate base URI and tokenURI (via string.concat).\n        return bytes(tokenURI).length > 0 ? string.concat($._baseURI, tokenURI) : super.uri(tokenId);\n    }",
            "startLine": 58
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC1155URIStorageStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC1155URIStorageStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getERC1155URIStorageStorage() private pure returns (ERC1155URIStorageStorage storage $) {\n        assembly {\n            $.slot := ERC1155URIStorageStorageLocation\n        }\n    }",
            "startLine": 26
          },
          {
            "name": "__ERC1155URIStorage_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC1155URIStorage_init() internal onlyInitializing {\n        __ERC1155URIStorage_init_unchained();\n    }",
            "startLine": 32
          },
          {
            "name": "__ERC1155URIStorage_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC1155URIStorageStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __ERC1155URIStorage_init_unchained() internal onlyInitializing {\n        ERC1155URIStorageStorage storage $ = _getERC1155URIStorageStorage();\n        $._baseURI = \"\";\n    }",
            "startLine": 36
          },
          {
            "name": "_setURI",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "tokenURI",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC1155URIStorageStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setURI(uint256 tokenId, string memory tokenURI) internal virtual {\n        ERC1155URIStorageStorage storage $ = _getERC1155URIStorageStorage();\n        $._tokenURIs[tokenId] = tokenURI;\n        emit URI(uri(tokenId), tokenId);\n    }",
            "startLine": 69
          },
          {
            "name": "_setBaseURI",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "baseURI",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC1155URIStorageStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setBaseURI(string memory baseURI) internal virtual {\n        ERC1155URIStorageStorage storage $ = _getERC1155URIStorageStorage();\n        $._baseURI = baseURI;\n    }",
            "startLine": 78
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "ERC1155URIStorageStorage",
            "members": [
              {
                "name": "_baseURI",
                "type": "string"
              },
              {
                "name": "_tokenURIs",
                "type": "mapping(uint256 => string)"
              }
            ],
            "startLine": 15
          }
        ],
        "stateVariables": [
          {
            "name": "ERC1155URIStorageStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 24
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC1155Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC1155/extensions/ERC1155URIStorage.sol)\n\npragma solidity ^0.8.24;\n\nimport {ERC1155Upgradeable} from \"../ERC1155Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC-1155 token with storage based token URI management.\n * Inspired by the {ERC721URIStorage} extension\n */\nabstract contract ERC1155URIStorageUpgradeable is Initializable, ERC1155Upgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC1155URIStorage\n    struct ERC1155URIStorageStorage {\n        // Optional base URI\n        string _baseURI;\n\n        // Optional mapping for token URIs\n        mapping(uint256 tokenId => string) _tokenURIs;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC1155URIStorage\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC1155URIStorageStorageLocation = 0x89fc852226e759c7c636cf34d732f0198fc56a54876b2374a52beb7b0c558600;\n\n    function _getERC1155URIStorageStorage() private pure returns (ERC1155URIStorageStorage storage $) {\n        assembly {\n            $.slot := ERC1155URIStorageStorageLocation\n        }\n    }\n\n    function __ERC1155URIStorage_init() internal onlyInitializing {\n        __ERC1155URIStorage_init_unchained();\n    }\n\n    function __ERC1155URIStorage_init_unchained() internal onlyInitializing {\n        ERC1155URIStorageStorage storage $ = _getERC1155URIStorageStorage();\n        $._baseURI = \"\";\n    }\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the concatenation of the `_baseURI`\n     * and the token-specific uri if the latter is set\n     *\n     * This enables the following behaviors:\n     *\n     * - if `_tokenURIs[tokenId]` is set, then the result is the concatenation\n     *   of `_baseURI` and `_tokenURIs[tokenId]` (keep in mind that `_baseURI`\n     *   is empty per default);\n     *\n     * - if `_tokenURIs[tokenId]` is NOT set then we fallback to `super.uri()`\n     *   which in most cases will contain `ERC1155._uri`;\n     *\n     * - if `_tokenURIs[tokenId]` is NOT set, and if the parents do not have a\n     *   uri value set, then the result is empty.\n     */\n    function uri(uint256 tokenId) public view virtual override returns (string memory) {\n        ERC1155URIStorageStorage storage $ = _getERC1155URIStorageStorage();\n        string memory tokenURI = $._tokenURIs[tokenId];\n\n        // If token URI is set, concatenate base URI and tokenURI (via string.concat).\n        return bytes(tokenURI).length > 0 ? string.concat($._baseURI, tokenURI) : super.uri(tokenId);\n    }\n\n    /**\n     * @dev Sets `tokenURI` as the tokenURI of `tokenId`.\n     */\n    function _setURI(uint256 tokenId, string memory tokenURI) internal virtual {\n        ERC1155URIStorageStorage storage $ = _getERC1155URIStorageStorage();\n        $._tokenURIs[tokenId] = tokenURI;\n        emit URI(uri(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Sets `baseURI` as the `_baseURI` for all tokens\n     */\n    function _setBaseURI(string memory baseURI) internal virtual {\n        ERC1155URIStorageStorage storage $ = _getERC1155URIStorageStorage();\n        $._baseURI = baseURI;\n    }\n}\n"
      },
      {
        "name": "ERC20Upgradeable",
        "filePath": "token/ERC20/ERC20Upgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ContextUpgradeable",
          "IERC20",
          "IERC20Metadata",
          "IERC20Errors"
        ],
        "implements": [],
        "category": "token/ERC20",
        "externalFunctions": [
          {
            "name": "name",
            "signature": "name()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }",
            "startLine": 70
          },
          {
            "name": "symbol",
            "signature": "symbol()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }",
            "startLine": 79
          },
          {
            "name": "decimals",
            "signature": "decimals()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function decimals() public view virtual returns (uint8) {\n        return 18;\n    }",
            "startLine": 97
          },
          {
            "name": "totalSupply",
            "signature": "totalSupply()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }",
            "startLine": 102
          },
          {
            "name": "balanceOf",
            "signature": "balanceOf(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }",
            "startLine": 108
          },
          {
            "name": "transfer",
            "signature": "transfer(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_transfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }",
            "startLine": 121
          },
          {
            "name": "allowance",
            "signature": "allowance(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }",
            "startLine": 128
          },
          {
            "name": "approve",
            "signature": "approve(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_approve",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }",
            "startLine": 143
          },
          {
            "name": "transferFrom",
            "signature": "transferFrom(address,address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_spendAllowance",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_transfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }",
            "startLine": 165
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC20Storage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC20Storage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }",
            "startLine": 46
          },
          {
            "name": "__ERC20_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name_",
                "type": "string"
              },
              {
                "name": "symbol_",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }",
            "startLine": 57
          },
          {
            "name": "__ERC20_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name_",
                "type": "string"
              },
              {
                "name": "symbol_",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }",
            "startLine": 61
          },
          {
            "name": "_transfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }",
            "startLine": 182
          },
          {
            "name": "_update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
            "startLine": 199
          },
          {
            "name": "_mint",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }",
            "startLine": 238
          },
          {
            "name": "_burn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }",
            "startLine": 253
          },
          {
            "name": "_approve",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_approve",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }",
            "startLine": 275
          },
          {
            "name": "_approve",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "emitEvent",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        $._allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }",
            "startLine": 297
          },
          {
            "name": "_spendAllowance",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "allowance",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_approve",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }",
            "startLine": 319
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "ERC20Storage",
            "members": [
              {
                "name": "_balances",
                "type": "mapping(address => uint256)"
              },
              {
                "name": "_allowances",
                "type": "mapping(address => mapping(address => uint256))"
              },
              {
                "name": "_totalSupply",
                "type": "uint256"
              },
              {
                "name": "_name",
                "type": "string"
              },
              {
                "name": "_symbol",
                "type": "string"
              }
            ],
            "startLine": 32
          }
        ],
        "stateVariables": [
          {
            "name": "ERC20StorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 44
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/token/ERC20/IERC20.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../../utils/ContextUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/interfaces/draft-IERC6093.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC20Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\n    struct ERC20Storage {\n        mapping(address account => uint256) _balances;\n\n        mapping(address account => mapping(address spender => uint256)) _allowances;\n\n        uint256 _totalSupply;\n\n        string _name;\n        string _symbol;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\n\n    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation sets the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the `transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        $._allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
      },
      {
        "name": "ERC1363Upgradeable",
        "filePath": "token/ERC20/extensions/ERC1363Upgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC20Upgradeable",
          "ERC165Upgradeable",
          "IERC1363"
        ],
        "implements": [],
        "category": "token/ERC20",
        "externalFunctions": [
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "supportsInterface",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IERC1363).interfaceId || super.supportsInterface(interfaceId);\n    }",
            "startLine": 50
          },
          {
            "name": "transferAndCall",
            "signature": "transferAndCall(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "transferAndCall",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function transferAndCall(address to, uint256 value) public returns (bool) {\n        return transferAndCall(to, value, \"\");\n    }",
            "startLine": 66
          },
          {
            "name": "transferAndCall",
            "signature": "transferAndCall(address,uint256,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "transfer",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "ERC1363Utils.checkOnERC1363TransferReceived",
                "type": "library",
                "argCount": 5
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function transferAndCall(address to, uint256 value, bytes memory data) public virtual returns (bool) {\n        if (!transfer(to, value)) {\n            revert ERC1363TransferFailed(to, value);\n        }\n        ERC1363Utils.checkOnERC1363TransferReceived(_msgSender(), _msgSender(), to, value, data);\n        return true;\n    }",
            "startLine": 74
          },
          {
            "name": "transferFromAndCall",
            "signature": "transferFromAndCall(address,address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "transferFromAndCall",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function transferFromAndCall(address from, address to, uint256 value) public returns (bool) {\n        return transferFromAndCall(from, to, value, \"\");\n    }",
            "startLine": 94
          },
          {
            "name": "transferFromAndCall",
            "signature": "transferFromAndCall(address,address,uint256,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "transferFrom",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "ERC1363Utils.checkOnERC1363TransferReceived",
                "type": "library",
                "argCount": 5
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function transferFromAndCall(\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) public virtual returns (bool) {\n        if (!transferFrom(from, to, value)) {\n            revert ERC1363TransferFromFailed(from, to, value);\n        }\n        ERC1363Utils.checkOnERC1363TransferReceived(_msgSender(), from, to, value, data);\n        return true;\n    }",
            "startLine": 102
          },
          {
            "name": "approveAndCall",
            "signature": "approveAndCall(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "approveAndCall",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function approveAndCall(address spender, uint256 value) public returns (bool) {\n        return approveAndCall(spender, value, \"\");\n    }",
            "startLine": 127
          },
          {
            "name": "approveAndCall",
            "signature": "approveAndCall(address,uint256,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "approve",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "ERC1363Utils.checkOnERC1363ApprovalReceived",
                "type": "library",
                "argCount": 4
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function approveAndCall(address spender, uint256 value, bytes memory data) public virtual returns (bool) {\n        if (!approve(spender, value)) {\n            revert ERC1363ApproveFailed(spender, value);\n        }\n        ERC1363Utils.checkOnERC1363ApprovalReceived(_msgSender(), spender, value, data);\n        return true;\n    }",
            "startLine": 135
          }
        ],
        "internalFunctions": [
          {
            "name": "__ERC1363_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC1363_init() internal onlyInitializing {\n    }",
            "startLine": 44
          },
          {
            "name": "__ERC1363_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC1363_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 47
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ERC1363TransferFailed",
            "parameters": [
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "startLine": 27
          },
          {
            "name": "ERC1363TransferFromFailed",
            "parameters": [
              {
                "name": "sender",
                "type": "address"
              },
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "startLine": 35
          },
          {
            "name": "ERC1363ApproveFailed",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "startLine": 42
          }
        ],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC20Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/introspection/IERC165.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../../../utils/introspection/ERC165Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/interfaces/IERC1363.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/token/ERC20/utils/ERC1363Utils.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/ERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../../../utils/introspection/ERC165Upgradeable.sol\";\nimport {IERC1363} from \"@openzeppelin/contracts/interfaces/IERC1363.sol\";\nimport {ERC1363Utils} from \"@openzeppelin/contracts/token/ERC20/utils/ERC1363Utils.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @title ERC1363\n * @dev Extension of {ERC20} tokens that adds support for code execution after transfers and approvals\n * on recipient contracts. Calls after transfers are enabled through the {ERC1363-transferAndCall} and\n * {ERC1363-transferFromAndCall} methods while calls after approvals can be made with {ERC1363-approveAndCall}\n *\n * _Available since v5.1._\n */\nabstract contract ERC1363Upgradeable is Initializable, ERC20Upgradeable, ERC165Upgradeable, IERC1363 {\n    /**\n     * @dev Indicates a failure within the {transfer} part of a transferAndCall operation.\n     * @param receiver Address to which tokens are being transferred.\n     * @param value Amount of tokens to be transferred.\n     */\n    error ERC1363TransferFailed(address receiver, uint256 value);\n\n    /**\n     * @dev Indicates a failure within the {transferFrom} part of a transferFromAndCall operation.\n     * @param sender Address from which to send tokens.\n     * @param receiver Address to which tokens are being transferred.\n     * @param value Amount of tokens to be transferred.\n     */\n    error ERC1363TransferFromFailed(address sender, address receiver, uint256 value);\n\n    /**\n     * @dev Indicates a failure within the {approve} part of a approveAndCall operation.\n     * @param spender Address which will spend the funds.\n     * @param value Amount of tokens to be spent.\n     */\n    error ERC1363ApproveFailed(address spender, uint256 value);\n\n    function __ERC1363_init() internal onlyInitializing {\n    }\n\n    function __ERC1363_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IERC1363).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`. Returns a flag that indicates\n     * if the call succeeded.\n     *\n     * Requirements:\n     *\n     * - The target has code (i.e. is a contract).\n     * - The target `to` must implement the {IERC1363Receiver} interface.\n     * - The target must return the {IERC1363Receiver-onTransferReceived} selector to accept the transfer.\n     * - The internal {transfer} must succeed (returned `true`).\n     */\n    function transferAndCall(address to, uint256 value) public returns (bool) {\n        return transferAndCall(to, value, \"\");\n    }\n\n    /**\n     * @dev Variant of {transferAndCall} that accepts an additional `data` parameter with\n     * no specified format.\n     */\n    function transferAndCall(address to, uint256 value, bytes memory data) public virtual returns (bool) {\n        if (!transfer(to, value)) {\n            revert ERC1363TransferFailed(to, value);\n        }\n        ERC1363Utils.checkOnERC1363TransferReceived(_msgSender(), _msgSender(), to, value, data);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`. Returns a flag that indicates\n     * if the call succeeded.\n     *\n     * Requirements:\n     *\n     * - The target has code (i.e. is a contract).\n     * - The target `to` must implement the {IERC1363Receiver} interface.\n     * - The target must return the {IERC1363Receiver-onTransferReceived} selector to accept the transfer.\n     * - The internal {transferFrom} must succeed (returned `true`).\n     */\n    function transferFromAndCall(address from, address to, uint256 value) public returns (bool) {\n        return transferFromAndCall(from, to, value, \"\");\n    }\n\n    /**\n     * @dev Variant of {transferFromAndCall} that accepts an additional `data` parameter with\n     * no specified format.\n     */\n    function transferFromAndCall(\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) public virtual returns (bool) {\n        if (!transferFrom(from, to, value)) {\n            revert ERC1363TransferFromFailed(from, to, value);\n        }\n        ERC1363Utils.checkOnERC1363TransferReceived(_msgSender(), from, to, value, data);\n        return true;\n    }\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * Returns a flag that indicates if the call succeeded.\n     *\n     * Requirements:\n     *\n     * - The target has code (i.e. is a contract).\n     * - The target `spender` must implement the {IERC1363Spender} interface.\n     * - The target must return the {IERC1363Spender-onApprovalReceived} selector to accept the approval.\n     * - The internal {approve} must succeed (returned `true`).\n     */\n    function approveAndCall(address spender, uint256 value) public returns (bool) {\n        return approveAndCall(spender, value, \"\");\n    }\n\n    /**\n     * @dev Variant of {approveAndCall} that accepts an additional `data` parameter with\n     * no specified format.\n     */\n    function approveAndCall(address spender, uint256 value, bytes memory data) public virtual returns (bool) {\n        if (!approve(spender, value)) {\n            revert ERC1363ApproveFailed(spender, value);\n        }\n        ERC1363Utils.checkOnERC1363ApprovalReceived(_msgSender(), spender, value, data);\n        return true;\n    }\n}\n"
      },
      {
        "name": "ERC20BurnableUpgradeable",
        "filePath": "token/ERC20/extensions/ERC20BurnableUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ContextUpgradeable",
          "ERC20Upgradeable"
        ],
        "implements": [],
        "category": "token/ERC20",
        "externalFunctions": [
          {
            "name": "burn",
            "signature": "burn(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_burn",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function burn(uint256 value) public virtual {\n        _burn(_msgSender(), value);\n    }",
            "startLine": 26
          },
          {
            "name": "burnFrom",
            "signature": "burnFrom(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_spendAllowance",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_burn",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function burnFrom(address account, uint256 value) public virtual {\n        _spendAllowance(account, _msgSender(), value);\n        _burn(account, value);\n    }",
            "startLine": 41
          }
        ],
        "internalFunctions": [
          {
            "name": "__ERC20Burnable_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20Burnable_init() internal onlyInitializing {\n    }",
            "startLine": 16
          },
          {
            "name": "__ERC20Burnable_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 19
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC20Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../../../utils/ContextUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {ContextUpgradeable} from \"../../../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys a `value` amount of tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 value) public virtual {\n        _burn(_msgSender(), value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\n     * the caller's allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `value`.\n     */\n    function burnFrom(address account, uint256 value) public virtual {\n        _spendAllowance(account, _msgSender(), value);\n        _burn(account, value);\n    }\n}\n"
      },
      {
        "name": "ERC20CappedUpgradeable",
        "filePath": "token/ERC20/extensions/ERC20CappedUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC20Upgradeable"
        ],
        "implements": [],
        "category": "token/ERC20",
        "externalFunctions": [
          {
            "name": "cap",
            "signature": "cap()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20CappedStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function cap() public view virtual returns (uint256) {\n        ERC20CappedStorage storage $ = _getERC20CappedStorage();\n        return $._cap;\n    }",
            "startLine": 56
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC20CappedStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC20CappedStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getERC20CappedStorage() private pure returns (ERC20CappedStorage storage $) {\n        assembly {\n            $.slot := ERC20CappedStorageLocation\n        }\n    }",
            "startLine": 21
          },
          {
            "name": "__ERC20Capped_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "cap_",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20Capped_init(uint256 cap_) internal onlyInitializing {\n        __ERC20Capped_init_unchained(cap_);\n    }",
            "startLine": 41
          },
          {
            "name": "__ERC20Capped_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "cap_",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20CappedStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __ERC20Capped_init_unchained(uint256 cap_) internal onlyInitializing {\n        ERC20CappedStorage storage $ = _getERC20CappedStorage();\n        if (cap_ == 0) {\n            revert ERC20InvalidCap(0);\n        }\n        $._cap = cap_;\n    }",
            "startLine": 45
          },
          {
            "name": "_update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "super",
                "argCount": 3
              },
              {
                "target": "cap",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "totalSupply",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _update(address from, address to, uint256 value) internal virtual override {\n        super._update(from, to, value);\n\n        if (from == address(0)) {\n            uint256 maxSupply = cap();\n            uint256 supply = totalSupply();\n            if (supply > maxSupply) {\n                revert ERC20ExceededCap(supply, maxSupply);\n            }\n        }\n    }",
            "startLine": 62
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ERC20ExceededCap",
            "parameters": [
              {
                "name": "increasedSupply",
                "type": "uint256"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "startLine": 30
          },
          {
            "name": "ERC20InvalidCap",
            "parameters": [
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "startLine": 35
          }
        ],
        "structs": [
          {
            "name": "ERC20CappedStorage",
            "members": [
              {
                "name": "_cap",
                "type": "uint256"
              }
            ],
            "startLine": 14
          }
        ],
        "stateVariables": [
          {
            "name": "ERC20CappedStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 19
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC20Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/ERC20Capped.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that adds a cap to the supply of tokens.\n */\nabstract contract ERC20CappedUpgradeable is Initializable, ERC20Upgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20Capped\n    struct ERC20CappedStorage {\n        uint256 _cap;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20Capped\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20CappedStorageLocation = 0x0f070392f17d5f958cc1ac31867dabecfc5c9758b4a419a200803226d7155d00;\n\n    function _getERC20CappedStorage() private pure returns (ERC20CappedStorage storage $) {\n        assembly {\n            $.slot := ERC20CappedStorageLocation\n        }\n    }\n\n    /**\n     * @dev Total supply cap has been exceeded.\n     */\n    error ERC20ExceededCap(uint256 increasedSupply, uint256 cap);\n\n    /**\n     * @dev The supplied cap is not a valid cap.\n     */\n    error ERC20InvalidCap(uint256 cap);\n\n    /**\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\n     * set once during construction.\n     */\n    function __ERC20Capped_init(uint256 cap_) internal onlyInitializing {\n        __ERC20Capped_init_unchained(cap_);\n    }\n\n    function __ERC20Capped_init_unchained(uint256 cap_) internal onlyInitializing {\n        ERC20CappedStorage storage $ = _getERC20CappedStorage();\n        if (cap_ == 0) {\n            revert ERC20InvalidCap(0);\n        }\n        $._cap = cap_;\n    }\n\n    /**\n     * @dev Returns the cap on the token's total supply.\n     */\n    function cap() public view virtual returns (uint256) {\n        ERC20CappedStorage storage $ = _getERC20CappedStorage();\n        return $._cap;\n    }\n\n    /// @inheritdoc ERC20Upgradeable\n    function _update(address from, address to, uint256 value) internal virtual override {\n        super._update(from, to, value);\n\n        if (from == address(0)) {\n            uint256 maxSupply = cap();\n            uint256 supply = totalSupply();\n            if (supply > maxSupply) {\n                revert ERC20ExceededCap(supply, maxSupply);\n            }\n        }\n    }\n}\n"
      },
      {
        "name": "ERC20CrosschainUpgradeable",
        "filePath": "token/ERC20/extensions/ERC20CrosschainUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC20Upgradeable",
          "BridgeERC20CoreUpgradeable"
        ],
        "implements": [],
        "category": "token/ERC20",
        "externalFunctions": [
          {
            "name": "crosschainTransferFrom",
            "signature": "crosschainTransferFrom(address,bytes,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "bytes"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_spendAllowance",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_crosschainTransfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function crosschainTransferFrom(address from, bytes memory to, uint256 amount) public virtual returns (bytes32) {\n        _spendAllowance(from, _msgSender(), amount);\n        return _crosschainTransfer(from, to, amount);\n    }",
            "startLine": 30
          }
        ],
        "internalFunctions": [
          {
            "name": "__ERC20Crosschain_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20Crosschain_init() internal onlyInitializing {\n    }",
            "startLine": 24
          },
          {
            "name": "__ERC20Crosschain_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20Crosschain_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 27
          },
          {
            "name": "_onSend",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_burn",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _onSend(address from, uint256 amount) internal virtual override {\n        _burn(from, amount);\n    }",
            "startLine": 36
          },
          {
            "name": "_onReceive",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_mint",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _onReceive(address to, uint256 amount) internal virtual override {\n        _mint(to, amount);\n    }",
            "startLine": 41
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC20Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../../../crosschain/bridges/BridgeERC20CoreUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.26;\n\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {BridgeERC20CoreUpgradeable} from \"../../../crosschain/bridges/BridgeERC20CoreUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that makes it natively cross-chain using the ERC-7786 based {BridgeERC20Core}.\n *\n * This extension makes the token compatible with counterparts on other chains, which can be:\n * * {ERC20Crosschain} instances,\n * * {ERC20} instances that are bridged using {BridgeERC20},\n * * {ERC20Bridgeable} instances that are bridged using {BridgeERC7802}.\n *\n * It is mostly equivalent to inheriting from both {ERC20Bridgeable} and {BridgeERC7802}, and configuring them such\n * that:\n * * `token` (on the {BridgeERC7802} side) is `address(this)`,\n * * `_checkTokenBridge` (on the {ERC20Bridgeable} side) is implemented such that it only accepts self-calls.\n */\n// slither-disable-next-line locked-ether\nabstract contract ERC20CrosschainUpgradeable is Initializable, ERC20Upgradeable, BridgeERC20CoreUpgradeable {\n    function __ERC20Crosschain_init() internal onlyInitializing {\n    }\n\n    function __ERC20Crosschain_init_unchained() internal onlyInitializing {\n    }\n    /// @dev Variant of {crosschainTransfer} that allows an authorized account (using ERC20 allowance) to operate on `from`'s assets.\n    function crosschainTransferFrom(address from, bytes memory to, uint256 amount) public virtual returns (bytes32) {\n        _spendAllowance(from, _msgSender(), amount);\n        return _crosschainTransfer(from, to, amount);\n    }\n\n    /// @dev \"Locking\" tokens is achieved through burning\n    function _onSend(address from, uint256 amount) internal virtual override {\n        _burn(from, amount);\n    }\n\n    /// @dev \"Unlocking\" tokens is achieved through minting\n    function _onReceive(address to, uint256 amount) internal virtual override {\n        _mint(to, amount);\n    }\n}\n"
      },
      {
        "name": "ERC20FlashMintUpgradeable",
        "filePath": "token/ERC20/extensions/ERC20FlashMintUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC20Upgradeable",
          "IERC3156FlashLender"
        ],
        "implements": [],
        "category": "token/ERC20",
        "externalFunctions": [
          {
            "name": "maxFlashLoan",
            "signature": "maxFlashLoan(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "totalSupply",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function maxFlashLoan(address token) public view virtual returns (uint256) {\n        return token == address(this) ? type(uint256).max - totalSupply() : 0;\n    }",
            "startLine": 55
          },
          {
            "name": "flashFee",
            "signature": "flashFee(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_flashFee",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function flashFee(address token, uint256 value) public view virtual returns (uint256) {\n        if (token != address(this)) {\n            revert ERC3156UnsupportedToken(token);\n        }\n        return _flashFee(token, value);\n    }",
            "startLine": 67
          },
          {
            "name": "flashLoan",
            "signature": "flashLoan(IERC3156FlashBorrower,address,uint256,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "receiver",
                "type": "IERC3156FlashBorrower"
              },
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "maxFlashLoan",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "flashFee",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_mint",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "onFlashLoan",
                "type": "external",
                "targetType": "receiver",
                "argCount": 5
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_flashFeeReceiver",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_spendAllowance",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_burn",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_transfer",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 value,\n        bytes calldata data\n    ) public virtual returns (bool) {\n        uint256 maxLoan = maxFlashLoan(token);\n        if (value > maxLoan) {\n            revert ERC3156ExceededMaxLoan(maxLoan);\n        }\n        uint256 fee = flashFee(token, value);\n        _mint(address(receiver), value);\n        if (receiver.onFlashLoan(_msgSender(), token, value, fee, data) != RETURN_VALUE) {\n            revert ERC3156InvalidReceiver(address(receiver));\n        }\n        address flashFeeReceiver = _flashFeeReceiver();\n        _spendAllowance(address(receiver), address(this), value + fee);\n        if (fee == 0 || flashFeeReceiver == address(0)) {\n            _burn(address(receiver), value + fee);\n        } else {\n            _burn(address(receiver), value);\n            _transfer(address(receiver), flashFeeReceiver, fee);\n        }\n        return true;\n    }",
            "startLine": 111
          }
        ],
        "internalFunctions": [
          {
            "name": "__ERC20FlashMint_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20FlashMint_init() internal onlyInitializing {\n    }",
            "startLine": 40
          },
          {
            "name": "__ERC20FlashMint_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20FlashMint_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 43
          },
          {
            "name": "_flashFee",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _flashFee(address /*token*/, uint256 /*value*/) internal view virtual returns (uint256) {\n        return 0;\n    }",
            "startLine": 80
          },
          {
            "name": "_flashFeeReceiver",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _flashFeeReceiver() internal view virtual returns (address) {\n        return address(0);\n    }",
            "startLine": 90
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ERC3156UnsupportedToken",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              }
            ],
            "startLine": 28
          },
          {
            "name": "ERC3156ExceededMaxLoan",
            "parameters": [
              {
                "name": "maxLoan",
                "type": "uint256"
              }
            ],
            "startLine": 33
          },
          {
            "name": "ERC3156InvalidReceiver",
            "parameters": [
              {
                "name": "receiver",
                "type": "address"
              }
            ],
            "startLine": 38
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "RETURN_VALUE",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 23
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../ERC20Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/ERC20FlashMint.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC3156FlashBorrower} from \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC-3156 Flash loans extension, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * Adds the {flashLoan} method, which provides flash loan support at the token\n * level. By default there is no fee, but this can be changed by overriding {flashFee}.\n *\n * NOTE: When this extension is used along with the {ERC20Capped} or {ERC20Votes} extensions,\n * {maxFlashLoan} will not correctly reflect the maximum that can be flash minted. We recommend\n * overriding {maxFlashLoan} so that it correctly reflects the supply cap.\n */\nabstract contract ERC20FlashMintUpgradeable is Initializable, ERC20Upgradeable, IERC3156FlashLender {\n    bytes32 private constant RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /**\n     * @dev The loan token is not valid.\n     */\n    error ERC3156UnsupportedToken(address token);\n\n    /**\n     * @dev The requested loan exceeds the max loan value for `token`.\n     */\n    error ERC3156ExceededMaxLoan(uint256 maxLoan);\n\n    /**\n     * @dev The receiver of a flashloan is not a valid {IERC3156FlashBorrower-onFlashLoan} implementer.\n     */\n    error ERC3156InvalidReceiver(address receiver);\n\n    function __ERC20FlashMint_init() internal onlyInitializing {\n    }\n\n    function __ERC20FlashMint_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the maximum amount of tokens available for loan.\n     *\n     * NOTE: This function will not automatically detect any supply cap\n     * added by other extensions, such as {ERC20Capped}. If necessary,\n     * override this function to take a supply cap into account.\n     *\n     * @param token The address of the token that is requested.\n     * @return The amount of token that can be loaned.\n     */\n    function maxFlashLoan(address token) public view virtual returns (uint256) {\n        return token == address(this) ? type(uint256).max - totalSupply() : 0;\n    }\n\n    /**\n     * @dev Returns the fee applied when doing flash loans. This function calls\n     * the {_flashFee} function which returns the fee applied when doing flash\n     * loans.\n     * @param token The token to be flash loaned.\n     * @param value The amount of tokens to be loaned.\n     * @return The fees applied to the corresponding flash loan.\n     */\n    function flashFee(address token, uint256 value) public view virtual returns (uint256) {\n        if (token != address(this)) {\n            revert ERC3156UnsupportedToken(token);\n        }\n        return _flashFee(token, value);\n    }\n\n    /**\n     * @dev Returns the fee applied when doing flash loans. By default this\n     * implementation has 0 fees. This function can be overloaded to make\n     * the flash loan mechanism deflationary.\n     * @return The fees applied to the corresponding flash loan.\n     */\n    function _flashFee(address /*token*/, uint256 /*value*/) internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Returns the receiver address of the flash fee. By default this\n     * implementation returns the address(0) which means the fee amount will be burnt.\n     * This function can be overloaded to change the fee receiver.\n     * @return The address for which the flash fee will be sent to.\n     */\n    function _flashFeeReceiver() internal view virtual returns (address) {\n        return address(0);\n    }\n\n    /**\n     * @dev Performs a flash loan. New tokens are minted and sent to the\n     * `receiver`, who is required to implement the {IERC3156FlashBorrower}\n     * interface. By the end of the flash loan, the receiver is expected to own\n     * value + fee tokens and have them approved back to the token contract itself so\n     * they can be burned.\n     * @param receiver The receiver of the flash loan. Should implement the\n     * {IERC3156FlashBorrower-onFlashLoan} interface.\n     * @param token The token to be flash loaned. Only `address(this)` is\n     * supported.\n     * @param value The amount of tokens to be loaned.\n     * @param data An arbitrary datafield that is passed to the receiver.\n     * @return `true` if the flash loan was successful.\n     */\n    // This function can reenter, but it doesn't pose a risk because it always preserves the property that the amount\n    // minted at the beginning is always recovered and burned at the end, or else the entire function will revert.\n    // slither-disable-next-line reentrancy-no-eth\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 value,\n        bytes calldata data\n    ) public virtual returns (bool) {\n        uint256 maxLoan = maxFlashLoan(token);\n        if (value > maxLoan) {\n            revert ERC3156ExceededMaxLoan(maxLoan);\n        }\n        uint256 fee = flashFee(token, value);\n        _mint(address(receiver), value);\n        if (receiver.onFlashLoan(_msgSender(), token, value, fee, data) != RETURN_VALUE) {\n            revert ERC3156InvalidReceiver(address(receiver));\n        }\n        address flashFeeReceiver = _flashFeeReceiver();\n        _spendAllowance(address(receiver), address(this), value + fee);\n        if (fee == 0 || flashFeeReceiver == address(0)) {\n            _burn(address(receiver), value + fee);\n        } else {\n            _burn(address(receiver), value);\n            _transfer(address(receiver), flashFeeReceiver, fee);\n        }\n        return true;\n    }\n}\n"
      },
      {
        "name": "ERC20PausableUpgradeable",
        "filePath": "token/ERC20/extensions/ERC20PausableUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC20Upgradeable",
          "PausableUpgradeable"
        ],
        "implements": [],
        "category": "token/ERC20",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "__ERC20Pausable_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20Pausable_init() internal onlyInitializing {\n    }",
            "startLine": 24
          },
          {
            "name": "__ERC20Pausable_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20Pausable_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 27
          },
          {
            "name": "_update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "super",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _update(address from, address to, uint256 value) internal virtual override whenNotPaused {\n        super._update(from, to, value);\n    }",
            "startLine": 36
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC20Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../../../utils/PausableUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {PausableUpgradeable} from \"../../../utils/PausableUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC-20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract pause mechanism of the contract unreachable, and thus unusable.\n */\nabstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {\n    function __ERC20Pausable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC20-_update}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _update(address from, address to, uint256 value) internal virtual override whenNotPaused {\n        super._update(from, to, value);\n    }\n}\n"
      },
      {
        "name": "ERC20PermitUpgradeable",
        "filePath": "token/ERC20/extensions/ERC20PermitUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC20Upgradeable",
          "IERC20Permit",
          "EIP712Upgradeable",
          "NoncesUpgradeable"
        ],
        "implements": [],
        "category": "token/ERC20",
        "externalFunctions": [
          {
            "name": "permit",
            "signature": "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "deadline",
                "type": "uint256"
              },
              {
                "name": "v",
                "type": "uint8"
              },
              {
                "name": "r",
                "type": "bytes32"
              },
              {
                "name": "s",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useNonce",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_hashTypedDataV4",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "ECDSA.recover",
                "type": "library",
                "argCount": 4
              },
              {
                "target": "_approve",
                "type": "internal",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }",
            "startLine": 47
          },
          {
            "name": "nonces",
            "signature": "nonces(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "nonces",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function nonces(address owner) public view virtual override(IERC20Permit, NoncesUpgradeable) returns (uint256) {\n        return super.nonces(owner);\n    }",
            "startLine": 73
          },
          {
            "name": "DOMAIN_SEPARATOR",
            "signature": "DOMAIN_SEPARATOR()",
            "selector": "",
            "visibility": "external",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_domainSeparatorV4",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }",
            "startLine": 79
          }
        ],
        "internalFunctions": [
          {
            "name": "__ERC20Permit_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }",
            "startLine": 40
          },
          {
            "name": "__ERC20Permit_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}",
            "startLine": 44
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ERC2612ExpiredSignature",
            "parameters": [
              {
                "name": "deadline",
                "type": "uint256"
              }
            ],
            "startLine": 28
          },
          {
            "name": "ERC2612InvalidSigner",
            "parameters": [
              {
                "name": "signer",
                "type": "address"
              },
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "startLine": 33
          }
        ],
        "structs": [],
        "stateVariables": [
          {
            "name": "PERMIT_TYPEHASH",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 22
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../ERC20Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/cryptography/ECDSA.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../../../utils/cryptography/EIP712Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../../../utils/NoncesUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.24;\n\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {EIP712Upgradeable} from \"../../../utils/cryptography/EIP712Upgradeable.sol\";\nimport {NoncesUpgradeable} from \"../../../utils/NoncesUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20Permit, EIP712Upgradeable, NoncesUpgradeable {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC-20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }\n\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n    /// @inheritdoc IERC20Permit\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /// @inheritdoc IERC20Permit\n    function nonces(address owner) public view virtual override(IERC20Permit, NoncesUpgradeable) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /// @inheritdoc IERC20Permit\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
      },
      {
        "name": "ERC20VotesUpgradeable",
        "filePath": "token/ERC20/extensions/ERC20VotesUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC20Upgradeable",
          "VotesUpgradeable"
        ],
        "implements": [],
        "category": "token/ERC20",
        "externalFunctions": [
          {
            "name": "numCheckpoints",
            "signature": "numCheckpoints(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint32"
              }
            ],
            "calls": [
              {
                "target": "_numCheckpoints",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function numCheckpoints(address account) public view virtual returns (uint32) {\n        return _numCheckpoints(account);\n    }",
            "startLine": 79
          },
          {
            "name": "checkpoints",
            "signature": "checkpoints(address,uint32)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "pos",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "Checkpoints.Checkpoint208"
              }
            ],
            "calls": [
              {
                "target": "_checkpoints",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoints.Checkpoint208 memory) {\n        return _checkpoints(account, pos);\n    }",
            "startLine": 86
          }
        ],
        "internalFunctions": [
          {
            "name": "__ERC20Votes_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20Votes_init() internal onlyInitializing {\n    }",
            "startLine": 30
          },
          {
            "name": "__ERC20Votes_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20Votes_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 33
          },
          {
            "name": "_maxSupply",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _maxSupply() internal view virtual returns (uint256) {\n        return type(uint208).max;\n    }",
            "startLine": 45
          },
          {
            "name": "_update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "super",
                "argCount": 3
              },
              {
                "target": "totalSupply",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_maxSupply",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_transferVotingUnits",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _update(address from, address to, uint256 value) internal virtual override {\n        super._update(from, to, value);\n        if (from == address(0)) {\n            uint256 supply = totalSupply();\n            uint256 cap = _maxSupply();\n            if (supply > cap) {\n                revert ERC20ExceededSafeSupply(supply, cap);\n            }\n        }\n        _transferVotingUnits(from, to, value);\n    }",
            "startLine": 54
          },
          {
            "name": "_getVotingUnits",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "balanceOf",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _getVotingUnits(address account) internal view virtual override returns (uint256) {\n        return balanceOf(account);\n    }",
            "startLine": 72
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ERC20ExceededSafeSupply",
            "parameters": [
              {
                "name": "increasedSupply",
                "type": "uint256"
              },
              {
                "name": "cap",
                "type": "uint256"
              }
            ],
            "startLine": 28
          }
        ],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC20Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../../../governance/utils/VotesUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/structs/Checkpoints.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.24;\n\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {VotesUpgradeable} from \"../../../governance/utils/VotesUpgradeable.sol\";\nimport {Checkpoints} from \"@openzeppelin/contracts/utils/structs/Checkpoints.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC-20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^208^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: This contract does not provide interface compatibility with Compound's COMP token.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {Votes-delegate} function directly, or by providing a signature to be used with {Votes-delegateBySig}. Voting\n * power can be queried through the public accessors {Votes-getVotes} and {Votes-getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n */\nabstract contract ERC20VotesUpgradeable is Initializable, ERC20Upgradeable, VotesUpgradeable {\n    /**\n     * @dev Total supply cap has been exceeded, introducing a risk of votes overflowing.\n     */\n    error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);\n\n    function __ERC20Votes_init() internal onlyInitializing {\n    }\n\n    function __ERC20Votes_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint208).max` (2^208^ - 1).\n     *\n     * This maximum is enforced in {_update}. It limits the total supply of the token, which is otherwise a uint256,\n     * so that checkpoints can be stored in the Trace208 structure used by {Votes}. Increasing this value will not\n     * remove the underlying limitation, and will cause {_update} to fail because of a math overflow in\n     * {Votes-_transferVotingUnits}. An override could be used to further restrict the total supply (to a lower value) if\n     * additional logic requires it. When resolving override conflicts on this function, the minimum should be\n     * returned.\n     */\n    function _maxSupply() internal view virtual returns (uint256) {\n        return type(uint208).max;\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {IVotes-DelegateVotesChanged} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual override {\n        super._update(from, to, value);\n        if (from == address(0)) {\n            uint256 supply = totalSupply();\n            uint256 cap = _maxSupply();\n            if (supply > cap) {\n                revert ERC20ExceededSafeSupply(supply, cap);\n            }\n        }\n        _transferVotingUnits(from, to, value);\n    }\n\n    /**\n     * @dev Returns the voting units of an `account`.\n     *\n     * WARNING: Overriding this function may compromise the internal vote accounting.\n     * `ERC20Votes` assumes tokens map to voting units 1:1 and this is not easy to change.\n     */\n    function _getVotingUnits(address account) internal view virtual override returns (uint256) {\n        return balanceOf(account);\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return _numCheckpoints(account);\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoints.Checkpoint208 memory) {\n        return _checkpoints(account, pos);\n    }\n}\n"
      },
      {
        "name": "ERC20WrapperUpgradeable",
        "filePath": "token/ERC20/extensions/ERC20WrapperUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC20Upgradeable"
        ],
        "implements": [],
        "category": "token/ERC20",
        "externalFunctions": [
          {
            "name": "decimals",
            "signature": "decimals()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [
              {
                "target": "_getERC20WrapperStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "decimals",
                "type": "external",
                "targetType": "ERC20Metadata",
                "argCount": 0
              },
              {
                "target": "decimals",
                "type": "super",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function decimals() public view virtual override returns (uint8) {\n        ERC20WrapperStorage storage $ = _getERC20WrapperStorage();\n        try IERC20Metadata(address($._underlying)).decimals() returns (uint8 value) {\n            return value;\n        } catch {\n            return super.decimals();\n        }\n    }",
            "startLine": 57
          },
          {
            "name": "underlying",
            "signature": "underlying()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "IERC20"
              }
            ],
            "calls": [
              {
                "target": "_getERC20WrapperStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function underlying() public view returns (IERC20) {\n        ERC20WrapperStorage storage $ = _getERC20WrapperStorage();\n        return $._underlying;\n    }",
            "startLine": 69
          },
          {
            "name": "depositFor",
            "signature": "depositFor(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getERC20WrapperStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "SafeERC20.safeTransferFrom",
                "type": "library",
                "argCount": 4
              },
              {
                "target": "_mint",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function depositFor(address account, uint256 value) public virtual returns (bool) {\n        ERC20WrapperStorage storage $ = _getERC20WrapperStorage();\n        address sender = _msgSender();\n        if (sender == address(this)) {\n            revert ERC20InvalidSender(address(this));\n        }\n        if (account == address(this)) {\n            revert ERC20InvalidReceiver(account);\n        }\n        SafeERC20.safeTransferFrom($._underlying, sender, address(this), value);\n        _mint(account, value);\n        return true;\n    }",
            "startLine": 77
          },
          {
            "name": "withdrawTo",
            "signature": "withdrawTo(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getERC20WrapperStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_burn",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "SafeERC20.safeTransfer",
                "type": "library",
                "argCount": 3
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function withdrawTo(address account, uint256 value) public virtual returns (bool) {\n        ERC20WrapperStorage storage $ = _getERC20WrapperStorage();\n        if (account == address(this)) {\n            revert ERC20InvalidReceiver(account);\n        }\n        _burn(_msgSender(), value);\n        SafeERC20.safeTransfer($._underlying, account, value);\n        return true;\n    }",
            "startLine": 94
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC20WrapperStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC20WrapperStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getERC20WrapperStorage() private pure returns (ERC20WrapperStorage storage $) {\n        assembly {\n            $.slot := ERC20WrapperStorageLocation\n        }\n    }",
            "startLine": 33
          },
          {
            "name": "__ERC20Wrapper_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "underlyingToken",
                "type": "IERC20"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20Wrapper_init(IERC20 underlyingToken) internal onlyInitializing {\n        __ERC20Wrapper_init_unchained(underlyingToken);\n    }",
            "startLine": 44
          },
          {
            "name": "__ERC20Wrapper_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "underlyingToken",
                "type": "IERC20"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20WrapperStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __ERC20Wrapper_init_unchained(IERC20 underlyingToken) internal onlyInitializing {\n        ERC20WrapperStorage storage $ = _getERC20WrapperStorage();\n        if (address(underlyingToken) == address(this)) {\n            revert ERC20InvalidUnderlying(address(this));\n        }\n        $._underlying = underlyingToken;\n    }",
            "startLine": 48
          },
          {
            "name": "_recover",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20WrapperStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "totalSupply",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_mint",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _recover(address account) internal virtual returns (uint256) {\n        ERC20WrapperStorage storage $ = _getERC20WrapperStorage();\n        uint256 value = $._underlying.balanceOf(address(this)) - totalSupply();\n        _mint(account, value);\n        return value;\n    }",
            "startLine": 108
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ERC20InvalidUnderlying",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              }
            ],
            "startLine": 42
          }
        ],
        "structs": [
          {
            "name": "ERC20WrapperStorage",
            "members": [
              {
                "name": "_underlying",
                "type": "IERC20"
              }
            ],
            "startLine": 26
          }
        ],
        "stateVariables": [
          {
            "name": "ERC20WrapperStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 31
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/token/ERC20/IERC20.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../ERC20Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/ERC20Wrapper.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of the ERC-20 token contract to support token wrapping.\n *\n * Users can deposit and withdraw \"underlying tokens\" and receive a matching number of \"wrapped tokens\". This is useful\n * in conjunction with other modules. For example, combining this wrapping mechanism with {ERC20Votes} will allow the\n * wrapping of an existing \"basic\" ERC-20 into a governance token.\n *\n * WARNING: Any mechanism in which the underlying token changes the {balanceOf} of an account without an explicit transfer\n * may desynchronize this contract's supply and its underlying balance. Please exercise caution when wrapping tokens that\n * may undercollateralize the wrapper (i.e. wrapper's total supply is higher than its underlying balance). See {_recover}\n * for recovering value accrued to the wrapper.\n */\nabstract contract ERC20WrapperUpgradeable is Initializable, ERC20Upgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20Wrapper\n    struct ERC20WrapperStorage {\n        IERC20 _underlying;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20Wrapper\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20WrapperStorageLocation = 0x3b5a617e0d4c238430871a64fe18212794b0c8d05a4eac064a8c9039fb5e0700;\n\n    function _getERC20WrapperStorage() private pure returns (ERC20WrapperStorage storage $) {\n        assembly {\n            $.slot := ERC20WrapperStorageLocation\n        }\n    }\n\n    /**\n     * @dev The underlying token couldn't be wrapped.\n     */\n    error ERC20InvalidUnderlying(address token);\n\n    function __ERC20Wrapper_init(IERC20 underlyingToken) internal onlyInitializing {\n        __ERC20Wrapper_init_unchained(underlyingToken);\n    }\n\n    function __ERC20Wrapper_init_unchained(IERC20 underlyingToken) internal onlyInitializing {\n        ERC20WrapperStorage storage $ = _getERC20WrapperStorage();\n        if (address(underlyingToken) == address(this)) {\n            revert ERC20InvalidUnderlying(address(this));\n        }\n        $._underlying = underlyingToken;\n    }\n\n    /// @inheritdoc IERC20Metadata\n    function decimals() public view virtual override returns (uint8) {\n        ERC20WrapperStorage storage $ = _getERC20WrapperStorage();\n        try IERC20Metadata(address($._underlying)).decimals() returns (uint8 value) {\n            return value;\n        } catch {\n            return super.decimals();\n        }\n    }\n\n    /**\n     * @dev Returns the address of the underlying ERC-20 token that is being wrapped.\n     */\n    function underlying() public view returns (IERC20) {\n        ERC20WrapperStorage storage $ = _getERC20WrapperStorage();\n        return $._underlying;\n    }\n\n    /**\n     * @dev Allow a user to deposit underlying tokens and mint the corresponding number of wrapped tokens.\n     */\n    function depositFor(address account, uint256 value) public virtual returns (bool) {\n        ERC20WrapperStorage storage $ = _getERC20WrapperStorage();\n        address sender = _msgSender();\n        if (sender == address(this)) {\n            revert ERC20InvalidSender(address(this));\n        }\n        if (account == address(this)) {\n            revert ERC20InvalidReceiver(account);\n        }\n        SafeERC20.safeTransferFrom($._underlying, sender, address(this), value);\n        _mint(account, value);\n        return true;\n    }\n\n    /**\n     * @dev Allow a user to burn a number of wrapped tokens and withdraw the corresponding number of underlying tokens.\n     */\n    function withdrawTo(address account, uint256 value) public virtual returns (bool) {\n        ERC20WrapperStorage storage $ = _getERC20WrapperStorage();\n        if (account == address(this)) {\n            revert ERC20InvalidReceiver(account);\n        }\n        _burn(_msgSender(), value);\n        SafeERC20.safeTransfer($._underlying, account, value);\n        return true;\n    }\n\n    /**\n     * @dev Mint wrapped token to cover any underlyingTokens that would have been transferred by mistake or acquired from\n     * rebasing mechanisms. Internal function that can be exposed with access control if desired.\n     */\n    function _recover(address account) internal virtual returns (uint256) {\n        ERC20WrapperStorage storage $ = _getERC20WrapperStorage();\n        uint256 value = $._underlying.balanceOf(address(this)) - totalSupply();\n        _mint(account, value);\n        return value;\n    }\n}\n"
      },
      {
        "name": "ERC4626Upgradeable",
        "filePath": "token/ERC20/extensions/ERC4626Upgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC20Upgradeable",
          "IERC4626"
        ],
        "implements": [],
        "category": "token/ERC20",
        "externalFunctions": [
          {
            "name": "decimals",
            "signature": "decimals()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [
              {
                "target": "_getERC4626Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_decimalsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function decimals() public view virtual override(IERC20Metadata, ERC20Upgradeable) returns (uint8) {\n        ERC4626Storage storage $ = _getERC4626Storage();\n        return $._underlyingDecimals + _decimalsOffset();\n    }",
            "startLine": 149
          },
          {
            "name": "asset",
            "signature": "asset()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getERC4626Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function asset() public view virtual returns (address) {\n        ERC4626Storage storage $ = _getERC4626Storage();\n        return address($._asset);\n    }",
            "startLine": 155
          },
          {
            "name": "totalAssets",
            "signature": "totalAssets()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "balanceOf",
                "type": "external",
                "targetType": "ERC20",
                "argCount": 1
              },
              {
                "target": "asset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function totalAssets() public view virtual returns (uint256) {\n        return IERC20(asset()).balanceOf(address(this));\n    }",
            "startLine": 161
          },
          {
            "name": "convertToShares",
            "signature": "convertToShares(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_convertToShares",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }",
            "startLine": 166
          },
          {
            "name": "convertToAssets",
            "signature": "convertToAssets(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_convertToAssets",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }",
            "startLine": 171
          },
          {
            "name": "maxDeposit",
            "signature": "maxDeposit(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }",
            "startLine": 176
          },
          {
            "name": "maxMint",
            "signature": "maxMint(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }",
            "startLine": 181
          },
          {
            "name": "maxWithdraw",
            "signature": "maxWithdraw(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "previewRedeem",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "maxRedeem",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return previewRedeem(maxRedeem(owner));\n    }",
            "startLine": 186
          },
          {
            "name": "maxRedeem",
            "signature": "maxRedeem(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "balanceOf",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf(owner);\n    }",
            "startLine": 191
          },
          {
            "name": "previewDeposit",
            "signature": "previewDeposit(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_convertToShares",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }",
            "startLine": 196
          },
          {
            "name": "previewMint",
            "signature": "previewMint(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_convertToAssets",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Ceil);\n    }",
            "startLine": 201
          },
          {
            "name": "previewWithdraw",
            "signature": "previewWithdraw(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_convertToShares",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Ceil);\n    }",
            "startLine": 206
          },
          {
            "name": "previewRedeem",
            "signature": "previewRedeem(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_convertToAssets",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }",
            "startLine": 211
          },
          {
            "name": "deposit",
            "signature": "deposit(uint256,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "receiver",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "maxDeposit",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "previewDeposit",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_deposit",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function deposit(uint256 assets, address receiver) public virtual returns (uint256) {\n        uint256 maxAssets = maxDeposit(receiver);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);\n        }\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }",
            "startLine": 216
          },
          {
            "name": "mint",
            "signature": "mint(uint256,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "shares",
                "type": "uint256"
              },
              {
                "name": "receiver",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "maxMint",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "previewMint",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_deposit",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function mint(uint256 shares, address receiver) public virtual returns (uint256) {\n        uint256 maxShares = maxMint(receiver);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxMint(receiver, shares, maxShares);\n        }\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }",
            "startLine": 229
          },
          {
            "name": "withdraw",
            "signature": "withdraw(uint256,address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "maxWithdraw",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "previewWithdraw",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_withdraw",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }",
            "startLine": 242
          },
          {
            "name": "redeem",
            "signature": "redeem(uint256,address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "shares",
                "type": "uint256"
              },
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "maxRedeem",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "previewRedeem",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_withdraw",
                "type": "internal",
                "argCount": 5
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }",
            "startLine": 255
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC4626Storage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC4626Storage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getERC4626Storage() private pure returns (ERC4626Storage storage $) {\n        assembly {\n            $.slot := ERC4626StorageLocation\n        }\n    }",
            "startLine": 85
          },
          {
            "name": "__ERC4626_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "asset_",
                "type": "IERC20"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC4626_init(IERC20 asset_) internal onlyInitializing {\n        __ERC4626_init_unchained(asset_);\n    }",
            "startLine": 114
          },
          {
            "name": "__ERC4626_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "asset_",
                "type": "IERC20"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC4626Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_tryGetAssetDecimals",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __ERC4626_init_unchained(IERC20 asset_) internal onlyInitializing {\n        ERC4626Storage storage $ = _getERC4626Storage();\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        $._underlyingDecimals = success ? assetDecimals : 18;\n        $._asset = asset_;\n    }",
            "startLine": 118
          },
          {
            "name": "_tryGetAssetDecimals",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "asset_",
                "type": "IERC20"
              }
            ],
            "returnValues": [
              {
                "name": "ok",
                "type": "bool"
              },
              {
                "name": "assetDecimals",
                "type": "uint8"
              }
            ],
            "calls": [
              {
                "target": "Memory.getFreeMemoryPointer",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "LowLevelCall.staticcallReturn64Bytes",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "Memory.setFreeMemoryPointer",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "LowLevelCall.returnDataSize",
                "type": "library",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool ok, uint8 assetDecimals) {\n        Memory.Pointer ptr = Memory.getFreeMemoryPointer();\n        (bool success, bytes32 returnedDecimals, ) = LowLevelCall.staticcallReturn64Bytes(\n            address(asset_),\n            abi.encodeCall(IERC20Metadata.decimals, ())\n        );\n        Memory.setFreeMemoryPointer(ptr);\n\n        return\n            (success && LowLevelCall.returnDataSize() >= 32 && uint256(returnedDecimals) <= type(uint8).max)\n                ? (true, uint8(uint256(returnedDecimals)))\n                : (false, 0);\n    }",
            "startLine": 128
          },
          {
            "name": "_convertToShares",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "rounding",
                "type": "Math.Rounding"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "Math.mulDiv",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "totalSupply",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_decimalsOffset",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "totalAssets",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);\n    }",
            "startLine": 270
          },
          {
            "name": "_convertToAssets",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "shares",
                "type": "uint256"
              },
              {
                "name": "rounding",
                "type": "Math.Rounding"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "Math.mulDiv",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "totalAssets",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "totalSupply",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_decimalsOffset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);\n    }",
            "startLine": 277
          },
          {
            "name": "_deposit",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "caller",
                "type": "address"
              },
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferIn",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_mint",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {\n        // If asset() is ERC-777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        _transferIn(caller, assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }",
            "startLine": 284
          },
          {
            "name": "_withdraw",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "caller",
                "type": "address"
              },
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "shares",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_spendAllowance",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_burn",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_transferOut",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If asset() is ERC-777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        _transferOut(receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }",
            "startLine": 301
          },
          {
            "name": "_transferIn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "SafeERC20.safeTransferFrom",
                "type": "library",
                "argCount": 4
              },
              {
                "target": "asset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _transferIn(address from, uint256 assets) internal virtual {\n        SafeERC20.safeTransferFrom(IERC20(asset()), from, address(this), assets);\n    }",
            "startLine": 325
          },
          {
            "name": "_transferOut",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "assets",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "SafeERC20.safeTransfer",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "asset",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOut(address to, uint256 assets) internal virtual {\n        SafeERC20.safeTransfer(IERC20(asset()), to, assets);\n    }",
            "startLine": 330
          },
          {
            "name": "_decimalsOffset",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _decimalsOffset() internal view virtual returns (uint8) {\n        return 0;\n    }",
            "startLine": 334
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ERC4626ExceededMaxDeposit",
            "parameters": [
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "max",
                "type": "uint256"
              }
            ],
            "startLine": 94
          },
          {
            "name": "ERC4626ExceededMaxMint",
            "parameters": [
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "shares",
                "type": "uint256"
              },
              {
                "name": "max",
                "type": "uint256"
              }
            ],
            "startLine": 99
          },
          {
            "name": "ERC4626ExceededMaxWithdraw",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "assets",
                "type": "uint256"
              },
              {
                "name": "max",
                "type": "uint256"
              }
            ],
            "startLine": 104
          },
          {
            "name": "ERC4626ExceededMaxRedeem",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "shares",
                "type": "uint256"
              },
              {
                "name": "max",
                "type": "uint256"
              }
            ],
            "startLine": 109
          }
        ],
        "structs": [
          {
            "name": "ERC4626Storage",
            "members": [
              {
                "name": "_asset",
                "type": "IERC20"
              },
              {
                "name": "_underlyingDecimals",
                "type": "uint8"
              }
            ],
            "startLine": 77
          }
        ],
        "stateVariables": [
          {
            "name": "ERC4626StorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 83
          }
        ],
        "usesLibraries": [
          "Math"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/token/ERC20/IERC20.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../ERC20Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/interfaces/IERC4626.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/LowLevelCall.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/Memory.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/math/Math.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.24;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {LowLevelCall} from \"@openzeppelin/contracts/utils/LowLevelCall.sol\";\nimport {Memory} from \"@openzeppelin/contracts/utils/Memory.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC-4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC-20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC-20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * [CAUTION]\n * ====\n * In empty (or nearly empty) ERC-4626 vaults, deposits are at high risk of being stolen through frontrunning\n * with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\n * attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\n * deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\n * similarly be affected by slippage. Users can protect against this attack as well as unexpected slippage in general by\n * verifying the amount received is as expected, using a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * Since v4.9, this implementation introduces configurable virtual assets and shares to help developers mitigate that risk.\n * The `_decimalsOffset()` corresponds to an offset in the decimal representation between the underlying asset's decimals\n * and the vault decimals. This offset also determines the rate of virtual shares to virtual assets in the vault, which\n * itself determines the initial exchange rate. While not fully preventing the attack, analysis shows that the default\n * offset (0) makes it non-profitable even if an attacker is able to capture value from multiple user deposits, as a result\n * of the value being captured by the virtual shares (out of the attacker's donation) matching the attacker's expected gains.\n * With a larger offset, the attack becomes orders of magnitude more expensive than it is profitable. More details about the\n * underlying math can be found xref:ROOT:erc4626.adoc#inflation-attack[here].\n *\n * The drawback of this approach is that the virtual shares do capture (a very small) part of the value being accrued\n * to the vault. Also, if the vault experiences losses, the users try to exit the vault, the virtual shares and assets\n * will cause the first user to exit to experience reduced losses in detriment to the last users that will experience\n * bigger losses. Developers willing to revert back to the pre-v4.9 behavior just need to override the\n * `_convertToShares` and `_convertToAssets` functions.\n *\n * To learn more, check out our xref:ROOT:erc4626.adoc[ERC-4626 guide].\n * ====\n *\n * [NOTE]\n * ====\n * When overriding this contract, some elements must be considered:\n *\n * * When overriding the behavior of the deposit or withdraw mechanisms, it is recommended to override the internal\n * functions. Overriding {_deposit} automatically affects both {deposit} and {mint}. Similarly, overriding {_withdraw}\n * automatically affects both {withdraw} and {redeem}. Overall it is not recommended to override the public facing\n * functions since that could lead to inconsistent behaviors between the {deposit} and {mint} or between {withdraw} and\n * {redeem}, which is documented to have led to loss of funds.\n *\n * * Overrides to the deposit or withdraw mechanism must be reflected in the preview functions as well.\n *\n * * {maxWithdraw} depends on {maxRedeem}. Therefore, overriding {maxRedeem} only is enough. On the other hand,\n * overriding {maxWithdraw} only would have no effect on {maxRedeem}, and could create an inconsistency between the two\n * functions.\n *\n * * If {previewRedeem} is overridden to revert, {maxWithdraw} must be overridden as necessary to ensure it\n * always return successfully.\n * ====\n */\nabstract contract ERC4626Upgradeable is Initializable, ERC20Upgradeable, IERC4626 {\n    using Math for uint256;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC4626\n    struct ERC4626Storage {\n        IERC20 _asset;\n        uint8 _underlyingDecimals;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC4626\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC4626StorageLocation = 0x0773e532dfede91f04b12a73d3d2acd361424f41f76b4fb79f090161e36b4e00;\n\n    function _getERC4626Storage() private pure returns (ERC4626Storage storage $) {\n        assembly {\n            $.slot := ERC4626StorageLocation\n        }\n    }\n\n    /**\n     * @dev Attempted to deposit more assets than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxDeposit(address receiver, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to mint more shares than the max amount for `receiver`.\n     */\n    error ERC4626ExceededMaxMint(address receiver, uint256 shares, uint256 max);\n\n    /**\n     * @dev Attempted to withdraw more assets than the max amount for `owner`.\n     */\n    error ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);\n\n    /**\n     * @dev Attempted to redeem more shares than the max amount for `owner`.\n     */\n    error ERC4626ExceededMaxRedeem(address owner, uint256 shares, uint256 max);\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC-20 or ERC-777).\n     */\n    function __ERC4626_init(IERC20 asset_) internal onlyInitializing {\n        __ERC4626_init_unchained(asset_);\n    }\n\n    function __ERC4626_init_unchained(IERC20 asset_) internal onlyInitializing {\n        ERC4626Storage storage $ = _getERC4626Storage();\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        $._underlyingDecimals = success ? assetDecimals : 18;\n        $._asset = asset_;\n    }\n\n    /**\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\n     */\n    function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool ok, uint8 assetDecimals) {\n        Memory.Pointer ptr = Memory.getFreeMemoryPointer();\n        (bool success, bytes32 returnedDecimals, ) = LowLevelCall.staticcallReturn64Bytes(\n            address(asset_),\n            abi.encodeCall(IERC20Metadata.decimals, ())\n        );\n        Memory.setFreeMemoryPointer(ptr);\n\n        return\n            (success && LowLevelCall.returnDataSize() >= 32 && uint256(returnedDecimals) <= type(uint8).max)\n                ? (true, uint8(uint256(returnedDecimals)))\n                : (false, 0);\n    }\n\n    /**\n     * @dev Decimals are computed by adding the decimal offset on top of the underlying asset's decimals. This\n     * \"original\" value is cached during construction of the vault contract. If this read operation fails (e.g., the\n     * asset has not been created yet), a default of 18 is used to represent the underlying asset's decimals.\n     *\n     * See {IERC20Metadata-decimals}.\n     */\n    function decimals() public view virtual override(IERC20Metadata, ERC20Upgradeable) returns (uint8) {\n        ERC4626Storage storage $ = _getERC4626Storage();\n        return $._underlyingDecimals + _decimalsOffset();\n    }\n\n    /// @inheritdoc IERC4626\n    function asset() public view virtual returns (address) {\n        ERC4626Storage storage $ = _getERC4626Storage();\n        return address($._asset);\n    }\n\n    /// @inheritdoc IERC4626\n    function totalAssets() public view virtual returns (uint256) {\n        return IERC20(asset()).balanceOf(address(this));\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return previewRedeem(maxRedeem(owner));\n    }\n\n    /// @inheritdoc IERC4626\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Ceil);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }\n\n    /// @inheritdoc IERC4626\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256) {\n        uint256 maxAssets = maxDeposit(receiver);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);\n        }\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function mint(uint256 shares, address receiver) public virtual returns (uint256) {\n        uint256 maxShares = maxMint(receiver);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxMint(receiver, shares, maxShares);\n        }\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /// @inheritdoc IERC4626\n    function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {\n        // If asset() is ERC-777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        _transferIn(caller, assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If asset() is ERC-777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        _transferOut(receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    /// @dev Performs a transfer in of underlying assets. The default implementation uses `SafeERC20`. Used by {_deposit}.\n    function _transferIn(address from, uint256 assets) internal virtual {\n        SafeERC20.safeTransferFrom(IERC20(asset()), from, address(this), assets);\n    }\n\n    /// @dev Performs a transfer out of underlying assets. The default implementation uses `SafeERC20`. Used by {_withdraw}.\n    function _transferOut(address to, uint256 assets) internal virtual {\n        SafeERC20.safeTransfer(IERC20(asset()), to, assets);\n    }\n\n    function _decimalsOffset() internal view virtual returns (uint8) {\n        return 0;\n    }\n}\n"
      },
      {
        "name": "ERC20BridgeableUpgradeable",
        "filePath": "token/ERC20/extensions/draft-ERC20BridgeableUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC20Upgradeable",
          "ERC165Upgradeable",
          "IERC7802"
        ],
        "implements": [],
        "category": "token/ERC20",
        "externalFunctions": [
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "supportsInterface",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IERC7802).interfaceId || super.supportsInterface(interfaceId);\n    }",
            "startLine": 31
          },
          {
            "name": "crosschainMint",
            "signature": "crosschainMint(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_mint",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function crosschainMint(address to, uint256 value) public virtual override onlyTokenBridge {\n        _mint(to, value);\n        emit CrosschainMint(to, value, _msgSender());\n    }",
            "startLine": 38
          },
          {
            "name": "crosschainBurn",
            "signature": "crosschainBurn(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_burn",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function crosschainBurn(address from, uint256 value) public virtual override onlyTokenBridge {\n        _burn(from, value);\n        emit CrosschainBurn(from, value, _msgSender());\n    }",
            "startLine": 46
          }
        ],
        "internalFunctions": [
          {
            "name": "__ERC20Bridgeable_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20Bridgeable_init() internal onlyInitializing {\n    }",
            "startLine": 25
          },
          {
            "name": "__ERC20Bridgeable_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20Bridgeable_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 28
          },
          {
            "name": "_checkTokenBridge",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "caller",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _checkTokenBridge(address caller) internal virtual;",
            "startLine": 57
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC20Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../../../utils/introspection/ERC165Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/introspection/IERC165.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/interfaces/draft-IERC7802.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/draft-ERC20Bridgeable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {ERC165Upgradeable} from \"../../../utils/introspection/ERC165Upgradeable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC7802} from \"@openzeppelin/contracts/interfaces/draft-IERC7802.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC20 extension that implements the standard token interface according to\n * https://eips.ethereum.org/EIPS/eip-7802[ERC-7802].\n */\nabstract contract ERC20BridgeableUpgradeable is Initializable, ERC20Upgradeable, ERC165Upgradeable, IERC7802 {\n    /// @dev Modifier to restrict access to the token bridge.\n    modifier onlyTokenBridge() {\n        // Token bridge should never be impersonated using a relayer/forwarder. Using msg.sender is preferable to\n        // _msgSender() for security reasons.\n        _checkTokenBridge(msg.sender);\n        _;\n    }\n\n    function __ERC20Bridgeable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Bridgeable_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc ERC165Upgradeable\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IERC7802).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC7802-crosschainMint}. Emits a {IERC7802-CrosschainMint} event.\n     */\n    function crosschainMint(address to, uint256 value) public virtual override onlyTokenBridge {\n        _mint(to, value);\n        emit CrosschainMint(to, value, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC7802-crosschainBurn}. Emits a {IERC7802-CrosschainBurn} event.\n     */\n    function crosschainBurn(address from, uint256 value) public virtual override onlyTokenBridge {\n        _burn(from, value);\n        emit CrosschainBurn(from, value, _msgSender());\n    }\n\n    /**\n     * @dev Checks if the caller is a trusted token bridge. MUST revert otherwise.\n     *\n     * Developers should implement this function using an access control mechanism that allows\n     * customizing the list of allowed senders. Consider using {AccessControl} or {AccessManaged}.\n     */\n    function _checkTokenBridge(address caller) internal virtual;\n}\n"
      },
      {
        "name": "ERC20TemporaryApprovalUpgradeable",
        "filePath": "token/ERC20/extensions/draft-ERC20TemporaryApprovalUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC20Upgradeable",
          "IERC7674"
        ],
        "implements": [],
        "category": "token/ERC20",
        "externalFunctions": [
          {
            "name": "allowance",
            "signature": "allowance(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "Math.tryAdd",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "allowance",
                "type": "super",
                "argCount": 2
              },
              {
                "target": "_temporaryAllowance",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function allowance(address owner, address spender) public view virtual override(IERC20, ERC20Upgradeable) returns (uint256) {\n        (bool success, uint256 amount) = Math.tryAdd(\n            super.allowance(owner, spender),\n            _temporaryAllowance(owner, spender)\n        );\n        return success ? amount : type(uint256).max;\n    }",
            "startLine": 39
          },
          {
            "name": "temporaryApprove",
            "signature": "temporaryApprove(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_temporaryApprove",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function temporaryApprove(address spender, uint256 value) public virtual returns (bool) {\n        _temporaryApprove(_msgSender(), spender, value);\n        return true;\n    }",
            "startLine": 65
          }
        ],
        "internalFunctions": [
          {
            "name": "__ERC20TemporaryApproval_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20TemporaryApproval_init() internal onlyInitializing {\n    }",
            "startLine": 30
          },
          {
            "name": "__ERC20TemporaryApproval_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20TemporaryApproval_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 33
          },
          {
            "name": "_temporaryAllowance",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "tload",
                "type": "external",
                "targetType": "_temporaryAllowanceSlot",
                "argCount": 0
              },
              {
                "target": "_temporaryAllowanceSlot",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _temporaryAllowance(address owner, address spender) internal view virtual returns (uint256) {\n        return _temporaryAllowanceSlot(owner, spender).tload();\n    }",
            "startLine": 50
          },
          {
            "name": "_temporaryApprove",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "tstore",
                "type": "external",
                "targetType": "_temporaryAllowanceSlot",
                "argCount": 1
              },
              {
                "target": "_temporaryAllowanceSlot",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _temporaryApprove(address owner, address spender, uint256 value) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _temporaryAllowanceSlot(owner, spender).tstore(value);\n    }",
            "startLine": 82
          },
          {
            "name": "_spendAllowance",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_temporaryAllowance",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "Math.min",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "_temporaryApprove",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_spendAllowance",
                "type": "super",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _spendAllowance(address owner, address spender, uint256 value) internal virtual override {\n        // load transient allowance\n        uint256 currentTemporaryAllowance = _temporaryAllowance(owner, spender);\n\n        // Check and update (if needed) the temporary allowance + set remaining value\n        if (currentTemporaryAllowance > 0) {\n            // All value is covered by the infinite allowance. nothing left to spend, we can return early\n            if (currentTemporaryAllowance == type(uint256).max) {\n                return;\n            }\n            // check how much of the value is covered by the transient allowance\n            uint256 spendTemporaryAllowance = Math.min(currentTemporaryAllowance, value);\n            unchecked {\n                // decrease transient allowance accordingly\n                _temporaryApprove(owner, spender, currentTemporaryAllowance - spendTemporaryAllowance);\n                // update value necessary\n                value -= spendTemporaryAllowance;\n            }\n        }\n        // reduce any remaining value from the persistent allowance\n        if (value > 0) {\n            super._spendAllowance(owner, spender, value);\n        }\n    }",
            "startLine": 98
          },
          {
            "name": "_temporaryAllowanceSlot",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "TransientSlot.Uint256Slot"
              }
            ],
            "calls": [
              {
                "target": "SlotDerivation.asUint256",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "SlotDerivation.deriveMapping",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "ERC20_TEMPORARY_APPROVAL_STORAGE.deriveMapping",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _temporaryAllowanceSlot(address owner, address spender) private pure returns (TransientSlot.Uint256Slot) {\n        return ERC20_TEMPORARY_APPROVAL_STORAGE.deriveMapping(owner).deriveMapping(spender).asUint256();\n    }",
            "startLine": 123
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [
          {
            "name": "ERC20_TEMPORARY_APPROVAL_STORAGE",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 27
          }
        ],
        "usesLibraries": [
          "SlotDerivation",
          "TransientSlot",
          "TransientSlot"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/token/ERC20/IERC20.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../ERC20Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/interfaces/draft-IERC7674.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/math/Math.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/SlotDerivation.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/TransientSlot.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/extensions/draft-ERC20TemporaryApproval.sol)\n\npragma solidity ^0.8.24;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20Upgradeable} from \"../ERC20Upgradeable.sol\";\nimport {IERC7674} from \"@openzeppelin/contracts/interfaces/draft-IERC7674.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SlotDerivation} from \"@openzeppelin/contracts/utils/SlotDerivation.sol\";\nimport {TransientSlot} from \"@openzeppelin/contracts/utils/TransientSlot.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that adds support for temporary allowances following ERC-7674.\n *\n * WARNING: This is a draft contract. The corresponding ERC is still subject to changes.\n *\n * _Available since v5.1._\n */\nabstract contract ERC20TemporaryApprovalUpgradeable is Initializable, ERC20Upgradeable, IERC7674 {\n    using SlotDerivation for bytes32;\n    using TransientSlot for bytes32;\n    using TransientSlot for TransientSlot.Uint256Slot;\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20_TEMPORARY_APPROVAL_STORAGE\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20_TEMPORARY_APPROVAL_STORAGE =\n        0xea2d0e77a01400d0111492b1321103eed560d8fe44b9a7c2410407714583c400;\n\n    function __ERC20TemporaryApproval_init() internal onlyInitializing {\n    }\n\n    function __ERC20TemporaryApproval_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev {allowance} override that includes the temporary allowance when looking up the current allowance. If\n     * adding up the persistent and the temporary allowances result in an overflow, type(uint256).max is returned.\n     */\n    function allowance(address owner, address spender) public view virtual override(IERC20, ERC20Upgradeable) returns (uint256) {\n        (bool success, uint256 amount) = Math.tryAdd(\n            super.allowance(owner, spender),\n            _temporaryAllowance(owner, spender)\n        );\n        return success ? amount : type(uint256).max;\n    }\n\n    /**\n     * @dev Internal getter for the current temporary allowance that `spender` has over `owner` tokens.\n     */\n    function _temporaryAllowance(address owner, address spender) internal view virtual returns (uint256) {\n        return _temporaryAllowanceSlot(owner, spender).tload();\n    }\n\n    /**\n     * @dev Alternative to {approve} that sets a `value` amount of tokens as the temporary allowance of `spender` over\n     * the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Requirements:\n     * - `spender` cannot be the zero address.\n     *\n     * Does NOT emit an {Approval} event.\n     */\n    function temporaryApprove(address spender, uint256 value) public virtual returns (bool) {\n        _temporaryApprove(_msgSender(), spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Sets `value` as the temporary allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `temporaryApprove`, and can be used to e.g. set automatic allowances\n     * for certain subsystems, etc.\n     *\n     * Requirements:\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Does NOT emit an {Approval} event.\n     */\n    function _temporaryApprove(address owner, address spender, uint256 value) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _temporaryAllowanceSlot(owner, spender).tstore(value);\n    }\n\n    /**\n     * @dev {_spendAllowance} override that consumes the temporary allowance (if any) before eventually falling back\n     * to consuming the persistent allowance.\n     * NOTE: This function skips calling `super._spendAllowance` if the temporary allowance\n     * is enough to cover the spending.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual override {\n        // load transient allowance\n        uint256 currentTemporaryAllowance = _temporaryAllowance(owner, spender);\n\n        // Check and update (if needed) the temporary allowance + set remaining value\n        if (currentTemporaryAllowance > 0) {\n            // All value is covered by the infinite allowance. nothing left to spend, we can return early\n            if (currentTemporaryAllowance == type(uint256).max) {\n                return;\n            }\n            // check how much of the value is covered by the transient allowance\n            uint256 spendTemporaryAllowance = Math.min(currentTemporaryAllowance, value);\n            unchecked {\n                // decrease transient allowance accordingly\n                _temporaryApprove(owner, spender, currentTemporaryAllowance - spendTemporaryAllowance);\n                // update value necessary\n                value -= spendTemporaryAllowance;\n            }\n        }\n        // reduce any remaining value from the persistent allowance\n        if (value > 0) {\n            super._spendAllowance(owner, spender, value);\n        }\n    }\n\n    function _temporaryAllowanceSlot(address owner, address spender) private pure returns (TransientSlot.Uint256Slot) {\n        return ERC20_TEMPORARY_APPROVAL_STORAGE.deriveMapping(owner).deriveMapping(spender).asUint256();\n    }\n}\n"
      },
      {
        "name": "ERC6909Upgradeable",
        "filePath": "token/ERC6909/ERC6909Upgradeable.sol",
        "kind": "contract",
        "inherits": [
          "Initializable",
          "ContextUpgradeable",
          "ERC165Upgradeable",
          "IERC6909"
        ],
        "implements": [],
        "category": "token/ERC6909",
        "externalFunctions": [
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "supportsInterface",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IERC6909).interfaceId || super.supportsInterface(interfaceId);\n    }",
            "startLine": 48
          },
          {
            "name": "balanceOf",
            "signature": "balanceOf(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC6909Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address owner, uint256 id) public view virtual override returns (uint256) {\n        ERC6909Storage storage $ = _getERC6909Storage();\n        return $._balances[owner][id];\n    }",
            "startLine": 53
          },
          {
            "name": "allowance",
            "signature": "allowance(address,address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC6909Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function allowance(address owner, address spender, uint256 id) public view virtual override returns (uint256) {\n        ERC6909Storage storage $ = _getERC6909Storage();\n        return $._allowances[owner][spender][id];\n    }",
            "startLine": 59
          },
          {
            "name": "isOperator",
            "signature": "isOperator(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getERC6909Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function isOperator(address owner, address spender) public view virtual override returns (bool) {\n        ERC6909Storage storage $ = _getERC6909Storage();\n        return $._operatorApprovals[owner][spender];\n    }",
            "startLine": 65
          },
          {
            "name": "approve",
            "signature": "approve(address,uint256,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_approve",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function approve(address spender, uint256 id, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, id, amount);\n        return true;\n    }",
            "startLine": 71
          },
          {
            "name": "setOperator",
            "signature": "setOperator(address,bool)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "approved",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_setOperator",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setOperator(address spender, bool approved) public virtual override returns (bool) {\n        _setOperator(_msgSender(), spender, approved);\n        return true;\n    }",
            "startLine": 77
          },
          {
            "name": "transfer",
            "signature": "transfer(address,uint256,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_transfer",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function transfer(address receiver, uint256 id, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), receiver, id, amount);\n        return true;\n    }",
            "startLine": 83
          },
          {
            "name": "transferFrom",
            "signature": "transferFrom(address,address,uint256,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sender",
                "type": "address"
              },
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "isOperator",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_spendAllowance",
                "type": "internal",
                "argCount": 4
              },
              {
                "target": "_transfer",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function transferFrom(\n        address sender,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address caller = _msgSender();\n        if (sender != caller && !isOperator(sender, caller)) {\n            _spendAllowance(sender, caller, id, amount);\n        }\n        _transfer(sender, receiver, id, amount);\n        return true;\n    }",
            "startLine": 89
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC6909Storage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC6909Storage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getERC6909Storage() private pure returns (ERC6909Storage storage $) {\n        assembly {\n            $.slot := ERC6909StorageLocation\n        }\n    }",
            "startLine": 29
          },
          {
            "name": "__ERC6909_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC6909_init() internal onlyInitializing {\n    }",
            "startLine": 42
          },
          {
            "name": "__ERC6909_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC6909_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 45
          },
          {
            "name": "_mint",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _mint(address to, uint256 id, uint256 amount) internal {\n        if (to == address(0)) {\n            revert ERC6909InvalidReceiver(address(0));\n        }\n        _update(address(0), to, id, amount);\n    }",
            "startLine": 111
          },
          {
            "name": "_transfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _transfer(address from, address to, uint256 id, uint256 amount) internal {\n        if (from == address(0)) {\n            revert ERC6909InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC6909InvalidReceiver(address(0));\n        }\n        _update(from, to, id, amount);\n    }",
            "startLine": 127
          },
          {
            "name": "_burn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _burn(address from, uint256 id, uint256 amount) internal {\n        if (from == address(0)) {\n            revert ERC6909InvalidSender(address(0));\n        }\n        _update(from, address(0), id, amount);\n    }",
            "startLine": 145
          },
          {
            "name": "_update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC6909Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _update(address from, address to, uint256 id, uint256 amount) internal virtual {\n        ERC6909Storage storage $ = _getERC6909Storage();\n        address caller = _msgSender();\n\n        if (from != address(0)) {\n            uint256 fromBalance = $._balances[from][id];\n            if (fromBalance < amount) {\n                revert ERC6909InsufficientBalance(from, fromBalance, amount, id);\n            }\n            unchecked {\n                // Overflow not possible: amount <= fromBalance.\n                $._balances[from][id] = fromBalance - amount;\n            }\n        }\n        if (to != address(0)) {\n            $._balances[to][id] += amount;\n        }\n\n        emit Transfer(caller, from, to, id, amount);\n    }",
            "startLine": 159
          },
          {
            "name": "_approve",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC6909Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _approve(address owner, address spender, uint256 id, uint256 amount) internal virtual {\n        ERC6909Storage storage $ = _getERC6909Storage();\n        if (owner == address(0)) {\n            revert ERC6909InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC6909InvalidSpender(address(0));\n        }\n        $._allowances[owner][spender][id] = amount;\n        emit Approval(owner, spender, id, amount);\n    }",
            "startLine": 193
          },
          {
            "name": "_setOperator",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "approved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC6909Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setOperator(address owner, address spender, bool approved) internal virtual {\n        ERC6909Storage storage $ = _getERC6909Storage();\n        if (owner == address(0)) {\n            revert ERC6909InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC6909InvalidSpender(address(0));\n        }\n        $._operatorApprovals[owner][spender] = approved;\n        emit OperatorSet(owner, spender, approved);\n    }",
            "startLine": 218
          },
          {
            "name": "_spendAllowance",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC6909Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "allowance",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _spendAllowance(address owner, address spender, uint256 id, uint256 amount) internal virtual {\n        ERC6909Storage storage $ = _getERC6909Storage();\n        uint256 currentAllowance = allowance(owner, spender, id);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < amount) {\n                revert ERC6909InsufficientAllowance(spender, currentAllowance, amount, id);\n            }\n            unchecked {\n                $._allowances[owner][spender][id] = currentAllowance - amount;\n            }\n        }\n    }",
            "startLine": 238
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ERC6909InsufficientBalance",
            "parameters": [
              {
                "name": "sender",
                "type": "address"
              },
              {
                "name": "balance",
                "type": "uint256"
              },
              {
                "name": "needed",
                "type": "uint256"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "startLine": 35
          },
          {
            "name": "ERC6909InsufficientAllowance",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "allowance",
                "type": "uint256"
              },
              {
                "name": "needed",
                "type": "uint256"
              },
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "startLine": 36
          },
          {
            "name": "ERC6909InvalidApprover",
            "parameters": [
              {
                "name": "approver",
                "type": "address"
              }
            ],
            "startLine": 37
          },
          {
            "name": "ERC6909InvalidReceiver",
            "parameters": [
              {
                "name": "receiver",
                "type": "address"
              }
            ],
            "startLine": 38
          },
          {
            "name": "ERC6909InvalidSender",
            "parameters": [
              {
                "name": "sender",
                "type": "address"
              }
            ],
            "startLine": 39
          },
          {
            "name": "ERC6909InvalidSpender",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "startLine": 40
          }
        ],
        "structs": [
          {
            "name": "ERC6909Storage",
            "members": [
              {
                "name": "_balances",
                "type": "mapping(address => mapping(uint256 => uint256))"
              },
              {
                "name": "_operatorApprovals",
                "type": "mapping(address => mapping(address => bool))"
              },
              {
                "name": "_allowances",
                "type": "mapping(address => mapping(address => mapping(uint256 => uint256)))"
              }
            ],
            "startLine": 18
          }
        ],
        "stateVariables": [
          {
            "name": "ERC6909StorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 27
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/interfaces/IERC6909.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../../utils/ContextUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/introspection/IERC165.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../../utils/introspection/ERC165Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC6909/ERC6909.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC6909} from \"@openzeppelin/contracts/interfaces/IERC6909.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of ERC-6909.\n * See https://eips.ethereum.org/EIPS/eip-6909\n */\ncontract ERC6909Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC6909 {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC6909\n    struct ERC6909Storage {\n        mapping(address owner => mapping(uint256 id => uint256)) _balances;\n\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n\n        mapping(address owner => mapping(address spender => mapping(uint256 id => uint256))) _allowances;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC6909\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC6909StorageLocation = 0x9e75074fe7582401cc58901f6bda367c4d687c51437956963a7c06ef5cfaf900;\n\n    function _getERC6909Storage() private pure returns (ERC6909Storage storage $) {\n        assembly {\n            $.slot := ERC6909StorageLocation\n        }\n    }\n\n    error ERC6909InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 id);\n    error ERC6909InsufficientAllowance(address spender, uint256 allowance, uint256 needed, uint256 id);\n    error ERC6909InvalidApprover(address approver);\n    error ERC6909InvalidReceiver(address receiver);\n    error ERC6909InvalidSender(address sender);\n    error ERC6909InvalidSpender(address spender);\n\n    function __ERC6909_init() internal onlyInitializing {\n    }\n\n    function __ERC6909_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IERC6909).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IERC6909\n    function balanceOf(address owner, uint256 id) public view virtual override returns (uint256) {\n        ERC6909Storage storage $ = _getERC6909Storage();\n        return $._balances[owner][id];\n    }\n\n    /// @inheritdoc IERC6909\n    function allowance(address owner, address spender, uint256 id) public view virtual override returns (uint256) {\n        ERC6909Storage storage $ = _getERC6909Storage();\n        return $._allowances[owner][spender][id];\n    }\n\n    /// @inheritdoc IERC6909\n    function isOperator(address owner, address spender) public view virtual override returns (bool) {\n        ERC6909Storage storage $ = _getERC6909Storage();\n        return $._operatorApprovals[owner][spender];\n    }\n\n    /// @inheritdoc IERC6909\n    function approve(address spender, uint256 id, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, id, amount);\n        return true;\n    }\n\n    /// @inheritdoc IERC6909\n    function setOperator(address spender, bool approved) public virtual override returns (bool) {\n        _setOperator(_msgSender(), spender, approved);\n        return true;\n    }\n\n    /// @inheritdoc IERC6909\n    function transfer(address receiver, uint256 id, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), receiver, id, amount);\n        return true;\n    }\n\n    /// @inheritdoc IERC6909\n    function transferFrom(\n        address sender,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address caller = _msgSender();\n        if (sender != caller && !isOperator(sender, caller)) {\n            _spendAllowance(sender, caller, id, amount);\n        }\n        _transfer(sender, receiver, id, amount);\n        return true;\n    }\n\n    /**\n     * @dev Creates `amount` of token `id` and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address to, uint256 id, uint256 amount) internal {\n        if (to == address(0)) {\n            revert ERC6909InvalidReceiver(address(0));\n        }\n        _update(address(0), to, id, amount);\n    }\n\n    /**\n     * @dev Moves `amount` of token `id` from `from` to `to` without checking for approvals. This function verifies\n     * that neither the sender nor the receiver are address(0), which means it cannot mint or burn tokens.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 id, uint256 amount) internal {\n        if (from == address(0)) {\n            revert ERC6909InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC6909InvalidReceiver(address(0));\n        }\n        _update(from, to, id, amount);\n    }\n\n    /**\n     * @dev Destroys a `amount` of token `id` from `account`.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address from, uint256 id, uint256 amount) internal {\n        if (from == address(0)) {\n            revert ERC6909InvalidSender(address(0));\n        }\n        _update(from, address(0), id, amount);\n    }\n\n    /**\n     * @dev Transfers `amount` of token `id` from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 id, uint256 amount) internal virtual {\n        ERC6909Storage storage $ = _getERC6909Storage();\n        address caller = _msgSender();\n\n        if (from != address(0)) {\n            uint256 fromBalance = $._balances[from][id];\n            if (fromBalance < amount) {\n                revert ERC6909InsufficientBalance(from, fromBalance, amount, id);\n            }\n            unchecked {\n                // Overflow not possible: amount <= fromBalance.\n                $._balances[from][id] = fromBalance - amount;\n            }\n        }\n        if (to != address(0)) {\n            $._balances[to][id] += amount;\n        }\n\n        emit Transfer(caller, from, to, id, amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`'s `id` tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to e.g. set automatic allowances for certain\n     * subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 id, uint256 amount) internal virtual {\n        ERC6909Storage storage $ = _getERC6909Storage();\n        if (owner == address(0)) {\n            revert ERC6909InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC6909InvalidSpender(address(0));\n        }\n        $._allowances[owner][spender][id] = amount;\n        emit Approval(owner, spender, id, amount);\n    }\n\n    /**\n     * @dev Approve `spender` to operate on all of `owner`'s tokens\n     *\n     * This internal function is equivalent to `setOperator`, and can be used to e.g. set automatic allowances for\n     * certain subsystems, etc.\n     *\n     * Emits an {OperatorSet} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _setOperator(address owner, address spender, bool approved) internal virtual {\n        ERC6909Storage storage $ = _getERC6909Storage();\n        if (owner == address(0)) {\n            revert ERC6909InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC6909InvalidSpender(address(0));\n        }\n        $._operatorApprovals[owner][spender] = approved;\n        emit OperatorSet(owner, spender, approved);\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 id, uint256 amount) internal virtual {\n        ERC6909Storage storage $ = _getERC6909Storage();\n        uint256 currentAllowance = allowance(owner, spender, id);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < amount) {\n                revert ERC6909InsufficientAllowance(spender, currentAllowance, amount, id);\n            }\n            unchecked {\n                $._allowances[owner][spender][id] = currentAllowance - amount;\n            }\n        }\n    }\n}\n"
      },
      {
        "name": "ERC6909ContentURIUpgradeable",
        "filePath": "token/ERC6909/extensions/ERC6909ContentURIUpgradeable.sol",
        "kind": "contract",
        "inherits": [
          "Initializable",
          "ERC6909Upgradeable",
          "IERC6909ContentURI"
        ],
        "implements": [],
        "category": "token/ERC6909",
        "externalFunctions": [
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "supportsInterface",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual override(ERC6909Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IERC6909ContentURI).interfaceId || super.supportsInterface(interfaceId);\n    }",
            "startLine": 42
          },
          {
            "name": "contractURI",
            "signature": "contractURI()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC6909ContentURIStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function contractURI() public view virtual override returns (string memory) {\n        ERC6909ContentURIStorage storage $ = _getERC6909ContentURIStorage();\n        return $._contractURI;\n    }",
            "startLine": 47
          },
          {
            "name": "tokenURI",
            "signature": "tokenURI(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC6909ContentURIStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function tokenURI(uint256 id) public view virtual override returns (string memory) {\n        ERC6909ContentURIStorage storage $ = _getERC6909ContentURIStorage();\n        return $._tokenURIs[id];\n    }",
            "startLine": 53
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC6909ContentURIStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC6909ContentURIStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getERC6909ContentURIStorage() private pure returns (ERC6909ContentURIStorage storage $) {\n        assembly {\n            $.slot := ERC6909ContentURIStorageLocation\n        }\n    }",
            "startLine": 24
          },
          {
            "name": "__ERC6909ContentURI_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC6909ContentURI_init() internal onlyInitializing {\n    }",
            "startLine": 36
          },
          {
            "name": "__ERC6909ContentURI_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC6909ContentURI_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 39
          },
          {
            "name": "_setContractURI",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newContractURI",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC6909ContentURIStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setContractURI(string memory newContractURI) internal virtual {\n        ERC6909ContentURIStorage storage $ = _getERC6909ContentURIStorage();\n        $._contractURI = newContractURI;\n\n        emit ContractURIUpdated();\n    }",
            "startLine": 63
          },
          {
            "name": "_setTokenURI",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "newTokenURI",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC6909ContentURIStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setTokenURI(uint256 id, string memory newTokenURI) internal virtual {\n        ERC6909ContentURIStorage storage $ = _getERC6909ContentURIStorage();\n        $._tokenURIs[id] = newTokenURI;\n\n        emit URI(newTokenURI, id);\n    }",
            "startLine": 75
          }
        ],
        "events": [
          {
            "name": "ContractURIUpdated",
            "parameters": [],
            "startLine": 31
          },
          {
            "name": "URI",
            "parameters": [
              {
                "name": "value",
                "type": "string",
                "indexed": false
              },
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              }
            ],
            "startLine": 34
          }
        ],
        "errors": [],
        "structs": [
          {
            "name": "ERC6909ContentURIStorage",
            "members": [
              {
                "name": "_contractURI",
                "type": "string"
              },
              {
                "name": "_tokenURIs",
                "type": "mapping(uint256 => string)"
              }
            ],
            "startLine": 16
          }
        ],
        "stateVariables": [
          {
            "name": "ERC6909ContentURIStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 22
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC6909Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/interfaces/IERC6909.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/introspection/IERC165.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC6909/extensions/ERC6909ContentURI.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC6909Upgradeable} from \"../ERC6909Upgradeable.sol\";\nimport {IERC6909ContentURI} from \"@openzeppelin/contracts/interfaces/IERC6909.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the Content URI extension defined in ERC6909.\n */\ncontract ERC6909ContentURIUpgradeable is Initializable, ERC6909Upgradeable, IERC6909ContentURI {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC6909ContentURI\n    struct ERC6909ContentURIStorage {\n        string _contractURI;\n        mapping(uint256 id => string) _tokenURIs;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC6909ContentURI\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC6909ContentURIStorageLocation = 0x2ada2772a8c4d40c4be8741992e423a9f97d5f4ef76852e5c17a40aa7fb9e500;\n\n    function _getERC6909ContentURIStorage() private pure returns (ERC6909ContentURIStorage storage $) {\n        assembly {\n            $.slot := ERC6909ContentURIStorageLocation\n        }\n    }\n\n    /// @dev Event emitted when the contract URI is changed. See https://eips.ethereum.org/EIPS/eip-7572[ERC-7572] for details.\n    event ContractURIUpdated();\n\n    /// @dev See {IERC1155-URI}\n    event URI(string value, uint256 indexed id);\n\n    function __ERC6909ContentURI_init() internal onlyInitializing {\n    }\n\n    function __ERC6909ContentURI_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC6909Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IERC6909ContentURI).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IERC6909ContentURI\n    function contractURI() public view virtual override returns (string memory) {\n        ERC6909ContentURIStorage storage $ = _getERC6909ContentURIStorage();\n        return $._contractURI;\n    }\n\n    /// @inheritdoc IERC6909ContentURI\n    function tokenURI(uint256 id) public view virtual override returns (string memory) {\n        ERC6909ContentURIStorage storage $ = _getERC6909ContentURIStorage();\n        return $._tokenURIs[id];\n    }\n\n    /**\n     * @dev Sets the {contractURI} for the contract.\n     *\n     * Emits a {ContractURIUpdated} event.\n     */\n    function _setContractURI(string memory newContractURI) internal virtual {\n        ERC6909ContentURIStorage storage $ = _getERC6909ContentURIStorage();\n        $._contractURI = newContractURI;\n\n        emit ContractURIUpdated();\n    }\n\n    /**\n     * @dev Sets the {tokenURI} for a given token of type `id`.\n     *\n     * Emits a {URI} event.\n     */\n    function _setTokenURI(uint256 id, string memory newTokenURI) internal virtual {\n        ERC6909ContentURIStorage storage $ = _getERC6909ContentURIStorage();\n        $._tokenURIs[id] = newTokenURI;\n\n        emit URI(newTokenURI, id);\n    }\n}\n"
      },
      {
        "name": "ERC6909MetadataUpgradeable",
        "filePath": "token/ERC6909/extensions/ERC6909MetadataUpgradeable.sol",
        "kind": "contract",
        "inherits": [
          "Initializable",
          "ERC6909Upgradeable",
          "IERC6909Metadata"
        ],
        "implements": [],
        "category": "token/ERC6909",
        "externalFunctions": [
          {
            "name": "name",
            "signature": "name(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC6909MetadataStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function name(uint256 id) public view virtual override returns (string memory) {\n        ERC6909MetadataStorage storage $ = _getERC6909MetadataStorage();\n        return $._tokenMetadata[id].name;\n    }",
            "startLine": 50
          },
          {
            "name": "symbol",
            "signature": "symbol(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC6909MetadataStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function symbol(uint256 id) public view virtual override returns (string memory) {\n        ERC6909MetadataStorage storage $ = _getERC6909MetadataStorage();\n        return $._tokenMetadata[id].symbol;\n    }",
            "startLine": 56
          },
          {
            "name": "decimals",
            "signature": "decimals(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [
              {
                "target": "_getERC6909MetadataStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function decimals(uint256 id) public view virtual override returns (uint8) {\n        ERC6909MetadataStorage storage $ = _getERC6909MetadataStorage();\n        return $._tokenMetadata[id].decimals;\n    }",
            "startLine": 62
          },
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "supportsInterface",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual override(ERC6909Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IERC6909Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }",
            "startLine": 68
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC6909MetadataStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC6909MetadataStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getERC6909MetadataStorage() private pure returns (ERC6909MetadataStorage storage $) {\n        assembly {\n            $.slot := ERC6909MetadataStorageLocation\n        }\n    }",
            "startLine": 29
          },
          {
            "name": "__ERC6909Metadata_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC6909Metadata_init() internal onlyInitializing {\n    }",
            "startLine": 44
          },
          {
            "name": "__ERC6909Metadata_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC6909Metadata_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 47
          },
          {
            "name": "_setName",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "newName",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC6909MetadataStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setName(uint256 id, string memory newName) internal virtual {\n        ERC6909MetadataStorage storage $ = _getERC6909MetadataStorage();\n        $._tokenMetadata[id].name = newName;\n\n        emit ERC6909NameUpdated(id, newName);\n    }",
            "startLine": 77
          },
          {
            "name": "_setSymbol",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "newSymbol",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC6909MetadataStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setSymbol(uint256 id, string memory newSymbol) internal virtual {\n        ERC6909MetadataStorage storage $ = _getERC6909MetadataStorage();\n        $._tokenMetadata[id].symbol = newSymbol;\n\n        emit ERC6909SymbolUpdated(id, newSymbol);\n    }",
            "startLine": 89
          },
          {
            "name": "_setDecimals",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "newDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC6909MetadataStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setDecimals(uint256 id, uint8 newDecimals) internal virtual {\n        ERC6909MetadataStorage storage $ = _getERC6909MetadataStorage();\n        $._tokenMetadata[id].decimals = newDecimals;\n\n        emit ERC6909DecimalsUpdated(id, newDecimals);\n    }",
            "startLine": 101
          }
        ],
        "events": [
          {
            "name": "ERC6909NameUpdated",
            "parameters": [
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              },
              {
                "name": "newName",
                "type": "string",
                "indexed": false
              }
            ],
            "startLine": 36
          },
          {
            "name": "ERC6909SymbolUpdated",
            "parameters": [
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              },
              {
                "name": "newSymbol",
                "type": "string",
                "indexed": false
              }
            ],
            "startLine": 39
          },
          {
            "name": "ERC6909DecimalsUpdated",
            "parameters": [
              {
                "name": "id",
                "type": "uint256",
                "indexed": true
              },
              {
                "name": "newDecimals",
                "type": "uint8",
                "indexed": false
              }
            ],
            "startLine": 42
          }
        ],
        "errors": [],
        "structs": [
          {
            "name": "TokenMetadata",
            "members": [
              {
                "name": "name",
                "type": "string"
              },
              {
                "name": "symbol",
                "type": "string"
              },
              {
                "name": "decimals",
                "type": "uint8"
              }
            ],
            "startLine": 15
          },
          {
            "name": "ERC6909MetadataStorage",
            "members": [
              {
                "name": "_tokenMetadata",
                "type": "mapping(uint256 => TokenMetadata)"
              }
            ],
            "startLine": 22
          }
        ],
        "stateVariables": [
          {
            "name": "ERC6909MetadataStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 27
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC6909Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/interfaces/IERC6909.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/introspection/IERC165.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC6909/extensions/ERC6909Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC6909Upgradeable} from \"../ERC6909Upgradeable.sol\";\nimport {IERC6909Metadata} from \"@openzeppelin/contracts/interfaces/IERC6909.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the Metadata extension defined in ERC6909. Exposes the name, symbol, and decimals of each token id.\n */\ncontract ERC6909MetadataUpgradeable is Initializable, ERC6909Upgradeable, IERC6909Metadata {\n    struct TokenMetadata {\n        string name;\n        string symbol;\n        uint8 decimals;\n    }\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC6909Metadata\n    struct ERC6909MetadataStorage {\n        mapping(uint256 id => TokenMetadata) _tokenMetadata;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC6909Metadata\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC6909MetadataStorageLocation = 0xa0651e3d105d335a33d7d04897e080112be09c416f44637d6543e5b47885f800;\n\n    function _getERC6909MetadataStorage() private pure returns (ERC6909MetadataStorage storage $) {\n        assembly {\n            $.slot := ERC6909MetadataStorageLocation\n        }\n    }\n\n    /// @dev The name of the token of type `id` was updated to `newName`.\n    event ERC6909NameUpdated(uint256 indexed id, string newName);\n\n    /// @dev The symbol for the token of type `id` was updated to `newSymbol`.\n    event ERC6909SymbolUpdated(uint256 indexed id, string newSymbol);\n\n    /// @dev The decimals value for token of type `id` was updated to `newDecimals`.\n    event ERC6909DecimalsUpdated(uint256 indexed id, uint8 newDecimals);\n\n    function __ERC6909Metadata_init() internal onlyInitializing {\n    }\n\n    function __ERC6909Metadata_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC6909Metadata\n    function name(uint256 id) public view virtual override returns (string memory) {\n        ERC6909MetadataStorage storage $ = _getERC6909MetadataStorage();\n        return $._tokenMetadata[id].name;\n    }\n\n    /// @inheritdoc IERC6909Metadata\n    function symbol(uint256 id) public view virtual override returns (string memory) {\n        ERC6909MetadataStorage storage $ = _getERC6909MetadataStorage();\n        return $._tokenMetadata[id].symbol;\n    }\n\n    /// @inheritdoc IERC6909Metadata\n    function decimals(uint256 id) public view virtual override returns (uint8) {\n        ERC6909MetadataStorage storage $ = _getERC6909MetadataStorage();\n        return $._tokenMetadata[id].decimals;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC6909Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IERC6909Metadata).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Sets the `name` for a given token of type `id`.\n     *\n     * Emits an {ERC6909NameUpdated} event.\n     */\n    function _setName(uint256 id, string memory newName) internal virtual {\n        ERC6909MetadataStorage storage $ = _getERC6909MetadataStorage();\n        $._tokenMetadata[id].name = newName;\n\n        emit ERC6909NameUpdated(id, newName);\n    }\n\n    /**\n     * @dev Sets the `symbol` for a given token of type `id`.\n     *\n     * Emits an {ERC6909SymbolUpdated} event.\n     */\n    function _setSymbol(uint256 id, string memory newSymbol) internal virtual {\n        ERC6909MetadataStorage storage $ = _getERC6909MetadataStorage();\n        $._tokenMetadata[id].symbol = newSymbol;\n\n        emit ERC6909SymbolUpdated(id, newSymbol);\n    }\n\n    /**\n     * @dev Sets the `decimals` for a given token of type `id`.\n     *\n     * Emits an {ERC6909DecimalsUpdated} event.\n     */\n    function _setDecimals(uint256 id, uint8 newDecimals) internal virtual {\n        ERC6909MetadataStorage storage $ = _getERC6909MetadataStorage();\n        $._tokenMetadata[id].decimals = newDecimals;\n\n        emit ERC6909DecimalsUpdated(id, newDecimals);\n    }\n}\n"
      },
      {
        "name": "ERC6909TokenSupplyUpgradeable",
        "filePath": "token/ERC6909/extensions/ERC6909TokenSupplyUpgradeable.sol",
        "kind": "contract",
        "inherits": [
          "Initializable",
          "ERC6909Upgradeable",
          "IERC6909TokenSupply"
        ],
        "implements": [],
        "category": "token/ERC6909",
        "externalFunctions": [
          {
            "name": "totalSupply",
            "signature": "totalSupply(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "id",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC6909TokenSupplyStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function totalSupply(uint256 id) public view virtual override returns (uint256) {\n        ERC6909TokenSupplyStorage storage $ = _getERC6909TokenSupplyStorage();\n        return $._totalSupplies[id];\n    }",
            "startLine": 36
          },
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "supportsInterface",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual override(ERC6909Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IERC6909TokenSupply).interfaceId || super.supportsInterface(interfaceId);\n    }",
            "startLine": 42
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC6909TokenSupplyStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC6909TokenSupplyStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getERC6909TokenSupplyStorage() private pure returns (ERC6909TokenSupplyStorage storage $) {\n        assembly {\n            $.slot := ERC6909TokenSupplyStorageLocation\n        }\n    }",
            "startLine": 24
          },
          {
            "name": "__ERC6909TokenSupply_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC6909TokenSupply_init() internal onlyInitializing {\n    }",
            "startLine": 30
          },
          {
            "name": "__ERC6909TokenSupply_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC6909TokenSupply_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 33
          },
          {
            "name": "_update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "id",
                "type": "uint256"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC6909TokenSupplyStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_update",
                "type": "super",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _update(address from, address to, uint256 id, uint256 amount) internal virtual override {\n        ERC6909TokenSupplyStorage storage $ = _getERC6909TokenSupplyStorage();\n        super._update(from, to, id, amount);\n\n        if (from == address(0)) {\n            $._totalSupplies[id] += amount;\n        }\n        if (to == address(0)) {\n            unchecked {\n                // amount <= _balances[from][id] <= _totalSupplies[id]\n                $._totalSupplies[id] -= amount;\n            }\n        }\n    }",
            "startLine": 47
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "ERC6909TokenSupplyStorage",
            "members": [
              {
                "name": "_totalSupplies",
                "type": "mapping(uint256 => uint256)"
              }
            ],
            "startLine": 17
          }
        ],
        "stateVariables": [
          {
            "name": "ERC6909TokenSupplyStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 22
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC6909Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/interfaces/IERC6909.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/introspection/IERC165.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC6909/extensions/ERC6909TokenSupply.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC6909Upgradeable} from \"../ERC6909Upgradeable.sol\";\nimport {IERC6909TokenSupply} from \"@openzeppelin/contracts/interfaces/IERC6909.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the Token Supply extension defined in ERC6909.\n * Tracks the total supply of each token id individually.\n */\ncontract ERC6909TokenSupplyUpgradeable is Initializable, ERC6909Upgradeable, IERC6909TokenSupply {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC6909TokenSupply\n    struct ERC6909TokenSupplyStorage {\n        mapping(uint256 id => uint256) _totalSupplies;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC6909TokenSupply\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC6909TokenSupplyStorageLocation = 0x9cc5ac148333cfaf4365d2d67a9c6e8fab8e8f4df7b569f769d68102db719600;\n\n    function _getERC6909TokenSupplyStorage() private pure returns (ERC6909TokenSupplyStorage storage $) {\n        assembly {\n            $.slot := ERC6909TokenSupplyStorageLocation\n        }\n    }\n\n    function __ERC6909TokenSupply_init() internal onlyInitializing {\n    }\n\n    function __ERC6909TokenSupply_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC6909TokenSupply\n    function totalSupply(uint256 id) public view virtual override returns (uint256) {\n        ERC6909TokenSupplyStorage storage $ = _getERC6909TokenSupplyStorage();\n        return $._totalSupplies[id];\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC6909Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IERC6909TokenSupply).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @dev Override the `_update` function to update the total supply of each token id as necessary.\n    function _update(address from, address to, uint256 id, uint256 amount) internal virtual override {\n        ERC6909TokenSupplyStorage storage $ = _getERC6909TokenSupplyStorage();\n        super._update(from, to, id, amount);\n\n        if (from == address(0)) {\n            $._totalSupplies[id] += amount;\n        }\n        if (to == address(0)) {\n            unchecked {\n                // amount <= _balances[from][id] <= _totalSupplies[id]\n                $._totalSupplies[id] -= amount;\n            }\n        }\n    }\n}\n"
      },
      {
        "name": "ERC721Upgradeable",
        "filePath": "token/ERC721/ERC721Upgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ContextUpgradeable",
          "ERC165Upgradeable",
          "IERC721",
          "IERC721Metadata",
          "IERC721Errors"
        ],
        "implements": [],
        "category": "token/ERC721",
        "externalFunctions": [
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "supportsInterface",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }",
            "startLine": 64
          },
          {
            "name": "balanceOf",
            "signature": "balanceOf(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC721Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }",
            "startLine": 72
          },
          {
            "name": "ownerOf",
            "signature": "ownerOf(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }",
            "startLine": 81
          },
          {
            "name": "name",
            "signature": "name()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC721Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }",
            "startLine": 86
          },
          {
            "name": "symbol",
            "signature": "symbol()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC721Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }",
            "startLine": 92
          },
          {
            "name": "tokenURI",
            "signature": "tokenURI(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_baseURI",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Strings.concat",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "Strings.toString",
                "type": "library",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }",
            "startLine": 98
          },
          {
            "name": "approve",
            "signature": "approve(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_approve",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }",
            "startLine": 115
          },
          {
            "name": "getApproved",
            "signature": "getApproved(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }",
            "startLine": 120
          },
          {
            "name": "setApprovalForAll",
            "signature": "setApprovalForAll(address,bool)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "approved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setApprovalForAll",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }",
            "startLine": 127
          },
          {
            "name": "isApprovedForAll",
            "signature": "isApprovedForAll(address,address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getERC721Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }",
            "startLine": 132
          },
          {
            "name": "transferFrom",
            "signature": "transferFrom(address,address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }",
            "startLine": 138
          },
          {
            "name": "safeTransferFrom",
            "signature": "safeTransferFrom(address,address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "safeTransferFrom",
                "type": "internal",
                "argCount": 4
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": false,
            "sourceCode": "function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }",
            "startLine": 151
          },
          {
            "name": "safeTransferFrom",
            "signature": "safeTransferFrom(address,address,uint256,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "transferFrom",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "ERC721Utils.checkOnERC721Received",
                "type": "library",
                "argCount": 5
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\n    }",
            "startLine": 156
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC721Storage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC721Storage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }",
            "startLine": 44
          },
          {
            "name": "__ERC721_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name_",
                "type": "string"
              },
              {
                "name": "symbol_",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }",
            "startLine": 53
          },
          {
            "name": "__ERC721_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name_",
                "type": "string"
              },
              {
                "name": "symbol_",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC721Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }",
            "startLine": 57
          },
          {
            "name": "_baseURI",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }",
            "startLine": 110
          },
          {
            "name": "_ownerOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getERC721Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }",
            "startLine": 169
          },
          {
            "name": "_getApproved",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getERC721Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }",
            "startLine": 177
          },
          {
            "name": "_isAuthorized",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "isApprovedForAll",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }",
            "startLine": 189
          },
          {
            "name": "_checkAuthorized",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }",
            "startLine": 204
          },
          {
            "name": "_increaseBalance",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint128"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC721Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }",
            "startLine": 224
          },
          {
            "name": "_update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "auth",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getERC721Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_ownerOf",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_approve",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n\n        $._owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }",
            "startLine": 242
          },
          {
            "name": "_mint",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }",
            "startLine": 286
          },
          {
            "name": "_safeMint",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeMint",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }",
            "startLine": 306
          },
          {
            "name": "_safeMint",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_mint",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "ERC721Utils.checkOnERC721Received",
                "type": "library",
                "argCount": 5
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), address(0), to, tokenId, data);\n    }",
            "startLine": 314
          },
          {
            "name": "_burn",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }",
            "startLine": 330
          },
          {
            "name": "_transfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }",
            "startLine": 348
          },
          {
            "name": "_safeTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_safeTransfer",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }",
            "startLine": 379
          },
          {
            "name": "_safeTransfer",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transfer",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "ERC721Utils.checkOnERC721Received",
                "type": "library",
                "argCount": 5
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\n    }",
            "startLine": 387
          },
          {
            "name": "_approve",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "auth",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_approve",
                "type": "internal",
                "argCount": 4
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }",
            "startLine": 402
          },
          {
            "name": "_approve",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "auth",
                "type": "address"
              },
              {
                "name": "emitEvent",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC721Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "isApprovedForAll",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        $._tokenApprovals[tokenId] = to;\n    }",
            "startLine": 410
          },
          {
            "name": "_setApprovalForAll",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "approved",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC721Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidApprover(address(0));\n        }\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }",
            "startLine": 437
          },
          {
            "name": "_requireOwned",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_ownerOf",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }",
            "startLine": 455
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "ERC721Storage",
            "members": [
              {
                "name": "_name",
                "type": "string"
              },
              {
                "name": "_symbol",
                "type": "string"
              },
              {
                "name": "_owners",
                "type": "mapping(uint256 => address)"
              },
              {
                "name": "_balances",
                "type": "mapping(address => uint256)"
              },
              {
                "name": "_tokenApprovals",
                "type": "mapping(uint256 => address)"
              },
              {
                "name": "_operatorApprovals",
                "type": "mapping(address => mapping(address => bool))"
              }
            ],
            "startLine": 25
          }
        ],
        "stateVariables": [
          {
            "name": "ERC721StorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 42
          }
        ],
        "usesLibraries": [
          "Strings"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/token/ERC721/IERC721.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/token/ERC721/utils/ERC721Utils.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../../utils/ContextUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/Strings.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/introspection/IERC165.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../../utils/introspection/ERC165Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/interfaces/draft-IERC6093.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.24;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {ERC721Utils} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Utils.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport {IERC721Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC-721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC721\n    struct ERC721Storage {\n        // Token name\n        string _name;\n\n        // Token symbol\n        string _symbol;\n\n        mapping(uint256 tokenId => address) _owners;\n\n        mapping(address owner => uint256) _balances;\n\n        mapping(uint256 tokenId => address) _tokenApprovals;\n\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC721\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IERC721\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n\n    /// @inheritdoc IERC721\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /// @inheritdoc IERC721Metadata\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n\n    /// @inheritdoc IERC721Metadata\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n\n    /// @inheritdoc IERC721Metadata\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /// @inheritdoc IERC721\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /// @inheritdoc IERC721\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /// @inheritdoc IERC721\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /// @inheritdoc IERC721\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n\n    /// @inheritdoc IERC721\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC-721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if:\n     * - `spender` does not have approval from `owner` for `tokenId`.\n     * - `spender` does not have approval to manage all of `owner`'s assets.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n\n        $._owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC-721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        $._tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidApprover(address(0));\n        }\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n}\n"
      },
      {
        "name": "ERC721BurnableUpgradeable",
        "filePath": "token/ERC721/extensions/ERC721BurnableUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ContextUpgradeable",
          "ERC721Upgradeable"
        ],
        "implements": [],
        "category": "token/ERC721",
        "externalFunctions": [
          {
            "name": "burn",
            "signature": "burn(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function burn(uint256 tokenId) public virtual {\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        _update(address(0), tokenId, _msgSender());\n    }",
            "startLine": 27
          }
        ],
        "internalFunctions": [
          {
            "name": "__ERC721Burnable_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC721Burnable_init() internal onlyInitializing {\n    }",
            "startLine": 15
          },
          {
            "name": "__ERC721Burnable_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC721Burnable_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 18
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC721Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../../../utils/ContextUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.24;\n\nimport {ERC721Upgradeable} from \"../ERC721Upgradeable.sol\";\nimport {ContextUpgradeable} from \"../../../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @title ERC-721 Burnable Token\n * @dev ERC-721 Token that can be burned (destroyed).\n */\nabstract contract ERC721BurnableUpgradeable is Initializable, ContextUpgradeable, ERC721Upgradeable {\n    function __ERC721Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        _update(address(0), tokenId, _msgSender());\n    }\n}\n"
      },
      {
        "name": "ERC721ConsecutiveUpgradeable",
        "filePath": "token/ERC721/extensions/ERC721ConsecutiveUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "IERC2309",
          "ERC721Upgradeable"
        ],
        "implements": [],
        "category": "token/ERC721",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "_getERC721ConsecutiveStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC721ConsecutiveStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getERC721ConsecutiveStorage() private pure returns (ERC721ConsecutiveStorage storage $) {\n        assembly {\n            $.slot := ERC721ConsecutiveStorageLocation\n        }\n    }",
            "startLine": 44
          },
          {
            "name": "__ERC721Consecutive_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC721Consecutive_init() internal onlyInitializing {\n    }",
            "startLine": 72
          },
          {
            "name": "__ERC721Consecutive_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC721Consecutive_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 75
          },
          {
            "name": "_maxBatchSize",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint96"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _maxBatchSize() internal view virtual returns (uint96) {\n        return 5000;\n    }",
            "startLine": 85
          },
          {
            "name": "_ownerOf",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getERC721ConsecutiveStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_ownerOf",
                "type": "super",
                "argCount": 1
              },
              {
                "target": "_firstConsecutiveId",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "BitMaps.get",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "BitMaps.lowerLookup",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _ownerOf(uint256 tokenId) internal view virtual override returns (address) {\n        ERC721ConsecutiveStorage storage $ = _getERC721ConsecutiveStorage();\n        address owner = super._ownerOf(tokenId);\n\n        // If token is owned by the core, or beyond consecutive range, return base value\n        if (owner != address(0) || tokenId > type(uint96).max || tokenId < _firstConsecutiveId()) {\n            return owner;\n        }\n\n        // Otherwise, check the token was not burned, and fetch ownership from the anchors\n        // Note: no need for safe cast, we know that tokenId <= type(uint96).max\n        return $._sequentialBurn.get(tokenId) ? address(0) : address($._sequentialOwnership.lowerLookup(uint96(tokenId)));\n    }",
            "startLine": 93
          },
          {
            "name": "_mintConsecutive",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "batchSize",
                "type": "uint96"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint96"
              }
            ],
            "calls": [
              {
                "target": "_getERC721ConsecutiveStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_nextConsecutiveId",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_maxBatchSize",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "BitMaps.push",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "_increaseBalance",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _mintConsecutive(address to, uint96 batchSize) internal virtual returns (uint96) {\n        ERC721ConsecutiveStorage storage $ = _getERC721ConsecutiveStorage();\n        uint96 next = _nextConsecutiveId();\n\n        // minting a batch of size 0 is a no-op\n        if (batchSize > 0) {\n            if (address(this).code.length > 0) {\n                revert ERC721ForbiddenBatchMint();\n            }\n            if (to == address(0)) {\n                revert ERC721InvalidReceiver(address(0));\n            }\n\n            uint256 maxBatchSize = _maxBatchSize();\n            if (batchSize > maxBatchSize) {\n                revert ERC721ExceededMaxBatchMint(batchSize, maxBatchSize);\n            }\n\n            // push an ownership checkpoint & emit event\n            uint96 last = next + batchSize - 1;\n            $._sequentialOwnership.push(last, uint160(to));\n\n            // The invariant required by this function is preserved because the new sequentialOwnership checkpoint\n            // is attributing ownership of `batchSize` new tokens to account `to`.\n            _increaseBalance(to, batchSize);\n\n            emit ConsecutiveTransfer(next, last, address(0), to);\n        }\n\n        return next;\n    }",
            "startLine": 123
          },
          {
            "name": "_update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "auth",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getERC721ConsecutiveStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_update",
                "type": "super",
                "argCount": 3
              },
              {
                "target": "_nextConsecutiveId",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "BitMaps.get",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "BitMaps.set",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        ERC721ConsecutiveStorage storage $ = _getERC721ConsecutiveStorage();\n        address previousOwner = super._update(to, tokenId, auth);\n\n        // only mint after construction\n        if (previousOwner == address(0) && address(this).code.length == 0) {\n            revert ERC721ForbiddenMint();\n        }\n\n        // record burn\n        if (\n            to == address(0) && // if we burn\n            tokenId < _nextConsecutiveId() && // and the tokenId was minted in a batch\n            !$._sequentialBurn.get(tokenId) // and the token was never marked as burnt\n        ) {\n            $._sequentialBurn.set(tokenId);\n        }\n\n        return previousOwner;\n    }",
            "startLine": 161
          },
          {
            "name": "_firstConsecutiveId",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint96"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _firstConsecutiveId() internal view virtual returns (uint96) {\n        return 0;\n    }",
            "startLine": 185
          },
          {
            "name": "_nextConsecutiveId",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint96"
              }
            ],
            "calls": [
              {
                "target": "_getERC721ConsecutiveStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "BitMaps.latestCheckpoint",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "_firstConsecutiveId",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _nextConsecutiveId() private view returns (uint96) {\n        ERC721ConsecutiveStorage storage $ = _getERC721ConsecutiveStorage();\n        (bool exists, uint96 latestId, ) = $._sequentialOwnership.latestCheckpoint();\n        return exists ? latestId + 1 : _firstConsecutiveId();\n    }",
            "startLine": 193
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ERC721ForbiddenBatchMint",
            "parameters": [],
            "startLine": 55
          },
          {
            "name": "ERC721ExceededMaxBatchMint",
            "parameters": [
              {
                "name": "batchSize",
                "type": "uint256"
              },
              {
                "name": "maxBatch",
                "type": "uint256"
              }
            ],
            "startLine": 60
          },
          {
            "name": "ERC721ForbiddenMint",
            "parameters": [],
            "startLine": 65
          },
          {
            "name": "ERC721ForbiddenBatchBurn",
            "parameters": [],
            "startLine": 70
          }
        ],
        "structs": [
          {
            "name": "ERC721ConsecutiveStorage",
            "members": [
              {
                "name": "_sequentialOwnership",
                "type": "Checkpoints.Trace160"
              },
              {
                "name": "_sequentialBurn",
                "type": "BitMaps.BitMap"
              }
            ],
            "startLine": 36
          }
        ],
        "stateVariables": [
          {
            "name": "ERC721ConsecutiveStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 42
          }
        ],
        "usesLibraries": [
          "BitMaps",
          "Checkpoints"
        ],
        "imports": [
          {
            "path": "../ERC721Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/interfaces/IERC2309.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/structs/BitMaps.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/structs/Checkpoints.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC721/extensions/ERC721Consecutive.sol)\n\npragma solidity ^0.8.24;\n\nimport {ERC721Upgradeable} from \"../ERC721Upgradeable.sol\";\nimport {IERC2309} from \"@openzeppelin/contracts/interfaces/IERC2309.sol\";\nimport {BitMaps} from \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\nimport {Checkpoints} from \"@openzeppelin/contracts/utils/structs/Checkpoints.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC-2309 \"Consecutive Transfer Extension\" as defined in\n * https://eips.ethereum.org/EIPS/eip-2309[ERC-2309].\n *\n * This extension allows the minting of large batches of tokens, during contract construction only. For upgradeable\n * contracts this implies that batch minting is only available during proxy deployment, and not in subsequent upgrades.\n * These batches are limited to 5000 tokens at a time by default to accommodate off-chain indexers.\n *\n * Using this extension removes the ability to mint single tokens during contract construction. This ability is\n * regained after construction. During construction, only batch minting is allowed.\n *\n * IMPORTANT: This extension does not call the {_update} function for tokens minted in batch. Any logic added to this\n * function through overrides will not be triggered when tokens are minted in batch. You may want to also override\n * {_increaseBalance} or {_mintConsecutive} to account for these mints.\n *\n * IMPORTANT: When overriding {_mintConsecutive}, be careful about call ordering. {ownerOf} may return invalid\n * values during the {_mintConsecutive} execution if the super call is not called first. To be safe, execute the\n * super call before your custom logic.\n */\nabstract contract ERC721ConsecutiveUpgradeable is Initializable, IERC2309, ERC721Upgradeable {\n    using BitMaps for BitMaps.BitMap;\n    using Checkpoints for Checkpoints.Trace160;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC721Consecutive\n    struct ERC721ConsecutiveStorage {\n        Checkpoints.Trace160 _sequentialOwnership;\n        BitMaps.BitMap _sequentialBurn;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC721Consecutive\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC721ConsecutiveStorageLocation = 0x24de1071a22e1e6f709b09cc0dadb696f919b85b456665cd36195df4bc89ff00;\n\n    function _getERC721ConsecutiveStorage() private pure returns (ERC721ConsecutiveStorage storage $) {\n        assembly {\n            $.slot := ERC721ConsecutiveStorageLocation\n        }\n    }\n\n    /**\n     * @dev Batch mint is restricted to the constructor.\n     * Any batch mint not emitting the {IERC721-Transfer} event outside of the constructor\n     * is non ERC-721 compliant.\n     */\n    error ERC721ForbiddenBatchMint();\n\n    /**\n     * @dev Exceeds the max amount of mints per batch.\n     */\n    error ERC721ExceededMaxBatchMint(uint256 batchSize, uint256 maxBatch);\n\n    /**\n     * @dev Individual minting is not allowed.\n     */\n    error ERC721ForbiddenMint();\n\n    /**\n     * @dev Batch burn is not supported.\n     */\n    error ERC721ForbiddenBatchBurn();\n\n    function __ERC721Consecutive_init() internal onlyInitializing {\n    }\n\n    function __ERC721Consecutive_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Maximum size of a batch of consecutive tokens. This is designed to limit stress on off-chain indexing\n     * services that have to record one entry per token, and have protections against \"unreasonably large\" batches of\n     * tokens.\n     *\n     * NOTE: Overriding the default value of 5000 will not cause on-chain issues, but may result in the asset not being\n     * correctly supported by off-chain indexing services (including marketplaces).\n     */\n    function _maxBatchSize() internal view virtual returns (uint96) {\n        return 5000;\n    }\n\n    /**\n     * @dev See {ERC721-_ownerOf}. Override that checks the sequential ownership structure for tokens that have\n     * been minted as part of a batch, and not yet transferred.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual override returns (address) {\n        ERC721ConsecutiveStorage storage $ = _getERC721ConsecutiveStorage();\n        address owner = super._ownerOf(tokenId);\n\n        // If token is owned by the core, or beyond consecutive range, return base value\n        if (owner != address(0) || tokenId > type(uint96).max || tokenId < _firstConsecutiveId()) {\n            return owner;\n        }\n\n        // Otherwise, check the token was not burned, and fetch ownership from the anchors\n        // Note: no need for safe cast, we know that tokenId <= type(uint96).max\n        return $._sequentialBurn.get(tokenId) ? address(0) : address($._sequentialOwnership.lowerLookup(uint96(tokenId)));\n    }\n\n    /**\n     * @dev Mint a batch of tokens of length `batchSize` for `to`. Returns the token id of the first token minted in the\n     * batch; if `batchSize` is 0, returns the number of consecutive ids minted so far.\n     *\n     * Requirements:\n     *\n     * - `batchSize` must not be greater than {_maxBatchSize}.\n     * - The function is called in the constructor of the contract (directly or indirectly).\n     *\n     * CAUTION: Does not emit a `Transfer` event. This is ERC-721 compliant as long as it is done inside of the\n     * constructor, which is enforced by this function.\n     *\n     * CAUTION: Does not invoke `onERC721Received` on the receiver.\n     *\n     * Emits a {IERC2309-ConsecutiveTransfer} event.\n     */\n    function _mintConsecutive(address to, uint96 batchSize) internal virtual returns (uint96) {\n        ERC721ConsecutiveStorage storage $ = _getERC721ConsecutiveStorage();\n        uint96 next = _nextConsecutiveId();\n\n        // minting a batch of size 0 is a no-op\n        if (batchSize > 0) {\n            if (address(this).code.length > 0) {\n                revert ERC721ForbiddenBatchMint();\n            }\n            if (to == address(0)) {\n                revert ERC721InvalidReceiver(address(0));\n            }\n\n            uint256 maxBatchSize = _maxBatchSize();\n            if (batchSize > maxBatchSize) {\n                revert ERC721ExceededMaxBatchMint(batchSize, maxBatchSize);\n            }\n\n            // push an ownership checkpoint & emit event\n            uint96 last = next + batchSize - 1;\n            $._sequentialOwnership.push(last, uint160(to));\n\n            // The invariant required by this function is preserved because the new sequentialOwnership checkpoint\n            // is attributing ownership of `batchSize` new tokens to account `to`.\n            _increaseBalance(to, batchSize);\n\n            emit ConsecutiveTransfer(next, last, address(0), to);\n        }\n\n        return next;\n    }\n\n    /**\n     * @dev See {ERC721-_update}. Override version that restricts normal minting to after construction.\n     *\n     * WARNING: Using {ERC721Consecutive} prevents minting during construction in favor of {_mintConsecutive}.\n     * After construction, {_mintConsecutive} is no longer available and minting through {_update} becomes available.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        ERC721ConsecutiveStorage storage $ = _getERC721ConsecutiveStorage();\n        address previousOwner = super._update(to, tokenId, auth);\n\n        // only mint after construction\n        if (previousOwner == address(0) && address(this).code.length == 0) {\n            revert ERC721ForbiddenMint();\n        }\n\n        // record burn\n        if (\n            to == address(0) && // if we burn\n            tokenId < _nextConsecutiveId() && // and the tokenId was minted in a batch\n            !$._sequentialBurn.get(tokenId) // and the token was never marked as burnt\n        ) {\n            $._sequentialBurn.set(tokenId);\n        }\n\n        return previousOwner;\n    }\n\n    /**\n     * @dev Used to offset the first token id in `_nextConsecutiveId`\n     */\n    function _firstConsecutiveId() internal view virtual returns (uint96) {\n        return 0;\n    }\n\n    /**\n     * @dev Returns the next tokenId to mint using {_mintConsecutive}. It will return {_firstConsecutiveId}\n     * if no consecutive tokenId has been minted before.\n     */\n    function _nextConsecutiveId() private view returns (uint96) {\n        ERC721ConsecutiveStorage storage $ = _getERC721ConsecutiveStorage();\n        (bool exists, uint96 latestId, ) = $._sequentialOwnership.latestCheckpoint();\n        return exists ? latestId + 1 : _firstConsecutiveId();\n    }\n}\n"
      },
      {
        "name": "ERC721EnumerableUpgradeable",
        "filePath": "token/ERC721/extensions/ERC721EnumerableUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC721Upgradeable",
          "IERC721Enumerable"
        ],
        "implements": [],
        "category": "token/ERC721",
        "externalFunctions": [
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "supportsInterface",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }",
            "startLine": 55
          },
          {
            "name": "tokenOfOwnerByIndex",
            "signature": "tokenOfOwnerByIndex(address,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC721EnumerableStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "balanceOf",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return $._ownedTokens[owner][index];\n    }",
            "startLine": 60
          },
          {
            "name": "totalSupply",
            "signature": "totalSupply()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC721EnumerableStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function totalSupply() public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        return $._allTokens.length;\n    }",
            "startLine": 69
          },
          {
            "name": "tokenByIndex",
            "signature": "tokenByIndex(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC721EnumerableStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "totalSupply",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return $._allTokens[index];\n    }",
            "startLine": 75
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC721EnumerableStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC721EnumerableStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getERC721EnumerableStorage() private pure returns (ERC721EnumerableStorage storage $) {\n        assembly {\n            $.slot := ERC721EnumerableStorageLocation\n        }\n    }",
            "startLine": 31
          },
          {
            "name": "__ERC721Enumerable_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC721Enumerable_init() internal onlyInitializing {\n    }",
            "startLine": 49
          },
          {
            "name": "__ERC721Enumerable_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 52
          },
          {
            "name": "_update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "auth",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_update",
                "type": "super",
                "argCount": 3
              },
              {
                "target": "_addTokenToAllTokensEnumeration",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_removeTokenFromOwnerEnumeration",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_removeTokenFromAllTokensEnumeration",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_addTokenToOwnerEnumeration",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n\n        return previousOwner;\n    }",
            "startLine": 84
          },
          {
            "name": "_addTokenToOwnerEnumeration",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC721EnumerableStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "balanceOf",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 length = balanceOf(to) - 1;\n        $._ownedTokens[to][length] = tokenId;\n        $._ownedTokensIndex[tokenId] = length;\n    }",
            "startLine": 106
          },
          {
            "name": "_addTokenToAllTokensEnumeration",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC721EnumerableStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        $._allTokensIndex[tokenId] = $._allTokens.length;\n        $._allTokens.push(tokenId);\n    }",
            "startLine": 117
          },
          {
            "name": "_removeTokenFromOwnerEnumeration",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC721EnumerableStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "balanceOf",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = $._ownedTokensIndex[tokenId];\n\n        mapping(uint256 index => uint256) storage _ownedTokensByOwner = $._ownedTokens[from];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokensByOwner[lastTokenIndex];\n\n            _ownedTokensByOwner[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            $._ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete $._ownedTokensIndex[tokenId];\n        delete _ownedTokensByOwner[lastTokenIndex];\n    }",
            "startLine": 131
          },
          {
            "name": "_removeTokenFromAllTokensEnumeration",
            "visibility": "private",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC721EnumerableStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = $._allTokens.length - 1;\n        uint256 tokenIndex = $._allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = $._allTokens[lastTokenIndex];\n\n        $._allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        $._allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete $._allTokensIndex[tokenId];\n        $._allTokens.pop();\n    }",
            "startLine": 159
          },
          {
            "name": "_increaseBalance",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint128"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_increaseBalance",
                "type": "super",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }",
            "startLine": 184
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ERC721OutOfBoundsIndex",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "startLine": 42
          },
          {
            "name": "ERC721EnumerableForbiddenBatchMint",
            "parameters": [],
            "startLine": 47
          }
        ],
        "structs": [
          {
            "name": "ERC721EnumerableStorage",
            "members": [
              {
                "name": "_ownedTokens",
                "type": "mapping(address => mapping(uint256 => uint256))"
              },
              {
                "name": "_ownedTokensIndex",
                "type": "mapping(uint256 => uint256)"
              },
              {
                "name": "_allTokens",
                "type": "uint256[]"
              },
              {
                "name": "_allTokensIndex",
                "type": "mapping(uint256 => uint256)"
              }
            ],
            "startLine": 20
          }
        ],
        "stateVariables": [
          {
            "name": "ERC721EnumerableStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 29
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC721Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/introspection/IERC165.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.24;\n\nimport {ERC721Upgradeable} from \"../ERC721Upgradeable.sol\";\nimport {IERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the ERC that adds enumerability\n * of all the token ids in the contract as well as all token ids owned by each account.\n *\n * CAUTION: {ERC721} extensions that implement custom `balanceOf` logic, such as {ERC721Consecutive},\n * interfere with enumerability and should not be used together with {ERC721Enumerable}.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721Enumerable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC721Enumerable\n    struct ERC721EnumerableStorage {\n        mapping(address owner => mapping(uint256 index => uint256)) _ownedTokens;\n        mapping(uint256 tokenId => uint256) _ownedTokensIndex;\n\n        uint256[] _allTokens;\n        mapping(uint256 tokenId => uint256) _allTokensIndex;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC721Enumerable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC721EnumerableStorageLocation = 0x645e039705490088daad89bae25049a34f4a9072d398537b1ab2425f24cbed00;\n\n    function _getERC721EnumerableStorage() private pure returns (ERC721EnumerableStorage storage $) {\n        assembly {\n            $.slot := ERC721EnumerableStorageLocation\n        }\n    }\n\n    /**\n     * @dev An `owner`'s token query was out of bounds for `index`.\n     *\n     * NOTE: The owner being `address(0)` indicates a global out of bounds index.\n     */\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n\n    /**\n     * @dev Batch mint is not allowed.\n     */\n    error ERC721EnumerableForbiddenBatchMint();\n\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IERC721Enumerable\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return $._ownedTokens[owner][index];\n    }\n\n    /// @inheritdoc IERC721Enumerable\n    function totalSupply() public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        return $._allTokens.length;\n    }\n\n    /// @inheritdoc IERC721Enumerable\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return $._allTokens[index];\n    }\n\n    /// @inheritdoc ERC721Upgradeable\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n\n        return previousOwner;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 length = balanceOf(to) - 1;\n        $._ownedTokens[to][length] = tokenId;\n        $._ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        $._allTokensIndex[tokenId] = $._allTokens.length;\n        $._allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = $._ownedTokensIndex[tokenId];\n\n        mapping(uint256 index => uint256) storage _ownedTokensByOwner = $._ownedTokens[from];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokensByOwner[lastTokenIndex];\n\n            _ownedTokensByOwner[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            $._ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete $._ownedTokensIndex[tokenId];\n        delete _ownedTokensByOwner[lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = $._allTokens.length - 1;\n        uint256 tokenIndex = $._allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = $._allTokens[lastTokenIndex];\n\n        $._allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        $._allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete $._allTokensIndex[tokenId];\n        $._allTokens.pop();\n    }\n\n    /**\n     * See {ERC721-_increaseBalance}. We need to forbid batch minting because the enumeration\n     * extension does not support it.\n     */\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}\n"
      },
      {
        "name": "ERC721PausableUpgradeable",
        "filePath": "token/ERC721/extensions/ERC721PausableUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC721Upgradeable",
          "PausableUpgradeable"
        ],
        "implements": [],
        "category": "token/ERC721",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "__ERC721Pausable_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC721Pausable_init() internal onlyInitializing {\n    }",
            "startLine": 24
          },
          {
            "name": "__ERC721Pausable_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC721Pausable_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 27
          },
          {
            "name": "_update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "auth",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_update",
                "type": "super",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    ) internal virtual override whenNotPaused returns (address) {\n        return super._update(to, tokenId, auth);\n    }",
            "startLine": 36
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC721Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../../../utils/PausableUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC721/extensions/ERC721Pausable.sol)\n\npragma solidity ^0.8.24;\n\nimport {ERC721Upgradeable} from \"../ERC721Upgradeable.sol\";\nimport {PausableUpgradeable} from \"../../../utils/PausableUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC-721 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract pause mechanism of the contract unreachable, and thus unusable.\n */\nabstract contract ERC721PausableUpgradeable is Initializable, ERC721Upgradeable, PausableUpgradeable {\n    function __ERC721Pausable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC721-_update}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    ) internal virtual override whenNotPaused returns (address) {\n        return super._update(to, tokenId, auth);\n    }\n}\n"
      },
      {
        "name": "ERC721RoyaltyUpgradeable",
        "filePath": "token/ERC721/extensions/ERC721RoyaltyUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC2981Upgradeable",
          "ERC721Upgradeable"
        ],
        "implements": [],
        "category": "token/ERC721",
        "externalFunctions": [
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "supportsInterface",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, ERC2981Upgradeable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }",
            "startLine": 29
          }
        ],
        "internalFunctions": [
          {
            "name": "__ERC721Royalty_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC721Royalty_init() internal onlyInitializing {\n    }",
            "startLine": 23
          },
          {
            "name": "__ERC721Royalty_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC721Royalty_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 26
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC721Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/introspection/IERC165.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../../common/ERC2981Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC721/extensions/ERC721Royalty.sol)\n\npragma solidity ^0.8.24;\n\nimport {ERC721Upgradeable} from \"../ERC721Upgradeable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC2981Upgradeable} from \"../../common/ERC2981Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC-721 with the ERC-2981 NFT Royalty Standard, a standardized way to retrieve royalty payment\n * information.\n *\n * Royalty information can be specified globally for all token ids via {ERC2981-_setDefaultRoyalty}, and/or individually\n * for specific token ids via {ERC2981-_setTokenRoyalty}. The latter takes precedence over the first.\n *\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the ERC. Marketplaces are expected to\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\n */\nabstract contract ERC721RoyaltyUpgradeable is Initializable, ERC2981Upgradeable, ERC721Upgradeable {\n    function __ERC721Royalty_init() internal onlyInitializing {\n    }\n\n    function __ERC721Royalty_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, ERC2981Upgradeable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
      },
      {
        "name": "ERC721URIStorageUpgradeable",
        "filePath": "token/ERC721/extensions/ERC721URIStorageUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "IERC4906",
          "ERC721Upgradeable"
        ],
        "implements": [],
        "category": "token/ERC721",
        "externalFunctions": [
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "supportsInterface",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, IERC165) returns (bool) {\n        return interfaceId == ERC4906_INTERFACE_ID || super.supportsInterface(interfaceId);\n    }",
            "startLine": 41
          },
          {
            "name": "tokenURI",
            "signature": "tokenURI(uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_baseURI",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_suffixURI",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "tokenURI",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory base = _baseURI();\n        string memory suffix = _suffixURI(tokenId);\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return suffix;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via string.concat).\n        if (bytes(suffix).length > 0) {\n            return string.concat(base, suffix);\n        }\n\n        return super.tokenURI(tokenId);\n    }",
            "startLine": 46
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC721URIStorageStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC721URIStorageStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getERC721URIStorageStorage() private pure returns (ERC721URIStorageStorage storage $) {\n        assembly {\n            $.slot := ERC721URIStorageStorageLocation\n        }\n    }",
            "startLine": 29
          },
          {
            "name": "__ERC721URIStorage_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC721URIStorage_init() internal onlyInitializing {\n    }",
            "startLine": 35
          },
          {
            "name": "__ERC721URIStorage_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC721URIStorage_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 38
          },
          {
            "name": "_setTokenURI",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "_tokenURI",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC721URIStorageStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        ERC721URIStorageStorage storage $ = _getERC721URIStorageStorage();\n        $._tokenURIs[tokenId] = _tokenURI;\n        emit MetadataUpdate(tokenId);\n    }",
            "startLine": 69
          },
          {
            "name": "_suffixURI",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC721URIStorageStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _suffixURI(uint256 tokenId) internal view virtual returns (string memory) {\n        ERC721URIStorageStorage storage $ = _getERC721URIStorageStorage();\n        return $._tokenURIs[tokenId];\n    }",
            "startLine": 78
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "ERC721URIStorageStorage",
            "members": [
              {
                "name": "_tokenURIs",
                "type": "mapping(uint256 => string)"
              }
            ],
            "startLine": 21
          }
        ],
        "stateVariables": [
          {
            "name": "ERC4906_INTERFACE_ID",
            "type": "bytes4",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 18
          },
          {
            "name": "ERC721URIStorageStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 27
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC721Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/interfaces/IERC4906.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/introspection/IERC165.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.24;\n\nimport {ERC721Upgradeable} from \"../ERC721Upgradeable.sol\";\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {IERC4906} from \"@openzeppelin/contracts/interfaces/IERC4906.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC-721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorageUpgradeable is Initializable, IERC4906, ERC721Upgradeable {\n    // Interface ID as defined in ERC-4906. This does not correspond to a traditional interface ID as ERC-4906 only\n    // defines events and does not include any external function.\n    bytes4 private constant ERC4906_INTERFACE_ID = bytes4(0x49064906);\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC721URIStorage\n    struct ERC721URIStorageStorage {\n        // Optional mapping for token URIs\n        mapping(uint256 tokenId => string) _tokenURIs;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC721URIStorage\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC721URIStorageStorageLocation = 0x0542a41881ee128a365a727b282c86fa859579490b9bb45aab8503648c8e7900;\n\n    function _getERC721URIStorageStorage() private pure returns (ERC721URIStorageStorage storage $) {\n        assembly {\n            $.slot := ERC721URIStorageStorageLocation\n        }\n    }\n\n    function __ERC721URIStorage_init() internal onlyInitializing {\n    }\n\n    function __ERC721URIStorage_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, IERC165) returns (bool) {\n        return interfaceId == ERC4906_INTERFACE_ID || super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IERC721Metadata\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory base = _baseURI();\n        string memory suffix = _suffixURI(tokenId);\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return suffix;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via string.concat).\n        if (bytes(suffix).length > 0) {\n            return string.concat(base, suffix);\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Emits {IERC4906-MetadataUpdate}.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        ERC721URIStorageStorage storage $ = _getERC721URIStorageStorage();\n        $._tokenURIs[tokenId] = _tokenURI;\n        emit MetadataUpdate(tokenId);\n    }\n\n    /**\n     * @dev Returns the suffix part of the tokenURI for `tokenId`.\n     */\n    function _suffixURI(uint256 tokenId) internal view virtual returns (string memory) {\n        ERC721URIStorageStorage storage $ = _getERC721URIStorageStorage();\n        return $._tokenURIs[tokenId];\n    }\n}\n"
      },
      {
        "name": "ERC721VotesUpgradeable",
        "filePath": "token/ERC721/extensions/ERC721VotesUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC721Upgradeable",
          "VotesUpgradeable"
        ],
        "implements": [],
        "category": "token/ERC721",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "__ERC721Votes_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC721Votes_init() internal onlyInitializing {\n    }",
            "startLine": 19
          },
          {
            "name": "__ERC721Votes_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC721Votes_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 22
          },
          {
            "name": "_update",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "auth",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_update",
                "type": "super",
                "argCount": 3
              },
              {
                "target": "_transferVotingUnits",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n\n        _transferVotingUnits(previousOwner, to, 1);\n\n        return previousOwner;\n    }",
            "startLine": 29
          },
          {
            "name": "_getVotingUnits",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "balanceOf",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _getVotingUnits(address account) internal view virtual override returns (uint256) {\n        return balanceOf(account);\n    }",
            "startLine": 42
          },
          {
            "name": "_increaseBalance",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint128"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_increaseBalance",
                "type": "super",
                "argCount": 2
              },
              {
                "target": "_transferVotingUnits",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _increaseBalance(address account, uint128 amount) internal virtual override {\n        super._increaseBalance(account, amount);\n        _transferVotingUnits(address(0), account, amount);\n    }",
            "startLine": 49
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../ERC721Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "../../../governance/utils/VotesUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC721/extensions/ERC721Votes.sol)\n\npragma solidity ^0.8.24;\n\nimport {ERC721Upgradeable} from \"../ERC721Upgradeable.sol\";\nimport {VotesUpgradeable} from \"../../../governance/utils/VotesUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC-721 to support voting and delegation as implemented by {Votes}, where each individual NFT counts\n * as 1 vote unit.\n *\n * Tokens do not count as votes until they are delegated, because votes must be tracked which incurs an additional cost\n * on every transfer. Token holders can either delegate to a trusted representative who will decide how to make use of\n * the votes in governance decisions, or they can delegate to themselves to be their own representative.\n */\nabstract contract ERC721VotesUpgradeable is Initializable, ERC721Upgradeable, VotesUpgradeable {\n    function __ERC721Votes_init() internal onlyInitializing {\n    }\n\n    function __ERC721Votes_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC721-_update}. Adjusts votes when tokens are transferred.\n     *\n     * Emits a {IVotes-DelegateVotesChanged} event.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n\n        _transferVotingUnits(previousOwner, to, 1);\n\n        return previousOwner;\n    }\n\n    /**\n     * @dev Returns the balance of `account`.\n     *\n     * WARNING: Overriding this function will likely result in incorrect vote tracking.\n     */\n    function _getVotingUnits(address account) internal view virtual override returns (uint256) {\n        return balanceOf(account);\n    }\n\n    /**\n     * @dev See {ERC721-_increaseBalance}. We need that to account tokens that were minted in batch.\n     */\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        super._increaseBalance(account, amount);\n        _transferVotingUnits(address(0), account, amount);\n    }\n}\n"
      },
      {
        "name": "ERC721WrapperUpgradeable",
        "filePath": "token/ERC721/extensions/ERC721WrapperUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ERC721Upgradeable",
          "IERC721Receiver"
        ],
        "implements": [],
        "category": "token/ERC721",
        "externalFunctions": [
          {
            "name": "depositFor",
            "signature": "depositFor(address,uint256[])",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "tokenIds",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "underlying",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_safeMint",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function depositFor(address account, uint256[] memory tokenIds) public virtual returns (bool) {\n        uint256 length = tokenIds.length;\n        for (uint256 i = 0; i < length; ++i) {\n            uint256 tokenId = tokenIds[i];\n\n            // This is an \"unsafe\" transfer that doesn't call any hook on the receiver. With underlying() being trusted\n            // (by design of this contract) and no other contracts expected to be called from there, we are safe.\n            // slither-disable-next-line reentrancy-no-eth\n            underlying().transferFrom(_msgSender(), address(this), tokenId); // forge-lint: disable-line(erc20-unchecked-transfer)\n            _safeMint(account, tokenId);\n        }\n\n        return true;\n    }",
            "startLine": 50
          },
          {
            "name": "withdrawTo",
            "signature": "withdrawTo(address,uint256[])",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "tokenIds",
                "type": "uint256[]"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_update",
                "type": "internal",
                "argCount": 3
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "underlying",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function withdrawTo(address account, uint256[] memory tokenIds) public virtual returns (bool) {\n        uint256 length = tokenIds.length;\n        for (uint256 i = 0; i < length; ++i) {\n            uint256 tokenId = tokenIds[i];\n            // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n            // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n            _update(address(0), tokenId, _msgSender());\n            // Checks were already performed at this point, and there's no way to retake ownership or approval from\n            // the wrapped tokenId after this point, so it's safe to remove the reentrancy check for the next line.\n            // slither-disable-next-line reentrancy-no-eth\n            underlying().safeTransferFrom(address(this), account, tokenId);\n        }\n\n        return true;\n    }",
            "startLine": 68
          },
          {
            "name": "onERC721Received",
            "signature": "onERC721Received(address,address,uint256,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes4"
              }
            ],
            "calls": [
              {
                "target": "underlying",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_safeMint",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function onERC721Received(address, address from, uint256 tokenId, bytes memory) public virtual returns (bytes4) {\n        if (address(underlying()) != _msgSender()) {\n            revert ERC721UnsupportedToken(_msgSender());\n        }\n        _safeMint(from, tokenId);\n        return IERC721Receiver.onERC721Received.selector;\n    }",
            "startLine": 94
          },
          {
            "name": "underlying",
            "signature": "underlying()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "IERC721"
              }
            ],
            "calls": [
              {
                "target": "_getERC721WrapperStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function underlying() public view virtual returns (IERC721) {\n        ERC721WrapperStorage storage $ = _getERC721WrapperStorage();\n        return $._underlying;\n    }",
            "startLine": 118
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC721WrapperStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC721WrapperStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getERC721WrapperStorage() private pure returns (ERC721WrapperStorage storage $) {\n        assembly {\n            $.slot := ERC721WrapperStorageLocation\n        }\n    }",
            "startLine": 27
          },
          {
            "name": "__ERC721Wrapper_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "underlyingToken",
                "type": "IERC721"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC721Wrapper_init(IERC721 underlyingToken) internal onlyInitializing {\n        __ERC721Wrapper_init_unchained(underlyingToken);\n    }",
            "startLine": 38
          },
          {
            "name": "__ERC721Wrapper_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "underlyingToken",
                "type": "IERC721"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC721WrapperStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __ERC721Wrapper_init_unchained(IERC721 underlyingToken) internal onlyInitializing {\n        ERC721WrapperStorage storage $ = _getERC721WrapperStorage();\n        $._underlying = underlyingToken;\n    }",
            "startLine": 42
          },
          {
            "name": "_recover",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "underlying",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_safeMint",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _recover(address account, uint256 tokenId) internal virtual returns (uint256) {\n        address owner = underlying().ownerOf(tokenId);\n        if (owner != address(this)) {\n            revert ERC721IncorrectOwner(address(this), tokenId, owner);\n        }\n        _safeMint(account, tokenId);\n        return tokenId;\n    }",
            "startLine": 106
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ERC721UnsupportedToken",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              }
            ],
            "startLine": 36
          }
        ],
        "structs": [
          {
            "name": "ERC721WrapperStorage",
            "members": [
              {
                "name": "_underlying",
                "type": "IERC721"
              }
            ],
            "startLine": 20
          }
        ],
        "stateVariables": [
          {
            "name": "ERC721WrapperStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 25
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/token/ERC721/IERC721.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../ERC721Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC721/extensions/ERC721Wrapper.sol)\n\npragma solidity ^0.8.24;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {ERC721Upgradeable} from \"../ERC721Upgradeable.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of the ERC-721 token contract to support token wrapping.\n *\n * Users can deposit and withdraw an \"underlying token\" and receive a \"wrapped token\" with a matching tokenId. This is\n * useful in conjunction with other modules. For example, combining this wrapping mechanism with {ERC721Votes} will allow\n * the wrapping of an existing \"basic\" ERC-721 into a governance token.\n */\nabstract contract ERC721WrapperUpgradeable is Initializable, ERC721Upgradeable, IERC721Receiver {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC721Wrapper\n    struct ERC721WrapperStorage {\n        IERC721 _underlying;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC721Wrapper\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC721WrapperStorageLocation = 0xa27ade666fc2e768f0cfbad659dfd6a7039cae52f9274d2ab808f70dce364400;\n\n    function _getERC721WrapperStorage() private pure returns (ERC721WrapperStorage storage $) {\n        assembly {\n            $.slot := ERC721WrapperStorageLocation\n        }\n    }\n\n    /**\n     * @dev The received ERC-721 token couldn't be wrapped.\n     */\n    error ERC721UnsupportedToken(address token);\n\n    function __ERC721Wrapper_init(IERC721 underlyingToken) internal onlyInitializing {\n        __ERC721Wrapper_init_unchained(underlyingToken);\n    }\n\n    function __ERC721Wrapper_init_unchained(IERC721 underlyingToken) internal onlyInitializing {\n        ERC721WrapperStorage storage $ = _getERC721WrapperStorage();\n        $._underlying = underlyingToken;\n    }\n\n    /**\n     * @dev Allow a user to deposit underlying tokens and mint the corresponding tokenIds.\n     */\n    function depositFor(address account, uint256[] memory tokenIds) public virtual returns (bool) {\n        uint256 length = tokenIds.length;\n        for (uint256 i = 0; i < length; ++i) {\n            uint256 tokenId = tokenIds[i];\n\n            // This is an \"unsafe\" transfer that doesn't call any hook on the receiver. With underlying() being trusted\n            // (by design of this contract) and no other contracts expected to be called from there, we are safe.\n            // slither-disable-next-line reentrancy-no-eth\n            underlying().transferFrom(_msgSender(), address(this), tokenId); // forge-lint: disable-line(erc20-unchecked-transfer)\n            _safeMint(account, tokenId);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Allow a user to burn wrapped tokens and withdraw the corresponding tokenIds of the underlying tokens.\n     */\n    function withdrawTo(address account, uint256[] memory tokenIds) public virtual returns (bool) {\n        uint256 length = tokenIds.length;\n        for (uint256 i = 0; i < length; ++i) {\n            uint256 tokenId = tokenIds[i];\n            // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n            // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n            _update(address(0), tokenId, _msgSender());\n            // Checks were already performed at this point, and there's no way to retake ownership or approval from\n            // the wrapped tokenId after this point, so it's safe to remove the reentrancy check for the next line.\n            // slither-disable-next-line reentrancy-no-eth\n            underlying().safeTransferFrom(address(this), account, tokenId);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Overrides {IERC721Receiver-onERC721Received} to allow minting on direct ERC-721 transfers to\n     * this contract.\n     *\n     * In case there's data attached, it validates that the operator is this contract, so only trusted data\n     * is accepted from {depositFor}.\n     *\n     * WARNING: Doesn't work with unsafe transfers (eg. {IERC721-transferFrom}). Use {ERC721Wrapper-_recover}\n     * for recovering in that scenario.\n     */\n    function onERC721Received(address, address from, uint256 tokenId, bytes memory) public virtual returns (bytes4) {\n        if (address(underlying()) != _msgSender()) {\n            revert ERC721UnsupportedToken(_msgSender());\n        }\n        _safeMint(from, tokenId);\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    /**\n     * @dev Mint a wrapped token to cover any underlyingToken that would have been transferred by mistake. Internal\n     * function that can be exposed with access control if desired.\n     */\n    function _recover(address account, uint256 tokenId) internal virtual returns (uint256) {\n        address owner = underlying().ownerOf(tokenId);\n        if (owner != address(this)) {\n            revert ERC721IncorrectOwner(address(this), tokenId, owner);\n        }\n        _safeMint(account, tokenId);\n        return tokenId;\n    }\n\n    /**\n     * @dev Returns the underlying token.\n     */\n    function underlying() public view virtual returns (IERC721) {\n        ERC721WrapperStorage storage $ = _getERC721WrapperStorage();\n        return $._underlying;\n    }\n}\n"
      },
      {
        "name": "ERC2981Upgradeable",
        "filePath": "token/common/ERC2981Upgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "IERC2981",
          "ERC165Upgradeable"
        ],
        "implements": [],
        "category": "token/common",
        "externalFunctions": [
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "supportsInterface",
                "type": "super",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }",
            "startLine": 71
          },
          {
            "name": "royaltyInfo",
            "signature": "royaltyInfo(uint256,uint256)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "salePrice",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC2981Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_feeDenominator",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function royaltyInfo(\n        uint256 tokenId,\n        uint256 salePrice\n    ) public view virtual returns (address receiver, uint256 amount) {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        RoyaltyInfo storage _royaltyInfo = $._tokenRoyaltyInfo[tokenId];\n        address royaltyReceiver = _royaltyInfo.receiver;\n        uint96 royaltyFraction = _royaltyInfo.royaltyFraction;\n\n        if (royaltyReceiver == address(0)) {\n            royaltyReceiver = $._defaultRoyaltyInfo.receiver;\n            royaltyFraction = $._defaultRoyaltyInfo.royaltyFraction;\n        }\n\n        uint256 royaltyAmount = (salePrice * royaltyFraction) / _feeDenominator();\n\n        return (royaltyReceiver, royaltyAmount);\n    }",
            "startLine": 76
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC2981Storage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC2981Storage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getERC2981Storage() private pure returns (ERC2981Storage storage $) {\n        assembly {\n            $.slot := ERC2981StorageLocation\n        }\n    }",
            "startLine": 39
          },
          {
            "name": "__ERC2981_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC2981_init() internal onlyInitializing {\n    }",
            "startLine": 65
          },
          {
            "name": "__ERC2981_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC2981_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 68
          },
          {
            "name": "_feeDenominator",
            "visibility": "internal",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint96"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }",
            "startLine": 100
          },
          {
            "name": "_setDefaultRoyalty",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "feeNumerator",
                "type": "uint96"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC2981Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_feeDenominator",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "RoyaltyInfo",
                "type": "external",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            // Royalty fee will exceed the sale price\n            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));\n        }\n\n        $._defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }",
            "startLine": 112
          },
          {
            "name": "_deleteDefaultRoyalty",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC2981Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _deleteDefaultRoyalty() internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._defaultRoyaltyInfo;\n    }",
            "startLine": 129
          },
          {
            "name": "_setTokenRoyalty",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "feeNumerator",
                "type": "uint96"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC2981Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_feeDenominator",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "RoyaltyInfo",
                "type": "external",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            // Royalty fee will exceed the sale price\n            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));\n        }\n\n        $._tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }",
            "startLine": 142
          },
          {
            "name": "_resetTokenRoyalty",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC2981Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._tokenRoyaltyInfo[tokenId];\n    }",
            "startLine": 159
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "ERC2981InvalidDefaultRoyalty",
            "parameters": [
              {
                "name": "numerator",
                "type": "uint256"
              },
              {
                "name": "denominator",
                "type": "uint256"
              }
            ],
            "startLine": 48
          },
          {
            "name": "ERC2981InvalidDefaultRoyaltyReceiver",
            "parameters": [
              {
                "name": "receiver",
                "type": "address"
              }
            ],
            "startLine": 53
          },
          {
            "name": "ERC2981InvalidTokenRoyalty",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "numerator",
                "type": "uint256"
              },
              {
                "name": "denominator",
                "type": "uint256"
              }
            ],
            "startLine": 58
          },
          {
            "name": "ERC2981InvalidTokenRoyaltyReceiver",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "receiver",
                "type": "address"
              }
            ],
            "startLine": 63
          }
        ],
        "structs": [
          {
            "name": "RoyaltyInfo",
            "members": [
              {
                "name": "receiver",
                "type": "address"
              },
              {
                "name": "royaltyFraction",
                "type": "uint96"
              }
            ],
            "startLine": 25
          },
          {
            "name": "ERC2981Storage",
            "members": [
              {
                "name": "_defaultRoyaltyInfo",
                "type": "RoyaltyInfo"
              },
              {
                "name": "_tokenRoyaltyInfo",
                "type": "mapping(uint256 => RoyaltyInfo)"
              }
            ],
            "startLine": 31
          }
        ],
        "stateVariables": [
          {
            "name": "ERC2981StorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 37
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/interfaces/IERC2981.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/introspection/IERC165.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../../utils/introspection/ERC165Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/common/ERC2981.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC2981} from \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\n *\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\n *\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\n * fee is specified in basis points by default.\n *\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the ERC. Marketplaces are expected to\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\n */\nabstract contract ERC2981Upgradeable is Initializable, IERC2981, ERC165Upgradeable {\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC2981\n    struct ERC2981Storage {\n        RoyaltyInfo _defaultRoyaltyInfo;\n        mapping(uint256 tokenId => RoyaltyInfo) _tokenRoyaltyInfo;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC2981\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC2981StorageLocation = 0xdaedc9ab023613a7caf35e703657e986ccfad7e3eb0af93a2853f8d65dd86b00;\n\n    function _getERC2981Storage() private pure returns (ERC2981Storage storage $) {\n        assembly {\n            $.slot := ERC2981StorageLocation\n        }\n    }\n\n    /**\n     * @dev The default royalty set is invalid (eg. (numerator / denominator) >= 1).\n     */\n    error ERC2981InvalidDefaultRoyalty(uint256 numerator, uint256 denominator);\n\n    /**\n     * @dev The default royalty receiver is invalid.\n     */\n    error ERC2981InvalidDefaultRoyaltyReceiver(address receiver);\n\n    /**\n     * @dev The royalty set for a specific `tokenId` is invalid (eg. (numerator / denominator) >= 1).\n     */\n    error ERC2981InvalidTokenRoyalty(uint256 tokenId, uint256 numerator, uint256 denominator);\n\n    /**\n     * @dev The royalty receiver for `tokenId` is invalid.\n     */\n    error ERC2981InvalidTokenRoyaltyReceiver(uint256 tokenId, address receiver);\n\n    function __ERC2981_init() internal onlyInitializing {\n    }\n\n    function __ERC2981_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IERC2981\n    function royaltyInfo(\n        uint256 tokenId,\n        uint256 salePrice\n    ) public view virtual returns (address receiver, uint256 amount) {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        RoyaltyInfo storage _royaltyInfo = $._tokenRoyaltyInfo[tokenId];\n        address royaltyReceiver = _royaltyInfo.receiver;\n        uint96 royaltyFraction = _royaltyInfo.royaltyFraction;\n\n        if (royaltyReceiver == address(0)) {\n            royaltyReceiver = $._defaultRoyaltyInfo.receiver;\n            royaltyFraction = $._defaultRoyaltyInfo.royaltyFraction;\n        }\n\n        uint256 royaltyAmount = (salePrice * royaltyFraction) / _feeDenominator();\n\n        return (royaltyReceiver, royaltyAmount);\n    }\n\n    /**\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\n     * override.\n     */\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n\n    /**\n     * @dev Sets the royalty information that all ids in this contract will default to.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            // Royalty fee will exceed the sale price\n            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));\n        }\n\n        $._defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Removes default royalty information.\n     */\n    function _deleteDefaultRoyalty() internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._defaultRoyaltyInfo;\n    }\n\n    /**\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            // Royalty fee will exceed the sale price\n            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));\n        }\n\n        $._tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Resets royalty information for the token id back to the global default.\n     */\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        ERC2981Storage storage $ = _getERC2981Storage();\n        delete $._tokenRoyaltyInfo[tokenId];\n    }\n}\n"
      },
      {
        "name": "ContextUpgradeable",
        "filePath": "utils/ContextUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable"
        ],
        "implements": [],
        "category": "utils",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "__Context_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __Context_init() internal onlyInitializing {\n    }",
            "startLine": 18
          },
          {
            "name": "__Context_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __Context_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 21
          },
          {
            "name": "_msgSender",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }",
            "startLine": 23
          },
          {
            "name": "_msgData",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }",
            "startLine": 27
          },
          {
            "name": "_contextSuffixLength",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": true,
            "sourceCode": "function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }",
            "startLine": 31
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      {
        "name": "MulticallUpgradeable",
        "filePath": "utils/MulticallUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ContextUpgradeable"
        ],
        "implements": [],
        "category": "utils",
        "externalFunctions": [
          {
            "name": "multicall",
            "signature": "multicall(bytes[])",
            "selector": "",
            "visibility": "public",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "data",
                "type": "bytes[]"
              }
            ],
            "returnValues": [
              {
                "name": "results",
                "type": "bytes[]"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_contextSuffixLength",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "Address.functionDelegateCall",
                "type": "library",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function multicall(bytes[] calldata data) public virtual returns (bytes[] memory results) {\n        bytes memory context = msg.sender == _msgSender()\n            ? new bytes(0)\n            : msg.data[msg.data.length - _contextSuffixLength():];\n\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = Address.functionDelegateCall(address(this), bytes.concat(data[i], context));\n        }\n        return results;\n    }",
            "startLine": 32
          }
        ],
        "internalFunctions": [
          {
            "name": "__Multicall_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __Multicall_init() internal onlyInitializing {\n    }",
            "startLine": 23
          },
          {
            "name": "__Multicall_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __Multicall_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 26
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/utils/Address.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "./ContextUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/Multicall.sol)\n\npragma solidity ^0.8.20;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ContextUpgradeable} from \"./ContextUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * Consider any assumption about calldata validation performed by the sender may be violated if it's not especially\n * careful about sending transactions invoking {multicall}. For example, a relay address that filters function\n * selectors won't filter calls nested within a {multicall} operation.\n *\n * NOTE: Since 5.0.1 and 4.9.4, this contract identifies non-canonical contexts (i.e. `msg.sender` is not {Context-_msgSender}).\n * If a non-canonical context is identified, the following self `delegatecall` appends the last bytes of `msg.data`\n * to the subcall. This makes it safe to use with {ERC2771Context}. Contexts that don't affect the resolution of\n * {Context-_msgSender} are not propagated to subcalls.\n */\nabstract contract MulticallUpgradeable is Initializable, ContextUpgradeable {\n    function __Multicall_init() internal onlyInitializing {\n    }\n\n    function __Multicall_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function multicall(bytes[] calldata data) public virtual returns (bytes[] memory results) {\n        bytes memory context = msg.sender == _msgSender()\n            ? new bytes(0)\n            : msg.data[msg.data.length - _contextSuffixLength():];\n\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = Address.functionDelegateCall(address(this), bytes.concat(data[i], context));\n        }\n        return results;\n    }\n}\n"
      },
      {
        "name": "NoncesKeyedUpgradeable",
        "filePath": "utils/NoncesKeyedUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "NoncesUpgradeable"
        ],
        "implements": [],
        "category": "utils",
        "externalFunctions": [
          {
            "name": "nonces",
            "signature": "nonces(address,uint192)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "key",
                "type": "uint192"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getNoncesKeyedStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "nonces",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_pack",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function nonces(address owner, uint192 key) public view virtual returns (uint256) {\n        NoncesKeyedStorage storage $ = _getNoncesKeyedStorage();\n        return key == 0 ? nonces(owner) : _pack(key, $._nonces[owner][key]);\n    }",
            "startLine": 38
          }
        ],
        "internalFunctions": [
          {
            "name": "_getNoncesKeyedStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "NoncesKeyedStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getNoncesKeyedStorage() private pure returns (NoncesKeyedStorage storage $) {\n        assembly {\n            $.slot := NoncesKeyedStorageLocation\n        }\n    }",
            "startLine": 26
          },
          {
            "name": "__NoncesKeyed_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __NoncesKeyed_init() internal onlyInitializing {\n    }",
            "startLine": 32
          },
          {
            "name": "__NoncesKeyed_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __NoncesKeyed_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 35
          },
          {
            "name": "_useNonce",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "key",
                "type": "uint192"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getNoncesKeyedStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_useNonce",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_pack",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _useNonce(address owner, uint192 key) internal virtual returns (uint256) {\n        NoncesKeyedStorage storage $ = _getNoncesKeyedStorage();\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return key == 0 ? _useNonce(owner) : _pack(key, $._nonces[owner][key]++);\n        }\n    }",
            "startLine": 49
          },
          {
            "name": "_useCheckedNonce",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "keyNonce",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_unpack",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_useCheckedNonce",
                "type": "super",
                "argCount": 2
              },
              {
                "target": "_useNonce",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _useCheckedNonce(address owner, uint256 keyNonce) internal virtual override {\n        (uint192 key, ) = _unpack(keyNonce);\n        if (key == 0) {\n            super._useCheckedNonce(owner, keyNonce);\n        } else {\n            uint256 current = _useNonce(owner, key);\n            if (keyNonce != current) revert InvalidAccountNonce(owner, current);\n        }\n    }",
            "startLine": 66
          },
          {
            "name": "_useCheckedNonce",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "key",
                "type": "uint192"
              },
              {
                "name": "nonce",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useCheckedNonce",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_pack",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _useCheckedNonce(address owner, uint192 key, uint64 nonce) internal virtual {\n        _useCheckedNonce(owner, _pack(key, nonce));\n    }",
            "startLine": 81
          },
          {
            "name": "_pack",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "key",
                "type": "uint192"
              },
              {
                "name": "nonce",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _pack(uint192 key, uint64 nonce) private pure returns (uint256) {\n        return (uint256(key) << 64) | nonce;\n    }",
            "startLine": 86
          },
          {
            "name": "_unpack",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "keyNonce",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "key",
                "type": "uint192"
              },
              {
                "name": "nonce",
                "type": "uint64"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _unpack(uint256 keyNonce) private pure returns (uint192 key, uint64 nonce) {\n        return (uint192(keyNonce >> 64), uint64(keyNonce));\n    }",
            "startLine": 91
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "NoncesKeyedStorage",
            "members": [
              {
                "name": "_nonces",
                "type": "mapping(address => mapping(uint192 => uint64))"
              }
            ],
            "startLine": 19
          }
        ],
        "stateVariables": [
          {
            "name": "NoncesKeyedStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 24
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./NoncesUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/NoncesKeyed.sol)\npragma solidity ^0.8.20;\n\nimport {NoncesUpgradeable} from \"./NoncesUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Alternative to {Nonces}, that supports key-ed nonces.\n *\n * Follows the https://eips.ethereum.org/EIPS/eip-4337#semi-abstracted-nonce-support[ERC-4337's semi-abstracted nonce system].\n *\n * NOTE: This contract inherits from {Nonces} and reuses its storage for the first nonce key (i.e. `0`). This\n * makes upgrading from {Nonces} to {NoncesKeyed} safe when using their upgradeable versions (e.g. `NoncesKeyedUpgradeable`).\n * Doing so will NOT reset the current state of nonces, avoiding replay attacks where a nonce is reused after the upgrade.\n */\nabstract contract NoncesKeyedUpgradeable is Initializable, NoncesUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.NoncesKeyed\n    struct NoncesKeyedStorage {\n        mapping(address owner => mapping(uint192 key => uint64)) _nonces;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.NoncesKeyed\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant NoncesKeyedStorageLocation = 0x06e302b11020b9cca26edb75da0d4c952e2c49f7ac00d8954230e81bd5769c00;\n\n    function _getNoncesKeyedStorage() private pure returns (NoncesKeyedStorage storage $) {\n        assembly {\n            $.slot := NoncesKeyedStorageLocation\n        }\n    }\n\n    function __NoncesKeyed_init() internal onlyInitializing {\n    }\n\n    function __NoncesKeyed_init_unchained() internal onlyInitializing {\n    }\n    /// @dev Returns the next unused nonce for an address and key. Result contains the key prefix.\n    function nonces(address owner, uint192 key) public view virtual returns (uint256) {\n        NoncesKeyedStorage storage $ = _getNoncesKeyedStorage();\n        return key == 0 ? nonces(owner) : _pack(key, $._nonces[owner][key]);\n    }\n\n    /**\n     * @dev Consumes the next unused nonce for an address and key.\n     *\n     * Returns the current value without the key prefix. Consumed nonce is increased, so calling this function twice\n     * with the same arguments will return different (sequential) results.\n     */\n    function _useNonce(address owner, uint192 key) internal virtual returns (uint256) {\n        NoncesKeyedStorage storage $ = _getNoncesKeyedStorage();\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return key == 0 ? _useNonce(owner) : _pack(key, $._nonces[owner][key]++);\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     *\n     * This version takes the key and the nonce in a single uint256 parameter:\n     * - use the first 24 bytes for the key\n     * - use the last 8 bytes for the nonce\n     */\n    function _useCheckedNonce(address owner, uint256 keyNonce) internal virtual override {\n        (uint192 key, ) = _unpack(keyNonce);\n        if (key == 0) {\n            super._useCheckedNonce(owner, keyNonce);\n        } else {\n            uint256 current = _useNonce(owner, key);\n            if (keyNonce != current) revert InvalidAccountNonce(owner, current);\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     *\n     * This version takes the key and the nonce as two different parameters.\n     */\n    function _useCheckedNonce(address owner, uint192 key, uint64 nonce) internal virtual {\n        _useCheckedNonce(owner, _pack(key, nonce));\n    }\n\n    /// @dev Pack key and nonce into a keyNonce\n    function _pack(uint192 key, uint64 nonce) private pure returns (uint256) {\n        return (uint256(key) << 64) | nonce;\n    }\n\n    /// @dev Unpack a keyNonce into its key and nonce components\n    function _unpack(uint256 keyNonce) private pure returns (uint192 key, uint64 nonce) {\n        return (uint192(keyNonce >> 64), uint64(keyNonce));\n    }\n}\n"
      },
      {
        "name": "NoncesUpgradeable",
        "filePath": "utils/NoncesUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable"
        ],
        "implements": [],
        "category": "utils",
        "externalFunctions": [
          {
            "name": "nonces",
            "signature": "nonces(address)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getNoncesStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function nonces(address owner) public view virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        return $._nonces[owner];\n    }",
            "startLine": 37
          }
        ],
        "internalFunctions": [
          {
            "name": "_getNoncesStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "NoncesStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getNoncesStorage() private pure returns (NoncesStorage storage $) {\n        assembly {\n            $.slot := NoncesStorageLocation\n        }\n    }",
            "startLine": 23
          },
          {
            "name": "__Nonces_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __Nonces_init() internal onlyInitializing {\n    }",
            "startLine": 29
          },
          {
            "name": "__Nonces_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __Nonces_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 32
          },
          {
            "name": "_useNonce",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getNoncesStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _useNonce(address owner) internal virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return $._nonces[owner]++;\n        }\n    }",
            "startLine": 47
          },
          {
            "name": "_useCheckedNonce",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "nonce",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_useNonce",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }",
            "startLine": 60
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "InvalidAccountNonce",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "currentNonce",
                "type": "uint256"
              }
            ],
            "startLine": 13
          }
        ],
        "structs": [
          {
            "name": "NoncesStorage",
            "members": [
              {
                "name": "_nonces",
                "type": "mapping(address => uint256)"
              }
            ],
            "startLine": 16
          }
        ],
        "stateVariables": [
          {
            "name": "NoncesStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 21
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract NoncesUpgradeable is Initializable {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.Nonces\n    struct NoncesStorage {\n        mapping(address account => uint256) _nonces;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Nonces\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant NoncesStorageLocation = 0x5ab42ced628888259c08ac98db1eb0cf702fc1501344311d8b100cd1bfe4bb00;\n\n    function _getNoncesStorage() private pure returns (NoncesStorage storage $) {\n        assembly {\n            $.slot := NoncesStorageLocation\n        }\n    }\n\n    function __Nonces_init() internal onlyInitializing {\n    }\n\n    function __Nonces_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        return $._nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        NoncesStorage storage $ = _getNoncesStorage();\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return $._nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
      },
      {
        "name": "PausableUpgradeable",
        "filePath": "utils/PausableUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "ContextUpgradeable"
        ],
        "implements": [],
        "category": "utils",
        "externalFunctions": [
          {
            "name": "paused",
            "signature": "paused()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getPausableStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }",
            "startLine": 85
          }
        ],
        "internalFunctions": [
          {
            "name": "_getPausableStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "PausableStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }",
            "startLine": 27
          },
          {
            "name": "__Pausable_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __Pausable_init() internal onlyInitializing {\n    }",
            "startLine": 77
          },
          {
            "name": "__Pausable_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __Pausable_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 80
          },
          {
            "name": "_requireNotPaused",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "paused",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }",
            "startLine": 93
          },
          {
            "name": "_requirePaused",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "paused",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }",
            "startLine": 102
          },
          {
            "name": "_pause",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getPausableStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }",
            "startLine": 115
          },
          {
            "name": "_unpause",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getPausableStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }",
            "startLine": 128
          }
        ],
        "events": [
          {
            "name": "Paused",
            "parameters": [
              {
                "name": "account",
                "type": "address",
                "indexed": false
              }
            ],
            "startLine": 36
          },
          {
            "name": "Unpaused",
            "parameters": [
              {
                "name": "account",
                "type": "address",
                "indexed": false
              }
            ],
            "startLine": 41
          }
        ],
        "errors": [
          {
            "name": "EnforcedPause",
            "parameters": [],
            "startLine": 46
          },
          {
            "name": "ExpectedPause",
            "parameters": [],
            "startLine": 51
          }
        ],
        "structs": [
          {
            "name": "PausableStorage",
            "members": [
              {
                "name": "_paused",
                "type": "bool"
              }
            ],
            "startLine": 20
          }
        ],
        "stateVariables": [
          {
            "name": "PausableStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 25
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "../utils/ContextUpgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    function __Pausable_init() internal onlyInitializing {\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
      },
      {
        "name": "EIP712Upgradeable",
        "filePath": "utils/cryptography/EIP712Upgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "IERC5267"
        ],
        "implements": [],
        "category": "utils/cryptography",
        "externalFunctions": [
          {
            "name": "eip712Domain",
            "signature": "eip712Domain()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "fields",
                "type": "bytes1"
              },
              {
                "name": "name",
                "type": "string"
              },
              {
                "name": "version",
                "type": "string"
              },
              {
                "name": "chainId",
                "type": "uint256"
              },
              {
                "name": "verifyingContract",
                "type": "address"
              },
              {
                "name": "salt",
                "type": "bytes32"
              },
              {
                "name": "extensions",
                "type": "uint256[]"
              }
            ],
            "calls": [
              {
                "target": "_EIP712Name",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_EIP712Version",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }",
            "startLine": 106
          }
        ],
        "internalFunctions": [
          {
            "name": "_getEIP712Storage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "EIP712Storage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }",
            "startLine": 47
          },
          {
            "name": "__EIP712_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name",
                "type": "string"
              },
              {
                "name": "version",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }",
            "startLine": 65
          },
          {
            "name": "__EIP712_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name",
                "type": "string"
              },
              {
                "name": "version",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getEIP712Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n    }",
            "startLine": 69
          },
          {
            "name": "_domainSeparatorV4",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_buildDomainSeparator",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }",
            "startLine": 78
          },
          {
            "name": "_buildDomainSeparator",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_EIP712NameHash",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_EIP712VersionHash",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }",
            "startLine": 82
          },
          {
            "name": "_hashTypedDataV4",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "structHash",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "MessageHashUtils.toTypedDataHash",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "_domainSeparatorV4",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }",
            "startLine": 101
          },
          {
            "name": "_EIP712Name",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getEIP712Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }",
            "startLine": 137
          },
          {
            "name": "_EIP712Version",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getEIP712Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }",
            "startLine": 148
          },
          {
            "name": "_EIP712NameHash",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_EIP712Name",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _EIP712NameHash() internal view returns (bytes32) {\n        return keccak256(bytes(_EIP712Name()));\n    }",
            "startLine": 158
          },
          {
            "name": "_EIP712VersionHash",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_EIP712Version",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _EIP712VersionHash() internal view returns (bytes32) {\n        return keccak256(bytes(_EIP712Version()));\n    }",
            "startLine": 167
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "EIP712Storage",
            "members": [
              {
                "name": "_hashedName",
                "type": "bytes32"
              },
              {
                "name": "_hashedVersion",
                "type": "bytes32"
              },
              {
                "name": "_name",
                "type": "string"
              },
              {
                "name": "_version",
                "type": "string"
              }
            ],
            "startLine": 36
          }
        ],
        "stateVariables": [
          {
            "name": "TYPE_HASH",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 32
          },
          {
            "name": "EIP712StorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 45
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/interfaces/IERC5267.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.24;\n\nimport {MessageHashUtils} from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport {IERC5267} from \"@openzeppelin/contracts/interfaces/IERC5267.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP-712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP-712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: The upgradeable version of this contract does not use an immutable cache and recomputes the domain separator\n * each time {_domainSeparatorV4} is called. This is cheaper than accessing a cached version in cold storage.\n */\nabstract contract EIP712Upgradeable is Initializable, IERC5267 {\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.EIP712\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n\n        string _name;\n        string _version;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.EIP712\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP-712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /// @inheritdoc IERC5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\n     */\n    function _EIP712NameHash() internal view returns (bytes32) {\n        return keccak256(bytes(_EIP712Name()));\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\n     */\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        return keccak256(bytes(_EIP712Version()));\n    }\n}\n"
      },
      {
        "name": "MultiSignerERC7913Upgradeable",
        "filePath": "utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "AbstractSigner"
        ],
        "implements": [],
        "category": "utils/cryptography",
        "externalFunctions": [
          {
            "name": "getSigners",
            "signature": "getSigners(uint64,uint64)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "start",
                "type": "uint64"
              },
              {
                "name": "end",
                "type": "uint64"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes[]"
              }
            ],
            "calls": [
              {
                "target": "_getMultiSignerERC7913Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "EnumerableSet.values",
                "type": "library",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getSigners(uint64 start, uint64 end) public view virtual returns (bytes[] memory) {\n        MultiSignerERC7913Storage storage $ = _getMultiSignerERC7913Storage();\n        return $._signers.values(start, end);\n    }",
            "startLine": 107
          },
          {
            "name": "getSignerCount",
            "signature": "getSignerCount()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getMultiSignerERC7913Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "EnumerableSet.length",
                "type": "library",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function getSignerCount() public view virtual returns (uint256) {\n        MultiSignerERC7913Storage storage $ = _getMultiSignerERC7913Storage();\n        return $._signers.length();\n    }",
            "startLine": 113
          },
          {
            "name": "isSigner",
            "signature": "isSigner(bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getMultiSignerERC7913Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "EnumerableSet.contains",
                "type": "library",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function isSigner(bytes memory signer) public view virtual returns (bool) {\n        MultiSignerERC7913Storage storage $ = _getMultiSignerERC7913Storage();\n        return $._signers.contains(signer);\n    }",
            "startLine": 119
          },
          {
            "name": "threshold",
            "signature": "threshold()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getMultiSignerERC7913Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function threshold() public view virtual returns (uint64) {\n        MultiSignerERC7913Storage storage $ = _getMultiSignerERC7913Storage();\n        return $._threshold;\n    }",
            "startLine": 125
          }
        ],
        "internalFunctions": [
          {
            "name": "_getMultiSignerERC7913Storage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "MultiSignerERC7913Storage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getMultiSignerERC7913Storage() private pure returns (MultiSignerERC7913Storage storage $) {\n        assembly {\n            $.slot := MultiSignerERC7913StorageLocation\n        }\n    }",
            "startLine": 59
          },
          {
            "name": "__MultiSignerERC7913_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "signers_",
                "type": "bytes[]"
              },
              {
                "name": "threshold_",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __MultiSignerERC7913_init(bytes[] memory signers_, uint64 threshold_) internal onlyInitializing {\n        __MultiSignerERC7913_init_unchained(signers_, threshold_);\n    }",
            "startLine": 89
          },
          {
            "name": "__MultiSignerERC7913_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "signers_",
                "type": "bytes[]"
              },
              {
                "name": "threshold_",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_addSigners",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_setThreshold",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __MultiSignerERC7913_init_unchained(bytes[] memory signers_, uint64 threshold_) internal onlyInitializing {\n        _addSigners(signers_);\n        _setThreshold(threshold_);\n    }",
            "startLine": 93
          },
          {
            "name": "_addSigners",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newSigners",
                "type": "bytes[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getMultiSignerERC7913Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "EnumerableSet.add",
                "type": "library",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _addSigners(bytes[] memory newSigners) internal virtual {\n        MultiSignerERC7913Storage storage $ = _getMultiSignerERC7913Storage();\n        for (uint256 i = 0; i < newSigners.length; ++i) {\n            bytes memory signer = newSigners[i];\n            require(signer.length >= 20, MultiSignerERC7913InvalidSigner(signer));\n            require($._signers.add(signer), MultiSignerERC7913AlreadyExists(signer));\n            emit ERC7913SignerAdded(signer);\n        }\n    }",
            "startLine": 146
          },
          {
            "name": "_removeSigners",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "oldSigners",
                "type": "bytes[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getMultiSignerERC7913Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "EnumerableSet.remove",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "MultiSignerERC7913NonexistentSigner",
                "type": "external",
                "argCount": 1
              },
              {
                "target": "_validateReachableThreshold",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _removeSigners(bytes[] memory oldSigners) internal virtual {\n        MultiSignerERC7913Storage storage $ = _getMultiSignerERC7913Storage();\n        for (uint256 i = 0; i < oldSigners.length; ++i) {\n            bytes memory signer = oldSigners[i];\n            require($._signers.remove(signer), MultiSignerERC7913NonexistentSigner(signer));\n            emit ERC7913SignerRemoved(signer);\n        }\n        _validateReachableThreshold();\n    }",
            "startLine": 164
          },
          {
            "name": "_setThreshold",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newThreshold",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getMultiSignerERC7913Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "MultiSignerERC7913ZeroThreshold",
                "type": "external",
                "argCount": 0
              },
              {
                "target": "_validateReachableThreshold",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setThreshold(uint64 newThreshold) internal virtual {\n        MultiSignerERC7913Storage storage $ = _getMultiSignerERC7913Storage();\n        require(newThreshold > 0, MultiSignerERC7913ZeroThreshold());\n        $._threshold = newThreshold;\n        _validateReachableThreshold();\n        emit ERC7913ThresholdSet(newThreshold);\n    }",
            "startLine": 182
          },
          {
            "name": "_validateReachableThreshold",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getMultiSignerERC7913Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "EnumerableSet.length",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "threshold",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "MultiSignerERC7913UnreachableThreshold",
                "type": "external",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _validateReachableThreshold() internal view virtual {\n        MultiSignerERC7913Storage storage $ = _getMultiSignerERC7913Storage();\n        uint256 signersLength = $._signers.length();\n        uint64 currentThreshold = threshold();\n        require(\n            signersLength >= currentThreshold,\n            MultiSignerERC7913UnreachableThreshold(\n                uint64(signersLength), // Safe cast. Economically impossible to overflow.\n                currentThreshold\n            )\n        );\n    }",
            "startLine": 198
          },
          {
            "name": "_rawSignatureValidation",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_validateThreshold",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "_validateSignatures",
                "type": "internal",
                "argCount": 3
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _rawSignatureValidation(\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view virtual override returns (bool) {\n        if (signature.length == 0) return false; // For ERC-7739 compatibility\n        (bytes[] memory signers, bytes[] memory signatures) = abi.decode(signature, (bytes[], bytes[]));\n        return _validateThreshold(signers) && _validateSignatures(hash, signers, signatures);\n    }",
            "startLine": 244
          },
          {
            "name": "_validateSignatures",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signers",
                "type": "bytes[]"
              },
              {
                "name": "signatures",
                "type": "bytes[]"
              }
            ],
            "returnValues": [
              {
                "name": "valid",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "isSigner",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "EnumerableSet.areValidSignaturesNow",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _validateSignatures(\n        bytes32 hash,\n        bytes[] memory signers,\n        bytes[] memory signatures\n    ) internal view virtual returns (bool valid) {\n        for (uint256 i = 0; i < signers.length; ++i) {\n            if (!isSigner(signers[i])) {\n                return false;\n            }\n        }\n        return hash.areValidSignaturesNow(signers, signatures);\n    }",
            "startLine": 264
          },
          {
            "name": "_validateThreshold",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "validatingSigners",
                "type": "bytes[]"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "threshold",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _validateThreshold(bytes[] memory validatingSigners) internal view virtual returns (bool) {\n        return validatingSigners.length >= threshold();\n    }",
            "startLine": 281
          }
        ],
        "events": [
          {
            "name": "ERC7913SignerAdded",
            "parameters": [
              {
                "name": "signers",
                "type": "bytes",
                "indexed": true
              }
            ],
            "startLine": 66
          },
          {
            "name": "ERC7913SignerRemoved",
            "parameters": [
              {
                "name": "signers",
                "type": "bytes",
                "indexed": true
              }
            ],
            "startLine": 69
          },
          {
            "name": "ERC7913ThresholdSet",
            "parameters": [
              {
                "name": "threshold",
                "type": "uint64",
                "indexed": false
              }
            ],
            "startLine": 72
          }
        ],
        "errors": [
          {
            "name": "MultiSignerERC7913AlreadyExists",
            "parameters": [
              {
                "name": "signer",
                "type": "bytes"
              }
            ],
            "startLine": 75
          },
          {
            "name": "MultiSignerERC7913NonexistentSigner",
            "parameters": [
              {
                "name": "signer",
                "type": "bytes"
              }
            ],
            "startLine": 78
          },
          {
            "name": "MultiSignerERC7913InvalidSigner",
            "parameters": [
              {
                "name": "signer",
                "type": "bytes"
              }
            ],
            "startLine": 81
          },
          {
            "name": "MultiSignerERC7913ZeroThreshold",
            "parameters": [],
            "startLine": 84
          },
          {
            "name": "MultiSignerERC7913UnreachableThreshold",
            "parameters": [
              {
                "name": "signers",
                "type": "uint64"
              },
              {
                "name": "threshold",
                "type": "uint64"
              }
            ],
            "startLine": 87
          }
        ],
        "structs": [
          {
            "name": "MultiSignerERC7913Storage",
            "members": [
              {
                "name": "_signers",
                "type": "EnumerableSet.BytesSet"
              },
              {
                "name": "_threshold",
                "type": "uint64"
              }
            ],
            "startLine": 51
          }
        ],
        "stateVariables": [
          {
            "name": "MultiSignerERC7913StorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 57
          }
        ],
        "usesLibraries": [
          "EnumerableSet",
          "SignatureChecker"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/structs/EnumerableSet.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/cryptography/signers/MultiSignerERC7913.sol)\n\npragma solidity ^0.8.26;\n\nimport {AbstractSigner} from \"@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol\";\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of {AbstractSigner} using multiple ERC-7913 signers with a threshold-based\n * signature verification system.\n *\n * This contract allows managing a set of authorized signers and requires a minimum number of\n * signatures (threshold) to approve operations. It uses ERC-7913 formatted signers, which\n * makes it natively compatible with ECDSA and ERC-1271 signers.\n *\n * Example of usage:\n *\n * ```solidity\n * contract MyMultiSignerAccount is Account, MultiSignerERC7913, Initializable {\n *     function initialize(bytes[] memory signers, uint64 threshold) public initializer {\n *         _addSigners(signers);\n *         _setThreshold(threshold);\n *     }\n *\n *     function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {\n *         _addSigners(signers);\n *     }\n *\n *     function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {\n *         _removeSigners(signers);\n *     }\n *\n *     function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {\n *         _setThreshold(threshold);\n *     }\n * }\n * ```\n *\n * IMPORTANT: Failing to properly initialize the signers and threshold either during construction\n * (if used standalone) or during initialization (if used as a clone) may leave the contract\n * either front-runnable or unusable.\n */\nabstract contract MultiSignerERC7913Upgradeable is Initializable, AbstractSigner {\n    using EnumerableSet for EnumerableSet.BytesSet;\n    using SignatureChecker for *;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.MultiSignerERC7913\n    struct MultiSignerERC7913Storage {\n        EnumerableSet.BytesSet _signers;\n        uint64 _threshold;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.MultiSignerERC7913\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant MultiSignerERC7913StorageLocation = 0xdfe169305a533e288e0557da8d289146d3cc75fa6e04c87599b048a60a4e5600;\n\n    function _getMultiSignerERC7913Storage() private pure returns (MultiSignerERC7913Storage storage $) {\n        assembly {\n            $.slot := MultiSignerERC7913StorageLocation\n        }\n    }\n\n    /// @dev Emitted when a signer is added.\n    event ERC7913SignerAdded(bytes indexed signers);\n\n    /// @dev Emitted when a signers is removed.\n    event ERC7913SignerRemoved(bytes indexed signers);\n\n    /// @dev Emitted when the threshold is updated.\n    event ERC7913ThresholdSet(uint64 threshold);\n\n    /// @dev The `signer` already exists.\n    error MultiSignerERC7913AlreadyExists(bytes signer);\n\n    /// @dev The `signer` does not exist.\n    error MultiSignerERC7913NonexistentSigner(bytes signer);\n\n    /// @dev The `signer` is less than 20 bytes long.\n    error MultiSignerERC7913InvalidSigner(bytes signer);\n\n    /// @dev The `threshold` is zero.\n    error MultiSignerERC7913ZeroThreshold();\n\n    /// @dev The `threshold` is unreachable given the number of `signers`.\n    error MultiSignerERC7913UnreachableThreshold(uint64 signers, uint64 threshold);\n\n    function __MultiSignerERC7913_init(bytes[] memory signers_, uint64 threshold_) internal onlyInitializing {\n        __MultiSignerERC7913_init_unchained(signers_, threshold_);\n    }\n\n    function __MultiSignerERC7913_init_unchained(bytes[] memory signers_, uint64 threshold_) internal onlyInitializing {\n        _addSigners(signers_);\n        _setThreshold(threshold_);\n    }\n\n    /**\n     * @dev Returns a slice of the set of authorized signers.\n     *\n     * Using `start = 0` and `end = type(uint64).max` will return the entire set of signers.\n     *\n     * WARNING: Depending on the `start` and `end`, this operation can copy a large amount of data to memory, which\n     * can be expensive. This is designed for view accessors queried without gas fees. Using it in state-changing\n     * functions may become uncallable if the slice grows too large.\n     */\n    function getSigners(uint64 start, uint64 end) public view virtual returns (bytes[] memory) {\n        MultiSignerERC7913Storage storage $ = _getMultiSignerERC7913Storage();\n        return $._signers.values(start, end);\n    }\n\n    /// @dev Returns the number of authorized signers\n    function getSignerCount() public view virtual returns (uint256) {\n        MultiSignerERC7913Storage storage $ = _getMultiSignerERC7913Storage();\n        return $._signers.length();\n    }\n\n    /// @dev Returns whether the `signer` is an authorized signer.\n    function isSigner(bytes memory signer) public view virtual returns (bool) {\n        MultiSignerERC7913Storage storage $ = _getMultiSignerERC7913Storage();\n        return $._signers.contains(signer);\n    }\n\n    /// @dev Returns the minimum number of signers required to approve a multisignature operation.\n    function threshold() public view virtual returns (uint64) {\n        MultiSignerERC7913Storage storage $ = _getMultiSignerERC7913Storage();\n        return $._threshold;\n    }\n\n    /**\n     * @dev Adds the `newSigners` to those allowed to sign on behalf of this contract.\n     * Internal version without access control.\n     *\n     * Requirements:\n     *\n     * * Each of `newSigners` must be at least 20 bytes long. Reverts with {MultiSignerERC7913InvalidSigner} if not.\n     * * Each of `newSigners` must not be authorized. See {isSigner}. Reverts with {MultiSignerERC7913AlreadyExists} if so.\n     *\n     * NOTE: This function does not validate that signers are controlled or represent appropriate entities. Integrators\n     * must ensure signers are properly validated before adding them. Problematic signers can compromise\n     * the multisig's security or functionality. Examples include uncontrolled addresses (e.g., `address(0)`),\n     * the account's own address (which may cause recursive validation loops), or contracts that may unintentionally\n     * allow arbitrary validation (e.g. using the identity precompile at `address(0x04)`, which would return the\n     * ERC-1271 magic value for any `isValidSignature` call).\n     */\n    function _addSigners(bytes[] memory newSigners) internal virtual {\n        MultiSignerERC7913Storage storage $ = _getMultiSignerERC7913Storage();\n        for (uint256 i = 0; i < newSigners.length; ++i) {\n            bytes memory signer = newSigners[i];\n            require(signer.length >= 20, MultiSignerERC7913InvalidSigner(signer));\n            require($._signers.add(signer), MultiSignerERC7913AlreadyExists(signer));\n            emit ERC7913SignerAdded(signer);\n        }\n    }\n\n    /**\n     * @dev Removes the `oldSigners` from the authorized signers. Internal version without access control.\n     *\n     * Requirements:\n     *\n     * * Each of `oldSigners` must be authorized. See {isSigner}. Otherwise {MultiSignerERC7913NonexistentSigner} is thrown.\n     * * See {_validateReachableThreshold} for the threshold validation.\n     */\n    function _removeSigners(bytes[] memory oldSigners) internal virtual {\n        MultiSignerERC7913Storage storage $ = _getMultiSignerERC7913Storage();\n        for (uint256 i = 0; i < oldSigners.length; ++i) {\n            bytes memory signer = oldSigners[i];\n            require($._signers.remove(signer), MultiSignerERC7913NonexistentSigner(signer));\n            emit ERC7913SignerRemoved(signer);\n        }\n        _validateReachableThreshold();\n    }\n\n    /**\n     * @dev Sets the signatures `threshold` required to approve a multisignature operation.\n     * Internal version without access control.\n     *\n     * Requirements:\n     *\n     * * See {_validateReachableThreshold} for the threshold validation.\n     */\n    function _setThreshold(uint64 newThreshold) internal virtual {\n        MultiSignerERC7913Storage storage $ = _getMultiSignerERC7913Storage();\n        require(newThreshold > 0, MultiSignerERC7913ZeroThreshold());\n        $._threshold = newThreshold;\n        _validateReachableThreshold();\n        emit ERC7913ThresholdSet(newThreshold);\n    }\n\n    /**\n     * @dev Validates the current threshold is reachable.\n     *\n     * Requirements:\n     *\n     * * The {getSignerCount} must be greater or equal than to the {threshold}. Throws\n     * {MultiSignerERC7913UnreachableThreshold} if not.\n     */\n    function _validateReachableThreshold() internal view virtual {\n        MultiSignerERC7913Storage storage $ = _getMultiSignerERC7913Storage();\n        uint256 signersLength = $._signers.length();\n        uint64 currentThreshold = threshold();\n        require(\n            signersLength >= currentThreshold,\n            MultiSignerERC7913UnreachableThreshold(\n                uint64(signersLength), // Safe cast. Economically impossible to overflow.\n                currentThreshold\n            )\n        );\n    }\n\n    /**\n     * @dev Decodes, validates the signature and checks the signers are authorized.\n     * See {_validateSignatures} and {_validateThreshold} for more details.\n     *\n     * Example of signature encoding:\n     *\n     * ```solidity\n     * // Encode signers (verifier || key)\n     * bytes memory signer1 = abi.encodePacked(verifier1, key1);\n     * bytes memory signer2 = abi.encodePacked(verifier2, key2);\n     *\n     * // Order signers by their id\n     * if (keccak256(signer1) > keccak256(signer2)) {\n     *     (signer1, signer2) = (signer2, signer1);\n     *     (signature1, signature2) = (signature2, signature1);\n     * }\n     *\n     * // Assign ordered signers and signatures\n     * bytes[] memory signers = new bytes[](2);\n     * bytes[] memory signatures = new bytes[](2);\n     * signers[0] = signer1;\n     * signatures[0] = signature1;\n     * signers[1] = signer2;\n     * signatures[1] = signature2;\n     *\n     * // Encode the multi signature\n     * bytes memory signature = abi.encode(signers, signatures);\n     * ```\n     *\n     * Requirements:\n     *\n     * * The `signature` must be encoded as `abi.encode(signers, signatures)`.\n     */\n    function _rawSignatureValidation(\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view virtual override returns (bool) {\n        if (signature.length == 0) return false; // For ERC-7739 compatibility\n        (bytes[] memory signers, bytes[] memory signatures) = abi.decode(signature, (bytes[], bytes[]));\n        return _validateThreshold(signers) && _validateSignatures(hash, signers, signatures);\n    }\n\n    /**\n     * @dev Validates the signatures using the signers and their corresponding signatures.\n     * Returns whether the signers are authorized and the signatures are valid for the given hash.\n     *\n     * IMPORTANT: Sorting the signers by their `keccak256` hash will improve the gas efficiency of this function.\n     * See {SignatureChecker-areValidSignaturesNow-bytes32-bytes[]-bytes[]} for more details.\n     *\n     * Requirements:\n     *\n     * * The `signatures` and `signers` arrays must be equal in length. Returns false otherwise.\n     */\n    function _validateSignatures(\n        bytes32 hash,\n        bytes[] memory signers,\n        bytes[] memory signatures\n    ) internal view virtual returns (bool valid) {\n        for (uint256 i = 0; i < signers.length; ++i) {\n            if (!isSigner(signers[i])) {\n                return false;\n            }\n        }\n        return hash.areValidSignaturesNow(signers, signatures);\n    }\n\n    /**\n     * @dev Validates that the number of signers meets the {threshold} requirement.\n     * Assumes the signers were already validated. See {_validateSignatures} for more details.\n     */\n    function _validateThreshold(bytes[] memory validatingSigners) internal view virtual returns (bool) {\n        return validatingSigners.length >= threshold();\n    }\n}\n"
      },
      {
        "name": "MultiSignerERC7913WeightedUpgradeable",
        "filePath": "utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "MultiSignerERC7913Upgradeable"
        ],
        "implements": [],
        "category": "utils/cryptography",
        "externalFunctions": [
          {
            "name": "signerWeight",
            "signature": "signerWeight(bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signer",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getMultiSignerERC7913WeightedStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "SafeCast.toUint",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "isSigner",
                "type": "internal",
                "argCount": 1
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function signerWeight(bytes memory signer) public view virtual returns (uint64) {\n        MultiSignerERC7913WeightedStorage storage $ = _getMultiSignerERC7913WeightedStorage();\n        unchecked {\n            // Safe cast, _setSignerWeights guarantees 1+_extraWeights is a uint64\n            return uint64(isSigner(signer).toUint() * (1 + $._extraWeights[signer]));\n        }\n    }",
            "startLine": 95
          },
          {
            "name": "totalWeight",
            "signature": "totalWeight()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getMultiSignerERC7913WeightedStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "SafeCast.toUint64",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "getSignerCount",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function totalWeight() public view virtual returns (uint64) {\n        MultiSignerERC7913WeightedStorage storage $ = _getMultiSignerERC7913WeightedStorage();\n        return (getSignerCount() + $._totalExtraWeight).toUint64();\n    }",
            "startLine": 104
          }
        ],
        "internalFunctions": [
          {
            "name": "_getMultiSignerERC7913WeightedStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "MultiSignerERC7913WeightedStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getMultiSignerERC7913WeightedStorage() private pure returns (MultiSignerERC7913WeightedStorage storage $) {\n        assembly {\n            $.slot := MultiSignerERC7913WeightedStorageLocation\n        }\n    }",
            "startLine": 64
          },
          {
            "name": "__MultiSignerERC7913Weighted_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "signers_",
                "type": "bytes[]"
              },
              {
                "name": "weights_",
                "type": "uint64[]"
              },
              {
                "name": "threshold_",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __MultiSignerERC7913Weighted_init(bytes[] memory signers_, uint64[] memory weights_, uint64 threshold_) internal onlyInitializing {\n        __MultiSignerERC7913_init_unchained(signers_, 1);\n        __MultiSignerERC7913Weighted_init_unchained(signers_, weights_, threshold_);\n    }",
            "startLine": 84
          },
          {
            "name": "__MultiSignerERC7913Weighted_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "signers_",
                "type": "bytes[]"
              },
              {
                "name": "weights_",
                "type": "uint64[]"
              },
              {
                "name": "threshold_",
                "type": "uint64"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setSignerWeights",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_setThreshold",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __MultiSignerERC7913Weighted_init_unchained(bytes[] memory signers_, uint64[] memory weights_, uint64 threshold_) internal onlyInitializing {\n        _setSignerWeights(signers_, weights_);\n        _setThreshold(threshold_);\n    }",
            "startLine": 89
          },
          {
            "name": "_setSignerWeights",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "signers",
                "type": "bytes[]"
              },
              {
                "name": "weights",
                "type": "uint64[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getMultiSignerERC7913WeightedStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "MultiSignerERC7913WeightedMismatchedLength",
                "type": "external",
                "argCount": 0
              },
              {
                "target": "isSigner",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "MultiSignerERC7913NonexistentSigner",
                "type": "external",
                "argCount": 1
              },
              {
                "target": "SafeCast.toUint64",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "_validateReachableThreshold",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _setSignerWeights(bytes[] memory signers, uint64[] memory weights) internal virtual {\n        MultiSignerERC7913WeightedStorage storage $ = _getMultiSignerERC7913WeightedStorage();\n        require(signers.length == weights.length, MultiSignerERC7913WeightedMismatchedLength());\n\n        uint256 extraWeightAdded = 0;\n        uint256 extraWeightRemoved = 0;\n        for (uint256 i = 0; i < signers.length; ++i) {\n            bytes memory signer = signers[i];\n            require(isSigner(signer), MultiSignerERC7913NonexistentSigner(signer));\n\n            uint64 weight = weights[i];\n            require(weight > 0, MultiSignerERC7913WeightedInvalidWeight(signer, weight));\n\n            unchecked {\n                uint64 oldExtraWeight = $._extraWeights[signer];\n                uint64 newExtraWeight = weight - 1;\n\n                if (oldExtraWeight != newExtraWeight) {\n                    // Overflow impossible: weight values are bounded by uint64 and economic constraints\n                    extraWeightRemoved += oldExtraWeight;\n                    extraWeightAdded += $._extraWeights[signer] = newExtraWeight;\n                    emit ERC7913SignerWeightChanged(signer, weight);\n                }\n            }\n        }\n        unchecked {\n            // Safe from underflow: `extraWeightRemoved` is bounded by `_totalExtraWeight` by construction\n            // and weight values are bounded by uint64 and economic constraints\n            $._totalExtraWeight = (uint256($._totalExtraWeight) + extraWeightAdded - extraWeightRemoved).toUint64();\n        }\n        _validateReachableThreshold();\n    }",
            "startLine": 121
          },
          {
            "name": "_addSigners",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newSigners",
                "type": "bytes[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_addSigners",
                "type": "super",
                "argCount": 1
              },
              {
                "target": "_validateReachableThreshold",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _addSigners(bytes[] memory newSigners) internal virtual override {\n        super._addSigners(newSigners);\n\n        // This will revert if the new signers cause an overflow\n        _validateReachableThreshold();\n    }",
            "startLine": 161
          },
          {
            "name": "_removeSigners",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "signers",
                "type": "bytes[]"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getMultiSignerERC7913WeightedStorage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "_removeSigners",
                "type": "super",
                "argCount": 1
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _removeSigners(bytes[] memory signers) internal virtual override {\n        MultiSignerERC7913WeightedStorage storage $ = _getMultiSignerERC7913WeightedStorage();\n        // Clean up weights for removed signers\n        //\n        // The `extraWeightRemoved` is bounded by `_totalExtraWeight`. The `super._removeSigners` function will revert\n        // if the signers array contains any duplicates, ensuring each signer's weight is only counted once. Since\n        // `_totalExtraWeight` is stored as a `uint64`, the final subtraction operation is also safe.\n        unchecked {\n            uint64 extraWeightRemoved = 0;\n            for (uint256 i = 0; i < signers.length; ++i) {\n                bytes memory signer = signers[i];\n\n                extraWeightRemoved += $._extraWeights[signer];\n                delete $._extraWeights[signer];\n            }\n            $._totalExtraWeight -= extraWeightRemoved;\n        }\n        super._removeSigners(signers);\n    }",
            "startLine": 174
          },
          {
            "name": "_validateReachableThreshold",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "totalWeight",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "threshold",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "MultiSignerERC7913UnreachableThreshold",
                "type": "external",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _validateReachableThreshold() internal view virtual override {\n        uint64 weight = totalWeight();\n        uint64 currentThreshold = threshold();\n        require(weight >= currentThreshold, MultiSignerERC7913UnreachableThreshold(weight, currentThreshold));\n    }",
            "startLine": 206
          },
          {
            "name": "_validateThreshold",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "signers",
                "type": "bytes[]"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "signerWeight",
                "type": "internal",
                "argCount": 1
              },
              {
                "target": "threshold",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _validateThreshold(bytes[] memory signers) internal view virtual override returns (bool) {\n        unchecked {\n            uint64 weight = 0;\n            for (uint256 i = 0; i < signers.length; ++i) {\n                // Overflow impossible: weight values are bounded by uint64 and economic constraints\n                weight += signerWeight(signers[i]);\n            }\n            return weight >= threshold();\n        }\n    }",
            "startLine": 220
          }
        ],
        "events": [
          {
            "name": "ERC7913SignerWeightChanged",
            "parameters": [
              {
                "name": "signer",
                "type": "bytes",
                "indexed": true
              },
              {
                "name": "weight",
                "type": "uint64",
                "indexed": false
              }
            ],
            "startLine": 76
          }
        ],
        "errors": [
          {
            "name": "MultiSignerERC7913WeightedInvalidWeight",
            "parameters": [
              {
                "name": "signer",
                "type": "bytes"
              },
              {
                "name": "weight",
                "type": "uint64"
              }
            ],
            "startLine": 79
          },
          {
            "name": "MultiSignerERC7913WeightedMismatchedLength",
            "parameters": [],
            "startLine": 82
          }
        ],
        "structs": [
          {
            "name": "MultiSignerERC7913WeightedStorage",
            "members": [
              {
                "name": "_totalExtraWeight",
                "type": "uint64"
              },
              {
                "name": "_extraWeights",
                "type": "mapping(bytes => uint64)"
              }
            ],
            "startLine": 53
          }
        ],
        "stateVariables": [
          {
            "name": "MultiSignerERC7913WeightedStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 62
          }
        ],
        "usesLibraries": [
          "SafeCast"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/utils/math/SafeCast.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "./MultiSignerERC7913Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/cryptography/signers/MultiSignerERC7913Weighted.sol)\n\npragma solidity ^0.8.26;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {MultiSignerERC7913Upgradeable} from \"./MultiSignerERC7913Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {MultiSignerERC7913} that supports weighted signatures.\n *\n * This contract allows assigning different weights to each signer, enabling more\n * flexible governance schemes. For example, some signers could have higher weight\n * than others, allowing for weighted voting or prioritized authorization.\n *\n * Example of usage:\n *\n * ```solidity\n * contract MyWeightedMultiSignerAccount is Account, MultiSignerERC7913Weighted, Initializable {\n *     function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold) public initializer {\n *         _addSigners(signers);\n *         _setSignerWeights(signers, weights);\n *         _setThreshold(threshold);\n *     }\n *\n *     function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {\n *         _addSigners(signers);\n *     }\n *\n *     function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {\n *         _removeSigners(signers);\n *     }\n *\n *     function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {\n *         _setThreshold(threshold);\n *     }\n *\n *     function setSignerWeights(bytes[] memory signers, uint64[] memory weights) public onlyEntryPointOrSelf {\n *         _setSignerWeights(signers, weights);\n *     }\n * }\n * ```\n *\n * IMPORTANT: When setting a threshold value, ensure it matches the scale used for signer weights.\n * For example, if signers have weights like 1, 2, or 3, then a threshold of 4 would require at\n * least two signers (e.g., one with weight 1 and one with weight 3). See {signerWeight}.\n */\nabstract contract MultiSignerERC7913WeightedUpgradeable is Initializable, MultiSignerERC7913Upgradeable {\n    using SafeCast for *;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.MultiSignerERC7913Weighted\n    struct MultiSignerERC7913WeightedStorage {\n        // Sum of all the extra weights of all signers. Storage packed with `MultiSignerERC7913._threshold`\n        uint64 _totalExtraWeight;\n\n        // Mapping from signer to extraWeight (in addition to all authorized signers having weight 1)\n        mapping(bytes signer => uint64) _extraWeights;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.MultiSignerERC7913Weighted\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant MultiSignerERC7913WeightedStorageLocation = 0x5ec62f110612a7ff5e720b9a2f4970583e308ad11d9cde77cb7db3ea251b1f00;\n\n    function _getMultiSignerERC7913WeightedStorage() private pure returns (MultiSignerERC7913WeightedStorage storage $) {\n        assembly {\n            $.slot := MultiSignerERC7913WeightedStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when a signer's weight is changed.\n     *\n     * NOTE: Not emitted in {_addSigners} or {_removeSigners}. Indexers must rely on {ERC7913SignerAdded}\n     * and {ERC7913SignerRemoved} to index a default weight of 1. See {signerWeight}.\n     */\n    event ERC7913SignerWeightChanged(bytes indexed signer, uint64 weight);\n\n    /// @dev Thrown when a signer's weight is invalid.\n    error MultiSignerERC7913WeightedInvalidWeight(bytes signer, uint64 weight);\n\n    /// @dev Thrown when the arrays lengths don't match. See {_setSignerWeights}.\n    error MultiSignerERC7913WeightedMismatchedLength();\n\n    function __MultiSignerERC7913Weighted_init(bytes[] memory signers_, uint64[] memory weights_, uint64 threshold_) internal onlyInitializing {\n        __MultiSignerERC7913_init_unchained(signers_, 1);\n        __MultiSignerERC7913Weighted_init_unchained(signers_, weights_, threshold_);\n    }\n\n    function __MultiSignerERC7913Weighted_init_unchained(bytes[] memory signers_, uint64[] memory weights_, uint64 threshold_) internal onlyInitializing {\n        _setSignerWeights(signers_, weights_);\n        _setThreshold(threshold_);\n    }\n\n    /// @dev Gets the weight of a signer. Returns 0 if the signer is not authorized.\n    function signerWeight(bytes memory signer) public view virtual returns (uint64) {\n        MultiSignerERC7913WeightedStorage storage $ = _getMultiSignerERC7913WeightedStorage();\n        unchecked {\n            // Safe cast, _setSignerWeights guarantees 1+_extraWeights is a uint64\n            return uint64(isSigner(signer).toUint() * (1 + $._extraWeights[signer]));\n        }\n    }\n\n    /// @dev Gets the total weight of all signers.\n    function totalWeight() public view virtual returns (uint64) {\n        MultiSignerERC7913WeightedStorage storage $ = _getMultiSignerERC7913WeightedStorage();\n        return (getSignerCount() + $._totalExtraWeight).toUint64();\n    }\n\n    /**\n     * @dev Sets weights for multiple signers at once. Internal version without access control.\n     *\n     * Requirements:\n     *\n     * * `signers` and `weights` arrays must have the same length. Reverts with {MultiSignerERC7913WeightedMismatchedLength} on mismatch.\n     * * Each signer must exist in the set of authorized signers. Otherwise reverts with {MultiSignerERC7913NonexistentSigner}\n     * * Each weight must be greater than 0. Otherwise reverts with {MultiSignerERC7913WeightedInvalidWeight}\n     * * See {_validateReachableThreshold} for the threshold validation.\n     *\n     * Emits {ERC7913SignerWeightChanged} for each signer.\n     */\n    function _setSignerWeights(bytes[] memory signers, uint64[] memory weights) internal virtual {\n        MultiSignerERC7913WeightedStorage storage $ = _getMultiSignerERC7913WeightedStorage();\n        require(signers.length == weights.length, MultiSignerERC7913WeightedMismatchedLength());\n\n        uint256 extraWeightAdded = 0;\n        uint256 extraWeightRemoved = 0;\n        for (uint256 i = 0; i < signers.length; ++i) {\n            bytes memory signer = signers[i];\n            require(isSigner(signer), MultiSignerERC7913NonexistentSigner(signer));\n\n            uint64 weight = weights[i];\n            require(weight > 0, MultiSignerERC7913WeightedInvalidWeight(signer, weight));\n\n            unchecked {\n                uint64 oldExtraWeight = $._extraWeights[signer];\n                uint64 newExtraWeight = weight - 1;\n\n                if (oldExtraWeight != newExtraWeight) {\n                    // Overflow impossible: weight values are bounded by uint64 and economic constraints\n                    extraWeightRemoved += oldExtraWeight;\n                    extraWeightAdded += $._extraWeights[signer] = newExtraWeight;\n                    emit ERC7913SignerWeightChanged(signer, weight);\n                }\n            }\n        }\n        unchecked {\n            // Safe from underflow: `extraWeightRemoved` is bounded by `_totalExtraWeight` by construction\n            // and weight values are bounded by uint64 and economic constraints\n            $._totalExtraWeight = (uint256($._totalExtraWeight) + extraWeightAdded - extraWeightRemoved).toUint64();\n        }\n        _validateReachableThreshold();\n    }\n\n    /**\n     * @dev See {MultiSignerERC7913-_addSigners}.\n     *\n     * In cases where {totalWeight} is almost `type(uint64).max` (due to a large `_totalExtraWeight`), adding new\n     * signers could cause the {totalWeight} computation to overflow. Adding a {totalWeight} calls after the new\n     * signers are added ensures no such overflow happens.\n     */\n    function _addSigners(bytes[] memory newSigners) internal virtual override {\n        super._addSigners(newSigners);\n\n        // This will revert if the new signers cause an overflow\n        _validateReachableThreshold();\n    }\n\n    /**\n     * @dev See {MultiSignerERC7913-_removeSigners}.\n     *\n     * Just like {_addSigners}, this function does not emit {ERC7913SignerWeightChanged} events. The\n     * {ERC7913SignerRemoved} event emitted by {MultiSignerERC7913-_removeSigners} is enough to track weights here.\n     */\n    function _removeSigners(bytes[] memory signers) internal virtual override {\n        MultiSignerERC7913WeightedStorage storage $ = _getMultiSignerERC7913WeightedStorage();\n        // Clean up weights for removed signers\n        //\n        // The `extraWeightRemoved` is bounded by `_totalExtraWeight`. The `super._removeSigners` function will revert\n        // if the signers array contains any duplicates, ensuring each signer's weight is only counted once. Since\n        // `_totalExtraWeight` is stored as a `uint64`, the final subtraction operation is also safe.\n        unchecked {\n            uint64 extraWeightRemoved = 0;\n            for (uint256 i = 0; i < signers.length; ++i) {\n                bytes memory signer = signers[i];\n\n                extraWeightRemoved += $._extraWeights[signer];\n                delete $._extraWeights[signer];\n            }\n            $._totalExtraWeight -= extraWeightRemoved;\n        }\n        super._removeSigners(signers);\n    }\n\n    /**\n     * @dev Sets the threshold for the multisignature operation. Internal version without access control.\n     *\n     * Requirements:\n     *\n     * * The {totalWeight} must be `>=` the {threshold}. Otherwise reverts with {MultiSignerERC7913UnreachableThreshold}\n     *\n     * NOTE: This function intentionally does not call `super._validateReachableThreshold` because the base implementation\n     * assumes each signer has a weight of 1, which is a subset of this weighted implementation. Consider that multiple\n     * implementations of this function may exist in the contract, so important side effects may be missed\n     * depending on the linearization order.\n     */\n    function _validateReachableThreshold() internal view virtual override {\n        uint64 weight = totalWeight();\n        uint64 currentThreshold = threshold();\n        require(weight >= currentThreshold, MultiSignerERC7913UnreachableThreshold(weight, currentThreshold));\n    }\n\n    /**\n     * @dev Validates that the total weight of signers meets the threshold requirement.\n     *\n     * NOTE: This function intentionally does not call `super._validateThreshold` because the base implementation\n     * assumes each signer has a weight of 1, which is a subset of this weighted implementation. Consider that multiple\n     * implementations of this function may exist in the contract, so important side effects may be missed\n     * depending on the linearization order.\n     */\n    function _validateThreshold(bytes[] memory signers) internal view virtual override returns (bool) {\n        unchecked {\n            uint64 weight = 0;\n            for (uint256 i = 0; i < signers.length; ++i) {\n                // Overflow impossible: weight values are bounded by uint64 and economic constraints\n                weight += signerWeight(signers[i]);\n            }\n            return weight >= threshold();\n        }\n    }\n}\n"
      },
      {
        "name": "SignerECDSAUpgradeable",
        "filePath": "utils/cryptography/signers/SignerECDSAUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "AbstractSigner"
        ],
        "implements": [],
        "category": "utils/cryptography",
        "externalFunctions": [
          {
            "name": "signer",
            "signature": "signer()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getSignerECDSAStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function signer() public view virtual returns (address) {\n        SignerECDSAStorage storage $ = _getSignerECDSAStorage();\n        return $._signer;\n    }",
            "startLine": 62
          }
        ],
        "internalFunctions": [
          {
            "name": "_getSignerECDSAStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "SignerECDSAStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getSignerECDSAStorage() private pure returns (SignerECDSAStorage storage $) {\n        assembly {\n            $.slot := SignerECDSAStorageLocation\n        }\n    }",
            "startLine": 38
          },
          {
            "name": "__SignerECDSA_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "signerAddr",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __SignerECDSA_init(address signerAddr) internal onlyInitializing {\n        __SignerECDSA_init_unchained(signerAddr);\n    }",
            "startLine": 44
          },
          {
            "name": "__SignerECDSA_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "signerAddr",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setSigner",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __SignerECDSA_init_unchained(address signerAddr) internal onlyInitializing {\n        _setSigner(signerAddr);\n    }",
            "startLine": 48
          },
          {
            "name": "_setSigner",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "signerAddr",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getSignerECDSAStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _setSigner(address signerAddr) internal {\n        SignerECDSAStorage storage $ = _getSignerECDSAStorage();\n        $._signer = signerAddr;\n    }",
            "startLine": 56
          },
          {
            "name": "_rawSignatureValidation",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "ECDSA.tryRecoverCalldata",
                "type": "library",
                "argCount": 2
              },
              {
                "target": "signer",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _rawSignatureValidation(\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view virtual override returns (bool) {\n        (address recovered, ECDSA.RecoverError err, ) = ECDSA.tryRecoverCalldata(hash, signature);\n        return signer() == recovered && err == ECDSA.RecoverError.NoError;\n    }",
            "startLine": 68
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "SignerECDSAStorage",
            "members": [
              {
                "name": "_signer",
                "type": "address"
              }
            ],
            "startLine": 31
          }
        ],
        "stateVariables": [
          {
            "name": "SignerECDSAStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 36
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/cryptography/ECDSA.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/cryptography/signers/SignerECDSA.sol)\n\npragma solidity ^0.8.20;\n\nimport {AbstractSigner} from \"@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of {AbstractSigner} using xref:api:utils/cryptography#ECDSA[ECDSA] signatures.\n *\n * For {Account} usage, a {_setSigner} function is provided to set the {signer} address.\n * Doing so is easier for a factory, who is likely to use initializable clones of this contract.\n *\n * Example of usage:\n *\n * ```solidity\n * contract MyAccountECDSA is Account, SignerECDSA, Initializable {\n *     function initialize(address signerAddr) public initializer {\n *       _setSigner(signerAddr);\n *     }\n * }\n * ```\n *\n * IMPORTANT: Failing to call {_setSigner} either during construction (if used standalone)\n * or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.\n */\nabstract contract SignerECDSAUpgradeable is Initializable, AbstractSigner {\n    /// @custom:storage-location erc7201:openzeppelin.storage.SignerECDSA\n    struct SignerECDSAStorage {\n        address _signer;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.SignerECDSA\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant SignerECDSAStorageLocation = 0x21a2a8bb424898f7a6033d112ec6057811f27c903c45eccf7ad7cefcbbc0d200;\n\n    function _getSignerECDSAStorage() private pure returns (SignerECDSAStorage storage $) {\n        assembly {\n            $.slot := SignerECDSAStorageLocation\n        }\n    }\n\n    function __SignerECDSA_init(address signerAddr) internal onlyInitializing {\n        __SignerECDSA_init_unchained(signerAddr);\n    }\n\n    function __SignerECDSA_init_unchained(address signerAddr) internal onlyInitializing {\n        _setSigner(signerAddr);\n    }\n\n    /**\n     * @dev Sets the signer with the address of the native signer. This function should be called during construction\n     * or through an initializer.\n     */\n    function _setSigner(address signerAddr) internal {\n        SignerECDSAStorage storage $ = _getSignerECDSAStorage();\n        $._signer = signerAddr;\n    }\n\n    /// @dev Return the signer's address.\n    function signer() public view virtual returns (address) {\n        SignerECDSAStorage storage $ = _getSignerECDSAStorage();\n        return $._signer;\n    }\n\n    /// @inheritdoc AbstractSigner\n    function _rawSignatureValidation(\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view virtual override returns (bool) {\n        (address recovered, ECDSA.RecoverError err, ) = ECDSA.tryRecoverCalldata(hash, signature);\n        return signer() == recovered && err == ECDSA.RecoverError.NoError;\n    }\n}\n"
      },
      {
        "name": "SignerERC7913Upgradeable",
        "filePath": "utils/cryptography/signers/SignerERC7913Upgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "AbstractSigner"
        ],
        "implements": [],
        "category": "utils/cryptography",
        "externalFunctions": [
          {
            "name": "signer",
            "signature": "signer()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "_getSignerERC7913Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function signer() public view virtual returns (bytes memory) {\n        SignerERC7913Storage storage $ = _getSignerERC7913Storage();\n        return $._signer;\n    }",
            "startLine": 61
          }
        ],
        "internalFunctions": [
          {
            "name": "_getSignerERC7913Storage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "SignerERC7913Storage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getSignerERC7913Storage() private pure returns (SignerERC7913Storage storage $) {\n        assembly {\n            $.slot := SignerERC7913StorageLocation\n        }\n    }",
            "startLine": 46
          },
          {
            "name": "__SignerERC7913_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "signer_",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __SignerERC7913_init(bytes memory signer_) internal onlyInitializing {\n        __SignerERC7913_init_unchained(signer_);\n    }",
            "startLine": 52
          },
          {
            "name": "__SignerERC7913_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "signer_",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setSigner",
                "type": "internal",
                "argCount": 1
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __SignerERC7913_init_unchained(bytes memory signer_) internal onlyInitializing {\n        _setSigner(signer_);\n    }",
            "startLine": 56
          },
          {
            "name": "_setSigner",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "signer_",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getSignerERC7913Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _setSigner(bytes memory signer_) internal {\n        SignerERC7913Storage storage $ = _getSignerERC7913Storage();\n        $._signer = signer_;\n    }",
            "startLine": 67
          },
          {
            "name": "_rawSignatureValidation",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "SignatureChecker.isValidSignatureNow",
                "type": "library",
                "argCount": 3
              },
              {
                "target": "signer",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _rawSignatureValidation(\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view virtual override returns (bool) {\n        return SignatureChecker.isValidSignatureNow(signer(), hash, signature);\n    }",
            "startLine": 76
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "SignerERC7913Storage",
            "members": [
              {
                "name": "_signer",
                "type": "bytes"
              }
            ],
            "startLine": 39
          }
        ],
        "stateVariables": [
          {
            "name": "SignerERC7913StorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 44
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/cryptography/signers/SignerERC7913.sol)\n\npragma solidity ^0.8.24;\n\nimport {AbstractSigner} from \"@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol\";\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of {AbstractSigner} using\n * https://eips.ethereum.org/EIPS/eip-7913[ERC-7913] signature verification.\n *\n * For {Account} usage, a {_setSigner} function is provided to set the ERC-7913 formatted {signer}.\n * Doing so is easier for a factory, who is likely to use initializable clones of this contract.\n *\n * The signer is a `bytes` object that concatenates a verifier address and a key: `verifier || key`.\n *\n * Example of usage:\n *\n * ```solidity\n * contract MyAccountERC7913 is Account, SignerERC7913, Initializable {\n *     function initialize(bytes memory signer_) public initializer {\n *       _setSigner(signer_);\n *     }\n *\n *     function setSigner(bytes memory signer_) public onlyEntryPointOrSelf {\n *       _setSigner(signer_);\n *     }\n * }\n * ```\n *\n * IMPORTANT: Failing to call {_setSigner} either during construction (if used standalone)\n * or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.\n */\n\nabstract contract SignerERC7913Upgradeable is Initializable, AbstractSigner {\n    /// @custom:storage-location erc7201:openzeppelin.storage.SignerERC7913\n    struct SignerERC7913Storage {\n        bytes _signer;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.SignerERC7913\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant SignerERC7913StorageLocation = 0x170786af7cf7b78916dca5a937f25e3b9b70ae3faee6f0db68cda91b7e818e00;\n\n    function _getSignerERC7913Storage() private pure returns (SignerERC7913Storage storage $) {\n        assembly {\n            $.slot := SignerERC7913StorageLocation\n        }\n    }\n\n    function __SignerERC7913_init(bytes memory signer_) internal onlyInitializing {\n        __SignerERC7913_init_unchained(signer_);\n    }\n\n    function __SignerERC7913_init_unchained(bytes memory signer_) internal onlyInitializing {\n        _setSigner(signer_);\n    }\n\n    /// @dev Return the ERC-7913 signer (i.e. `verifier || key`).\n    function signer() public view virtual returns (bytes memory) {\n        SignerERC7913Storage storage $ = _getSignerERC7913Storage();\n        return $._signer;\n    }\n\n    /// @dev Sets the signer (i.e. `verifier || key`) with an ERC-7913 formatted signer.\n    function _setSigner(bytes memory signer_) internal {\n        SignerERC7913Storage storage $ = _getSignerERC7913Storage();\n        $._signer = signer_;\n    }\n\n    /**\n     * @dev Verifies a signature using {SignatureChecker-isValidSignatureNow-bytes-bytes32-bytes-}\n     * with {signer}, `hash` and `signature`.\n     */\n    function _rawSignatureValidation(\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view virtual override returns (bool) {\n        return SignatureChecker.isValidSignatureNow(signer(), hash, signature);\n    }\n}\n"
      },
      {
        "name": "SignerP256Upgradeable",
        "filePath": "utils/cryptography/signers/SignerP256Upgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "AbstractSigner"
        ],
        "implements": [],
        "category": "utils/cryptography",
        "externalFunctions": [
          {
            "name": "signer",
            "signature": "signer()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "qx",
                "type": "bytes32"
              },
              {
                "name": "qy",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getSignerP256Storage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function signer() public view virtual returns (bytes32 qx, bytes32 qy) {\n        SignerP256Storage storage $ = _getSignerP256Storage();\n        return ($._qx, $._qy);\n    }",
            "startLine": 67
          }
        ],
        "internalFunctions": [
          {
            "name": "_getSignerP256Storage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "SignerP256Storage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getSignerP256Storage() private pure returns (SignerP256Storage storage $) {\n        assembly {\n            $.slot := SignerP256StorageLocation\n        }\n    }",
            "startLine": 39
          },
          {
            "name": "__SignerP256_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "qx",
                "type": "bytes32"
              },
              {
                "name": "qy",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __SignerP256_init(bytes32 qx, bytes32 qy) internal onlyInitializing {\n        __SignerP256_init_unchained(qx, qy);\n    }",
            "startLine": 47
          },
          {
            "name": "__SignerP256_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "qx",
                "type": "bytes32"
              },
              {
                "name": "qy",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setSigner",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __SignerP256_init_unchained(bytes32 qx, bytes32 qy) internal onlyInitializing {\n        _setSigner(qx, qy);\n    }",
            "startLine": 51
          },
          {
            "name": "_setSigner",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "qx",
                "type": "bytes32"
              },
              {
                "name": "qy",
                "type": "bytes32"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getSignerP256Storage",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "P256.isValidPublicKey",
                "type": "library",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _setSigner(bytes32 qx, bytes32 qy) internal {\n        SignerP256Storage storage $ = _getSignerP256Storage();\n        if (!P256.isValidPublicKey(qx, qy)) revert SignerP256InvalidPublicKey(qx, qy);\n        $._qx = qx;\n        $._qy = qy;\n    }",
            "startLine": 59
          },
          {
            "name": "_rawSignatureValidation",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "signer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "P256.verify",
                "type": "library",
                "argCount": 5
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _rawSignatureValidation(\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view virtual override returns (bool) {\n        if (signature.length < 0x40) return false;\n        bytes32 r = bytes32(signature[0x00:0x20]);\n        bytes32 s = bytes32(signature[0x20:0x40]);\n        (bytes32 qx, bytes32 qy) = signer();\n        return P256.verify(hash, r, s, qx, qy);\n    }",
            "startLine": 73
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "SignerP256InvalidPublicKey",
            "parameters": [
              {
                "name": "qx",
                "type": "bytes32"
              },
              {
                "name": "qy",
                "type": "bytes32"
              }
            ],
            "startLine": 45
          }
        ],
        "structs": [
          {
            "name": "SignerP256Storage",
            "members": [
              {
                "name": "_qx",
                "type": "bytes32"
              },
              {
                "name": "_qy",
                "type": "bytes32"
              }
            ],
            "startLine": 31
          }
        ],
        "stateVariables": [
          {
            "name": "SignerP256StorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 37
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/cryptography/P256.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/cryptography/signers/SignerP256.sol)\n\npragma solidity ^0.8.20;\n\nimport {AbstractSigner} from \"@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol\";\nimport {P256} from \"@openzeppelin/contracts/utils/cryptography/P256.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of {AbstractSigner} using xref:api:utils/cryptography#P256[P256] signatures.\n *\n * For {Account} usage, a {_setSigner} function is provided to set the {signer} public key.\n * Doing so is easier for a factory, who is likely to use initializable clones of this contract.\n *\n * Example of usage:\n *\n * ```solidity\n * contract MyAccountP256 is Account, SignerP256, Initializable {\n *     function initialize(bytes32 qx, bytes32 qy) public initializer {\n *       _setSigner(qx, qy);\n *     }\n * }\n * ```\n *\n * IMPORTANT: Failing to call {_setSigner} either during construction (if used standalone)\n * or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.\n */\nabstract contract SignerP256Upgradeable is Initializable, AbstractSigner {\n    /// @custom:storage-location erc7201:openzeppelin.storage.SignerP256\n    struct SignerP256Storage {\n        bytes32 _qx;\n        bytes32 _qy;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.SignerP256\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant SignerP256StorageLocation = 0x6c6e681eb9c9937bb0e9a845af882a34f03801b1b670c4e5431f8b41c16a2700;\n\n    function _getSignerP256Storage() private pure returns (SignerP256Storage storage $) {\n        assembly {\n            $.slot := SignerP256StorageLocation\n        }\n    }\n\n    error SignerP256InvalidPublicKey(bytes32 qx, bytes32 qy);\n\n    function __SignerP256_init(bytes32 qx, bytes32 qy) internal onlyInitializing {\n        __SignerP256_init_unchained(qx, qy);\n    }\n\n    function __SignerP256_init_unchained(bytes32 qx, bytes32 qy) internal onlyInitializing {\n        _setSigner(qx, qy);\n    }\n\n    /**\n     * @dev Sets the signer with a P256 public key. This function should be called during construction\n     * or through an initializer.\n     */\n    function _setSigner(bytes32 qx, bytes32 qy) internal {\n        SignerP256Storage storage $ = _getSignerP256Storage();\n        if (!P256.isValidPublicKey(qx, qy)) revert SignerP256InvalidPublicKey(qx, qy);\n        $._qx = qx;\n        $._qy = qy;\n    }\n\n    /// @dev Return the signer's P256 public key.\n    function signer() public view virtual returns (bytes32 qx, bytes32 qy) {\n        SignerP256Storage storage $ = _getSignerP256Storage();\n        return ($._qx, $._qy);\n    }\n\n    /// @inheritdoc AbstractSigner\n    function _rawSignatureValidation(\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view virtual override returns (bool) {\n        if (signature.length < 0x40) return false;\n        bytes32 r = bytes32(signature[0x00:0x20]);\n        bytes32 s = bytes32(signature[0x20:0x40]);\n        (bytes32 qx, bytes32 qy) = signer();\n        return P256.verify(hash, r, s, qx, qy);\n    }\n}\n"
      },
      {
        "name": "SignerRSAUpgradeable",
        "filePath": "utils/cryptography/signers/SignerRSAUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "AbstractSigner"
        ],
        "implements": [],
        "category": "utils/cryptography",
        "externalFunctions": [
          {
            "name": "signer",
            "signature": "signer()",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "e",
                "type": "bytes"
              },
              {
                "name": "n",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "_getSignerRSAStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function signer() public view virtual returns (bytes memory e, bytes memory n) {\n        SignerRSAStorage storage $ = _getSignerRSAStorage();\n        return ($._e, $._n);\n    }",
            "startLine": 64
          }
        ],
        "internalFunctions": [
          {
            "name": "_getSignerRSAStorage",
            "visibility": "private",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "SignerRSAStorage"
              }
            ],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function _getSignerRSAStorage() private pure returns (SignerRSAStorage storage $) {\n        assembly {\n            $.slot := SignerRSAStorageLocation\n        }\n    }",
            "startLine": 39
          },
          {
            "name": "__SignerRSA_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "e",
                "type": "bytes"
              },
              {
                "name": "n",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __SignerRSA_init(bytes memory e, bytes memory n) internal onlyInitializing {\n        __SignerRSA_init_unchained(e, n);\n    }",
            "startLine": 45
          },
          {
            "name": "__SignerRSA_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "e",
                "type": "bytes"
              },
              {
                "name": "n",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_setSigner",
                "type": "internal",
                "argCount": 2
              }
            ],
            "isVirtual": false,
            "sourceCode": "function __SignerRSA_init_unchained(bytes memory e, bytes memory n) internal onlyInitializing {\n        _setSigner(e, n);\n    }",
            "startLine": 49
          },
          {
            "name": "_setSigner",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "e",
                "type": "bytes"
              },
              {
                "name": "n",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getSignerRSAStorage",
                "type": "internal",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _setSigner(bytes memory e, bytes memory n) internal {\n        SignerRSAStorage storage $ = _getSignerRSAStorage();\n        $._e = e;\n        $._n = n;\n    }",
            "startLine": 57
          },
          {
            "name": "_rawSignatureValidation",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "signer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "RSA.pkcs1Sha256",
                "type": "library",
                "argCount": 4
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _rawSignatureValidation(\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view virtual override returns (bool) {\n        (bytes memory e, bytes memory n) = signer();\n        return RSA.pkcs1Sha256(abi.encodePacked(hash), signature, e, n);\n    }",
            "startLine": 77
          }
        ],
        "events": [],
        "errors": [],
        "structs": [
          {
            "name": "SignerRSAStorage",
            "members": [
              {
                "name": "_e",
                "type": "bytes"
              },
              {
                "name": "_n",
                "type": "bytes"
              }
            ],
            "startLine": 31
          }
        ],
        "stateVariables": [
          {
            "name": "SignerRSAStorageLocation",
            "type": "bytes32",
            "visibility": "private",
            "isConstant": true,
            "isImmutable": false,
            "startLine": 37
          }
        ],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/cryptography/RSA.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/cryptography/signers/SignerRSA.sol)\n\npragma solidity ^0.8.20;\n\nimport {AbstractSigner} from \"@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol\";\nimport {RSA} from \"@openzeppelin/contracts/utils/cryptography/RSA.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of {AbstractSigner} using xref:api:utils/cryptography#RSA[RSA] signatures.\n *\n * For {Account} usage, a {_setSigner} function is provided to set the {signer} public key.\n * Doing so is easier for a factory, who is likely to use initializable clones of this contract.\n *\n * Example of usage:\n *\n * ```solidity\n * contract MyAccountRSA is Account, SignerRSA, Initializable {\n *     function initialize(bytes memory e, bytes memory n) public initializer {\n *       _setSigner(e, n);\n *     }\n * }\n * ```\n *\n * IMPORTANT: Failing to call {_setSigner} either during construction (if used standalone)\n * or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.\n */\nabstract contract SignerRSAUpgradeable is Initializable, AbstractSigner {\n    /// @custom:storage-location erc7201:openzeppelin.storage.SignerRSA\n    struct SignerRSAStorage {\n        bytes _e;\n        bytes _n;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.SignerRSA\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant SignerRSAStorageLocation = 0x8bf15870295cd9a811d81afc339672ef68c88b80db19b9fcfad708cc10d31600;\n\n    function _getSignerRSAStorage() private pure returns (SignerRSAStorage storage $) {\n        assembly {\n            $.slot := SignerRSAStorageLocation\n        }\n    }\n\n    function __SignerRSA_init(bytes memory e, bytes memory n) internal onlyInitializing {\n        __SignerRSA_init_unchained(e, n);\n    }\n\n    function __SignerRSA_init_unchained(bytes memory e, bytes memory n) internal onlyInitializing {\n        _setSigner(e, n);\n    }\n\n    /**\n     * @dev Sets the signer with a RSA public key. This function should be called during construction\n     * or through an initializer.\n     */\n    function _setSigner(bytes memory e, bytes memory n) internal {\n        SignerRSAStorage storage $ = _getSignerRSAStorage();\n        $._e = e;\n        $._n = n;\n    }\n\n    /// @dev Return the signer's RSA public key.\n    function signer() public view virtual returns (bytes memory e, bytes memory n) {\n        SignerRSAStorage storage $ = _getSignerRSAStorage();\n        return ($._e, $._n);\n    }\n\n    /**\n     * @dev See {AbstractSigner-_rawSignatureValidation}. Verifies a PKCSv1.5 signature by calling\n     * xref:api:utils/cryptography.adoc#RSA-pkcs1Sha256-bytes-bytes-bytes-bytes-[RSA.pkcs1Sha256].\n     *\n     * IMPORTANT: Following the RSASSA-PKCS1-V1_5-VERIFY procedure outlined in RFC8017 (section 8.2.2), the\n     * provided `hash` is used as the `M` (message) and rehashed using SHA256 according to EMSA-PKCS1-v1_5\n     * encoding as per section 9.2 (step 1) of the RFC.\n     */\n    function _rawSignatureValidation(\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view virtual override returns (bool) {\n        (bytes memory e, bytes memory n) = signer();\n        return RSA.pkcs1Sha256(abi.encodePacked(hash), signature, e, n);\n    }\n}\n"
      },
      {
        "name": "SignerWebAuthnUpgradeable",
        "filePath": "utils/cryptography/signers/SignerWebAuthnUpgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "SignerP256Upgradeable"
        ],
        "implements": [],
        "category": "utils/cryptography",
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "__SignerWebAuthn_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __SignerWebAuthn_init() internal onlyInitializing {\n    }",
            "startLine": 33
          },
          {
            "name": "__SignerWebAuthn_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __SignerWebAuthn_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 36
          },
          {
            "name": "_rawSignatureValidation",
            "visibility": "internal",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "WebAuthn.tryDecodeAuth",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "signer",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "WebAuthn.verify",
                "type": "library",
                "argCount": 4
              },
              {
                "target": "_rawSignatureValidation",
                "type": "super",
                "argCount": 2
              }
            ],
            "isVirtual": true,
            "sourceCode": "function _rawSignatureValidation(\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view virtual override returns (bool) {\n        (bool decodeSuccess, WebAuthn.WebAuthnAuth calldata auth) = WebAuthn.tryDecodeAuth(signature);\n        if (decodeSuccess) {\n            (bytes32 qx, bytes32 qy) = signer();\n            return WebAuthn.verify(abi.encodePacked(hash), auth, qx, qy);\n        } else {\n            return super._rawSignatureValidation(hash, signature);\n        }\n    }",
            "startLine": 45
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "./SignerP256Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/cryptography/WebAuthn.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/cryptography/signers/SignerWebAuthn.sol)\n\npragma solidity ^0.8.24;\n\nimport {SignerP256Upgradeable} from \"./SignerP256Upgradeable.sol\";\nimport {WebAuthn} from \"@openzeppelin/contracts/utils/cryptography/WebAuthn.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of {SignerP256} that supports WebAuthn authentication assertions.\n *\n * This contract enables signature validation using WebAuthn authentication assertions,\n * leveraging the P256 public key stored in the contract. It allows for both WebAuthn\n * and raw P256 signature validation, providing compatibility with both signature types.\n *\n * The signature is expected to be an abi-encoded {WebAuthn-WebAuthnAuth} struct.\n *\n * Example usage:\n *\n * ```solidity\n * contract MyAccountWebAuthn is Account, SignerWebAuthn, Initializable {\n *     function initialize(bytes32 qx, bytes32 qy) public initializer {\n *         _setSigner(qx, qy);\n *     }\n * }\n * ```\n *\n * IMPORTANT: Failing to call {_setSigner} either during construction (if used standalone)\n * or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.\n */\nabstract contract SignerWebAuthnUpgradeable is Initializable, SignerP256Upgradeable {\n    function __SignerWebAuthn_init() internal onlyInitializing {\n    }\n\n    function __SignerWebAuthn_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Validates a raw signature using the WebAuthn authentication assertion.\n     *\n     * In case the signature can't be validated, it falls back to the\n     * {SignerP256-_rawSignatureValidation} method for raw P256 signature validation by passing\n     * the raw `r` and `s` values from the signature.\n     */\n    function _rawSignatureValidation(\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view virtual override returns (bool) {\n        (bool decodeSuccess, WebAuthn.WebAuthnAuth calldata auth) = WebAuthn.tryDecodeAuth(signature);\n        if (decodeSuccess) {\n            (bytes32 qx, bytes32 qy) = signer();\n            return WebAuthn.verify(abi.encodePacked(hash), auth, qx, qy);\n        } else {\n            return super._rawSignatureValidation(hash, signature);\n        }\n    }\n}\n"
      },
      {
        "name": "ERC7739Upgradeable",
        "filePath": "utils/cryptography/signers/draft-ERC7739Upgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "AbstractSigner",
          "EIP712Upgradeable",
          "IERC1271"
        ],
        "implements": [],
        "category": "utils/cryptography",
        "externalFunctions": [
          {
            "name": "isValidSignature",
            "signature": "isValidSignature(bytes32,bytes)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "result",
                "type": "bytes4"
              }
            ],
            "calls": [
              {
                "target": "_isValidNestedTypedDataSignature",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "_isValidNestedPersonalSignSignature",
                "type": "internal",
                "argCount": 2
              }
            ],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function isValidSignature(bytes32 hash, bytes calldata signature) public view virtual returns (bytes4 result) {\n        // For the hash `0x7739773977397739773977397739773977397739773977397739773977397739` and an empty signature,\n        // we return the magic value `0x77390001` as it's assumed impossible to find a preimage for it that can be used\n        // maliciously. Useful for simulation purposes and to validate whether the contract supports ERC-7739.\n        return\n            (_isValidNestedTypedDataSignature(hash, signature) || _isValidNestedPersonalSignSignature(hash, signature))\n                ? IERC1271.isValidSignature.selector\n                : (hash == 0x7739773977397739773977397739773977397739773977397739773977397739 && signature.length == 0)\n                    ? bytes4(0x77390001)\n                    : bytes4(0xffffffff);\n    }",
            "startLine": 44
          }
        ],
        "internalFunctions": [
          {
            "name": "__ERC7739_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC7739_init() internal onlyInitializing {\n    }",
            "startLine": 31
          },
          {
            "name": "__ERC7739_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC7739_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 34
          },
          {
            "name": "_isValidNestedPersonalSignSignature",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "signature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_rawSignatureValidation",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "toTypedDataHash",
                "type": "external",
                "targetType": "_domainSeparatorV4",
                "argCount": 1
              },
              {
                "target": "_domainSeparatorV4",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "ERC7739Utils.personalSignStructHash",
                "type": "library",
                "argCount": 0
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _isValidNestedPersonalSignSignature(bytes32 hash, bytes calldata signature) private view returns (bool) {\n        return _rawSignatureValidation(_domainSeparatorV4().toTypedDataHash(hash.personalSignStructHash()), signature);\n    }",
            "startLine": 59
          },
          {
            "name": "_isValidNestedTypedDataSignature",
            "visibility": "private",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "hash",
                "type": "bytes32"
              },
              {
                "name": "encodedSignature",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "ERC7739Utils.decodeTypedDataSig",
                "type": "library",
                "argCount": 0
              },
              {
                "target": "eip712Domain",
                "type": "internal",
                "argCount": 0
              },
              {
                "target": "ERC7739Utils.toTypedDataHash",
                "type": "library",
                "argCount": 1
              },
              {
                "target": "_rawSignatureValidation",
                "type": "internal",
                "argCount": 2
              },
              {
                "target": "ERC7739Utils.typedDataSignStructHash",
                "type": "library",
                "argCount": 3
              }
            ],
            "isVirtual": false,
            "sourceCode": "function _isValidNestedTypedDataSignature(\n        bytes32 hash,\n        bytes calldata encodedSignature\n    ) private view returns (bool) {\n        // decode signature\n        (\n            bytes calldata signature,\n            bytes32 appSeparator,\n            bytes32 contentsHash,\n            string calldata contentsDescr\n        ) = encodedSignature.decodeTypedDataSig();\n\n        (\n            ,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n\n        ) = eip712Domain();\n\n        // Check that contentHash and separator are correct\n        // Rebuild nested hash\n        return\n            hash == appSeparator.toTypedDataHash(contentsHash) &&\n            bytes(contentsDescr).length != 0 &&\n            _rawSignatureValidation(\n                appSeparator.toTypedDataHash(\n                    ERC7739Utils.typedDataSignStructHash(\n                        contentsDescr,\n                        contentsHash,\n                        abi.encode(keccak256(bytes(name)), keccak256(bytes(version)), chainId, verifyingContract, salt)\n                    )\n                ),\n                signature\n            );\n    }",
            "startLine": 66
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [
          "ERC7739Utils",
          "MessageHashUtils"
        ],
        "imports": [
          {
            "path": "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "../EIP712Upgradeable.sol",
            "name": "",
            "alias": "",
            "isExternal": false
          },
          {
            "path": "@openzeppelin/contracts/utils/cryptography/draft-ERC7739Utils.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/interfaces/IERC1271.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/cryptography/signers/draft-ERC7739.sol)\n\npragma solidity ^0.8.24;\n\nimport {AbstractSigner} from \"@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol\";\nimport {EIP712Upgradeable} from \"../EIP712Upgradeable.sol\";\nimport {ERC7739Utils} from \"@openzeppelin/contracts/utils/cryptography/draft-ERC7739Utils.sol\";\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {MessageHashUtils} from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Validates signatures wrapping the message hash in a nested EIP712 type. See {ERC7739Utils}.\n *\n * Linking the signature to the EIP-712 domain separator is a security measure to prevent signature replay across different\n * EIP-712 domains (e.g. a single offchain owner of multiple contracts).\n *\n * This contract requires implementing the {_rawSignatureValidation} function, which passes the wrapped message hash,\n * which may be either an typed data or a personal sign nested type.\n *\n * NOTE: xref:api:utils/cryptography#EIP712[EIP-712] uses xref:api:utils/cryptography#ShortStrings[ShortStrings] to\n * optimize gas costs for short strings (up to 31 characters). Consider that strings longer than that will use storage,\n * which may limit the ability of the signer to be used within the ERC-4337 validation phase (due to\n * https://eips.ethereum.org/EIPS/eip-7562#storage-rules[ERC-7562 storage access rules]).\n */\nabstract contract ERC7739Upgradeable is Initializable, AbstractSigner, EIP712Upgradeable, IERC1271 {\n    using ERC7739Utils for *;\n    using MessageHashUtils for bytes32;\n\n    function __ERC7739_init() internal onlyInitializing {\n    }\n\n    function __ERC7739_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Attempts validating the signature in a nested EIP-712 type.\n     *\n     * A nested EIP-712 type might be presented in 2 different ways:\n     *\n     * - As a nested EIP-712 typed data\n     * - As a _personal_ signature (an EIP-712 mimic of the `eth_personalSign` for a smart contract)\n     */\n    function isValidSignature(bytes32 hash, bytes calldata signature) public view virtual returns (bytes4 result) {\n        // For the hash `0x7739773977397739773977397739773977397739773977397739773977397739` and an empty signature,\n        // we return the magic value `0x77390001` as it's assumed impossible to find a preimage for it that can be used\n        // maliciously. Useful for simulation purposes and to validate whether the contract supports ERC-7739.\n        return\n            (_isValidNestedTypedDataSignature(hash, signature) || _isValidNestedPersonalSignSignature(hash, signature))\n                ? IERC1271.isValidSignature.selector\n                : (hash == 0x7739773977397739773977397739773977397739773977397739773977397739 && signature.length == 0)\n                    ? bytes4(0x77390001)\n                    : bytes4(0xffffffff);\n    }\n\n    /**\n     * @dev Nested personal signature verification.\n     */\n    function _isValidNestedPersonalSignSignature(bytes32 hash, bytes calldata signature) private view returns (bool) {\n        return _rawSignatureValidation(_domainSeparatorV4().toTypedDataHash(hash.personalSignStructHash()), signature);\n    }\n\n    /**\n     * @dev Nested EIP-712 typed data verification.\n     */\n    function _isValidNestedTypedDataSignature(\n        bytes32 hash,\n        bytes calldata encodedSignature\n    ) private view returns (bool) {\n        // decode signature\n        (\n            bytes calldata signature,\n            bytes32 appSeparator,\n            bytes32 contentsHash,\n            string calldata contentsDescr\n        ) = encodedSignature.decodeTypedDataSig();\n\n        (\n            ,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n\n        ) = eip712Domain();\n\n        // Check that contentHash and separator are correct\n        // Rebuild nested hash\n        return\n            hash == appSeparator.toTypedDataHash(contentsHash) &&\n            bytes(contentsDescr).length != 0 &&\n            _rawSignatureValidation(\n                appSeparator.toTypedDataHash(\n                    ERC7739Utils.typedDataSignStructHash(\n                        contentsDescr,\n                        contentsHash,\n                        abi.encode(keccak256(bytes(name)), keccak256(bytes(version)), chainId, verifyingContract, salt)\n                    )\n                ),\n                signature\n            );\n    }\n}\n"
      },
      {
        "name": "ERC165Upgradeable",
        "filePath": "utils/introspection/ERC165Upgradeable.sol",
        "kind": "abstract",
        "inherits": [
          "Initializable",
          "IERC165"
        ],
        "implements": [],
        "category": "utils/introspection",
        "externalFunctions": [
          {
            "name": "supportsInterface",
            "signature": "supportsInterface(bytes4)",
            "selector": "",
            "visibility": "public",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "interfaceId",
                "type": "bytes4"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "modifiers": [],
            "isVirtual": true,
            "sourceCode": "function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }",
            "startLine": 28
          }
        ],
        "internalFunctions": [
          {
            "name": "__ERC165_init",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC165_init() internal onlyInitializing {\n    }",
            "startLine": 22
          },
          {
            "name": "__ERC165_init_unchained",
            "visibility": "internal",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "isVirtual": false,
            "sourceCode": "function __ERC165_init_unchained() internal onlyInitializing {\n    }",
            "startLine": 25
          }
        ],
        "events": [],
        "errors": [],
        "structs": [],
        "stateVariables": [],
        "usesLibraries": [],
        "imports": [
          {
            "path": "@openzeppelin/contracts/utils/introspection/IERC165.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          },
          {
            "path": "@openzeppelin/contracts/proxy/utils/Initializable.sol",
            "name": "",
            "alias": "",
            "isExternal": true
          }
        ],
        "sourceCode": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
      }
    ],
    "dependencies": [],
    "proxyGroups": [],
    "stats": {
      "totalContracts": 85,
      "totalLibraries": 0,
      "totalInterfaces": 0,
      "totalFunctions": 902
    }
  }
}