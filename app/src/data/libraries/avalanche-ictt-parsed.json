{
  "id": "avalanche-ictt",
  "name": "Avalanche ICTT",
  "version": "1.0.0",
  "generatedAt": "2026-01-27T07:24:09.572Z",
  "callGraph": {
    "version": "1.0.0",
    "generatedAt": "2026-01-27T07:24:09.572Z",
    "projectName": "Avalanche ICTT",
    "structure": {
      "name": "contracts",
      "type": "directory",
      "path": "contracts",
      "children": [
        {
          "name": "@ictt",
          "type": "directory",
          "path": "contracts/@ictt",
          "children": [
            {
              "name": "TokenHome",
              "type": "directory",
              "path": "contracts/@ictt/TokenHome",
              "children": [
                {
                  "name": "ERC20TokenHome.sol",
                  "type": "file",
                  "path": "contracts/@ictt/TokenHome/ERC20TokenHome.sol",
                  "contractName": "ERC20TokenHome"
                },
                {
                  "name": "ERC20TokenHomeUpgradeable.sol",
                  "type": "file",
                  "path": "contracts/@ictt/TokenHome/ERC20TokenHomeUpgradeable.sol",
                  "contractName": "ERC20TokenHomeUpgradeable"
                },
                {
                  "name": "NativeTokenHome.sol",
                  "type": "file",
                  "path": "contracts/@ictt/TokenHome/NativeTokenHome.sol",
                  "contractName": "NativeTokenHome"
                },
                {
                  "name": "NativeTokenHomeUpgradeable.sol",
                  "type": "file",
                  "path": "contracts/@ictt/TokenHome/NativeTokenHomeUpgradeable.sol",
                  "contractName": "NativeTokenHomeUpgradeable"
                },
                {
                  "name": "TokenHome.sol",
                  "type": "file",
                  "path": "contracts/@ictt/TokenHome/TokenHome.sol",
                  "contractName": "TokenHome"
                },
                {
                  "name": "interfaces",
                  "type": "directory",
                  "path": "contracts/@ictt/TokenHome/interfaces",
                  "children": [
                    {
                      "name": "IERC20TokenHome.sol",
                      "type": "file",
                      "path": "contracts/@ictt/TokenHome/interfaces/IERC20TokenHome.sol",
                      "contractName": "IERC20TokenHome"
                    },
                    {
                      "name": "INativeTokenHome.sol",
                      "type": "file",
                      "path": "contracts/@ictt/TokenHome/interfaces/INativeTokenHome.sol",
                      "contractName": "INativeTokenHome"
                    },
                    {
                      "name": "ITokenHome.sol",
                      "type": "file",
                      "path": "contracts/@ictt/TokenHome/interfaces/ITokenHome.sol",
                      "contractName": "ITokenHome"
                    }
                  ]
                }
              ]
            },
            {
              "name": "TokenRemote",
              "type": "directory",
              "path": "contracts/@ictt/TokenRemote",
              "children": [
                {
                  "name": "ERC20TokenRemote.sol",
                  "type": "file",
                  "path": "contracts/@ictt/TokenRemote/ERC20TokenRemote.sol",
                  "contractName": "ERC20TokenRemote"
                },
                {
                  "name": "ERC20TokenRemoteUpgradeable.sol",
                  "type": "file",
                  "path": "contracts/@ictt/TokenRemote/ERC20TokenRemoteUpgradeable.sol",
                  "contractName": "ERC20TokenRemoteUpgradeable"
                },
                {
                  "name": "NativeTokenRemote.sol",
                  "type": "file",
                  "path": "contracts/@ictt/TokenRemote/NativeTokenRemote.sol",
                  "contractName": "NativeTokenRemote"
                },
                {
                  "name": "NativeTokenRemoteUpgradeable.sol",
                  "type": "file",
                  "path": "contracts/@ictt/TokenRemote/NativeTokenRemoteUpgradeable.sol",
                  "contractName": "NativeTokenRemoteUpgradeable"
                },
                {
                  "name": "TokenRemote.sol",
                  "type": "file",
                  "path": "contracts/@ictt/TokenRemote/TokenRemote.sol",
                  "contractName": "TokenRemote"
                },
                {
                  "name": "interfaces",
                  "type": "directory",
                  "path": "contracts/@ictt/TokenRemote/interfaces",
                  "children": [
                    {
                      "name": "INativeTokenRemote.sol",
                      "type": "file",
                      "path": "contracts/@ictt/TokenRemote/interfaces/INativeTokenRemote.sol",
                      "contractName": "INativeTokenRemote"
                    },
                    {
                      "name": "ITokenRemote.sol",
                      "type": "file",
                      "path": "contracts/@ictt/TokenRemote/interfaces/ITokenRemote.sol",
                      "contractName": "ITokenRemote"
                    }
                  ]
                }
              ]
            },
            {
              "name": "WrappedNativeToken.sol",
              "type": "file",
              "path": "contracts/@ictt/WrappedNativeToken.sol",
              "contractName": "WrappedNativeToken"
            },
            {
              "name": "interfaces",
              "type": "directory",
              "path": "contracts/@ictt/interfaces",
              "children": [
                {
                  "name": "IERC20SendAndCallReceiver.sol",
                  "type": "file",
                  "path": "contracts/@ictt/interfaces/IERC20SendAndCallReceiver.sol",
                  "contractName": "IERC20SendAndCallReceiver"
                },
                {
                  "name": "IERC20TokenTransferrer.sol",
                  "type": "file",
                  "path": "contracts/@ictt/interfaces/IERC20TokenTransferrer.sol",
                  "contractName": "IERC20TokenTransferrer"
                },
                {
                  "name": "INativeSendAndCallReceiver.sol",
                  "type": "file",
                  "path": "contracts/@ictt/interfaces/INativeSendAndCallReceiver.sol",
                  "contractName": "INativeSendAndCallReceiver"
                },
                {
                  "name": "INativeTokenTransferrer.sol",
                  "type": "file",
                  "path": "contracts/@ictt/interfaces/INativeTokenTransferrer.sol",
                  "contractName": "INativeTokenTransferrer"
                },
                {
                  "name": "ITokenTransferrer.sol",
                  "type": "file",
                  "path": "contracts/@ictt/interfaces/ITokenTransferrer.sol",
                  "contractName": "ITokenTransferrer"
                },
                {
                  "name": "IWrappedNativeToken.sol",
                  "type": "file",
                  "path": "contracts/@ictt/interfaces/IWrappedNativeToken.sol",
                  "contractName": "IWrappedNativeToken"
                }
              ]
            }
          ]
        },
        {
          "name": "@openzeppelin",
          "type": "directory",
          "path": "contracts/@openzeppelin",
          "children": [
            {
              "name": "contracts@5.0.2",
              "type": "directory",
              "path": "contracts/@openzeppelin/contracts@5.0.2",
              "children": [
                {
                  "name": "token",
                  "type": "directory",
                  "path": "contracts/@openzeppelin/contracts@5.0.2/token",
                  "children": [
                    {
                      "name": "ERC20",
                      "type": "directory",
                      "path": "contracts/@openzeppelin/contracts@5.0.2/token/ERC20",
                      "children": [
                        {
                          "name": "ERC20.sol",
                          "type": "file",
                          "path": "contracts/@openzeppelin/contracts@5.0.2/token/ERC20/ERC20.sol",
                          "contractName": "ERC20"
                        },
                        {
                          "name": "utils",
                          "type": "directory",
                          "path": "contracts/@openzeppelin/contracts@5.0.2/token/ERC20/utils",
                          "children": [
                            {
                              "name": "SafeERC20.sol",
                              "type": "file",
                              "path": "contracts/@openzeppelin/contracts@5.0.2/token/ERC20/utils/SafeERC20.sol",
                              "contractName": "SafeERC20"
                            }
                          ]
                        },
                        {
                          "name": "IERC20.sol",
                          "type": "file",
                          "path": "contracts/@openzeppelin/contracts@5.0.2/token/ERC20/IERC20.sol",
                          "contractName": "IERC20"
                        }
                      ]
                    }
                  ]
                },
                {
                  "name": "utils",
                  "type": "directory",
                  "path": "contracts/@openzeppelin/contracts@5.0.2/utils",
                  "children": [
                    {
                      "name": "Address.sol",
                      "type": "file",
                      "path": "contracts/@openzeppelin/contracts@5.0.2/utils/Address.sol",
                      "contractName": "Address"
                    }
                  ]
                }
              ]
            },
            {
              "name": "contracts-upgradeable@5.0.2",
              "type": "directory",
              "path": "contracts/@openzeppelin/contracts-upgradeable@5.0.2",
              "children": [
                {
                  "name": "token",
                  "type": "directory",
                  "path": "contracts/@openzeppelin/contracts-upgradeable@5.0.2/token",
                  "children": [
                    {
                      "name": "ERC20",
                      "type": "directory",
                      "path": "contracts/@openzeppelin/contracts-upgradeable@5.0.2/token/ERC20",
                      "children": [
                        {
                          "name": "ERC20Upgradeable.sol",
                          "type": "file",
                          "path": "contracts/@openzeppelin/contracts-upgradeable@5.0.2/token/ERC20/ERC20Upgradeable.sol",
                          "contractName": "ERC20Upgradeable"
                        }
                      ]
                    }
                  ]
                },
                {
                  "name": "access",
                  "type": "directory",
                  "path": "contracts/@openzeppelin/contracts-upgradeable@5.0.2/access",
                  "children": [
                    {
                      "name": "OwnableUpgradeable.sol",
                      "type": "file",
                      "path": "contracts/@openzeppelin/contracts-upgradeable@5.0.2/access/OwnableUpgradeable.sol",
                      "contractName": "OwnableUpgradeable"
                    }
                  ]
                },
                {
                  "name": "proxy",
                  "type": "directory",
                  "path": "contracts/@openzeppelin/contracts-upgradeable@5.0.2/proxy",
                  "children": [
                    {
                      "name": "utils",
                      "type": "directory",
                      "path": "contracts/@openzeppelin/contracts-upgradeable@5.0.2/proxy/utils",
                      "children": [
                        {
                          "name": "Initializable.sol",
                          "type": "file",
                          "path": "contracts/@openzeppelin/contracts-upgradeable@5.0.2/proxy/utils/Initializable.sol",
                          "contractName": "Initializable"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "name": "contracts",
              "type": "directory",
              "path": "contracts/@openzeppelin/contracts",
              "children": [
                {
                  "name": "token",
                  "type": "directory",
                  "path": "contracts/@openzeppelin/contracts/token",
                  "children": [
                    {
                      "name": "ERC20",
                      "type": "directory",
                      "path": "contracts/@openzeppelin/contracts/token/ERC20",
                      "children": [
                        {
                          "name": "IERC20.sol",
                          "type": "file",
                          "path": "contracts/@openzeppelin/contracts/token/ERC20/IERC20.sol",
                          "contractName": "IERC20"
                        },
                        {
                          "name": "extensions",
                          "type": "directory",
                          "path": "contracts/@openzeppelin/contracts/token/ERC20/extensions",
                          "children": [
                            {
                              "name": "IERC20Metadata.sol",
                              "type": "file",
                              "path": "contracts/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol",
                              "contractName": "IERC20Metadata"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "name": "interfaces",
                  "type": "directory",
                  "path": "contracts/@openzeppelin/contracts/interfaces",
                  "children": [
                    {
                      "name": "draft-IERC6093.sol",
                      "type": "file",
                      "path": "contracts/@openzeppelin/contracts/interfaces/draft-IERC6093.sol",
                      "contractName": "IERC20Errors"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "name": "@utilities",
          "type": "directory",
          "path": "contracts/@utilities",
          "children": [
            {
              "name": "SafeERC20TransferFrom.sol",
              "type": "file",
              "path": "contracts/@utilities/SafeERC20TransferFrom.sol",
              "contractName": "SafeERC20TransferFrom"
            },
            {
              "name": "CallUtils.sol",
              "type": "file",
              "path": "contracts/@utilities/CallUtils.sol",
              "contractName": "CallUtils"
            },
            {
              "name": "SafeWrappedNativeTokenDeposit.sol",
              "type": "file",
              "path": "contracts/@utilities/SafeWrappedNativeTokenDeposit.sol",
              "contractName": "SafeWrappedNativeTokenDeposit"
            },
            {
              "name": "SendReentrancyGuardUpgradeable.sol",
              "type": "file",
              "path": "contracts/@utilities/SendReentrancyGuardUpgradeable.sol",
              "contractName": "SendReentrancyGuardUpgradeable"
            },
            {
              "name": "TokenScalingUtils.sol",
              "type": "file",
              "path": "contracts/@utilities/TokenScalingUtils.sol",
              "contractName": "TokenScalingUtils"
            }
          ]
        },
        {
          "name": "@teleporter",
          "type": "directory",
          "path": "contracts/@teleporter",
          "children": [
            {
              "name": "ITeleporterMessenger.sol",
              "type": "file",
              "path": "contracts/@teleporter/ITeleporterMessenger.sol",
              "contractName": "ITeleporterMessenger"
            },
            {
              "name": "registry",
              "type": "directory",
              "path": "contracts/@teleporter/registry",
              "children": [
                {
                  "name": "TeleporterRegistryOwnableAppUpgradeable.sol",
                  "type": "file",
                  "path": "contracts/@teleporter/registry/TeleporterRegistryOwnableAppUpgradeable.sol",
                  "contractName": "TeleporterRegistryOwnableAppUpgradeable"
                }
              ]
            },
            {
              "name": "ITeleporterReceiver.sol",
              "type": "file",
              "path": "contracts/@teleporter/ITeleporterReceiver.sol",
              "contractName": "ITeleporterReceiver"
            }
          ]
        },
        {
          "name": "@subnet-evm",
          "type": "directory",
          "path": "contracts/@subnet-evm",
          "children": [
            {
              "name": "IWarpMessenger.sol",
              "type": "file",
              "path": "contracts/@subnet-evm/IWarpMessenger.sol",
              "contractName": "IWarpMessenger"
            },
            {
              "name": "INativeMinter.sol",
              "type": "file",
              "path": "contracts/@subnet-evm/INativeMinter.sol",
              "contractName": "INativeMinter"
            },
            {
              "name": "IAllowList.sol",
              "type": "file",
              "path": "contracts/@subnet-evm/IAllowList.sol",
              "contractName": "IAllowList"
            }
          ]
        }
      ]
    },
    "contracts": [
      {
        "name": "ERC20TokenHome",
        "kind": "contract",
        "category": "ictt",
        "filePath": "@ictt/TokenHome/ERC20TokenHome.sol",
        "inherits": [
          "ERC20TokenHomeUpgradeable"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "ERC20TokenHomeUpgradeable",
            "path": "./ERC20TokenHomeUpgradeable.sol",
            "isExternal": false
          },
          {
            "name": "ICMInitializable",
            "path": "@utilities/ICMInitializable.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "initialize",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "teleporterManager",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              },
              {
                "name": "tokenAddress",
                "type": "address"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ERC20TokenHome_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initialize(\n        address teleporterRegistryAddress,\n        address teleporterManager,\n        uint256 minTeleporterVersion,\n        address tokenAddress,\n        uint8 tokenDecimals\n    ) public initializer {\n        __ERC20TokenHome_init(\n            teleporterRegistryAddress,\n            teleporterManager,\n            minTeleporterVersion,\n            tokenAddress,\n            tokenDecimals\n        );\n    }",
            "startLine": 77,
            "signature": "initialize(address,address,uint256,address,uint8)",
            "selector": "0x0439bbde",
            "visibility": "public",
            "modifiers": [
              "initializer"
            ],
            "inheritedFrom": "ERC20TokenHomeUpgradeable"
          },
          {
            "name": "send",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_send",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function send(SendTokensInput calldata input, uint256 amount) external {\n        _send(input, amount);\n    }",
            "startLine": 122,
            "signature": "send(SendTokensInput,uint256)",
            "selector": "0x247bc3d4",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "ERC20TokenHomeUpgradeable"
          },
          {
            "name": "sendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_sendAndCall",
                "type": "internal"
              },
              {
                "target": "getBlockchainID",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function sendAndCall(SendAndCallInput calldata input, uint256 amount) external {\n        _sendAndCall({\n            sourceBlockchainID: getBlockchainID(),\n            originTokenTransferrerAddress: address(this),\n            originSenderAddress: _msgSender(),\n            input: input,\n            amount: amount\n        });\n    }",
            "startLine": 129,
            "signature": "sendAndCall(SendAndCallInput,uint256)",
            "selector": "0x6f1f7d9c",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "ERC20TokenHomeUpgradeable"
          },
          {
            "name": "addCollateral",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_addCollateral",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function addCollateral(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) external {\n        _addCollateral(remoteBlockchainID, remoteTokenTransferrerAddress, amount);\n    }",
            "startLine": 142,
            "signature": "addCollateral(bytes32,address,uint256)",
            "selector": "0x52339fe6",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "ERC20TokenHomeUpgradeable"
          },
          {
            "name": "getRemoteTokenTransferrerSettings",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "RemoteTokenTransferrerSettings"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getRemoteTokenTransferrerSettings(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress\n    ) public view returns (RemoteTokenTransferrerSettings memory) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n    }",
            "startLine": 143,
            "signature": "getRemoteTokenTransferrerSettings(bytes32,address)",
            "selector": "0x7e9ee7c5",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "getTransferredBalance",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTransferredBalance(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress\n    ) public view returns (uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress];\n    }",
            "startLine": 151,
            "signature": "getTransferredBalance(bytes32,address)",
            "selector": "0x07d1716d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "getTokenAddress",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenAddress() public view returns (address) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._tokenAddress;\n    }",
            "startLine": 159,
            "signature": "getTokenAddress()",
            "selector": "0x4a82cef2",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "getBlockchainID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getBlockchainID() public view returns (bytes32) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._blockchainID;\n    }",
            "startLine": 164,
            "signature": "getBlockchainID()",
            "selector": "0x587a98a6",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }",
            "startLine": 73,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "renounceOwnership",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
            "startLine": 94,
            "signature": "renounceOwnership()",
            "selector": "0x765becbf",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }",
            "startLine": 102,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC20TokenHomeStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC20TokenHomeStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getERC20TokenHomeStorage() private pure returns (ERC20TokenHomeStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := ERC20_TOKEN_HOME_STORAGE_LOCATION\n        }\n    }",
            "startLine": 52,
            "visibility": "private",
            "inheritedFrom": "ERC20TokenHomeUpgradeable"
          },
          {
            "name": "__ERC20TokenHome_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "teleporterManager",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              },
              {
                "name": "tokenAddress",
                "type": "address"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TokenHome_init",
                "type": "internal"
              },
              {
                "target": "__ERC20TokenHome_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20TokenHome_init(\n        address teleporterRegistryAddress,\n        address teleporterManager,\n        uint256 minTeleporterVersion,\n        address tokenAddress,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        __TokenHome_init(\n            teleporterRegistryAddress,\n            teleporterManager,\n            minTeleporterVersion,\n            tokenAddress,\n            tokenDecimals\n        );\n        __ERC20TokenHome_init_unchained(tokenAddress);\n    }",
            "startLine": 94,
            "visibility": "internal",
            "inheritedFrom": "ERC20TokenHomeUpgradeable"
          },
          {
            "name": "__ERC20TokenHome_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenAddress",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20TokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20TokenHome_init_unchained(\n        address tokenAddress\n    ) internal onlyInitializing {\n        _getERC20TokenHomeStorage()._token = IERC20(tokenAddress);\n    }",
            "startLine": 112,
            "visibility": "internal",
            "inheritedFrom": "ERC20TokenHomeUpgradeable"
          },
          {
            "name": "_deposit",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20TokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "SafeERC20TransferFrom.safeTransferFrom",
                "type": "library"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _deposit(\n        uint256 amount\n    ) internal virtual override returns (uint256) {\n        ERC20TokenHomeStorage storage $ = _getERC20TokenHomeStorage();\n        return SafeERC20TransferFrom.safeTransferFrom($._token, _msgSender(), amount);\n    }",
            "startLine": 153,
            "visibility": "internal",
            "inheritedFrom": "ERC20TokenHomeUpgradeable"
          },
          {
            "name": "_withdraw",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "recipient",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20TokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensWithdrawn"
            ],
            "isVirtual": true,
            "sourceCode": "function _withdraw(address recipient, uint256 amount) internal virtual override {\n        ERC20TokenHomeStorage storage $ = _getERC20TokenHomeStorage();\n        emit TokensWithdrawn(recipient, amount);\n        $._token.safeTransfer(recipient, amount);\n    }",
            "startLine": 163,
            "visibility": "internal",
            "inheritedFrom": "ERC20TokenHomeUpgradeable"
          },
          {
            "name": "_handleSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "message",
                "type": "SingleHopCallMessage"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20TokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "SafeERC20.safeIncreaseAllowance",
                "type": "library"
              },
              {
                "target": "CallUtils._callWithExactGas",
                "type": "library"
              },
              {
                "target": "token.allowance",
                "type": "external"
              },
              {
                "target": "SafeERC20.forceApprove",
                "type": "library"
              },
              {
                "target": "token.safeTransfer",
                "type": "external"
              }
            ],
            "emits": [
              "CallSucceeded",
              "CallFailed"
            ],
            "isVirtual": true,
            "sourceCode": "function _handleSendAndCall(\n        SingleHopCallMessage memory message,\n        uint256 amount\n    ) internal virtual override {\n        ERC20TokenHomeStorage storage $ = _getERC20TokenHomeStorage();\n        IERC20 token = $._token;\n        // Approve the recipient contract to spend the amount from the collateral.\n        SafeERC20.safeIncreaseAllowance($._token, message.recipientContract, amount);\n\n        // Encode the call to {IERC20SendAndCallReceiver-receiveTokens}\n        bytes memory payload = abi.encodeCall(\n            IERC20SendAndCallReceiver.receiveTokens,\n            (\n                message.sourceBlockchainID,\n                message.originTokenTransferrerAddress,\n                message.originSenderAddress,\n                address(token),\n                amount,\n                message.recipientPayload\n            )\n        );\n\n        // Call the recipient contract with the given payload and gas amount.\n        bool success = CallUtils._callWithExactGas(\n            message.recipientGasLimit, message.recipientContract, payload\n        );\n\n        uint256 remainingAllowance = token.allowance(address(this), message.recipientContract);\n\n        // Reset the recipient contract allowance to 0.\n        SafeERC20.forceApprove(token, message.recipientContract, 0);\n\n        if (success) {\n            emit CallSucceeded(message.recipientContract, amount);\n        } else {\n            emit CallFailed(message.recipientContract, amount);\n        }\n\n        // Transfer any remaining allowance to the fallback recipient. This will be the\n        // full amount if the call failed.\n        if (remainingAllowance > 0) {\n            token.safeTransfer(message.fallbackRecipient, remainingAllowance);\n        }\n    }",
            "startLine": 177,
            "visibility": "internal",
            "inheritedFrom": "ERC20TokenHomeUpgradeable"
          },
          {
            "name": "_getTokenHomeStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "TokenHomeStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getTokenHomeStorage() private pure returns (TokenHomeStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := TOKEN_HOME_STORAGE_LOCATION\n        }\n    }",
            "startLine": 94,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "__TokenHome_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "teleporterManager",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              },
              {
                "name": "tokenAddress",
                "type": "address"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryOwnableApp_init",
                "type": "internal"
              },
              {
                "target": "__SendReentrancyGuard_init",
                "type": "internal"
              },
              {
                "target": "__TokenHome_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function __TokenHome_init(\n        address teleporterRegistryAddress,\n        address teleporterManager,\n        uint256 minTeleporterVersion,\n        address tokenAddress,\n        uint8 tokenDecimals\n    ) internal virtual onlyInitializing {\n        __TeleporterRegistryOwnableApp_init(\n            teleporterRegistryAddress, teleporterManager, minTeleporterVersion\n        );\n        __SendReentrancyGuard_init();\n        __TokenHome_init_unchained(tokenAddress, tokenDecimals);\n    }",
            "startLine": 111,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "__TokenHome_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenAddress",
                "type": "address"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TokenHome_init_unchained(\n        address tokenAddress,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        require(tokenAddress != address(0), \"TokenHome: zero token address\");\n        require(\n            tokenDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenHome: token decimals too high\"\n        );\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        $._blockchainID =\n            IWarpMessenger(0x0200000000000000000000000000000000000005).getBlockchainID();\n        $._tokenAddress = tokenAddress;\n        $._tokenDecimals = tokenDecimals;\n    }",
            "startLine": 126,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_registerRemote",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "message",
                "type": "RegisterRemoteMessage"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.deriveTokenMultiplierValues",
                "type": "library"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [
              "RemoteRegistered"
            ],
            "isVirtual": false,
            "sourceCode": "function _registerRemote(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        RegisterRemoteMessage memory message\n    ) internal {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        require(remoteBlockchainID != bytes32(0), \"TokenHome: zero remote blockchain ID\");\n        require(\n            remoteBlockchainID != $._blockchainID, \"TokenHome: cannot register remote on same chain\"\n        );\n        require(\n            remoteTokenTransferrerAddress != address(0),\n            \"TokenHome: zero remote token transferrer address\"\n        );\n        require(\n            !$._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress].registered,\n            \"TokenHome: remote already registered\"\n        );\n        require(\n            message.remoteTokenDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenHome: remote token decimals too high\"\n        );\n        require(\n            message.homeTokenDecimals == $._tokenDecimals, \"TokenHome: invalid home token decimals\"\n        );\n\n        (uint256 tokenMultiplier, bool multiplyOnRemote) = TokenScalingUtils\n            .deriveTokenMultiplierValues($._tokenDecimals, message.remoteTokenDecimals);\n\n        // Calculate the collateral needed in home token denomination.\n        uint256 collateralNeeded = TokenScalingUtils.removeTokenScale(\n            tokenMultiplier, multiplyOnRemote, message.initialReserveImbalance\n        );\n\n        // Round up the collateral needed by 1 in the case that {multiplyOnRemote} is true and\n        // {initialReserveImbalance} is not divisible by the {tokenMultiplier} to\n        // ensure that the full amount is accounted for.\n        if (multiplyOnRemote && message.initialReserveImbalance % tokenMultiplier != 0) {\n            collateralNeeded += 1;\n        }\n\n        $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress] =\n        RemoteTokenTransferrerSettings({\n            registered: true,\n            collateralNeeded: collateralNeeded,\n            tokenMultiplier: tokenMultiplier,\n            multiplyOnRemote: multiplyOnRemote\n        });\n\n        emit RemoteRegistered(\n            remoteBlockchainID,\n            remoteTokenTransferrerAddress,\n            collateralNeeded,\n            message.remoteTokenDecimals\n        );\n    }",
            "startLine": 169,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_send",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendTokensInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _send(SendTokensInput memory input, uint256 amount) internal sendNonReentrant {\n        _validateSendTokensInput(input);\n        // Require that a single hop transfer does not have a multi-hop fallback recipient.\n        require(input.multiHopFallback == address(0), \"TokenHome: non-zero multi-hop fallback\");\n\n        (uint256 adjustedAmount, uint256 feeAmount) = _prepareSend({\n            remoteBlockchainID: input.destinationBlockchainID,\n            remoteTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            feeAmount: input.primaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_SEND,\n            payload: abi.encode(\n                SingleHopSendMessage({recipient: input.recipient, amount: adjustedAmount})\n            )\n        });\n\n        // Send message to the TokenRemote instance\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: feeAmount\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensSent(messageID, _msgSender(), input, adjustedAmount);\n    }",
            "startLine": 239,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_routeMultiHop",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendTokensInput",
                "type": "internal"
              },
              {
                "target": "_prepareMultiHopRouting",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensRouted"
            ],
            "isVirtual": false,
            "sourceCode": "function _routeMultiHop(\n        SendTokensInput memory input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        _validateSendTokensInput(input);\n\n        uint256 adjustedAmount = _prepareMultiHopRouting(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            amount,\n            input.primaryFee\n        );\n\n        if (adjustedAmount == 0) {\n            // If the adjusted amount is zero for any reason (i.e. unregistered remote,\n            // being scaled down to zero, etc.), send the tokens to the multi-hop fallback.\n            _withdraw(input.multiHopFallback, amount);\n            return;\n        }\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_SEND,\n            payload: abi.encode(\n                SingleHopSendMessage({recipient: input.recipient, amount: adjustedAmount})\n            )\n        });\n\n        // Send message to the TokenRemote instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: input.primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensRouted(messageID, input, adjustedAmount);\n    }",
            "startLine": 290,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_sendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendAndCallInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _sendAndCall(\n        bytes32 sourceBlockchainID,\n        address originTokenTransferrerAddress,\n        address originSenderAddress,\n        SendAndCallInput memory input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        _validateSendAndCallInput(input);\n\n        // Require that a single hop transfer does not have a multi-hop fallback recipient.\n        require(input.multiHopFallback == address(0), \"TokenHome: non-zero multi-hop fallback\");\n\n        (uint256 adjustedAmount, uint256 feeAmount) = _prepareSend({\n            remoteBlockchainID: input.destinationBlockchainID,\n            remoteTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            feeAmount: input.primaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_CALL,\n            payload: abi.encode(\n                SingleHopCallMessage({\n                    sourceBlockchainID: sourceBlockchainID,\n                    originTokenTransferrerAddress: originTokenTransferrerAddress,\n                    originSenderAddress: originSenderAddress,\n                    recipientContract: input.recipientContract,\n                    amount: adjustedAmount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient\n                })\n            )\n        });\n\n        // Send message to the TokenRemote instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: feeAmount\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallSent(messageID, originSenderAddress, input, adjustedAmount);\n    }",
            "startLine": 335,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_routeMultiHopSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendAndCallInput",
                "type": "internal"
              },
              {
                "target": "_prepareMultiHopRouting",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallRouted"
            ],
            "isVirtual": false,
            "sourceCode": "function _routeMultiHopSendAndCall(\n        bytes32 sourceBlockchainID,\n        address originTokenTransferrerAddress,\n        address originSenderAddress,\n        SendAndCallInput memory input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        _validateSendAndCallInput(input);\n        uint256 adjustedAmount = _prepareMultiHopRouting(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            amount,\n            input.primaryFee\n        );\n\n        if (adjustedAmount == 0) {\n            // If the adjusted amount is zero for any reason (i.e. unregistered remote,\n            // being scaled down to zero, etc.), send the tokens to the multi-hop fallback recipient.\n            _withdraw(input.multiHopFallback, amount);\n            return;\n        }\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_CALL,\n            payload: abi.encode(\n                SingleHopCallMessage({\n                    sourceBlockchainID: sourceBlockchainID,\n                    originTokenTransferrerAddress: originTokenTransferrerAddress,\n                    originSenderAddress: originSenderAddress,\n                    recipientContract: input.recipientContract,\n                    amount: adjustedAmount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient\n                })\n            )\n        });\n\n        // Send message to the TokenRemote instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: input.primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallRouted(messageID, input, adjustedAmount);\n    }",
            "startLine": 389,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_addCollateral",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_deposit",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "CollateralAdded"
            ],
            "isVirtual": false,
            "sourceCode": "function _addCollateral(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) internal sendNonReentrant {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n        require(remoteSettings.registered, \"TokenHome: remote not registered\");\n        require(remoteSettings.collateralNeeded > 0, \"TokenHome: zero collateral needed\");\n\n        // Deposit the full amount, and withdraw back to the sender if there is excess.\n        amount = _deposit(amount);\n\n        // Calculate the remaining collateral needed, any excess amount, and adjust\n        // {amount} to represent the amount of tokens added as collateral.\n        uint256 remainingCollateralNeeded;\n        uint256 excessAmount;\n        if (amount >= remoteSettings.collateralNeeded) {\n            remainingCollateralNeeded = 0;\n            excessAmount = amount - remoteSettings.collateralNeeded;\n            amount = remoteSettings.collateralNeeded;\n        } else {\n            remainingCollateralNeeded = remoteSettings.collateralNeeded - amount;\n        }\n\n        // Update the remaining collateral needed.\n        $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress].collateralNeeded =\n            remainingCollateralNeeded;\n        emit CollateralAdded(\n            remoteBlockchainID, remoteTokenTransferrerAddress, amount, remainingCollateralNeeded\n        );\n\n        // If there is excess amount, send it back to the sender.\n        if (excessAmount > 0) {\n            _withdraw(_msgSender(), excessAmount);\n        }\n    }",
            "startLine": 448,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_receiveTeleporterMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "message",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_processSingleHopTransfer",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_handleSendAndCall",
                "type": "internal"
              },
              {
                "target": "_processMultiHopTransfer",
                "type": "internal"
              },
              {
                "target": "_routeMultiHop",
                "type": "internal"
              },
              {
                "target": "_routeMultiHopSendAndCall",
                "type": "internal"
              },
              {
                "target": "_registerRemote",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _receiveTeleporterMessage(\n        bytes32 sourceBlockchainID,\n        address originSenderAddress,\n        bytes memory message\n    ) internal override {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        TransferrerMessage memory transferrerMessage = abi.decode(message, (TransferrerMessage));\n        if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_SEND) {\n            SingleHopSendMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopSendMessage));\n\n            uint256 homeAmount =\n                _processSingleHopTransfer(sourceBlockchainID, originSenderAddress, payload.amount);\n\n            // Send the tokens to the recipient.\n            _withdraw(payload.recipient, homeAmount);\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_CALL) {\n            SingleHopCallMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopCallMessage));\n\n            uint256 homeAmount =\n                _processSingleHopTransfer(sourceBlockchainID, originSenderAddress, payload.amount);\n\n            // Verify that the payload's source blockchain ID and origin token transferrer address matches the source blockchain ID\n            // and origin sender address passed from Teleporter.\n            require(\n                payload.sourceBlockchainID == sourceBlockchainID,\n                \"TokenHome: mismatched source blockchain ID\"\n            );\n            require(\n                payload.originTokenTransferrerAddress == originSenderAddress,\n                \"TokenHome: mismatched origin sender address\"\n            );\n\n            _handleSendAndCall(payload, homeAmount);\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.MULTI_HOP_SEND) {\n            MultiHopSendMessage memory payload =\n                abi.decode(transferrerMessage.payload, (MultiHopSendMessage));\n\n            (uint256 homeAmount, uint256 fee) = _processMultiHopTransfer(\n                sourceBlockchainID, originSenderAddress, payload.amount, payload.secondaryFee\n            );\n\n            // For a multi-hop send, the fee token address has to be {tokenAddress},\n            // because the fee is taken from the amount that has already been deposited.\n            // For ERC20 tokens, the token address of the contract is directly passed.\n            // For native assets, the contract address is the wrapped token contract.\n            _routeMultiHop(\n                SendTokensInput({\n                    destinationBlockchainID: payload.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: payload.destinationTokenTransferrerAddress,\n                    recipient: payload.recipient,\n                    primaryFeeTokenAddress: $._tokenAddress,\n                    primaryFee: fee,\n                    secondaryFee: 0,\n                    requiredGasLimit: payload.secondaryGasLimit,\n                    multiHopFallback: payload.multiHopFallback\n                }),\n                homeAmount\n            );\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.MULTI_HOP_CALL) {\n            MultiHopCallMessage memory payload =\n                abi.decode(transferrerMessage.payload, (MultiHopCallMessage));\n\n            (uint256 homeAmount, uint256 fee) = _processMultiHopTransfer(\n                sourceBlockchainID, originSenderAddress, payload.amount, payload.secondaryFee\n            );\n\n            // For a multi-hop send, the fee token address has to be {tokenAddress},\n            // because the fee is taken from the amount that has already been deposited.\n            // For ERC20 tokens, the token address of the contract is directly passed.\n            // For native assets, the contract address is the wrapped token contract.\n            _routeMultiHopSendAndCall({\n                sourceBlockchainID: sourceBlockchainID,\n                originTokenTransferrerAddress: originSenderAddress,\n                originSenderAddress: payload.originSenderAddress,\n                input: SendAndCallInput({\n                    destinationBlockchainID: payload.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: payload.destinationTokenTransferrerAddress,\n                    recipientContract: payload.recipientContract,\n                    recipientPayload: payload.recipientPayload,\n                    requiredGasLimit: payload.secondaryRequiredGasLimit,\n                    recipientGasLimit: payload.recipientGasLimit,\n                    multiHopFallback: payload.multiHopFallback,\n                    fallbackRecipient: payload.fallbackRecipient,\n                    primaryFeeTokenAddress: $._tokenAddress,\n                    primaryFee: fee,\n                    secondaryFee: 0\n                }),\n                amount: homeAmount\n            });\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.REGISTER_REMOTE) {\n            RegisterRemoteMessage memory payload =\n                abi.decode(transferrerMessage.payload, (RegisterRemoteMessage));\n            _registerRemote(sourceBlockchainID, originSenderAddress, payload);\n        }\n    }",
            "startLine": 494,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_processSingleHopTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_processReceivedTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _processSingleHopTransfer(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) private returns (uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n\n        return _processReceivedTransfer(\n            remoteSettings, remoteBlockchainID, remoteTokenTransferrerAddress, amount\n        );\n    }",
            "startLine": 633,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_processMultiHopTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "secondaryFee",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_processReceivedTransfer",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _processMultiHopTransfer(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount,\n        uint256 secondaryFee\n    ) private returns (uint256, uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n\n        uint256 transferAmount = _processReceivedTransfer(\n            remoteSettings, remoteBlockchainID, remoteTokenTransferrerAddress, amount\n        );\n\n        uint256 fee = TokenScalingUtils.removeTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, secondaryFee\n        );\n\n        return (transferAmount, fee);\n    }",
            "startLine": 657,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_processReceivedTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteSettings",
                "type": "RemoteTokenTransferrerSettings"
              },
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_deductSenderBalance",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _processReceivedTransfer(\n        RemoteTokenTransferrerSettings memory remoteSettings,\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) private returns (uint256) {\n        // Require that the remote is registered and has no collateral needed.\n        require(remoteSettings.registered, \"TokenHome: remote not registered\");\n        require(remoteSettings.collateralNeeded == 0, \"TokenHome: remote not collateralized\");\n\n        // Deduct the balance transferred to the given TokenRemote instance prior to scaling the amount.\n        _deductSenderBalance(remoteBlockchainID, remoteTokenTransferrerAddress, amount);\n\n        // Remove the token scaling of the remote and get home token amount.\n        uint256 homeAmount = TokenScalingUtils.removeTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, amount\n        );\n\n        // Require that the home token amount is greater than zero after removed scaling.\n        require(homeAmount > 0, \"TokenHome: zero token amount\");\n        return homeAmount;\n    }",
            "startLine": 689,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_prepareMultiHopRouting",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "fee",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.applyTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _prepareMultiHopRouting(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount,\n        uint256 fee\n    ) private returns (uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n        if (!remoteSettings.registered || remoteSettings.collateralNeeded > 0) {\n            return 0;\n        }\n\n        // Subtract fee amount from amount prior to scaling.\n        require(amount > fee, \"TokenHome: insufficient amount to cover fees\");\n        amount -= fee;\n\n        // Scale the amount based on the token multiplier for the given TokenRemote instance.\n        uint256 scaledAmount = TokenScalingUtils.applyTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, amount\n        );\n        if (scaledAmount == 0) {\n            return 0;\n        }\n\n        // Increase the balance of the TokenRemote instance by the scaled amount.\n        $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress] += scaledAmount;\n\n        return scaledAmount;\n    }",
            "startLine": 718,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_prepareSend",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "primaryFeeTokenAddress",
                "type": "address"
              },
              {
                "name": "feeAmount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_deposit",
                "type": "internal"
              },
              {
                "target": "SafeERC20TransferFrom.safeTransferFrom",
                "type": "library"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.applyTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _prepareSend(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount,\n        address primaryFeeTokenAddress,\n        uint256 feeAmount\n    ) private returns (uint256, uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n        require(remoteSettings.registered, \"TokenHome: remote not registered\");\n        require(remoteSettings.collateralNeeded == 0, \"TokenHome: collateral needed for remote\");\n\n        // Deposit the funds sent from the user to the token transferrer,\n        // and set to adjusted amount after deposit.\n        amount = _deposit(amount);\n\n        if (feeAmount > 0) {\n            feeAmount = SafeERC20TransferFrom.safeTransferFrom(\n                IERC20(primaryFeeTokenAddress), _msgSender(), feeAmount\n            );\n        }\n\n        // Scale the amount based on the token multiplier for the given TokenRemote instance.\n        uint256 scaledAmount = TokenScalingUtils.applyTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, amount\n        );\n        require(scaledAmount > 0, \"TokenHome: zero scaled amount\");\n\n        // Increase the balance of the TokenRemote instance by the scaled amount.\n        $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress] += scaledAmount;\n\n        return (scaledAmount, feeAmount);\n    }",
            "startLine": 754,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_deductSenderBalance",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _deductSenderBalance(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) private {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        uint256 senderBalance =\n            $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress];\n        require(senderBalance >= amount, \"TokenHome: insufficient token transfer balance\");\n        $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress] =\n            senderBalance - amount;\n    }",
            "startLine": 789,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_validateSendAndCallInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendAndCallInput(\n        SendAndCallInput memory input\n    ) private pure {\n        require(input.recipientContract != address(0), \"TokenHome: zero recipient contract address\");\n        require(input.requiredGasLimit > 0, \"TokenHome: zero required gas limit\");\n        require(input.recipientGasLimit > 0, \"TokenHome: zero recipient gas limit\");\n        require(\n            input.recipientGasLimit < input.requiredGasLimit,\n            \"TokenHome: invalid recipient gas limit\"\n        );\n        require(input.fallbackRecipient != address(0), \"TokenHome: zero fallback recipient address\");\n        require(input.secondaryFee == 0, \"TokenHome: non-zero secondary fee\");\n    }",
            "startLine": 802,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_validateSendTokensInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendTokensInput(\n        SendTokensInput memory input\n    ) private pure {\n        require(input.recipient != address(0), \"TokenHome: zero recipient address\");\n        require(input.requiredGasLimit > 0, \"TokenHome: zero required gas limit\");\n        require(input.secondaryFee == 0, \"TokenHome: non-zero secondary fee\");\n    }",
            "startLine": 816,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "__TeleporterRegistryOwnableApp_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "initialOwner",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryApp_init",
                "type": "internal"
              },
              {
                "target": "__Ownable_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TeleporterRegistryOwnableApp_init(\n        address teleporterRegistryAddress,\n        address initialOwner,\n        uint256 minTeleporterVersion\n    ) internal onlyInitializing {\n        __TeleporterRegistryApp_init(teleporterRegistryAddress, minTeleporterVersion);\n        __Ownable_init(initialOwner);\n    }",
            "startLine": 24,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_TeleporterRegistryOwnableApp_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _TeleporterRegistryOwnableApp_init_unchained() internal onlyInitializing {}",
            "startLine": 34,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_checkTeleporterRegistryAppAccess",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_checkOwner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkTeleporterRegistryAppAccess() internal view virtual override {\n        _checkOwner();\n    }",
            "startLine": 42,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_getOwnableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "OwnableStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }",
            "startLine": 30,
            "visibility": "private",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__Ownable_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }",
            "startLine": 51,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }",
            "startLine": 55,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }",
            "startLine": 81,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "OwnershipTransferred"
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }",
            "startLine": 113,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getSendReentrancyGuardStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "SendReentrancyGuardStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getSendReentrancyGuardStorage()\n        private\n        pure\n        returns (SendReentrancyGuardStorage storage $)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := _SEND_REENTRANCY_GUARD_STORAGE_LOCATION\n        }\n    }",
            "startLine": 35,
            "visibility": "private",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrancyGuard_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "__SendReentrnacyGuard_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrancyGuard_init() internal onlyInitializing {\n        __SendReentrnacyGuard_init_unchained();\n    }",
            "startLine": 59,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrnacyGuard_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getSendReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrnacyGuard_init_unchained() internal {\n        SendReentrancyGuardStorage storage $ = _getSendReentrancyGuardStorage();\n        $._sendEntered = _NOT_ENTERED;\n    }",
            "startLine": 64,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "ERC20TokenHomeUpgradeable",
        "kind": "contract",
        "category": "ictt",
        "filePath": "@ictt/TokenHome/ERC20TokenHomeUpgradeable.sol",
        "inherits": [
          "TokenHome"
        ],
        "implements": [
          "IERC20TokenHome"
        ],
        "usesLibraries": [
          "SafeERC20"
        ],
        "imports": [
          {
            "name": "TokenHome",
            "path": "./TokenHome.sol",
            "isExternal": false
          },
          {
            "name": "IERC20TokenHome",
            "path": "./interfaces/IERC20TokenHome.sol",
            "isExternal": false
          },
          {
            "name": "IERC20SendAndCallReceiver",
            "path": "../interfaces/IERC20SendAndCallReceiver.sol",
            "isExternal": false
          },
          {
            "name": "SendTokensInput",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SendAndCallInput",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SingleHopCallMessage",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "IERC20",
            "path": "@openzeppelin/contracts@5.0.2/token/ERC20/ERC20.sol",
            "isExternal": true
          },
          {
            "name": "SafeERC20",
            "path": "@openzeppelin/contracts@5.0.2/token/ERC20/utils/SafeERC20.sol",
            "isExternal": true
          },
          {
            "name": "SafeERC20TransferFrom",
            "path": "@utilities/SafeERC20TransferFrom.sol",
            "isExternal": true
          },
          {
            "name": "CallUtils",
            "path": "@utilities/CallUtils.sol",
            "isExternal": true
          },
          {
            "name": "ICMInitializable",
            "path": "@utilities/ICMInitializable.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "initialize",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "teleporterManager",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              },
              {
                "name": "tokenAddress",
                "type": "address"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ERC20TokenHome_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initialize(\n        address teleporterRegistryAddress,\n        address teleporterManager,\n        uint256 minTeleporterVersion,\n        address tokenAddress,\n        uint8 tokenDecimals\n    ) public initializer {\n        __ERC20TokenHome_init(\n            teleporterRegistryAddress,\n            teleporterManager,\n            minTeleporterVersion,\n            tokenAddress,\n            tokenDecimals\n        );\n    }",
            "startLine": 77,
            "signature": "initialize(address,address,uint256,address,uint8)",
            "selector": "0x0439bbde",
            "visibility": "public",
            "modifiers": [
              "initializer"
            ]
          },
          {
            "name": "send",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_send",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function send(SendTokensInput calldata input, uint256 amount) external {\n        _send(input, amount);\n    }",
            "startLine": 122,
            "signature": "send(SendTokensInput,uint256)",
            "selector": "0x247bc3d4",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "sendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_sendAndCall",
                "type": "internal"
              },
              {
                "target": "getBlockchainID",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function sendAndCall(SendAndCallInput calldata input, uint256 amount) external {\n        _sendAndCall({\n            sourceBlockchainID: getBlockchainID(),\n            originTokenTransferrerAddress: address(this),\n            originSenderAddress: _msgSender(),\n            input: input,\n            amount: amount\n        });\n    }",
            "startLine": 129,
            "signature": "sendAndCall(SendAndCallInput,uint256)",
            "selector": "0x6f1f7d9c",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "addCollateral",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_addCollateral",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function addCollateral(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) external {\n        _addCollateral(remoteBlockchainID, remoteTokenTransferrerAddress, amount);\n    }",
            "startLine": 142,
            "signature": "addCollateral(bytes32,address,uint256)",
            "selector": "0x52339fe6",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "getRemoteTokenTransferrerSettings",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "RemoteTokenTransferrerSettings"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getRemoteTokenTransferrerSettings(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress\n    ) public view returns (RemoteTokenTransferrerSettings memory) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n    }",
            "startLine": 143,
            "signature": "getRemoteTokenTransferrerSettings(bytes32,address)",
            "selector": "0x7e9ee7c5",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "getTransferredBalance",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTransferredBalance(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress\n    ) public view returns (uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress];\n    }",
            "startLine": 151,
            "signature": "getTransferredBalance(bytes32,address)",
            "selector": "0x07d1716d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "getTokenAddress",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenAddress() public view returns (address) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._tokenAddress;\n    }",
            "startLine": 159,
            "signature": "getTokenAddress()",
            "selector": "0x4a82cef2",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "getBlockchainID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getBlockchainID() public view returns (bytes32) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._blockchainID;\n    }",
            "startLine": 164,
            "signature": "getBlockchainID()",
            "selector": "0x587a98a6",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }",
            "startLine": 73,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "renounceOwnership",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
            "startLine": 94,
            "signature": "renounceOwnership()",
            "selector": "0x765becbf",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }",
            "startLine": 102,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC20TokenHomeStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC20TokenHomeStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getERC20TokenHomeStorage() private pure returns (ERC20TokenHomeStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := ERC20_TOKEN_HOME_STORAGE_LOCATION\n        }\n    }",
            "startLine": 52,
            "visibility": "private"
          },
          {
            "name": "__ERC20TokenHome_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "teleporterManager",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              },
              {
                "name": "tokenAddress",
                "type": "address"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TokenHome_init",
                "type": "internal"
              },
              {
                "target": "__ERC20TokenHome_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20TokenHome_init(\n        address teleporterRegistryAddress,\n        address teleporterManager,\n        uint256 minTeleporterVersion,\n        address tokenAddress,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        __TokenHome_init(\n            teleporterRegistryAddress,\n            teleporterManager,\n            minTeleporterVersion,\n            tokenAddress,\n            tokenDecimals\n        );\n        __ERC20TokenHome_init_unchained(tokenAddress);\n    }",
            "startLine": 94,
            "visibility": "internal"
          },
          {
            "name": "__ERC20TokenHome_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenAddress",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20TokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20TokenHome_init_unchained(\n        address tokenAddress\n    ) internal onlyInitializing {\n        _getERC20TokenHomeStorage()._token = IERC20(tokenAddress);\n    }",
            "startLine": 112,
            "visibility": "internal"
          },
          {
            "name": "_deposit",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20TokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "SafeERC20TransferFrom.safeTransferFrom",
                "type": "library"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _deposit(\n        uint256 amount\n    ) internal virtual override returns (uint256) {\n        ERC20TokenHomeStorage storage $ = _getERC20TokenHomeStorage();\n        return SafeERC20TransferFrom.safeTransferFrom($._token, _msgSender(), amount);\n    }",
            "startLine": 153,
            "visibility": "internal"
          },
          {
            "name": "_withdraw",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "recipient",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20TokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensWithdrawn"
            ],
            "isVirtual": true,
            "sourceCode": "function _withdraw(address recipient, uint256 amount) internal virtual override {\n        ERC20TokenHomeStorage storage $ = _getERC20TokenHomeStorage();\n        emit TokensWithdrawn(recipient, amount);\n        $._token.safeTransfer(recipient, amount);\n    }",
            "startLine": 163,
            "visibility": "internal"
          },
          {
            "name": "_handleSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "message",
                "type": "SingleHopCallMessage"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20TokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "SafeERC20.safeIncreaseAllowance",
                "type": "library"
              },
              {
                "target": "CallUtils._callWithExactGas",
                "type": "library"
              },
              {
                "target": "token.allowance",
                "type": "external"
              },
              {
                "target": "SafeERC20.forceApprove",
                "type": "library"
              },
              {
                "target": "token.safeTransfer",
                "type": "external"
              }
            ],
            "emits": [
              "CallSucceeded",
              "CallFailed"
            ],
            "isVirtual": true,
            "sourceCode": "function _handleSendAndCall(\n        SingleHopCallMessage memory message,\n        uint256 amount\n    ) internal virtual override {\n        ERC20TokenHomeStorage storage $ = _getERC20TokenHomeStorage();\n        IERC20 token = $._token;\n        // Approve the recipient contract to spend the amount from the collateral.\n        SafeERC20.safeIncreaseAllowance($._token, message.recipientContract, amount);\n\n        // Encode the call to {IERC20SendAndCallReceiver-receiveTokens}\n        bytes memory payload = abi.encodeCall(\n            IERC20SendAndCallReceiver.receiveTokens,\n            (\n                message.sourceBlockchainID,\n                message.originTokenTransferrerAddress,\n                message.originSenderAddress,\n                address(token),\n                amount,\n                message.recipientPayload\n            )\n        );\n\n        // Call the recipient contract with the given payload and gas amount.\n        bool success = CallUtils._callWithExactGas(\n            message.recipientGasLimit, message.recipientContract, payload\n        );\n\n        uint256 remainingAllowance = token.allowance(address(this), message.recipientContract);\n\n        // Reset the recipient contract allowance to 0.\n        SafeERC20.forceApprove(token, message.recipientContract, 0);\n\n        if (success) {\n            emit CallSucceeded(message.recipientContract, amount);\n        } else {\n            emit CallFailed(message.recipientContract, amount);\n        }\n\n        // Transfer any remaining allowance to the fallback recipient. This will be the\n        // full amount if the call failed.\n        if (remainingAllowance > 0) {\n            token.safeTransfer(message.fallbackRecipient, remainingAllowance);\n        }\n    }",
            "startLine": 177,
            "visibility": "internal"
          },
          {
            "name": "_getTokenHomeStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "TokenHomeStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getTokenHomeStorage() private pure returns (TokenHomeStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := TOKEN_HOME_STORAGE_LOCATION\n        }\n    }",
            "startLine": 94,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "__TokenHome_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "teleporterManager",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              },
              {
                "name": "tokenAddress",
                "type": "address"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryOwnableApp_init",
                "type": "internal"
              },
              {
                "target": "__SendReentrancyGuard_init",
                "type": "internal"
              },
              {
                "target": "__TokenHome_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function __TokenHome_init(\n        address teleporterRegistryAddress,\n        address teleporterManager,\n        uint256 minTeleporterVersion,\n        address tokenAddress,\n        uint8 tokenDecimals\n    ) internal virtual onlyInitializing {\n        __TeleporterRegistryOwnableApp_init(\n            teleporterRegistryAddress, teleporterManager, minTeleporterVersion\n        );\n        __SendReentrancyGuard_init();\n        __TokenHome_init_unchained(tokenAddress, tokenDecimals);\n    }",
            "startLine": 111,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "__TokenHome_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenAddress",
                "type": "address"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TokenHome_init_unchained(\n        address tokenAddress,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        require(tokenAddress != address(0), \"TokenHome: zero token address\");\n        require(\n            tokenDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenHome: token decimals too high\"\n        );\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        $._blockchainID =\n            IWarpMessenger(0x0200000000000000000000000000000000000005).getBlockchainID();\n        $._tokenAddress = tokenAddress;\n        $._tokenDecimals = tokenDecimals;\n    }",
            "startLine": 126,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_registerRemote",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "message",
                "type": "RegisterRemoteMessage"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.deriveTokenMultiplierValues",
                "type": "library"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [
              "RemoteRegistered"
            ],
            "isVirtual": false,
            "sourceCode": "function _registerRemote(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        RegisterRemoteMessage memory message\n    ) internal {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        require(remoteBlockchainID != bytes32(0), \"TokenHome: zero remote blockchain ID\");\n        require(\n            remoteBlockchainID != $._blockchainID, \"TokenHome: cannot register remote on same chain\"\n        );\n        require(\n            remoteTokenTransferrerAddress != address(0),\n            \"TokenHome: zero remote token transferrer address\"\n        );\n        require(\n            !$._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress].registered,\n            \"TokenHome: remote already registered\"\n        );\n        require(\n            message.remoteTokenDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenHome: remote token decimals too high\"\n        );\n        require(\n            message.homeTokenDecimals == $._tokenDecimals, \"TokenHome: invalid home token decimals\"\n        );\n\n        (uint256 tokenMultiplier, bool multiplyOnRemote) = TokenScalingUtils\n            .deriveTokenMultiplierValues($._tokenDecimals, message.remoteTokenDecimals);\n\n        // Calculate the collateral needed in home token denomination.\n        uint256 collateralNeeded = TokenScalingUtils.removeTokenScale(\n            tokenMultiplier, multiplyOnRemote, message.initialReserveImbalance\n        );\n\n        // Round up the collateral needed by 1 in the case that {multiplyOnRemote} is true and\n        // {initialReserveImbalance} is not divisible by the {tokenMultiplier} to\n        // ensure that the full amount is accounted for.\n        if (multiplyOnRemote && message.initialReserveImbalance % tokenMultiplier != 0) {\n            collateralNeeded += 1;\n        }\n\n        $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress] =\n        RemoteTokenTransferrerSettings({\n            registered: true,\n            collateralNeeded: collateralNeeded,\n            tokenMultiplier: tokenMultiplier,\n            multiplyOnRemote: multiplyOnRemote\n        });\n\n        emit RemoteRegistered(\n            remoteBlockchainID,\n            remoteTokenTransferrerAddress,\n            collateralNeeded,\n            message.remoteTokenDecimals\n        );\n    }",
            "startLine": 169,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_send",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendTokensInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _send(SendTokensInput memory input, uint256 amount) internal sendNonReentrant {\n        _validateSendTokensInput(input);\n        // Require that a single hop transfer does not have a multi-hop fallback recipient.\n        require(input.multiHopFallback == address(0), \"TokenHome: non-zero multi-hop fallback\");\n\n        (uint256 adjustedAmount, uint256 feeAmount) = _prepareSend({\n            remoteBlockchainID: input.destinationBlockchainID,\n            remoteTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            feeAmount: input.primaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_SEND,\n            payload: abi.encode(\n                SingleHopSendMessage({recipient: input.recipient, amount: adjustedAmount})\n            )\n        });\n\n        // Send message to the TokenRemote instance\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: feeAmount\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensSent(messageID, _msgSender(), input, adjustedAmount);\n    }",
            "startLine": 239,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_routeMultiHop",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendTokensInput",
                "type": "internal"
              },
              {
                "target": "_prepareMultiHopRouting",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensRouted"
            ],
            "isVirtual": false,
            "sourceCode": "function _routeMultiHop(\n        SendTokensInput memory input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        _validateSendTokensInput(input);\n\n        uint256 adjustedAmount = _prepareMultiHopRouting(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            amount,\n            input.primaryFee\n        );\n\n        if (adjustedAmount == 0) {\n            // If the adjusted amount is zero for any reason (i.e. unregistered remote,\n            // being scaled down to zero, etc.), send the tokens to the multi-hop fallback.\n            _withdraw(input.multiHopFallback, amount);\n            return;\n        }\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_SEND,\n            payload: abi.encode(\n                SingleHopSendMessage({recipient: input.recipient, amount: adjustedAmount})\n            )\n        });\n\n        // Send message to the TokenRemote instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: input.primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensRouted(messageID, input, adjustedAmount);\n    }",
            "startLine": 290,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_sendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendAndCallInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _sendAndCall(\n        bytes32 sourceBlockchainID,\n        address originTokenTransferrerAddress,\n        address originSenderAddress,\n        SendAndCallInput memory input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        _validateSendAndCallInput(input);\n\n        // Require that a single hop transfer does not have a multi-hop fallback recipient.\n        require(input.multiHopFallback == address(0), \"TokenHome: non-zero multi-hop fallback\");\n\n        (uint256 adjustedAmount, uint256 feeAmount) = _prepareSend({\n            remoteBlockchainID: input.destinationBlockchainID,\n            remoteTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            feeAmount: input.primaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_CALL,\n            payload: abi.encode(\n                SingleHopCallMessage({\n                    sourceBlockchainID: sourceBlockchainID,\n                    originTokenTransferrerAddress: originTokenTransferrerAddress,\n                    originSenderAddress: originSenderAddress,\n                    recipientContract: input.recipientContract,\n                    amount: adjustedAmount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient\n                })\n            )\n        });\n\n        // Send message to the TokenRemote instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: feeAmount\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallSent(messageID, originSenderAddress, input, adjustedAmount);\n    }",
            "startLine": 335,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_routeMultiHopSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendAndCallInput",
                "type": "internal"
              },
              {
                "target": "_prepareMultiHopRouting",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallRouted"
            ],
            "isVirtual": false,
            "sourceCode": "function _routeMultiHopSendAndCall(\n        bytes32 sourceBlockchainID,\n        address originTokenTransferrerAddress,\n        address originSenderAddress,\n        SendAndCallInput memory input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        _validateSendAndCallInput(input);\n        uint256 adjustedAmount = _prepareMultiHopRouting(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            amount,\n            input.primaryFee\n        );\n\n        if (adjustedAmount == 0) {\n            // If the adjusted amount is zero for any reason (i.e. unregistered remote,\n            // being scaled down to zero, etc.), send the tokens to the multi-hop fallback recipient.\n            _withdraw(input.multiHopFallback, amount);\n            return;\n        }\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_CALL,\n            payload: abi.encode(\n                SingleHopCallMessage({\n                    sourceBlockchainID: sourceBlockchainID,\n                    originTokenTransferrerAddress: originTokenTransferrerAddress,\n                    originSenderAddress: originSenderAddress,\n                    recipientContract: input.recipientContract,\n                    amount: adjustedAmount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient\n                })\n            )\n        });\n\n        // Send message to the TokenRemote instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: input.primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallRouted(messageID, input, adjustedAmount);\n    }",
            "startLine": 389,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_addCollateral",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_deposit",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "CollateralAdded"
            ],
            "isVirtual": false,
            "sourceCode": "function _addCollateral(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) internal sendNonReentrant {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n        require(remoteSettings.registered, \"TokenHome: remote not registered\");\n        require(remoteSettings.collateralNeeded > 0, \"TokenHome: zero collateral needed\");\n\n        // Deposit the full amount, and withdraw back to the sender if there is excess.\n        amount = _deposit(amount);\n\n        // Calculate the remaining collateral needed, any excess amount, and adjust\n        // {amount} to represent the amount of tokens added as collateral.\n        uint256 remainingCollateralNeeded;\n        uint256 excessAmount;\n        if (amount >= remoteSettings.collateralNeeded) {\n            remainingCollateralNeeded = 0;\n            excessAmount = amount - remoteSettings.collateralNeeded;\n            amount = remoteSettings.collateralNeeded;\n        } else {\n            remainingCollateralNeeded = remoteSettings.collateralNeeded - amount;\n        }\n\n        // Update the remaining collateral needed.\n        $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress].collateralNeeded =\n            remainingCollateralNeeded;\n        emit CollateralAdded(\n            remoteBlockchainID, remoteTokenTransferrerAddress, amount, remainingCollateralNeeded\n        );\n\n        // If there is excess amount, send it back to the sender.\n        if (excessAmount > 0) {\n            _withdraw(_msgSender(), excessAmount);\n        }\n    }",
            "startLine": 448,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_receiveTeleporterMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "message",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_processSingleHopTransfer",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_handleSendAndCall",
                "type": "internal"
              },
              {
                "target": "_processMultiHopTransfer",
                "type": "internal"
              },
              {
                "target": "_routeMultiHop",
                "type": "internal"
              },
              {
                "target": "_routeMultiHopSendAndCall",
                "type": "internal"
              },
              {
                "target": "_registerRemote",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _receiveTeleporterMessage(\n        bytes32 sourceBlockchainID,\n        address originSenderAddress,\n        bytes memory message\n    ) internal override {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        TransferrerMessage memory transferrerMessage = abi.decode(message, (TransferrerMessage));\n        if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_SEND) {\n            SingleHopSendMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopSendMessage));\n\n            uint256 homeAmount =\n                _processSingleHopTransfer(sourceBlockchainID, originSenderAddress, payload.amount);\n\n            // Send the tokens to the recipient.\n            _withdraw(payload.recipient, homeAmount);\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_CALL) {\n            SingleHopCallMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopCallMessage));\n\n            uint256 homeAmount =\n                _processSingleHopTransfer(sourceBlockchainID, originSenderAddress, payload.amount);\n\n            // Verify that the payload's source blockchain ID and origin token transferrer address matches the source blockchain ID\n            // and origin sender address passed from Teleporter.\n            require(\n                payload.sourceBlockchainID == sourceBlockchainID,\n                \"TokenHome: mismatched source blockchain ID\"\n            );\n            require(\n                payload.originTokenTransferrerAddress == originSenderAddress,\n                \"TokenHome: mismatched origin sender address\"\n            );\n\n            _handleSendAndCall(payload, homeAmount);\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.MULTI_HOP_SEND) {\n            MultiHopSendMessage memory payload =\n                abi.decode(transferrerMessage.payload, (MultiHopSendMessage));\n\n            (uint256 homeAmount, uint256 fee) = _processMultiHopTransfer(\n                sourceBlockchainID, originSenderAddress, payload.amount, payload.secondaryFee\n            );\n\n            // For a multi-hop send, the fee token address has to be {tokenAddress},\n            // because the fee is taken from the amount that has already been deposited.\n            // For ERC20 tokens, the token address of the contract is directly passed.\n            // For native assets, the contract address is the wrapped token contract.\n            _routeMultiHop(\n                SendTokensInput({\n                    destinationBlockchainID: payload.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: payload.destinationTokenTransferrerAddress,\n                    recipient: payload.recipient,\n                    primaryFeeTokenAddress: $._tokenAddress,\n                    primaryFee: fee,\n                    secondaryFee: 0,\n                    requiredGasLimit: payload.secondaryGasLimit,\n                    multiHopFallback: payload.multiHopFallback\n                }),\n                homeAmount\n            );\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.MULTI_HOP_CALL) {\n            MultiHopCallMessage memory payload =\n                abi.decode(transferrerMessage.payload, (MultiHopCallMessage));\n\n            (uint256 homeAmount, uint256 fee) = _processMultiHopTransfer(\n                sourceBlockchainID, originSenderAddress, payload.amount, payload.secondaryFee\n            );\n\n            // For a multi-hop send, the fee token address has to be {tokenAddress},\n            // because the fee is taken from the amount that has already been deposited.\n            // For ERC20 tokens, the token address of the contract is directly passed.\n            // For native assets, the contract address is the wrapped token contract.\n            _routeMultiHopSendAndCall({\n                sourceBlockchainID: sourceBlockchainID,\n                originTokenTransferrerAddress: originSenderAddress,\n                originSenderAddress: payload.originSenderAddress,\n                input: SendAndCallInput({\n                    destinationBlockchainID: payload.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: payload.destinationTokenTransferrerAddress,\n                    recipientContract: payload.recipientContract,\n                    recipientPayload: payload.recipientPayload,\n                    requiredGasLimit: payload.secondaryRequiredGasLimit,\n                    recipientGasLimit: payload.recipientGasLimit,\n                    multiHopFallback: payload.multiHopFallback,\n                    fallbackRecipient: payload.fallbackRecipient,\n                    primaryFeeTokenAddress: $._tokenAddress,\n                    primaryFee: fee,\n                    secondaryFee: 0\n                }),\n                amount: homeAmount\n            });\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.REGISTER_REMOTE) {\n            RegisterRemoteMessage memory payload =\n                abi.decode(transferrerMessage.payload, (RegisterRemoteMessage));\n            _registerRemote(sourceBlockchainID, originSenderAddress, payload);\n        }\n    }",
            "startLine": 494,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_processSingleHopTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_processReceivedTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _processSingleHopTransfer(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) private returns (uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n\n        return _processReceivedTransfer(\n            remoteSettings, remoteBlockchainID, remoteTokenTransferrerAddress, amount\n        );\n    }",
            "startLine": 633,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_processMultiHopTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "secondaryFee",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_processReceivedTransfer",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _processMultiHopTransfer(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount,\n        uint256 secondaryFee\n    ) private returns (uint256, uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n\n        uint256 transferAmount = _processReceivedTransfer(\n            remoteSettings, remoteBlockchainID, remoteTokenTransferrerAddress, amount\n        );\n\n        uint256 fee = TokenScalingUtils.removeTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, secondaryFee\n        );\n\n        return (transferAmount, fee);\n    }",
            "startLine": 657,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_processReceivedTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteSettings",
                "type": "RemoteTokenTransferrerSettings"
              },
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_deductSenderBalance",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _processReceivedTransfer(\n        RemoteTokenTransferrerSettings memory remoteSettings,\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) private returns (uint256) {\n        // Require that the remote is registered and has no collateral needed.\n        require(remoteSettings.registered, \"TokenHome: remote not registered\");\n        require(remoteSettings.collateralNeeded == 0, \"TokenHome: remote not collateralized\");\n\n        // Deduct the balance transferred to the given TokenRemote instance prior to scaling the amount.\n        _deductSenderBalance(remoteBlockchainID, remoteTokenTransferrerAddress, amount);\n\n        // Remove the token scaling of the remote and get home token amount.\n        uint256 homeAmount = TokenScalingUtils.removeTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, amount\n        );\n\n        // Require that the home token amount is greater than zero after removed scaling.\n        require(homeAmount > 0, \"TokenHome: zero token amount\");\n        return homeAmount;\n    }",
            "startLine": 689,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_prepareMultiHopRouting",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "fee",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.applyTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _prepareMultiHopRouting(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount,\n        uint256 fee\n    ) private returns (uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n        if (!remoteSettings.registered || remoteSettings.collateralNeeded > 0) {\n            return 0;\n        }\n\n        // Subtract fee amount from amount prior to scaling.\n        require(amount > fee, \"TokenHome: insufficient amount to cover fees\");\n        amount -= fee;\n\n        // Scale the amount based on the token multiplier for the given TokenRemote instance.\n        uint256 scaledAmount = TokenScalingUtils.applyTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, amount\n        );\n        if (scaledAmount == 0) {\n            return 0;\n        }\n\n        // Increase the balance of the TokenRemote instance by the scaled amount.\n        $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress] += scaledAmount;\n\n        return scaledAmount;\n    }",
            "startLine": 718,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_prepareSend",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "primaryFeeTokenAddress",
                "type": "address"
              },
              {
                "name": "feeAmount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_deposit",
                "type": "internal"
              },
              {
                "target": "SafeERC20TransferFrom.safeTransferFrom",
                "type": "library"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.applyTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _prepareSend(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount,\n        address primaryFeeTokenAddress,\n        uint256 feeAmount\n    ) private returns (uint256, uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n        require(remoteSettings.registered, \"TokenHome: remote not registered\");\n        require(remoteSettings.collateralNeeded == 0, \"TokenHome: collateral needed for remote\");\n\n        // Deposit the funds sent from the user to the token transferrer,\n        // and set to adjusted amount after deposit.\n        amount = _deposit(amount);\n\n        if (feeAmount > 0) {\n            feeAmount = SafeERC20TransferFrom.safeTransferFrom(\n                IERC20(primaryFeeTokenAddress), _msgSender(), feeAmount\n            );\n        }\n\n        // Scale the amount based on the token multiplier for the given TokenRemote instance.\n        uint256 scaledAmount = TokenScalingUtils.applyTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, amount\n        );\n        require(scaledAmount > 0, \"TokenHome: zero scaled amount\");\n\n        // Increase the balance of the TokenRemote instance by the scaled amount.\n        $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress] += scaledAmount;\n\n        return (scaledAmount, feeAmount);\n    }",
            "startLine": 754,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_deductSenderBalance",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _deductSenderBalance(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) private {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        uint256 senderBalance =\n            $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress];\n        require(senderBalance >= amount, \"TokenHome: insufficient token transfer balance\");\n        $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress] =\n            senderBalance - amount;\n    }",
            "startLine": 789,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_validateSendAndCallInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendAndCallInput(\n        SendAndCallInput memory input\n    ) private pure {\n        require(input.recipientContract != address(0), \"TokenHome: zero recipient contract address\");\n        require(input.requiredGasLimit > 0, \"TokenHome: zero required gas limit\");\n        require(input.recipientGasLimit > 0, \"TokenHome: zero recipient gas limit\");\n        require(\n            input.recipientGasLimit < input.requiredGasLimit,\n            \"TokenHome: invalid recipient gas limit\"\n        );\n        require(input.fallbackRecipient != address(0), \"TokenHome: zero fallback recipient address\");\n        require(input.secondaryFee == 0, \"TokenHome: non-zero secondary fee\");\n    }",
            "startLine": 802,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_validateSendTokensInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendTokensInput(\n        SendTokensInput memory input\n    ) private pure {\n        require(input.recipient != address(0), \"TokenHome: zero recipient address\");\n        require(input.requiredGasLimit > 0, \"TokenHome: zero required gas limit\");\n        require(input.secondaryFee == 0, \"TokenHome: non-zero secondary fee\");\n    }",
            "startLine": 816,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "__TeleporterRegistryOwnableApp_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "initialOwner",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryApp_init",
                "type": "internal"
              },
              {
                "target": "__Ownable_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TeleporterRegistryOwnableApp_init(\n        address teleporterRegistryAddress,\n        address initialOwner,\n        uint256 minTeleporterVersion\n    ) internal onlyInitializing {\n        __TeleporterRegistryApp_init(teleporterRegistryAddress, minTeleporterVersion);\n        __Ownable_init(initialOwner);\n    }",
            "startLine": 24,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_TeleporterRegistryOwnableApp_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _TeleporterRegistryOwnableApp_init_unchained() internal onlyInitializing {}",
            "startLine": 34,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_checkTeleporterRegistryAppAccess",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_checkOwner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkTeleporterRegistryAppAccess() internal view virtual override {\n        _checkOwner();\n    }",
            "startLine": 42,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_getOwnableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "OwnableStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }",
            "startLine": 30,
            "visibility": "private",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__Ownable_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }",
            "startLine": 51,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }",
            "startLine": 55,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }",
            "startLine": 81,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "OwnershipTransferred"
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }",
            "startLine": 113,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getSendReentrancyGuardStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "SendReentrancyGuardStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getSendReentrancyGuardStorage()\n        private\n        pure\n        returns (SendReentrancyGuardStorage storage $)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := _SEND_REENTRANCY_GUARD_STORAGE_LOCATION\n        }\n    }",
            "startLine": 35,
            "visibility": "private",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrancyGuard_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "__SendReentrnacyGuard_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrancyGuard_init() internal onlyInitializing {\n        __SendReentrnacyGuard_init_unchained();\n    }",
            "startLine": 59,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrnacyGuard_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getSendReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrnacyGuard_init_unchained() internal {\n        SendReentrancyGuardStorage storage $ = _getSendReentrancyGuardStorage();\n        $._sendEntered = _NOT_ENTERED;\n    }",
            "startLine": 64,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "NativeTokenHome",
        "kind": "contract",
        "category": "ictt",
        "filePath": "@ictt/TokenHome/NativeTokenHome.sol",
        "inherits": [
          "NativeTokenHomeUpgradeable"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "NativeTokenHomeUpgradeable",
            "path": "./NativeTokenHomeUpgradeable.sol",
            "isExternal": false
          },
          {
            "name": "ICMInitializable",
            "path": "@utilities/ICMInitializable.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "initialize",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "teleporterManager",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              },
              {
                "name": "wrappedTokenAddress",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__NativeTokenHome_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initialize(\n        address teleporterRegistryAddress,\n        address teleporterManager,\n        uint256 minTeleporterVersion,\n        address wrappedTokenAddress\n    ) public initializer {\n        __NativeTokenHome_init(\n            teleporterRegistryAddress, teleporterManager, minTeleporterVersion, wrappedTokenAddress\n        );\n    }",
            "startLine": 80,
            "signature": "initialize(address,address,uint256,address)",
            "selector": "0x1df959b0",
            "visibility": "public",
            "modifiers": [
              "initializer"
            ],
            "inheritedFrom": "NativeTokenHomeUpgradeable"
          },
          {
            "name": "send",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_send",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function send(\n        SendTokensInput calldata input\n    ) external payable {\n        _send(input, msg.value);\n    }",
            "startLine": 133,
            "signature": "send(SendTokensInput)",
            "selector": "0x34cc3541",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "NativeTokenHomeUpgradeable"
          },
          {
            "name": "sendAndCall",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_sendAndCall",
                "type": "internal"
              },
              {
                "target": "getBlockchainID",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function sendAndCall(\n        SendAndCallInput calldata input\n    ) external payable {\n        _sendAndCall({\n            sourceBlockchainID: getBlockchainID(),\n            originTokenTransferrerAddress: address(this),\n            originSenderAddress: _msgSender(),\n            input: input,\n            amount: msg.value\n        });\n    }",
            "startLine": 142,
            "signature": "sendAndCall(SendAndCallInput)",
            "selector": "0x4b1f7c2f",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "NativeTokenHomeUpgradeable"
          },
          {
            "name": "addCollateral",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_addCollateral",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function addCollateral(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress\n    ) external payable {\n        _addCollateral(remoteBlockchainID, remoteTokenTransferrerAddress, msg.value);\n    }",
            "startLine": 157,
            "signature": "addCollateral(bytes32,address)",
            "selector": "0x4ac87787",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "NativeTokenHomeUpgradeable"
          },
          {
            "name": "getRemoteTokenTransferrerSettings",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "RemoteTokenTransferrerSettings"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getRemoteTokenTransferrerSettings(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress\n    ) public view returns (RemoteTokenTransferrerSettings memory) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n    }",
            "startLine": 143,
            "signature": "getRemoteTokenTransferrerSettings(bytes32,address)",
            "selector": "0x7e9ee7c5",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "getTransferredBalance",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTransferredBalance(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress\n    ) public view returns (uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress];\n    }",
            "startLine": 151,
            "signature": "getTransferredBalance(bytes32,address)",
            "selector": "0x07d1716d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "getTokenAddress",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenAddress() public view returns (address) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._tokenAddress;\n    }",
            "startLine": 159,
            "signature": "getTokenAddress()",
            "selector": "0x4a82cef2",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "getBlockchainID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getBlockchainID() public view returns (bytes32) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._blockchainID;\n    }",
            "startLine": 164,
            "signature": "getBlockchainID()",
            "selector": "0x587a98a6",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }",
            "startLine": 73,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "renounceOwnership",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
            "startLine": 94,
            "signature": "renounceOwnership()",
            "selector": "0x765becbf",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }",
            "startLine": 102,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          }
        ],
        "internalFunctions": [
          {
            "name": "_getNativeTokenHomeStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "NativeTokenHomeStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getNativeTokenHomeStorage() private pure returns (NativeTokenHomeStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := NATIVE_TOKEN_HOME_STORAGE_LOCATION\n        }\n    }",
            "startLine": 54,
            "visibility": "private",
            "inheritedFrom": "NativeTokenHomeUpgradeable"
          },
          {
            "name": "__NativeTokenHome_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "teleporterManager",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              },
              {
                "name": "wrappedTokenAddress",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TokenHome_init",
                "type": "internal"
              },
              {
                "target": "__NativeTokenHome_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __NativeTokenHome_init(\n        address teleporterRegistryAddress,\n        address teleporterManager,\n        uint256 minTeleporterVersion,\n        address wrappedTokenAddress\n    ) internal onlyInitializing {\n        __TokenHome_init(\n            teleporterRegistryAddress,\n            teleporterManager,\n            minTeleporterVersion,\n            wrappedTokenAddress,\n            18\n        );\n        __NativeTokenHome_init_unchained(wrappedTokenAddress);\n    }",
            "startLine": 92,
            "visibility": "internal",
            "inheritedFrom": "NativeTokenHomeUpgradeable"
          },
          {
            "name": "__NativeTokenHome_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "wrappedTokenAddress",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getNativeTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __NativeTokenHome_init_unchained(\n        address wrappedTokenAddress\n    ) internal onlyInitializing {\n        _getNativeTokenHomeStorage()._wrappedToken = IWrappedNativeToken(wrappedTokenAddress);\n    }",
            "startLine": 109,
            "visibility": "internal",
            "inheritedFrom": "NativeTokenHomeUpgradeable"
          },
          {
            "name": "_deposit",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getNativeTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "SafeWrappedNativeTokenDeposit.safeDeposit",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _deposit(\n        uint256 amount\n    ) internal virtual override returns (uint256) {\n        NativeTokenHomeStorage storage $ = _getNativeTokenHomeStorage();\n        return SafeWrappedNativeTokenDeposit.safeDeposit($._wrappedToken, amount);\n    }",
            "startLine": 168,
            "visibility": "internal",
            "inheritedFrom": "NativeTokenHomeUpgradeable"
          },
          {
            "name": "_withdraw",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "recipient",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getNativeTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensWithdrawn"
            ],
            "isVirtual": true,
            "sourceCode": "function _withdraw(address recipient, uint256 amount) internal virtual override {\n        NativeTokenHomeStorage storage $ = _getNativeTokenHomeStorage();\n        emit TokensWithdrawn(recipient, amount);\n        $._wrappedToken.withdraw(amount);\n        payable(recipient).sendValue(amount);\n    }",
            "startLine": 180,
            "visibility": "internal",
            "inheritedFrom": "NativeTokenHomeUpgradeable"
          },
          {
            "name": "_handleSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "message",
                "type": "SingleHopCallMessage"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getNativeTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "CallUtils._callWithExactGasAndValue",
                "type": "library"
              }
            ],
            "emits": [
              "CallSucceeded",
              "CallFailed"
            ],
            "isVirtual": true,
            "sourceCode": "function _handleSendAndCall(\n        SingleHopCallMessage memory message,\n        uint256 amount\n    ) internal virtual override {\n        NativeTokenHomeStorage storage $ = _getNativeTokenHomeStorage();\n        // Withdraw the native token from the wrapped native token contract.\n        $._wrappedToken.withdraw(amount);\n\n        // Encode the call to {INativeSendAndCallReceiver-receiveTokens}\n        bytes memory payload = abi.encodeCall(\n            INativeSendAndCallReceiver.receiveTokens,\n            (\n                message.sourceBlockchainID,\n                message.originTokenTransferrerAddress,\n                message.originSenderAddress,\n                message.recipientPayload\n            )\n        );\n\n        // Call the recipient contract with the given payload, gas amount, and value.\n        bool success = CallUtils._callWithExactGasAndValue(\n            message.recipientGasLimit, amount, message.recipientContract, payload\n        );\n\n        // If the call failed, send the funds to the fallback recipient.\n        if (success) {\n            emit CallSucceeded(message.recipientContract, amount);\n        } else {\n            emit CallFailed(message.recipientContract, amount);\n            payable(message.fallbackRecipient).sendValue(amount);\n        }\n    }",
            "startLine": 195,
            "visibility": "internal",
            "inheritedFrom": "NativeTokenHomeUpgradeable"
          },
          {
            "name": "_getTokenHomeStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "TokenHomeStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getTokenHomeStorage() private pure returns (TokenHomeStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := TOKEN_HOME_STORAGE_LOCATION\n        }\n    }",
            "startLine": 94,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "__TokenHome_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "teleporterManager",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              },
              {
                "name": "tokenAddress",
                "type": "address"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryOwnableApp_init",
                "type": "internal"
              },
              {
                "target": "__SendReentrancyGuard_init",
                "type": "internal"
              },
              {
                "target": "__TokenHome_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function __TokenHome_init(\n        address teleporterRegistryAddress,\n        address teleporterManager,\n        uint256 minTeleporterVersion,\n        address tokenAddress,\n        uint8 tokenDecimals\n    ) internal virtual onlyInitializing {\n        __TeleporterRegistryOwnableApp_init(\n            teleporterRegistryAddress, teleporterManager, minTeleporterVersion\n        );\n        __SendReentrancyGuard_init();\n        __TokenHome_init_unchained(tokenAddress, tokenDecimals);\n    }",
            "startLine": 111,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "__TokenHome_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenAddress",
                "type": "address"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TokenHome_init_unchained(\n        address tokenAddress,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        require(tokenAddress != address(0), \"TokenHome: zero token address\");\n        require(\n            tokenDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenHome: token decimals too high\"\n        );\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        $._blockchainID =\n            IWarpMessenger(0x0200000000000000000000000000000000000005).getBlockchainID();\n        $._tokenAddress = tokenAddress;\n        $._tokenDecimals = tokenDecimals;\n    }",
            "startLine": 126,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_registerRemote",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "message",
                "type": "RegisterRemoteMessage"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.deriveTokenMultiplierValues",
                "type": "library"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [
              "RemoteRegistered"
            ],
            "isVirtual": false,
            "sourceCode": "function _registerRemote(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        RegisterRemoteMessage memory message\n    ) internal {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        require(remoteBlockchainID != bytes32(0), \"TokenHome: zero remote blockchain ID\");\n        require(\n            remoteBlockchainID != $._blockchainID, \"TokenHome: cannot register remote on same chain\"\n        );\n        require(\n            remoteTokenTransferrerAddress != address(0),\n            \"TokenHome: zero remote token transferrer address\"\n        );\n        require(\n            !$._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress].registered,\n            \"TokenHome: remote already registered\"\n        );\n        require(\n            message.remoteTokenDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenHome: remote token decimals too high\"\n        );\n        require(\n            message.homeTokenDecimals == $._tokenDecimals, \"TokenHome: invalid home token decimals\"\n        );\n\n        (uint256 tokenMultiplier, bool multiplyOnRemote) = TokenScalingUtils\n            .deriveTokenMultiplierValues($._tokenDecimals, message.remoteTokenDecimals);\n\n        // Calculate the collateral needed in home token denomination.\n        uint256 collateralNeeded = TokenScalingUtils.removeTokenScale(\n            tokenMultiplier, multiplyOnRemote, message.initialReserveImbalance\n        );\n\n        // Round up the collateral needed by 1 in the case that {multiplyOnRemote} is true and\n        // {initialReserveImbalance} is not divisible by the {tokenMultiplier} to\n        // ensure that the full amount is accounted for.\n        if (multiplyOnRemote && message.initialReserveImbalance % tokenMultiplier != 0) {\n            collateralNeeded += 1;\n        }\n\n        $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress] =\n        RemoteTokenTransferrerSettings({\n            registered: true,\n            collateralNeeded: collateralNeeded,\n            tokenMultiplier: tokenMultiplier,\n            multiplyOnRemote: multiplyOnRemote\n        });\n\n        emit RemoteRegistered(\n            remoteBlockchainID,\n            remoteTokenTransferrerAddress,\n            collateralNeeded,\n            message.remoteTokenDecimals\n        );\n    }",
            "startLine": 169,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_send",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendTokensInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _send(SendTokensInput memory input, uint256 amount) internal sendNonReentrant {\n        _validateSendTokensInput(input);\n        // Require that a single hop transfer does not have a multi-hop fallback recipient.\n        require(input.multiHopFallback == address(0), \"TokenHome: non-zero multi-hop fallback\");\n\n        (uint256 adjustedAmount, uint256 feeAmount) = _prepareSend({\n            remoteBlockchainID: input.destinationBlockchainID,\n            remoteTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            feeAmount: input.primaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_SEND,\n            payload: abi.encode(\n                SingleHopSendMessage({recipient: input.recipient, amount: adjustedAmount})\n            )\n        });\n\n        // Send message to the TokenRemote instance\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: feeAmount\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensSent(messageID, _msgSender(), input, adjustedAmount);\n    }",
            "startLine": 239,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_routeMultiHop",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendTokensInput",
                "type": "internal"
              },
              {
                "target": "_prepareMultiHopRouting",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensRouted"
            ],
            "isVirtual": false,
            "sourceCode": "function _routeMultiHop(\n        SendTokensInput memory input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        _validateSendTokensInput(input);\n\n        uint256 adjustedAmount = _prepareMultiHopRouting(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            amount,\n            input.primaryFee\n        );\n\n        if (adjustedAmount == 0) {\n            // If the adjusted amount is zero for any reason (i.e. unregistered remote,\n            // being scaled down to zero, etc.), send the tokens to the multi-hop fallback.\n            _withdraw(input.multiHopFallback, amount);\n            return;\n        }\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_SEND,\n            payload: abi.encode(\n                SingleHopSendMessage({recipient: input.recipient, amount: adjustedAmount})\n            )\n        });\n\n        // Send message to the TokenRemote instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: input.primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensRouted(messageID, input, adjustedAmount);\n    }",
            "startLine": 290,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_sendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendAndCallInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _sendAndCall(\n        bytes32 sourceBlockchainID,\n        address originTokenTransferrerAddress,\n        address originSenderAddress,\n        SendAndCallInput memory input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        _validateSendAndCallInput(input);\n\n        // Require that a single hop transfer does not have a multi-hop fallback recipient.\n        require(input.multiHopFallback == address(0), \"TokenHome: non-zero multi-hop fallback\");\n\n        (uint256 adjustedAmount, uint256 feeAmount) = _prepareSend({\n            remoteBlockchainID: input.destinationBlockchainID,\n            remoteTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            feeAmount: input.primaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_CALL,\n            payload: abi.encode(\n                SingleHopCallMessage({\n                    sourceBlockchainID: sourceBlockchainID,\n                    originTokenTransferrerAddress: originTokenTransferrerAddress,\n                    originSenderAddress: originSenderAddress,\n                    recipientContract: input.recipientContract,\n                    amount: adjustedAmount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient\n                })\n            )\n        });\n\n        // Send message to the TokenRemote instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: feeAmount\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallSent(messageID, originSenderAddress, input, adjustedAmount);\n    }",
            "startLine": 335,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_routeMultiHopSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendAndCallInput",
                "type": "internal"
              },
              {
                "target": "_prepareMultiHopRouting",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallRouted"
            ],
            "isVirtual": false,
            "sourceCode": "function _routeMultiHopSendAndCall(\n        bytes32 sourceBlockchainID,\n        address originTokenTransferrerAddress,\n        address originSenderAddress,\n        SendAndCallInput memory input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        _validateSendAndCallInput(input);\n        uint256 adjustedAmount = _prepareMultiHopRouting(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            amount,\n            input.primaryFee\n        );\n\n        if (adjustedAmount == 0) {\n            // If the adjusted amount is zero for any reason (i.e. unregistered remote,\n            // being scaled down to zero, etc.), send the tokens to the multi-hop fallback recipient.\n            _withdraw(input.multiHopFallback, amount);\n            return;\n        }\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_CALL,\n            payload: abi.encode(\n                SingleHopCallMessage({\n                    sourceBlockchainID: sourceBlockchainID,\n                    originTokenTransferrerAddress: originTokenTransferrerAddress,\n                    originSenderAddress: originSenderAddress,\n                    recipientContract: input.recipientContract,\n                    amount: adjustedAmount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient\n                })\n            )\n        });\n\n        // Send message to the TokenRemote instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: input.primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallRouted(messageID, input, adjustedAmount);\n    }",
            "startLine": 389,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_addCollateral",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_deposit",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "CollateralAdded"
            ],
            "isVirtual": false,
            "sourceCode": "function _addCollateral(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) internal sendNonReentrant {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n        require(remoteSettings.registered, \"TokenHome: remote not registered\");\n        require(remoteSettings.collateralNeeded > 0, \"TokenHome: zero collateral needed\");\n\n        // Deposit the full amount, and withdraw back to the sender if there is excess.\n        amount = _deposit(amount);\n\n        // Calculate the remaining collateral needed, any excess amount, and adjust\n        // {amount} to represent the amount of tokens added as collateral.\n        uint256 remainingCollateralNeeded;\n        uint256 excessAmount;\n        if (amount >= remoteSettings.collateralNeeded) {\n            remainingCollateralNeeded = 0;\n            excessAmount = amount - remoteSettings.collateralNeeded;\n            amount = remoteSettings.collateralNeeded;\n        } else {\n            remainingCollateralNeeded = remoteSettings.collateralNeeded - amount;\n        }\n\n        // Update the remaining collateral needed.\n        $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress].collateralNeeded =\n            remainingCollateralNeeded;\n        emit CollateralAdded(\n            remoteBlockchainID, remoteTokenTransferrerAddress, amount, remainingCollateralNeeded\n        );\n\n        // If there is excess amount, send it back to the sender.\n        if (excessAmount > 0) {\n            _withdraw(_msgSender(), excessAmount);\n        }\n    }",
            "startLine": 448,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_receiveTeleporterMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "message",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_processSingleHopTransfer",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_handleSendAndCall",
                "type": "internal"
              },
              {
                "target": "_processMultiHopTransfer",
                "type": "internal"
              },
              {
                "target": "_routeMultiHop",
                "type": "internal"
              },
              {
                "target": "_routeMultiHopSendAndCall",
                "type": "internal"
              },
              {
                "target": "_registerRemote",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _receiveTeleporterMessage(\n        bytes32 sourceBlockchainID,\n        address originSenderAddress,\n        bytes memory message\n    ) internal override {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        TransferrerMessage memory transferrerMessage = abi.decode(message, (TransferrerMessage));\n        if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_SEND) {\n            SingleHopSendMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopSendMessage));\n\n            uint256 homeAmount =\n                _processSingleHopTransfer(sourceBlockchainID, originSenderAddress, payload.amount);\n\n            // Send the tokens to the recipient.\n            _withdraw(payload.recipient, homeAmount);\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_CALL) {\n            SingleHopCallMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopCallMessage));\n\n            uint256 homeAmount =\n                _processSingleHopTransfer(sourceBlockchainID, originSenderAddress, payload.amount);\n\n            // Verify that the payload's source blockchain ID and origin token transferrer address matches the source blockchain ID\n            // and origin sender address passed from Teleporter.\n            require(\n                payload.sourceBlockchainID == sourceBlockchainID,\n                \"TokenHome: mismatched source blockchain ID\"\n            );\n            require(\n                payload.originTokenTransferrerAddress == originSenderAddress,\n                \"TokenHome: mismatched origin sender address\"\n            );\n\n            _handleSendAndCall(payload, homeAmount);\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.MULTI_HOP_SEND) {\n            MultiHopSendMessage memory payload =\n                abi.decode(transferrerMessage.payload, (MultiHopSendMessage));\n\n            (uint256 homeAmount, uint256 fee) = _processMultiHopTransfer(\n                sourceBlockchainID, originSenderAddress, payload.amount, payload.secondaryFee\n            );\n\n            // For a multi-hop send, the fee token address has to be {tokenAddress},\n            // because the fee is taken from the amount that has already been deposited.\n            // For ERC20 tokens, the token address of the contract is directly passed.\n            // For native assets, the contract address is the wrapped token contract.\n            _routeMultiHop(\n                SendTokensInput({\n                    destinationBlockchainID: payload.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: payload.destinationTokenTransferrerAddress,\n                    recipient: payload.recipient,\n                    primaryFeeTokenAddress: $._tokenAddress,\n                    primaryFee: fee,\n                    secondaryFee: 0,\n                    requiredGasLimit: payload.secondaryGasLimit,\n                    multiHopFallback: payload.multiHopFallback\n                }),\n                homeAmount\n            );\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.MULTI_HOP_CALL) {\n            MultiHopCallMessage memory payload =\n                abi.decode(transferrerMessage.payload, (MultiHopCallMessage));\n\n            (uint256 homeAmount, uint256 fee) = _processMultiHopTransfer(\n                sourceBlockchainID, originSenderAddress, payload.amount, payload.secondaryFee\n            );\n\n            // For a multi-hop send, the fee token address has to be {tokenAddress},\n            // because the fee is taken from the amount that has already been deposited.\n            // For ERC20 tokens, the token address of the contract is directly passed.\n            // For native assets, the contract address is the wrapped token contract.\n            _routeMultiHopSendAndCall({\n                sourceBlockchainID: sourceBlockchainID,\n                originTokenTransferrerAddress: originSenderAddress,\n                originSenderAddress: payload.originSenderAddress,\n                input: SendAndCallInput({\n                    destinationBlockchainID: payload.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: payload.destinationTokenTransferrerAddress,\n                    recipientContract: payload.recipientContract,\n                    recipientPayload: payload.recipientPayload,\n                    requiredGasLimit: payload.secondaryRequiredGasLimit,\n                    recipientGasLimit: payload.recipientGasLimit,\n                    multiHopFallback: payload.multiHopFallback,\n                    fallbackRecipient: payload.fallbackRecipient,\n                    primaryFeeTokenAddress: $._tokenAddress,\n                    primaryFee: fee,\n                    secondaryFee: 0\n                }),\n                amount: homeAmount\n            });\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.REGISTER_REMOTE) {\n            RegisterRemoteMessage memory payload =\n                abi.decode(transferrerMessage.payload, (RegisterRemoteMessage));\n            _registerRemote(sourceBlockchainID, originSenderAddress, payload);\n        }\n    }",
            "startLine": 494,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_processSingleHopTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_processReceivedTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _processSingleHopTransfer(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) private returns (uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n\n        return _processReceivedTransfer(\n            remoteSettings, remoteBlockchainID, remoteTokenTransferrerAddress, amount\n        );\n    }",
            "startLine": 633,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_processMultiHopTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "secondaryFee",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_processReceivedTransfer",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _processMultiHopTransfer(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount,\n        uint256 secondaryFee\n    ) private returns (uint256, uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n\n        uint256 transferAmount = _processReceivedTransfer(\n            remoteSettings, remoteBlockchainID, remoteTokenTransferrerAddress, amount\n        );\n\n        uint256 fee = TokenScalingUtils.removeTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, secondaryFee\n        );\n\n        return (transferAmount, fee);\n    }",
            "startLine": 657,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_processReceivedTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteSettings",
                "type": "RemoteTokenTransferrerSettings"
              },
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_deductSenderBalance",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _processReceivedTransfer(\n        RemoteTokenTransferrerSettings memory remoteSettings,\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) private returns (uint256) {\n        // Require that the remote is registered and has no collateral needed.\n        require(remoteSettings.registered, \"TokenHome: remote not registered\");\n        require(remoteSettings.collateralNeeded == 0, \"TokenHome: remote not collateralized\");\n\n        // Deduct the balance transferred to the given TokenRemote instance prior to scaling the amount.\n        _deductSenderBalance(remoteBlockchainID, remoteTokenTransferrerAddress, amount);\n\n        // Remove the token scaling of the remote and get home token amount.\n        uint256 homeAmount = TokenScalingUtils.removeTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, amount\n        );\n\n        // Require that the home token amount is greater than zero after removed scaling.\n        require(homeAmount > 0, \"TokenHome: zero token amount\");\n        return homeAmount;\n    }",
            "startLine": 689,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_prepareMultiHopRouting",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "fee",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.applyTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _prepareMultiHopRouting(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount,\n        uint256 fee\n    ) private returns (uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n        if (!remoteSettings.registered || remoteSettings.collateralNeeded > 0) {\n            return 0;\n        }\n\n        // Subtract fee amount from amount prior to scaling.\n        require(amount > fee, \"TokenHome: insufficient amount to cover fees\");\n        amount -= fee;\n\n        // Scale the amount based on the token multiplier for the given TokenRemote instance.\n        uint256 scaledAmount = TokenScalingUtils.applyTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, amount\n        );\n        if (scaledAmount == 0) {\n            return 0;\n        }\n\n        // Increase the balance of the TokenRemote instance by the scaled amount.\n        $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress] += scaledAmount;\n\n        return scaledAmount;\n    }",
            "startLine": 718,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_prepareSend",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "primaryFeeTokenAddress",
                "type": "address"
              },
              {
                "name": "feeAmount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_deposit",
                "type": "internal"
              },
              {
                "target": "SafeERC20TransferFrom.safeTransferFrom",
                "type": "library"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.applyTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _prepareSend(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount,\n        address primaryFeeTokenAddress,\n        uint256 feeAmount\n    ) private returns (uint256, uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n        require(remoteSettings.registered, \"TokenHome: remote not registered\");\n        require(remoteSettings.collateralNeeded == 0, \"TokenHome: collateral needed for remote\");\n\n        // Deposit the funds sent from the user to the token transferrer,\n        // and set to adjusted amount after deposit.\n        amount = _deposit(amount);\n\n        if (feeAmount > 0) {\n            feeAmount = SafeERC20TransferFrom.safeTransferFrom(\n                IERC20(primaryFeeTokenAddress), _msgSender(), feeAmount\n            );\n        }\n\n        // Scale the amount based on the token multiplier for the given TokenRemote instance.\n        uint256 scaledAmount = TokenScalingUtils.applyTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, amount\n        );\n        require(scaledAmount > 0, \"TokenHome: zero scaled amount\");\n\n        // Increase the balance of the TokenRemote instance by the scaled amount.\n        $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress] += scaledAmount;\n\n        return (scaledAmount, feeAmount);\n    }",
            "startLine": 754,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_deductSenderBalance",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _deductSenderBalance(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) private {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        uint256 senderBalance =\n            $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress];\n        require(senderBalance >= amount, \"TokenHome: insufficient token transfer balance\");\n        $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress] =\n            senderBalance - amount;\n    }",
            "startLine": 789,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_validateSendAndCallInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendAndCallInput(\n        SendAndCallInput memory input\n    ) private pure {\n        require(input.recipientContract != address(0), \"TokenHome: zero recipient contract address\");\n        require(input.requiredGasLimit > 0, \"TokenHome: zero required gas limit\");\n        require(input.recipientGasLimit > 0, \"TokenHome: zero recipient gas limit\");\n        require(\n            input.recipientGasLimit < input.requiredGasLimit,\n            \"TokenHome: invalid recipient gas limit\"\n        );\n        require(input.fallbackRecipient != address(0), \"TokenHome: zero fallback recipient address\");\n        require(input.secondaryFee == 0, \"TokenHome: non-zero secondary fee\");\n    }",
            "startLine": 802,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_validateSendTokensInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendTokensInput(\n        SendTokensInput memory input\n    ) private pure {\n        require(input.recipient != address(0), \"TokenHome: zero recipient address\");\n        require(input.requiredGasLimit > 0, \"TokenHome: zero required gas limit\");\n        require(input.secondaryFee == 0, \"TokenHome: non-zero secondary fee\");\n    }",
            "startLine": 816,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "__TeleporterRegistryOwnableApp_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "initialOwner",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryApp_init",
                "type": "internal"
              },
              {
                "target": "__Ownable_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TeleporterRegistryOwnableApp_init(\n        address teleporterRegistryAddress,\n        address initialOwner,\n        uint256 minTeleporterVersion\n    ) internal onlyInitializing {\n        __TeleporterRegistryApp_init(teleporterRegistryAddress, minTeleporterVersion);\n        __Ownable_init(initialOwner);\n    }",
            "startLine": 24,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_TeleporterRegistryOwnableApp_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _TeleporterRegistryOwnableApp_init_unchained() internal onlyInitializing {}",
            "startLine": 34,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_checkTeleporterRegistryAppAccess",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_checkOwner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkTeleporterRegistryAppAccess() internal view virtual override {\n        _checkOwner();\n    }",
            "startLine": 42,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_getOwnableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "OwnableStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }",
            "startLine": 30,
            "visibility": "private",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__Ownable_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }",
            "startLine": 51,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }",
            "startLine": 55,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }",
            "startLine": 81,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "OwnershipTransferred"
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }",
            "startLine": 113,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getSendReentrancyGuardStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "SendReentrancyGuardStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getSendReentrancyGuardStorage()\n        private\n        pure\n        returns (SendReentrancyGuardStorage storage $)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := _SEND_REENTRANCY_GUARD_STORAGE_LOCATION\n        }\n    }",
            "startLine": 35,
            "visibility": "private",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrancyGuard_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "__SendReentrnacyGuard_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrancyGuard_init() internal onlyInitializing {\n        __SendReentrnacyGuard_init_unchained();\n    }",
            "startLine": 59,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrnacyGuard_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getSendReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrnacyGuard_init_unchained() internal {\n        SendReentrancyGuardStorage storage $ = _getSendReentrancyGuardStorage();\n        $._sendEntered = _NOT_ENTERED;\n    }",
            "startLine": 64,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "NativeTokenHomeUpgradeable",
        "kind": "contract",
        "category": "ictt",
        "filePath": "@ictt/TokenHome/NativeTokenHomeUpgradeable.sol",
        "inherits": [
          "TokenHome"
        ],
        "implements": [
          "INativeTokenHome"
        ],
        "usesLibraries": [
          "Address"
        ],
        "imports": [
          {
            "name": "TokenHome",
            "path": "./TokenHome.sol",
            "isExternal": false
          },
          {
            "name": "INativeTokenHome",
            "path": "./interfaces/INativeTokenHome.sol",
            "isExternal": false
          },
          {
            "name": "INativeSendAndCallReceiver",
            "path": "../interfaces/INativeSendAndCallReceiver.sol",
            "isExternal": false
          },
          {
            "name": "SendTokensInput",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SendAndCallInput",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SingleHopCallMessage",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "IWrappedNativeToken",
            "path": "../interfaces/IWrappedNativeToken.sol",
            "isExternal": false
          },
          {
            "name": "CallUtils",
            "path": "@utilities/CallUtils.sol",
            "isExternal": true
          },
          {
            "name": "SafeWrappedNativeTokenDeposit",
            "path": "@utilities/SafeWrappedNativeTokenDeposit.sol",
            "isExternal": true
          },
          {
            "name": "Address",
            "path": "@openzeppelin/contracts@5.0.2/utils/Address.sol",
            "isExternal": true
          },
          {
            "name": "ICMInitializable",
            "path": "@utilities/ICMInitializable.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "initialize",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "teleporterManager",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              },
              {
                "name": "wrappedTokenAddress",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__NativeTokenHome_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initialize(\n        address teleporterRegistryAddress,\n        address teleporterManager,\n        uint256 minTeleporterVersion,\n        address wrappedTokenAddress\n    ) public initializer {\n        __NativeTokenHome_init(\n            teleporterRegistryAddress, teleporterManager, minTeleporterVersion, wrappedTokenAddress\n        );\n    }",
            "startLine": 80,
            "signature": "initialize(address,address,uint256,address)",
            "selector": "0x1df959b0",
            "visibility": "public",
            "modifiers": [
              "initializer"
            ]
          },
          {
            "name": "send",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_send",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function send(\n        SendTokensInput calldata input\n    ) external payable {\n        _send(input, msg.value);\n    }",
            "startLine": 133,
            "signature": "send(SendTokensInput)",
            "selector": "0x34cc3541",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "sendAndCall",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_sendAndCall",
                "type": "internal"
              },
              {
                "target": "getBlockchainID",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function sendAndCall(\n        SendAndCallInput calldata input\n    ) external payable {\n        _sendAndCall({\n            sourceBlockchainID: getBlockchainID(),\n            originTokenTransferrerAddress: address(this),\n            originSenderAddress: _msgSender(),\n            input: input,\n            amount: msg.value\n        });\n    }",
            "startLine": 142,
            "signature": "sendAndCall(SendAndCallInput)",
            "selector": "0x4b1f7c2f",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "addCollateral",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_addCollateral",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function addCollateral(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress\n    ) external payable {\n        _addCollateral(remoteBlockchainID, remoteTokenTransferrerAddress, msg.value);\n    }",
            "startLine": 157,
            "signature": "addCollateral(bytes32,address)",
            "selector": "0x4ac87787",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "getRemoteTokenTransferrerSettings",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "RemoteTokenTransferrerSettings"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getRemoteTokenTransferrerSettings(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress\n    ) public view returns (RemoteTokenTransferrerSettings memory) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n    }",
            "startLine": 143,
            "signature": "getRemoteTokenTransferrerSettings(bytes32,address)",
            "selector": "0x7e9ee7c5",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "getTransferredBalance",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTransferredBalance(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress\n    ) public view returns (uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress];\n    }",
            "startLine": 151,
            "signature": "getTransferredBalance(bytes32,address)",
            "selector": "0x07d1716d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "getTokenAddress",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenAddress() public view returns (address) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._tokenAddress;\n    }",
            "startLine": 159,
            "signature": "getTokenAddress()",
            "selector": "0x4a82cef2",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "getBlockchainID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getBlockchainID() public view returns (bytes32) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._blockchainID;\n    }",
            "startLine": 164,
            "signature": "getBlockchainID()",
            "selector": "0x587a98a6",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }",
            "startLine": 73,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "renounceOwnership",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
            "startLine": 94,
            "signature": "renounceOwnership()",
            "selector": "0x765becbf",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }",
            "startLine": 102,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          }
        ],
        "internalFunctions": [
          {
            "name": "_getNativeTokenHomeStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "NativeTokenHomeStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getNativeTokenHomeStorage() private pure returns (NativeTokenHomeStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := NATIVE_TOKEN_HOME_STORAGE_LOCATION\n        }\n    }",
            "startLine": 54,
            "visibility": "private"
          },
          {
            "name": "__NativeTokenHome_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "teleporterManager",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              },
              {
                "name": "wrappedTokenAddress",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TokenHome_init",
                "type": "internal"
              },
              {
                "target": "__NativeTokenHome_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __NativeTokenHome_init(\n        address teleporterRegistryAddress,\n        address teleporterManager,\n        uint256 minTeleporterVersion,\n        address wrappedTokenAddress\n    ) internal onlyInitializing {\n        __TokenHome_init(\n            teleporterRegistryAddress,\n            teleporterManager,\n            minTeleporterVersion,\n            wrappedTokenAddress,\n            18\n        );\n        __NativeTokenHome_init_unchained(wrappedTokenAddress);\n    }",
            "startLine": 92,
            "visibility": "internal"
          },
          {
            "name": "__NativeTokenHome_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "wrappedTokenAddress",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getNativeTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __NativeTokenHome_init_unchained(\n        address wrappedTokenAddress\n    ) internal onlyInitializing {\n        _getNativeTokenHomeStorage()._wrappedToken = IWrappedNativeToken(wrappedTokenAddress);\n    }",
            "startLine": 109,
            "visibility": "internal"
          },
          {
            "name": "_deposit",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getNativeTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "SafeWrappedNativeTokenDeposit.safeDeposit",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _deposit(\n        uint256 amount\n    ) internal virtual override returns (uint256) {\n        NativeTokenHomeStorage storage $ = _getNativeTokenHomeStorage();\n        return SafeWrappedNativeTokenDeposit.safeDeposit($._wrappedToken, amount);\n    }",
            "startLine": 168,
            "visibility": "internal"
          },
          {
            "name": "_withdraw",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "recipient",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getNativeTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensWithdrawn"
            ],
            "isVirtual": true,
            "sourceCode": "function _withdraw(address recipient, uint256 amount) internal virtual override {\n        NativeTokenHomeStorage storage $ = _getNativeTokenHomeStorage();\n        emit TokensWithdrawn(recipient, amount);\n        $._wrappedToken.withdraw(amount);\n        payable(recipient).sendValue(amount);\n    }",
            "startLine": 180,
            "visibility": "internal"
          },
          {
            "name": "_handleSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "message",
                "type": "SingleHopCallMessage"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getNativeTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "CallUtils._callWithExactGasAndValue",
                "type": "library"
              }
            ],
            "emits": [
              "CallSucceeded",
              "CallFailed"
            ],
            "isVirtual": true,
            "sourceCode": "function _handleSendAndCall(\n        SingleHopCallMessage memory message,\n        uint256 amount\n    ) internal virtual override {\n        NativeTokenHomeStorage storage $ = _getNativeTokenHomeStorage();\n        // Withdraw the native token from the wrapped native token contract.\n        $._wrappedToken.withdraw(amount);\n\n        // Encode the call to {INativeSendAndCallReceiver-receiveTokens}\n        bytes memory payload = abi.encodeCall(\n            INativeSendAndCallReceiver.receiveTokens,\n            (\n                message.sourceBlockchainID,\n                message.originTokenTransferrerAddress,\n                message.originSenderAddress,\n                message.recipientPayload\n            )\n        );\n\n        // Call the recipient contract with the given payload, gas amount, and value.\n        bool success = CallUtils._callWithExactGasAndValue(\n            message.recipientGasLimit, amount, message.recipientContract, payload\n        );\n\n        // If the call failed, send the funds to the fallback recipient.\n        if (success) {\n            emit CallSucceeded(message.recipientContract, amount);\n        } else {\n            emit CallFailed(message.recipientContract, amount);\n            payable(message.fallbackRecipient).sendValue(amount);\n        }\n    }",
            "startLine": 195,
            "visibility": "internal"
          },
          {
            "name": "_getTokenHomeStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "TokenHomeStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getTokenHomeStorage() private pure returns (TokenHomeStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := TOKEN_HOME_STORAGE_LOCATION\n        }\n    }",
            "startLine": 94,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "__TokenHome_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "teleporterManager",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              },
              {
                "name": "tokenAddress",
                "type": "address"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryOwnableApp_init",
                "type": "internal"
              },
              {
                "target": "__SendReentrancyGuard_init",
                "type": "internal"
              },
              {
                "target": "__TokenHome_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function __TokenHome_init(\n        address teleporterRegistryAddress,\n        address teleporterManager,\n        uint256 minTeleporterVersion,\n        address tokenAddress,\n        uint8 tokenDecimals\n    ) internal virtual onlyInitializing {\n        __TeleporterRegistryOwnableApp_init(\n            teleporterRegistryAddress, teleporterManager, minTeleporterVersion\n        );\n        __SendReentrancyGuard_init();\n        __TokenHome_init_unchained(tokenAddress, tokenDecimals);\n    }",
            "startLine": 111,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "__TokenHome_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenAddress",
                "type": "address"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TokenHome_init_unchained(\n        address tokenAddress,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        require(tokenAddress != address(0), \"TokenHome: zero token address\");\n        require(\n            tokenDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenHome: token decimals too high\"\n        );\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        $._blockchainID =\n            IWarpMessenger(0x0200000000000000000000000000000000000005).getBlockchainID();\n        $._tokenAddress = tokenAddress;\n        $._tokenDecimals = tokenDecimals;\n    }",
            "startLine": 126,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_registerRemote",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "message",
                "type": "RegisterRemoteMessage"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.deriveTokenMultiplierValues",
                "type": "library"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [
              "RemoteRegistered"
            ],
            "isVirtual": false,
            "sourceCode": "function _registerRemote(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        RegisterRemoteMessage memory message\n    ) internal {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        require(remoteBlockchainID != bytes32(0), \"TokenHome: zero remote blockchain ID\");\n        require(\n            remoteBlockchainID != $._blockchainID, \"TokenHome: cannot register remote on same chain\"\n        );\n        require(\n            remoteTokenTransferrerAddress != address(0),\n            \"TokenHome: zero remote token transferrer address\"\n        );\n        require(\n            !$._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress].registered,\n            \"TokenHome: remote already registered\"\n        );\n        require(\n            message.remoteTokenDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenHome: remote token decimals too high\"\n        );\n        require(\n            message.homeTokenDecimals == $._tokenDecimals, \"TokenHome: invalid home token decimals\"\n        );\n\n        (uint256 tokenMultiplier, bool multiplyOnRemote) = TokenScalingUtils\n            .deriveTokenMultiplierValues($._tokenDecimals, message.remoteTokenDecimals);\n\n        // Calculate the collateral needed in home token denomination.\n        uint256 collateralNeeded = TokenScalingUtils.removeTokenScale(\n            tokenMultiplier, multiplyOnRemote, message.initialReserveImbalance\n        );\n\n        // Round up the collateral needed by 1 in the case that {multiplyOnRemote} is true and\n        // {initialReserveImbalance} is not divisible by the {tokenMultiplier} to\n        // ensure that the full amount is accounted for.\n        if (multiplyOnRemote && message.initialReserveImbalance % tokenMultiplier != 0) {\n            collateralNeeded += 1;\n        }\n\n        $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress] =\n        RemoteTokenTransferrerSettings({\n            registered: true,\n            collateralNeeded: collateralNeeded,\n            tokenMultiplier: tokenMultiplier,\n            multiplyOnRemote: multiplyOnRemote\n        });\n\n        emit RemoteRegistered(\n            remoteBlockchainID,\n            remoteTokenTransferrerAddress,\n            collateralNeeded,\n            message.remoteTokenDecimals\n        );\n    }",
            "startLine": 169,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_send",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendTokensInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _send(SendTokensInput memory input, uint256 amount) internal sendNonReentrant {\n        _validateSendTokensInput(input);\n        // Require that a single hop transfer does not have a multi-hop fallback recipient.\n        require(input.multiHopFallback == address(0), \"TokenHome: non-zero multi-hop fallback\");\n\n        (uint256 adjustedAmount, uint256 feeAmount) = _prepareSend({\n            remoteBlockchainID: input.destinationBlockchainID,\n            remoteTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            feeAmount: input.primaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_SEND,\n            payload: abi.encode(\n                SingleHopSendMessage({recipient: input.recipient, amount: adjustedAmount})\n            )\n        });\n\n        // Send message to the TokenRemote instance\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: feeAmount\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensSent(messageID, _msgSender(), input, adjustedAmount);\n    }",
            "startLine": 239,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_routeMultiHop",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendTokensInput",
                "type": "internal"
              },
              {
                "target": "_prepareMultiHopRouting",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensRouted"
            ],
            "isVirtual": false,
            "sourceCode": "function _routeMultiHop(\n        SendTokensInput memory input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        _validateSendTokensInput(input);\n\n        uint256 adjustedAmount = _prepareMultiHopRouting(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            amount,\n            input.primaryFee\n        );\n\n        if (adjustedAmount == 0) {\n            // If the adjusted amount is zero for any reason (i.e. unregistered remote,\n            // being scaled down to zero, etc.), send the tokens to the multi-hop fallback.\n            _withdraw(input.multiHopFallback, amount);\n            return;\n        }\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_SEND,\n            payload: abi.encode(\n                SingleHopSendMessage({recipient: input.recipient, amount: adjustedAmount})\n            )\n        });\n\n        // Send message to the TokenRemote instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: input.primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensRouted(messageID, input, adjustedAmount);\n    }",
            "startLine": 290,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_sendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendAndCallInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _sendAndCall(\n        bytes32 sourceBlockchainID,\n        address originTokenTransferrerAddress,\n        address originSenderAddress,\n        SendAndCallInput memory input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        _validateSendAndCallInput(input);\n\n        // Require that a single hop transfer does not have a multi-hop fallback recipient.\n        require(input.multiHopFallback == address(0), \"TokenHome: non-zero multi-hop fallback\");\n\n        (uint256 adjustedAmount, uint256 feeAmount) = _prepareSend({\n            remoteBlockchainID: input.destinationBlockchainID,\n            remoteTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            feeAmount: input.primaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_CALL,\n            payload: abi.encode(\n                SingleHopCallMessage({\n                    sourceBlockchainID: sourceBlockchainID,\n                    originTokenTransferrerAddress: originTokenTransferrerAddress,\n                    originSenderAddress: originSenderAddress,\n                    recipientContract: input.recipientContract,\n                    amount: adjustedAmount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient\n                })\n            )\n        });\n\n        // Send message to the TokenRemote instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: feeAmount\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallSent(messageID, originSenderAddress, input, adjustedAmount);\n    }",
            "startLine": 335,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_routeMultiHopSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendAndCallInput",
                "type": "internal"
              },
              {
                "target": "_prepareMultiHopRouting",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallRouted"
            ],
            "isVirtual": false,
            "sourceCode": "function _routeMultiHopSendAndCall(\n        bytes32 sourceBlockchainID,\n        address originTokenTransferrerAddress,\n        address originSenderAddress,\n        SendAndCallInput memory input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        _validateSendAndCallInput(input);\n        uint256 adjustedAmount = _prepareMultiHopRouting(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            amount,\n            input.primaryFee\n        );\n\n        if (adjustedAmount == 0) {\n            // If the adjusted amount is zero for any reason (i.e. unregistered remote,\n            // being scaled down to zero, etc.), send the tokens to the multi-hop fallback recipient.\n            _withdraw(input.multiHopFallback, amount);\n            return;\n        }\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_CALL,\n            payload: abi.encode(\n                SingleHopCallMessage({\n                    sourceBlockchainID: sourceBlockchainID,\n                    originTokenTransferrerAddress: originTokenTransferrerAddress,\n                    originSenderAddress: originSenderAddress,\n                    recipientContract: input.recipientContract,\n                    amount: adjustedAmount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient\n                })\n            )\n        });\n\n        // Send message to the TokenRemote instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: input.primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallRouted(messageID, input, adjustedAmount);\n    }",
            "startLine": 389,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_addCollateral",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_deposit",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "CollateralAdded"
            ],
            "isVirtual": false,
            "sourceCode": "function _addCollateral(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) internal sendNonReentrant {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n        require(remoteSettings.registered, \"TokenHome: remote not registered\");\n        require(remoteSettings.collateralNeeded > 0, \"TokenHome: zero collateral needed\");\n\n        // Deposit the full amount, and withdraw back to the sender if there is excess.\n        amount = _deposit(amount);\n\n        // Calculate the remaining collateral needed, any excess amount, and adjust\n        // {amount} to represent the amount of tokens added as collateral.\n        uint256 remainingCollateralNeeded;\n        uint256 excessAmount;\n        if (amount >= remoteSettings.collateralNeeded) {\n            remainingCollateralNeeded = 0;\n            excessAmount = amount - remoteSettings.collateralNeeded;\n            amount = remoteSettings.collateralNeeded;\n        } else {\n            remainingCollateralNeeded = remoteSettings.collateralNeeded - amount;\n        }\n\n        // Update the remaining collateral needed.\n        $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress].collateralNeeded =\n            remainingCollateralNeeded;\n        emit CollateralAdded(\n            remoteBlockchainID, remoteTokenTransferrerAddress, amount, remainingCollateralNeeded\n        );\n\n        // If there is excess amount, send it back to the sender.\n        if (excessAmount > 0) {\n            _withdraw(_msgSender(), excessAmount);\n        }\n    }",
            "startLine": 448,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_receiveTeleporterMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "message",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_processSingleHopTransfer",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_handleSendAndCall",
                "type": "internal"
              },
              {
                "target": "_processMultiHopTransfer",
                "type": "internal"
              },
              {
                "target": "_routeMultiHop",
                "type": "internal"
              },
              {
                "target": "_routeMultiHopSendAndCall",
                "type": "internal"
              },
              {
                "target": "_registerRemote",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _receiveTeleporterMessage(\n        bytes32 sourceBlockchainID,\n        address originSenderAddress,\n        bytes memory message\n    ) internal override {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        TransferrerMessage memory transferrerMessage = abi.decode(message, (TransferrerMessage));\n        if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_SEND) {\n            SingleHopSendMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopSendMessage));\n\n            uint256 homeAmount =\n                _processSingleHopTransfer(sourceBlockchainID, originSenderAddress, payload.amount);\n\n            // Send the tokens to the recipient.\n            _withdraw(payload.recipient, homeAmount);\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_CALL) {\n            SingleHopCallMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopCallMessage));\n\n            uint256 homeAmount =\n                _processSingleHopTransfer(sourceBlockchainID, originSenderAddress, payload.amount);\n\n            // Verify that the payload's source blockchain ID and origin token transferrer address matches the source blockchain ID\n            // and origin sender address passed from Teleporter.\n            require(\n                payload.sourceBlockchainID == sourceBlockchainID,\n                \"TokenHome: mismatched source blockchain ID\"\n            );\n            require(\n                payload.originTokenTransferrerAddress == originSenderAddress,\n                \"TokenHome: mismatched origin sender address\"\n            );\n\n            _handleSendAndCall(payload, homeAmount);\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.MULTI_HOP_SEND) {\n            MultiHopSendMessage memory payload =\n                abi.decode(transferrerMessage.payload, (MultiHopSendMessage));\n\n            (uint256 homeAmount, uint256 fee) = _processMultiHopTransfer(\n                sourceBlockchainID, originSenderAddress, payload.amount, payload.secondaryFee\n            );\n\n            // For a multi-hop send, the fee token address has to be {tokenAddress},\n            // because the fee is taken from the amount that has already been deposited.\n            // For ERC20 tokens, the token address of the contract is directly passed.\n            // For native assets, the contract address is the wrapped token contract.\n            _routeMultiHop(\n                SendTokensInput({\n                    destinationBlockchainID: payload.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: payload.destinationTokenTransferrerAddress,\n                    recipient: payload.recipient,\n                    primaryFeeTokenAddress: $._tokenAddress,\n                    primaryFee: fee,\n                    secondaryFee: 0,\n                    requiredGasLimit: payload.secondaryGasLimit,\n                    multiHopFallback: payload.multiHopFallback\n                }),\n                homeAmount\n            );\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.MULTI_HOP_CALL) {\n            MultiHopCallMessage memory payload =\n                abi.decode(transferrerMessage.payload, (MultiHopCallMessage));\n\n            (uint256 homeAmount, uint256 fee) = _processMultiHopTransfer(\n                sourceBlockchainID, originSenderAddress, payload.amount, payload.secondaryFee\n            );\n\n            // For a multi-hop send, the fee token address has to be {tokenAddress},\n            // because the fee is taken from the amount that has already been deposited.\n            // For ERC20 tokens, the token address of the contract is directly passed.\n            // For native assets, the contract address is the wrapped token contract.\n            _routeMultiHopSendAndCall({\n                sourceBlockchainID: sourceBlockchainID,\n                originTokenTransferrerAddress: originSenderAddress,\n                originSenderAddress: payload.originSenderAddress,\n                input: SendAndCallInput({\n                    destinationBlockchainID: payload.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: payload.destinationTokenTransferrerAddress,\n                    recipientContract: payload.recipientContract,\n                    recipientPayload: payload.recipientPayload,\n                    requiredGasLimit: payload.secondaryRequiredGasLimit,\n                    recipientGasLimit: payload.recipientGasLimit,\n                    multiHopFallback: payload.multiHopFallback,\n                    fallbackRecipient: payload.fallbackRecipient,\n                    primaryFeeTokenAddress: $._tokenAddress,\n                    primaryFee: fee,\n                    secondaryFee: 0\n                }),\n                amount: homeAmount\n            });\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.REGISTER_REMOTE) {\n            RegisterRemoteMessage memory payload =\n                abi.decode(transferrerMessage.payload, (RegisterRemoteMessage));\n            _registerRemote(sourceBlockchainID, originSenderAddress, payload);\n        }\n    }",
            "startLine": 494,
            "visibility": "internal",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_processSingleHopTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_processReceivedTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _processSingleHopTransfer(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) private returns (uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n\n        return _processReceivedTransfer(\n            remoteSettings, remoteBlockchainID, remoteTokenTransferrerAddress, amount\n        );\n    }",
            "startLine": 633,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_processMultiHopTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "secondaryFee",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_processReceivedTransfer",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _processMultiHopTransfer(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount,\n        uint256 secondaryFee\n    ) private returns (uint256, uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n\n        uint256 transferAmount = _processReceivedTransfer(\n            remoteSettings, remoteBlockchainID, remoteTokenTransferrerAddress, amount\n        );\n\n        uint256 fee = TokenScalingUtils.removeTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, secondaryFee\n        );\n\n        return (transferAmount, fee);\n    }",
            "startLine": 657,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_processReceivedTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteSettings",
                "type": "RemoteTokenTransferrerSettings"
              },
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_deductSenderBalance",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _processReceivedTransfer(\n        RemoteTokenTransferrerSettings memory remoteSettings,\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) private returns (uint256) {\n        // Require that the remote is registered and has no collateral needed.\n        require(remoteSettings.registered, \"TokenHome: remote not registered\");\n        require(remoteSettings.collateralNeeded == 0, \"TokenHome: remote not collateralized\");\n\n        // Deduct the balance transferred to the given TokenRemote instance prior to scaling the amount.\n        _deductSenderBalance(remoteBlockchainID, remoteTokenTransferrerAddress, amount);\n\n        // Remove the token scaling of the remote and get home token amount.\n        uint256 homeAmount = TokenScalingUtils.removeTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, amount\n        );\n\n        // Require that the home token amount is greater than zero after removed scaling.\n        require(homeAmount > 0, \"TokenHome: zero token amount\");\n        return homeAmount;\n    }",
            "startLine": 689,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_prepareMultiHopRouting",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "fee",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.applyTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _prepareMultiHopRouting(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount,\n        uint256 fee\n    ) private returns (uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n        if (!remoteSettings.registered || remoteSettings.collateralNeeded > 0) {\n            return 0;\n        }\n\n        // Subtract fee amount from amount prior to scaling.\n        require(amount > fee, \"TokenHome: insufficient amount to cover fees\");\n        amount -= fee;\n\n        // Scale the amount based on the token multiplier for the given TokenRemote instance.\n        uint256 scaledAmount = TokenScalingUtils.applyTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, amount\n        );\n        if (scaledAmount == 0) {\n            return 0;\n        }\n\n        // Increase the balance of the TokenRemote instance by the scaled amount.\n        $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress] += scaledAmount;\n\n        return scaledAmount;\n    }",
            "startLine": 718,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_prepareSend",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "primaryFeeTokenAddress",
                "type": "address"
              },
              {
                "name": "feeAmount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_deposit",
                "type": "internal"
              },
              {
                "target": "SafeERC20TransferFrom.safeTransferFrom",
                "type": "library"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.applyTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _prepareSend(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount,\n        address primaryFeeTokenAddress,\n        uint256 feeAmount\n    ) private returns (uint256, uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n        require(remoteSettings.registered, \"TokenHome: remote not registered\");\n        require(remoteSettings.collateralNeeded == 0, \"TokenHome: collateral needed for remote\");\n\n        // Deposit the funds sent from the user to the token transferrer,\n        // and set to adjusted amount after deposit.\n        amount = _deposit(amount);\n\n        if (feeAmount > 0) {\n            feeAmount = SafeERC20TransferFrom.safeTransferFrom(\n                IERC20(primaryFeeTokenAddress), _msgSender(), feeAmount\n            );\n        }\n\n        // Scale the amount based on the token multiplier for the given TokenRemote instance.\n        uint256 scaledAmount = TokenScalingUtils.applyTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, amount\n        );\n        require(scaledAmount > 0, \"TokenHome: zero scaled amount\");\n\n        // Increase the balance of the TokenRemote instance by the scaled amount.\n        $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress] += scaledAmount;\n\n        return (scaledAmount, feeAmount);\n    }",
            "startLine": 754,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_deductSenderBalance",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _deductSenderBalance(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) private {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        uint256 senderBalance =\n            $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress];\n        require(senderBalance >= amount, \"TokenHome: insufficient token transfer balance\");\n        $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress] =\n            senderBalance - amount;\n    }",
            "startLine": 789,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_validateSendAndCallInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendAndCallInput(\n        SendAndCallInput memory input\n    ) private pure {\n        require(input.recipientContract != address(0), \"TokenHome: zero recipient contract address\");\n        require(input.requiredGasLimit > 0, \"TokenHome: zero required gas limit\");\n        require(input.recipientGasLimit > 0, \"TokenHome: zero recipient gas limit\");\n        require(\n            input.recipientGasLimit < input.requiredGasLimit,\n            \"TokenHome: invalid recipient gas limit\"\n        );\n        require(input.fallbackRecipient != address(0), \"TokenHome: zero fallback recipient address\");\n        require(input.secondaryFee == 0, \"TokenHome: non-zero secondary fee\");\n    }",
            "startLine": 802,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "_validateSendTokensInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendTokensInput(\n        SendTokensInput memory input\n    ) private pure {\n        require(input.recipient != address(0), \"TokenHome: zero recipient address\");\n        require(input.requiredGasLimit > 0, \"TokenHome: zero required gas limit\");\n        require(input.secondaryFee == 0, \"TokenHome: non-zero secondary fee\");\n    }",
            "startLine": 816,
            "visibility": "private",
            "inheritedFrom": "TokenHome"
          },
          {
            "name": "__TeleporterRegistryOwnableApp_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "initialOwner",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryApp_init",
                "type": "internal"
              },
              {
                "target": "__Ownable_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TeleporterRegistryOwnableApp_init(\n        address teleporterRegistryAddress,\n        address initialOwner,\n        uint256 minTeleporterVersion\n    ) internal onlyInitializing {\n        __TeleporterRegistryApp_init(teleporterRegistryAddress, minTeleporterVersion);\n        __Ownable_init(initialOwner);\n    }",
            "startLine": 24,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_TeleporterRegistryOwnableApp_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _TeleporterRegistryOwnableApp_init_unchained() internal onlyInitializing {}",
            "startLine": 34,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_checkTeleporterRegistryAppAccess",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_checkOwner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkTeleporterRegistryAppAccess() internal view virtual override {\n        _checkOwner();\n    }",
            "startLine": 42,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_getOwnableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "OwnableStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }",
            "startLine": 30,
            "visibility": "private",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__Ownable_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }",
            "startLine": 51,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }",
            "startLine": 55,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }",
            "startLine": 81,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "OwnershipTransferred"
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }",
            "startLine": 113,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getSendReentrancyGuardStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "SendReentrancyGuardStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getSendReentrancyGuardStorage()\n        private\n        pure\n        returns (SendReentrancyGuardStorage storage $)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := _SEND_REENTRANCY_GUARD_STORAGE_LOCATION\n        }\n    }",
            "startLine": 35,
            "visibility": "private",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrancyGuard_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "__SendReentrnacyGuard_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrancyGuard_init() internal onlyInitializing {\n        __SendReentrnacyGuard_init_unchained();\n    }",
            "startLine": 59,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrnacyGuard_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getSendReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrnacyGuard_init_unchained() internal {\n        SendReentrancyGuardStorage storage $ = _getSendReentrancyGuardStorage();\n        $._sendEntered = _NOT_ENTERED;\n    }",
            "startLine": 64,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "TokenHome",
        "kind": "abstract",
        "category": "ictt",
        "filePath": "@ictt/TokenHome/TokenHome.sol",
        "inherits": [
          "TeleporterRegistryOwnableAppUpgradeable",
          "SendReentrancyGuardUpgradeable"
        ],
        "implements": [
          "ITokenHome"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "TeleporterMessageInput",
            "path": "@teleporter/ITeleporterMessenger.sol",
            "isExternal": true
          },
          {
            "name": "TeleporterFeeInfo",
            "path": "@teleporter/ITeleporterMessenger.sol",
            "isExternal": true
          },
          {
            "name": "TeleporterRegistryOwnableAppUpgradeable",
            "path": "@teleporter/registry/TeleporterRegistryOwnableAppUpgradeable.sol",
            "isExternal": true
          },
          {
            "name": "ITokenHome",
            "path": "./interfaces/ITokenHome.sol",
            "isExternal": false
          },
          {
            "name": "RemoteTokenTransferrerSettings",
            "path": "./interfaces/ITokenHome.sol",
            "isExternal": false
          },
          {
            "name": "SendTokensInput",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SendAndCallInput",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "TransferrerMessageType",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "TransferrerMessage",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SingleHopSendMessage",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SingleHopCallMessage",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "MultiHopSendMessage",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "MultiHopCallMessage",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "RegisterRemoteMessage",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SendReentrancyGuardUpgradeable",
            "path": "@utilities/SendReentrancyGuardUpgradeable.sol",
            "isExternal": true
          },
          {
            "name": "TokenScalingUtils",
            "path": "@utilities/TokenScalingUtils.sol",
            "isExternal": true
          },
          {
            "name": "SafeERC20TransferFrom",
            "path": "@utilities/SafeERC20TransferFrom.sol",
            "isExternal": true
          },
          {
            "name": "IWarpMessenger",
            "path": "@subnet-evm/IWarpMessenger.sol",
            "isExternal": true
          },
          {
            "name": "IERC20",
            "path": "@openzeppelin/contracts@5.0.2/token/ERC20/ERC20.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "getRemoteTokenTransferrerSettings",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "RemoteTokenTransferrerSettings"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getRemoteTokenTransferrerSettings(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress\n    ) public view returns (RemoteTokenTransferrerSettings memory) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n    }",
            "startLine": 143,
            "signature": "getRemoteTokenTransferrerSettings(bytes32,address)",
            "selector": "0x7e9ee7c5",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getTransferredBalance",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTransferredBalance(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress\n    ) public view returns (uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress];\n    }",
            "startLine": 151,
            "signature": "getTransferredBalance(bytes32,address)",
            "selector": "0x07d1716d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getTokenAddress",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenAddress() public view returns (address) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._tokenAddress;\n    }",
            "startLine": 159,
            "signature": "getTokenAddress()",
            "selector": "0x4a82cef2",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getBlockchainID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getBlockchainID() public view returns (bytes32) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        return $._blockchainID;\n    }",
            "startLine": 164,
            "signature": "getBlockchainID()",
            "selector": "0x587a98a6",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }",
            "startLine": 73,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "renounceOwnership",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
            "startLine": 94,
            "signature": "renounceOwnership()",
            "selector": "0x765becbf",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }",
            "startLine": 102,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          }
        ],
        "internalFunctions": [
          {
            "name": "_getTokenHomeStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "TokenHomeStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getTokenHomeStorage() private pure returns (TokenHomeStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := TOKEN_HOME_STORAGE_LOCATION\n        }\n    }",
            "startLine": 94,
            "visibility": "private"
          },
          {
            "name": "__TokenHome_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "teleporterManager",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              },
              {
                "name": "tokenAddress",
                "type": "address"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryOwnableApp_init",
                "type": "internal"
              },
              {
                "target": "__SendReentrancyGuard_init",
                "type": "internal"
              },
              {
                "target": "__TokenHome_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function __TokenHome_init(\n        address teleporterRegistryAddress,\n        address teleporterManager,\n        uint256 minTeleporterVersion,\n        address tokenAddress,\n        uint8 tokenDecimals\n    ) internal virtual onlyInitializing {\n        __TeleporterRegistryOwnableApp_init(\n            teleporterRegistryAddress, teleporterManager, minTeleporterVersion\n        );\n        __SendReentrancyGuard_init();\n        __TokenHome_init_unchained(tokenAddress, tokenDecimals);\n    }",
            "startLine": 111,
            "visibility": "internal"
          },
          {
            "name": "__TokenHome_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenAddress",
                "type": "address"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TokenHome_init_unchained(\n        address tokenAddress,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        require(tokenAddress != address(0), \"TokenHome: zero token address\");\n        require(\n            tokenDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenHome: token decimals too high\"\n        );\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        $._blockchainID =\n            IWarpMessenger(0x0200000000000000000000000000000000000005).getBlockchainID();\n        $._tokenAddress = tokenAddress;\n        $._tokenDecimals = tokenDecimals;\n    }",
            "startLine": 126,
            "visibility": "internal"
          },
          {
            "name": "_registerRemote",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "message",
                "type": "RegisterRemoteMessage"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.deriveTokenMultiplierValues",
                "type": "library"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [
              "RemoteRegistered"
            ],
            "isVirtual": false,
            "sourceCode": "function _registerRemote(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        RegisterRemoteMessage memory message\n    ) internal {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        require(remoteBlockchainID != bytes32(0), \"TokenHome: zero remote blockchain ID\");\n        require(\n            remoteBlockchainID != $._blockchainID, \"TokenHome: cannot register remote on same chain\"\n        );\n        require(\n            remoteTokenTransferrerAddress != address(0),\n            \"TokenHome: zero remote token transferrer address\"\n        );\n        require(\n            !$._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress].registered,\n            \"TokenHome: remote already registered\"\n        );\n        require(\n            message.remoteTokenDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenHome: remote token decimals too high\"\n        );\n        require(\n            message.homeTokenDecimals == $._tokenDecimals, \"TokenHome: invalid home token decimals\"\n        );\n\n        (uint256 tokenMultiplier, bool multiplyOnRemote) = TokenScalingUtils\n            .deriveTokenMultiplierValues($._tokenDecimals, message.remoteTokenDecimals);\n\n        // Calculate the collateral needed in home token denomination.\n        uint256 collateralNeeded = TokenScalingUtils.removeTokenScale(\n            tokenMultiplier, multiplyOnRemote, message.initialReserveImbalance\n        );\n\n        // Round up the collateral needed by 1 in the case that {multiplyOnRemote} is true and\n        // {initialReserveImbalance} is not divisible by the {tokenMultiplier} to\n        // ensure that the full amount is accounted for.\n        if (multiplyOnRemote && message.initialReserveImbalance % tokenMultiplier != 0) {\n            collateralNeeded += 1;\n        }\n\n        $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress] =\n        RemoteTokenTransferrerSettings({\n            registered: true,\n            collateralNeeded: collateralNeeded,\n            tokenMultiplier: tokenMultiplier,\n            multiplyOnRemote: multiplyOnRemote\n        });\n\n        emit RemoteRegistered(\n            remoteBlockchainID,\n            remoteTokenTransferrerAddress,\n            collateralNeeded,\n            message.remoteTokenDecimals\n        );\n    }",
            "startLine": 169,
            "visibility": "internal"
          },
          {
            "name": "_send",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendTokensInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _send(SendTokensInput memory input, uint256 amount) internal sendNonReentrant {\n        _validateSendTokensInput(input);\n        // Require that a single hop transfer does not have a multi-hop fallback recipient.\n        require(input.multiHopFallback == address(0), \"TokenHome: non-zero multi-hop fallback\");\n\n        (uint256 adjustedAmount, uint256 feeAmount) = _prepareSend({\n            remoteBlockchainID: input.destinationBlockchainID,\n            remoteTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            feeAmount: input.primaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_SEND,\n            payload: abi.encode(\n                SingleHopSendMessage({recipient: input.recipient, amount: adjustedAmount})\n            )\n        });\n\n        // Send message to the TokenRemote instance\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: feeAmount\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensSent(messageID, _msgSender(), input, adjustedAmount);\n    }",
            "startLine": 239,
            "visibility": "internal"
          },
          {
            "name": "_routeMultiHop",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendTokensInput",
                "type": "internal"
              },
              {
                "target": "_prepareMultiHopRouting",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensRouted"
            ],
            "isVirtual": false,
            "sourceCode": "function _routeMultiHop(\n        SendTokensInput memory input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        _validateSendTokensInput(input);\n\n        uint256 adjustedAmount = _prepareMultiHopRouting(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            amount,\n            input.primaryFee\n        );\n\n        if (adjustedAmount == 0) {\n            // If the adjusted amount is zero for any reason (i.e. unregistered remote,\n            // being scaled down to zero, etc.), send the tokens to the multi-hop fallback.\n            _withdraw(input.multiHopFallback, amount);\n            return;\n        }\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_SEND,\n            payload: abi.encode(\n                SingleHopSendMessage({recipient: input.recipient, amount: adjustedAmount})\n            )\n        });\n\n        // Send message to the TokenRemote instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: input.primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensRouted(messageID, input, adjustedAmount);\n    }",
            "startLine": 290,
            "visibility": "internal"
          },
          {
            "name": "_sendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendAndCallInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _sendAndCall(\n        bytes32 sourceBlockchainID,\n        address originTokenTransferrerAddress,\n        address originSenderAddress,\n        SendAndCallInput memory input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        _validateSendAndCallInput(input);\n\n        // Require that a single hop transfer does not have a multi-hop fallback recipient.\n        require(input.multiHopFallback == address(0), \"TokenHome: non-zero multi-hop fallback\");\n\n        (uint256 adjustedAmount, uint256 feeAmount) = _prepareSend({\n            remoteBlockchainID: input.destinationBlockchainID,\n            remoteTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            feeAmount: input.primaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_CALL,\n            payload: abi.encode(\n                SingleHopCallMessage({\n                    sourceBlockchainID: sourceBlockchainID,\n                    originTokenTransferrerAddress: originTokenTransferrerAddress,\n                    originSenderAddress: originSenderAddress,\n                    recipientContract: input.recipientContract,\n                    amount: adjustedAmount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient\n                })\n            )\n        });\n\n        // Send message to the TokenRemote instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: feeAmount\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallSent(messageID, originSenderAddress, input, adjustedAmount);\n    }",
            "startLine": 335,
            "visibility": "internal"
          },
          {
            "name": "_routeMultiHopSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_validateSendAndCallInput",
                "type": "internal"
              },
              {
                "target": "_prepareMultiHopRouting",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallRouted"
            ],
            "isVirtual": false,
            "sourceCode": "function _routeMultiHopSendAndCall(\n        bytes32 sourceBlockchainID,\n        address originTokenTransferrerAddress,\n        address originSenderAddress,\n        SendAndCallInput memory input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        _validateSendAndCallInput(input);\n        uint256 adjustedAmount = _prepareMultiHopRouting(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            amount,\n            input.primaryFee\n        );\n\n        if (adjustedAmount == 0) {\n            // If the adjusted amount is zero for any reason (i.e. unregistered remote,\n            // being scaled down to zero, etc.), send the tokens to the multi-hop fallback recipient.\n            _withdraw(input.multiHopFallback, amount);\n            return;\n        }\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_CALL,\n            payload: abi.encode(\n                SingleHopCallMessage({\n                    sourceBlockchainID: sourceBlockchainID,\n                    originTokenTransferrerAddress: originTokenTransferrerAddress,\n                    originSenderAddress: originSenderAddress,\n                    recipientContract: input.recipientContract,\n                    amount: adjustedAmount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient\n                })\n            )\n        });\n\n        // Send message to the TokenRemote instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: input.destinationBlockchainID,\n                destinationAddress: input.destinationTokenTransferrerAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: input.primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallRouted(messageID, input, adjustedAmount);\n    }",
            "startLine": 389,
            "visibility": "internal"
          },
          {
            "name": "_addCollateral",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_deposit",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "CollateralAdded"
            ],
            "isVirtual": false,
            "sourceCode": "function _addCollateral(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) internal sendNonReentrant {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n        require(remoteSettings.registered, \"TokenHome: remote not registered\");\n        require(remoteSettings.collateralNeeded > 0, \"TokenHome: zero collateral needed\");\n\n        // Deposit the full amount, and withdraw back to the sender if there is excess.\n        amount = _deposit(amount);\n\n        // Calculate the remaining collateral needed, any excess amount, and adjust\n        // {amount} to represent the amount of tokens added as collateral.\n        uint256 remainingCollateralNeeded;\n        uint256 excessAmount;\n        if (amount >= remoteSettings.collateralNeeded) {\n            remainingCollateralNeeded = 0;\n            excessAmount = amount - remoteSettings.collateralNeeded;\n            amount = remoteSettings.collateralNeeded;\n        } else {\n            remainingCollateralNeeded = remoteSettings.collateralNeeded - amount;\n        }\n\n        // Update the remaining collateral needed.\n        $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress].collateralNeeded =\n            remainingCollateralNeeded;\n        emit CollateralAdded(\n            remoteBlockchainID, remoteTokenTransferrerAddress, amount, remainingCollateralNeeded\n        );\n\n        // If there is excess amount, send it back to the sender.\n        if (excessAmount > 0) {\n            _withdraw(_msgSender(), excessAmount);\n        }\n    }",
            "startLine": 448,
            "visibility": "internal"
          },
          {
            "name": "_receiveTeleporterMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "message",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_processSingleHopTransfer",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_handleSendAndCall",
                "type": "internal"
              },
              {
                "target": "_processMultiHopTransfer",
                "type": "internal"
              },
              {
                "target": "_routeMultiHop",
                "type": "internal"
              },
              {
                "target": "_routeMultiHopSendAndCall",
                "type": "internal"
              },
              {
                "target": "_registerRemote",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _receiveTeleporterMessage(\n        bytes32 sourceBlockchainID,\n        address originSenderAddress,\n        bytes memory message\n    ) internal override {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        TransferrerMessage memory transferrerMessage = abi.decode(message, (TransferrerMessage));\n        if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_SEND) {\n            SingleHopSendMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopSendMessage));\n\n            uint256 homeAmount =\n                _processSingleHopTransfer(sourceBlockchainID, originSenderAddress, payload.amount);\n\n            // Send the tokens to the recipient.\n            _withdraw(payload.recipient, homeAmount);\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_CALL) {\n            SingleHopCallMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopCallMessage));\n\n            uint256 homeAmount =\n                _processSingleHopTransfer(sourceBlockchainID, originSenderAddress, payload.amount);\n\n            // Verify that the payload's source blockchain ID and origin token transferrer address matches the source blockchain ID\n            // and origin sender address passed from Teleporter.\n            require(\n                payload.sourceBlockchainID == sourceBlockchainID,\n                \"TokenHome: mismatched source blockchain ID\"\n            );\n            require(\n                payload.originTokenTransferrerAddress == originSenderAddress,\n                \"TokenHome: mismatched origin sender address\"\n            );\n\n            _handleSendAndCall(payload, homeAmount);\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.MULTI_HOP_SEND) {\n            MultiHopSendMessage memory payload =\n                abi.decode(transferrerMessage.payload, (MultiHopSendMessage));\n\n            (uint256 homeAmount, uint256 fee) = _processMultiHopTransfer(\n                sourceBlockchainID, originSenderAddress, payload.amount, payload.secondaryFee\n            );\n\n            // For a multi-hop send, the fee token address has to be {tokenAddress},\n            // because the fee is taken from the amount that has already been deposited.\n            // For ERC20 tokens, the token address of the contract is directly passed.\n            // For native assets, the contract address is the wrapped token contract.\n            _routeMultiHop(\n                SendTokensInput({\n                    destinationBlockchainID: payload.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: payload.destinationTokenTransferrerAddress,\n                    recipient: payload.recipient,\n                    primaryFeeTokenAddress: $._tokenAddress,\n                    primaryFee: fee,\n                    secondaryFee: 0,\n                    requiredGasLimit: payload.secondaryGasLimit,\n                    multiHopFallback: payload.multiHopFallback\n                }),\n                homeAmount\n            );\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.MULTI_HOP_CALL) {\n            MultiHopCallMessage memory payload =\n                abi.decode(transferrerMessage.payload, (MultiHopCallMessage));\n\n            (uint256 homeAmount, uint256 fee) = _processMultiHopTransfer(\n                sourceBlockchainID, originSenderAddress, payload.amount, payload.secondaryFee\n            );\n\n            // For a multi-hop send, the fee token address has to be {tokenAddress},\n            // because the fee is taken from the amount that has already been deposited.\n            // For ERC20 tokens, the token address of the contract is directly passed.\n            // For native assets, the contract address is the wrapped token contract.\n            _routeMultiHopSendAndCall({\n                sourceBlockchainID: sourceBlockchainID,\n                originTokenTransferrerAddress: originSenderAddress,\n                originSenderAddress: payload.originSenderAddress,\n                input: SendAndCallInput({\n                    destinationBlockchainID: payload.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: payload.destinationTokenTransferrerAddress,\n                    recipientContract: payload.recipientContract,\n                    recipientPayload: payload.recipientPayload,\n                    requiredGasLimit: payload.secondaryRequiredGasLimit,\n                    recipientGasLimit: payload.recipientGasLimit,\n                    multiHopFallback: payload.multiHopFallback,\n                    fallbackRecipient: payload.fallbackRecipient,\n                    primaryFeeTokenAddress: $._tokenAddress,\n                    primaryFee: fee,\n                    secondaryFee: 0\n                }),\n                amount: homeAmount\n            });\n            return;\n        } else if (transferrerMessage.messageType == TransferrerMessageType.REGISTER_REMOTE) {\n            RegisterRemoteMessage memory payload =\n                abi.decode(transferrerMessage.payload, (RegisterRemoteMessage));\n            _registerRemote(sourceBlockchainID, originSenderAddress, payload);\n        }\n    }",
            "startLine": 494,
            "visibility": "internal"
          },
          {
            "name": "_deposit",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _deposit(\n        uint256 amount\n    ) internal virtual returns (uint256);",
            "startLine": 602,
            "visibility": "internal"
          },
          {
            "name": "_withdraw",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "recipient",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _withdraw(address recipient, uint256 amount) internal virtual;",
            "startLine": 611,
            "visibility": "internal"
          },
          {
            "name": "_handleSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "message",
                "type": "SingleHopCallMessage"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _handleSendAndCall(\n        SingleHopCallMessage memory message,\n        uint256 amount\n    ) internal virtual;",
            "startLine": 619,
            "visibility": "internal"
          },
          {
            "name": "_processSingleHopTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_processReceivedTransfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _processSingleHopTransfer(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) private returns (uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n\n        return _processReceivedTransfer(\n            remoteSettings, remoteBlockchainID, remoteTokenTransferrerAddress, amount\n        );\n    }",
            "startLine": 633,
            "visibility": "private"
          },
          {
            "name": "_processMultiHopTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "secondaryFee",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_processReceivedTransfer",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _processMultiHopTransfer(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount,\n        uint256 secondaryFee\n    ) private returns (uint256, uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n\n        uint256 transferAmount = _processReceivedTransfer(\n            remoteSettings, remoteBlockchainID, remoteTokenTransferrerAddress, amount\n        );\n\n        uint256 fee = TokenScalingUtils.removeTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, secondaryFee\n        );\n\n        return (transferAmount, fee);\n    }",
            "startLine": 657,
            "visibility": "private"
          },
          {
            "name": "_processReceivedTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteSettings",
                "type": "RemoteTokenTransferrerSettings"
              },
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_deductSenderBalance",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _processReceivedTransfer(\n        RemoteTokenTransferrerSettings memory remoteSettings,\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) private returns (uint256) {\n        // Require that the remote is registered and has no collateral needed.\n        require(remoteSettings.registered, \"TokenHome: remote not registered\");\n        require(remoteSettings.collateralNeeded == 0, \"TokenHome: remote not collateralized\");\n\n        // Deduct the balance transferred to the given TokenRemote instance prior to scaling the amount.\n        _deductSenderBalance(remoteBlockchainID, remoteTokenTransferrerAddress, amount);\n\n        // Remove the token scaling of the remote and get home token amount.\n        uint256 homeAmount = TokenScalingUtils.removeTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, amount\n        );\n\n        // Require that the home token amount is greater than zero after removed scaling.\n        require(homeAmount > 0, \"TokenHome: zero token amount\");\n        return homeAmount;\n    }",
            "startLine": 689,
            "visibility": "private"
          },
          {
            "name": "_prepareMultiHopRouting",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "fee",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.applyTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _prepareMultiHopRouting(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount,\n        uint256 fee\n    ) private returns (uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n        if (!remoteSettings.registered || remoteSettings.collateralNeeded > 0) {\n            return 0;\n        }\n\n        // Subtract fee amount from amount prior to scaling.\n        require(amount > fee, \"TokenHome: insufficient amount to cover fees\");\n        amount -= fee;\n\n        // Scale the amount based on the token multiplier for the given TokenRemote instance.\n        uint256 scaledAmount = TokenScalingUtils.applyTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, amount\n        );\n        if (scaledAmount == 0) {\n            return 0;\n        }\n\n        // Increase the balance of the TokenRemote instance by the scaled amount.\n        $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress] += scaledAmount;\n\n        return scaledAmount;\n    }",
            "startLine": 718,
            "visibility": "private"
          },
          {
            "name": "_prepareSend",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "primaryFeeTokenAddress",
                "type": "address"
              },
              {
                "name": "feeAmount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              },
              {
                "target": "_deposit",
                "type": "internal"
              },
              {
                "target": "SafeERC20TransferFrom.safeTransferFrom",
                "type": "library"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.applyTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _prepareSend(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount,\n        address primaryFeeTokenAddress,\n        uint256 feeAmount\n    ) private returns (uint256, uint256) {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        RemoteTokenTransferrerSettings memory remoteSettings =\n            $._registeredRemotes[remoteBlockchainID][remoteTokenTransferrerAddress];\n        require(remoteSettings.registered, \"TokenHome: remote not registered\");\n        require(remoteSettings.collateralNeeded == 0, \"TokenHome: collateral needed for remote\");\n\n        // Deposit the funds sent from the user to the token transferrer,\n        // and set to adjusted amount after deposit.\n        amount = _deposit(amount);\n\n        if (feeAmount > 0) {\n            feeAmount = SafeERC20TransferFrom.safeTransferFrom(\n                IERC20(primaryFeeTokenAddress), _msgSender(), feeAmount\n            );\n        }\n\n        // Scale the amount based on the token multiplier for the given TokenRemote instance.\n        uint256 scaledAmount = TokenScalingUtils.applyTokenScale(\n            remoteSettings.tokenMultiplier, remoteSettings.multiplyOnRemote, amount\n        );\n        require(scaledAmount > 0, \"TokenHome: zero scaled amount\");\n\n        // Increase the balance of the TokenRemote instance by the scaled amount.\n        $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress] += scaledAmount;\n\n        return (scaledAmount, feeAmount);\n    }",
            "startLine": 754,
            "visibility": "private"
          },
          {
            "name": "_deductSenderBalance",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenHomeStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _deductSenderBalance(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) private {\n        TokenHomeStorage storage $ = _getTokenHomeStorage();\n        uint256 senderBalance =\n            $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress];\n        require(senderBalance >= amount, \"TokenHome: insufficient token transfer balance\");\n        $._transferredBalances[remoteBlockchainID][remoteTokenTransferrerAddress] =\n            senderBalance - amount;\n    }",
            "startLine": 789,
            "visibility": "private"
          },
          {
            "name": "_validateSendAndCallInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendAndCallInput(\n        SendAndCallInput memory input\n    ) private pure {\n        require(input.recipientContract != address(0), \"TokenHome: zero recipient contract address\");\n        require(input.requiredGasLimit > 0, \"TokenHome: zero required gas limit\");\n        require(input.recipientGasLimit > 0, \"TokenHome: zero recipient gas limit\");\n        require(\n            input.recipientGasLimit < input.requiredGasLimit,\n            \"TokenHome: invalid recipient gas limit\"\n        );\n        require(input.fallbackRecipient != address(0), \"TokenHome: zero fallback recipient address\");\n        require(input.secondaryFee == 0, \"TokenHome: non-zero secondary fee\");\n    }",
            "startLine": 802,
            "visibility": "private"
          },
          {
            "name": "_validateSendTokensInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendTokensInput(\n        SendTokensInput memory input\n    ) private pure {\n        require(input.recipient != address(0), \"TokenHome: zero recipient address\");\n        require(input.requiredGasLimit > 0, \"TokenHome: zero required gas limit\");\n        require(input.secondaryFee == 0, \"TokenHome: non-zero secondary fee\");\n    }",
            "startLine": 816,
            "visibility": "private"
          },
          {
            "name": "__TeleporterRegistryOwnableApp_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "initialOwner",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryApp_init",
                "type": "internal"
              },
              {
                "target": "__Ownable_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TeleporterRegistryOwnableApp_init(\n        address teleporterRegistryAddress,\n        address initialOwner,\n        uint256 minTeleporterVersion\n    ) internal onlyInitializing {\n        __TeleporterRegistryApp_init(teleporterRegistryAddress, minTeleporterVersion);\n        __Ownable_init(initialOwner);\n    }",
            "startLine": 24,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_TeleporterRegistryOwnableApp_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _TeleporterRegistryOwnableApp_init_unchained() internal onlyInitializing {}",
            "startLine": 34,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_checkTeleporterRegistryAppAccess",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_checkOwner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkTeleporterRegistryAppAccess() internal view virtual override {\n        _checkOwner();\n    }",
            "startLine": 42,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_getOwnableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "OwnableStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }",
            "startLine": 30,
            "visibility": "private",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__Ownable_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }",
            "startLine": 51,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }",
            "startLine": 55,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }",
            "startLine": 81,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "OwnershipTransferred"
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }",
            "startLine": 113,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getSendReentrancyGuardStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "SendReentrancyGuardStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getSendReentrancyGuardStorage()\n        private\n        pure\n        returns (SendReentrancyGuardStorage storage $)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := _SEND_REENTRANCY_GUARD_STORAGE_LOCATION\n        }\n    }",
            "startLine": 35,
            "visibility": "private",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrancyGuard_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "__SendReentrnacyGuard_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrancyGuard_init() internal onlyInitializing {\n        __SendReentrnacyGuard_init_unchained();\n    }",
            "startLine": 59,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrnacyGuard_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getSendReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrnacyGuard_init_unchained() internal {\n        SendReentrancyGuardStorage storage $ = _getSendReentrancyGuardStorage();\n        $._sendEntered = _NOT_ENTERED;\n    }",
            "startLine": 64,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "IERC20TokenHome",
        "kind": "interface",
        "category": "interface",
        "filePath": "@ictt/TokenHome/interfaces/IERC20TokenHome.sol",
        "inherits": [],
        "implements": [
          "IERC20TokenTransferrer",
          "ITokenHome"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IERC20TokenTransferrer",
            "path": "../../interfaces/IERC20TokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "ITokenHome",
            "path": "./ITokenHome.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "addCollateral",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function addCollateral(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress,\n        uint256 amount\n    ) external;",
            "startLine": 25,
            "signature": "addCollateral(bytes32,address,uint256)",
            "selector": "0x52339fe6",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": []
      },
      {
        "name": "INativeTokenHome",
        "kind": "interface",
        "category": "interface",
        "filePath": "@ictt/TokenHome/interfaces/INativeTokenHome.sol",
        "inherits": [],
        "implements": [
          "INativeTokenTransferrer",
          "ITokenHome"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "INativeTokenTransferrer",
            "path": "../../interfaces/INativeTokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "ITokenHome",
            "path": "./ITokenHome.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "addCollateral",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function addCollateral(\n        bytes32 remoteBlockchainID,\n        address remoteTokenTransferrerAddress\n    ) external payable;",
            "startLine": 25,
            "signature": "addCollateral(bytes32,address)",
            "selector": "0x4ac87787",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": []
      },
      {
        "name": "ITokenHome",
        "kind": "interface",
        "category": "interface",
        "filePath": "@ictt/TokenHome/interfaces/ITokenHome.sol",
        "inherits": [],
        "implements": [
          "ITokenTransferrer"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "ITokenTransferrer",
            "path": "../../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SendTokensInput",
            "path": "../../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SendAndCallInput",
            "path": "../../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [],
        "internalFunctions": [],
        "events": [
          {
            "name": "CollateralAdded",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "remaining",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "RemoteRegistered",
            "parameters": [
              {
                "name": "remoteBlockchainID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "remoteTokenTransferrerAddress",
                "type": "address",
                "indexed": true
              },
              {
                "name": "initialCollateralNeeded",
                "type": "uint256",
                "indexed": false
              },
              {
                "name": "tokenDecimals",
                "type": "uint8",
                "indexed": false
              }
            ]
          },
          {
            "name": "TokensRouted",
            "parameters": [
              {
                "name": "teleporterMessageID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "input",
                "type": "SendTokensInput",
                "indexed": false
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "TokensAndCallRouted",
            "parameters": [
              {
                "name": "teleporterMessageID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "input",
                "type": "SendAndCallInput",
                "indexed": false
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          }
        ],
        "errors": []
      },
      {
        "name": "ERC20TokenRemote",
        "kind": "contract",
        "category": "ictt",
        "filePath": "@ictt/TokenRemote/ERC20TokenRemote.sol",
        "inherits": [
          "ERC20TokenRemoteUpgradeable"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "ERC20TokenRemoteUpgradeable",
            "path": "./ERC20TokenRemoteUpgradeable.sol",
            "isExternal": false
          },
          {
            "name": "TokenRemoteSettings",
            "path": "./interfaces/ITokenRemote.sol",
            "isExternal": false
          },
          {
            "name": "ICMInitializable",
            "path": "@utilities/ICMInitializable.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "initialize",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "TokenRemoteSettings"
              },
              {
                "name": "tokenName",
                "type": "string"
              },
              {
                "name": "tokenSymbol",
                "type": "string"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ERC20TokenRemote_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initialize(\n        TokenRemoteSettings memory settings,\n        string memory tokenName,\n        string memory tokenSymbol,\n        uint8 tokenDecimals\n    ) public initializer {\n        __ERC20TokenRemote_init(settings, tokenName, tokenSymbol, tokenDecimals);\n    }",
            "startLine": 78,
            "signature": "initialize(TokenRemoteSettings,string,string,uint8)",
            "selector": "0x558cb4ad",
            "visibility": "public",
            "modifiers": [
              "initializer"
            ],
            "inheritedFrom": "ERC20TokenRemoteUpgradeable"
          },
          {
            "name": "send",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_send",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function send(SendTokensInput calldata input, uint256 amount) external {\n        _send(input, amount);\n    }",
            "startLine": 114,
            "signature": "send(SendTokensInput,uint256)",
            "selector": "0x247bc3d4",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "ERC20TokenRemoteUpgradeable"
          },
          {
            "name": "sendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_sendAndCall",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function sendAndCall(SendAndCallInput calldata input, uint256 amount) external {\n        _sendAndCall(input, amount);\n    }",
            "startLine": 121,
            "signature": "sendAndCall(SendAndCallInput,uint256)",
            "selector": "0x6f1f7d9c",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "ERC20TokenRemoteUpgradeable"
          },
          {
            "name": "decimals",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [
              {
                "target": "_getERC20TokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function decimals() public view override returns (uint8) {\n        ERC20TokenRemoteStorage storage $ = _getERC20TokenRemoteStorage();\n        return $._decimals;\n    }",
            "startLine": 128,
            "signature": "decimals()",
            "selector": "0x76436c3d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20TokenRemoteUpgradeable"
          },
          {
            "name": "name",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }",
            "startLine": 70,
            "signature": "name()",
            "selector": "0x3ec0f734",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "symbol",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }",
            "startLine": 79,
            "signature": "symbol()",
            "selector": "0x6a927499",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "totalSupply",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }",
            "startLine": 102,
            "signature": "totalSupply()",
            "selector": "0x6190166c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "balanceOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }",
            "startLine": 108,
            "signature": "balanceOf(address)",
            "selector": "0x7d2b9996",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }",
            "startLine": 121,
            "signature": "transfer(address,uint256)",
            "selector": "0x59d228e5",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "allowance",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }",
            "startLine": 128,
            "signature": "allowance(address,address)",
            "selector": "0x596dd87d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }",
            "startLine": 143,
            "signature": "approve(address,uint256)",
            "selector": "0x1d38323d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "transferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_spendAllowance",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }",
            "startLine": 165,
            "signature": "transferFrom(address,address,uint256)",
            "selector": "0x447f286d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "registerWithHome",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "feeInfo",
                "type": "TeleporterFeeInfo"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_handleFees",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function registerWithHome(\n        TeleporterFeeInfo calldata feeInfo\n    ) external virtual {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        require(!$._isRegistered, \"TokenRemote: already registered\");\n\n        // Send a message to the token TokenHome instance to register this TokenRemote instance.\n        RegisterRemoteMessage memory registerMessage = RegisterRemoteMessage({\n            initialReserveImbalance: $._initialReserveImbalance,\n            homeTokenDecimals: $._homeTokenDecimals,\n            remoteTokenDecimals: $._tokenDecimals\n        });\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.REGISTER_REMOTE,\n            payload: abi.encode(registerMessage)\n        });\n\n        uint256 feeAmount = _handleFees(feeInfo.feeTokenAddress, feeInfo.amount);\n        _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({feeTokenAddress: feeInfo.feeTokenAddress, amount: feeAmount}),\n                requiredGasLimit: REGISTER_REMOTE_REQUIRED_GAS,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n    }",
            "startLine": 206,
            "signature": "registerWithHome(TeleporterFeeInfo)",
            "selector": "0x5535b6b3",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "calculateNumWords",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "payloadSize",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function calculateNumWords(\n        uint256 payloadSize\n    ) public pure returns (uint256) {\n        // Add 31 to effectively round up to the nearest multiple of 32.\n        // Right-shift by 5 bits to divide by 32.\n        return (payloadSize + 31) >> 5;\n    }",
            "startLine": 240,
            "signature": "calculateNumWords(uint256)",
            "selector": "0x5a673771",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getIsCollateralized",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getIsCollateralized() public view returns (bool) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._isCollateralized;\n    }",
            "startLine": 248,
            "signature": "getIsCollateralized()",
            "selector": "0x0892f6c8",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getTokenMultiplier",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenMultiplier() public view returns (uint256) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._tokenMultiplier;\n    }",
            "startLine": 253,
            "signature": "getTokenMultiplier()",
            "selector": "0x10c6819b",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getMultiplyOnRemote",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getMultiplyOnRemote() public view returns (bool) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._multiplyOnRemote;\n    }",
            "startLine": 258,
            "signature": "getMultiplyOnRemote()",
            "selector": "0x1dc0ae00",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getTokenHomeBlockchainID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenHomeBlockchainID() public view returns (bytes32) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._tokenHomeBlockchainID;\n    }",
            "startLine": 263,
            "signature": "getTokenHomeBlockchainID()",
            "selector": "0x480733ee",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getTokenHomeAddress",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenHomeAddress() public view returns (address) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._tokenHomeAddress;\n    }",
            "startLine": 268,
            "signature": "getTokenHomeAddress()",
            "selector": "0x3b3fc1ad",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getInitialReserveImbalance",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getInitialReserveImbalance() public view returns (uint256) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._initialReserveImbalance;\n    }",
            "startLine": 273,
            "signature": "getInitialReserveImbalance()",
            "selector": "0x1bdb1d8b",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getBlockchainID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getBlockchainID() public view returns (bytes32) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._blockchainID;\n    }",
            "startLine": 278,
            "signature": "getBlockchainID()",
            "selector": "0x587a98a6",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }",
            "startLine": 73,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "renounceOwnership",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
            "startLine": 94,
            "signature": "renounceOwnership()",
            "selector": "0x765becbf",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }",
            "startLine": 102,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC20TokenRemoteStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC20TokenRemoteStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getERC20TokenRemoteStorage()\n        private\n        pure\n        returns (ERC20TokenRemoteStorage storage $)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := ERC20_TOKEN_REMOTE_STORAGE_LOCATION\n        }\n    }",
            "startLine": 51,
            "visibility": "private",
            "inheritedFrom": "ERC20TokenRemoteUpgradeable"
          },
          {
            "name": "__ERC20TokenRemote_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "TokenRemoteSettings"
              },
              {
                "name": "tokenName",
                "type": "string"
              },
              {
                "name": "tokenSymbol",
                "type": "string"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ERC20_init",
                "type": "internal"
              },
              {
                "target": "__TokenRemote_init",
                "type": "internal"
              },
              {
                "target": "__ERC20TokenRemote_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20TokenRemote_init(\n        TokenRemoteSettings memory settings,\n        string memory tokenName,\n        string memory tokenSymbol,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        __ERC20_init(tokenName, tokenSymbol);\n        __TokenRemote_init(settings, 0, tokenDecimals);\n        __ERC20TokenRemote_init_unchained(tokenDecimals);\n    }",
            "startLine": 88,
            "visibility": "internal",
            "inheritedFrom": "ERC20TokenRemoteUpgradeable"
          },
          {
            "name": "__ERC20TokenRemote_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20TokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20TokenRemote_init_unchained(\n        uint8 tokenDecimals\n    ) internal {\n        _getERC20TokenRemoteStorage()._decimals = tokenDecimals;\n    }",
            "startLine": 100,
            "visibility": "internal",
            "inheritedFrom": "ERC20TokenRemoteUpgradeable"
          },
          {
            "name": "_withdraw",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "recipient",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_mint",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensWithdrawn"
            ],
            "isVirtual": true,
            "sourceCode": "function _withdraw(address recipient, uint256 amount) internal virtual override {\n        emit TokensWithdrawn(recipient, amount);\n        _mint(recipient, amount);\n    }",
            "startLine": 136,
            "visibility": "internal",
            "inheritedFrom": "ERC20TokenRemoteUpgradeable"
          },
          {
            "name": "_burn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_spendAllowance",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_burn",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _burn(\n        uint256 amount\n    ) internal virtual override returns (uint256) {\n        _spendAllowance(_msgSender(), address(this), amount);\n        _burn(_msgSender(), amount);\n        return amount;\n    }",
            "startLine": 152,
            "visibility": "internal",
            "inheritedFrom": "ERC20TokenRemoteUpgradeable"
          },
          {
            "name": "_handleSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "message",
                "type": "SingleHopCallMessage"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_mint",
                "type": "internal"
              },
              {
                "target": "_approve",
                "type": "internal"
              },
              {
                "target": "CallUtils._callWithExactGas",
                "type": "library"
              },
              {
                "target": "allowance",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              }
            ],
            "emits": [
              "CallSucceeded",
              "CallFailed"
            ],
            "isVirtual": true,
            "sourceCode": "function _handleSendAndCall(\n        SingleHopCallMessage memory message,\n        uint256 amount\n    ) internal virtual override {\n        // Mint the tokens to this contract address.\n        _mint(address(this), amount);\n\n        // Approve the recipient contract to spend the amount.\n        _approve(address(this), message.recipientContract, amount);\n\n        // Encode the call to {IERC20SendAndCallReceiver-receiveTokens}\n        bytes memory payload = abi.encodeCall(\n            IERC20SendAndCallReceiver.receiveTokens,\n            (\n                message.sourceBlockchainID,\n                message.originTokenTransferrerAddress,\n                message.originSenderAddress,\n                address(this),\n                amount,\n                message.recipientPayload\n            )\n        );\n\n        // Call the recipient contract with the given payload and gas amount.\n        bool success = CallUtils._callWithExactGas(\n            message.recipientGasLimit, message.recipientContract, payload\n        );\n\n        // Check what the remaining allowance is to transfer to the fallback recipient.\n        uint256 remainingAllowance = allowance(address(this), message.recipientContract);\n\n        // Reset the recipient contract allowance to 0.\n        _approve(address(this), message.recipientContract, 0);\n\n        if (success) {\n            emit CallSucceeded(message.recipientContract, amount);\n        } else {\n            emit CallFailed(message.recipientContract, amount);\n        }\n\n        // Transfer any remaining allowance to the fallback recipient. This will be the\n        // full amount if the call failed.\n        if (remainingAllowance > 0) {\n            _transfer(address(this), message.fallbackRecipient, remainingAllowance);\n        }\n    }",
            "startLine": 168,
            "visibility": "internal",
            "inheritedFrom": "ERC20TokenRemoteUpgradeable"
          },
          {
            "name": "_handleFees",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "feeTokenAddress",
                "type": "address"
              },
              {
                "name": "feeAmount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_spendAllowance",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              },
              {
                "target": "SafeERC20TransferFrom.safeTransferFrom",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _handleFees(\n        address feeTokenAddress,\n        uint256 feeAmount\n    ) internal virtual override returns (uint256) {\n        if (feeAmount == 0) {\n            return 0;\n        }\n        // If the {feeTokenAddress} is this contract, then just deposit the tokens directly.\n        if (feeTokenAddress == address(this)) {\n            _spendAllowance(_msgSender(), address(this), feeAmount);\n            _transfer(_msgSender(), address(this), feeAmount);\n            return feeAmount;\n        }\n        return\n            SafeERC20TransferFrom.safeTransferFrom(IERC20(feeTokenAddress), _msgSender(), feeAmount);\n    }",
            "startLine": 222,
            "visibility": "internal",
            "inheritedFrom": "ERC20TokenRemoteUpgradeable"
          },
          {
            "name": "_getERC20Storage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC20Storage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }",
            "startLine": 46,
            "visibility": "private",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "__ERC20_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name_",
                "type": "string"
              },
              {
                "name": "symbol_",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ERC20_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }",
            "startLine": 57,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "__ERC20_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name_",
                "type": "string"
              },
              {
                "name": "symbol_",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }",
            "startLine": 61,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }",
            "startLine": 182,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_update",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [
              "Transfer"
            ],
            "isVirtual": true,
            "sourceCode": "function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
            "startLine": 199,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_mint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }",
            "startLine": 238,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }",
            "startLine": 275,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_spendAllowance",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "allowance",
                "type": "internal"
              },
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }",
            "startLine": 319,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getTokenRemoteStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "TokenRemoteStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getTokenRemoteStorage() private pure returns (TokenRemoteStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := TOKEN_REMOTE_STORAGE_LOCATION\n        }\n    }",
            "startLine": 108,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "__TokenRemote_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "TokenRemoteSettings"
              },
              {
                "name": "initialReserveImbalance_",
                "type": "uint256"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryOwnableApp_init",
                "type": "internal"
              },
              {
                "target": "__SendReentrancyGuard_init",
                "type": "internal"
              },
              {
                "target": "__TokenRemote_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TokenRemote_init(\n        TokenRemoteSettings memory settings,\n        uint256 initialReserveImbalance_,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        __TeleporterRegistryOwnableApp_init(\n            settings.teleporterRegistryAddress,\n            settings.teleporterManager,\n            settings.minTeleporterVersion\n        );\n        __SendReentrancyGuard_init();\n        __TokenRemote_init_unchained(settings, initialReserveImbalance_, tokenDecimals);\n    }",
            "startLine": 150,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "__TokenRemote_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "TokenRemoteSettings"
              },
              {
                "name": "initialReserveImbalance_",
                "type": "uint256"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.deriveTokenMultiplierValues",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TokenRemote_init_unchained(\n        TokenRemoteSettings memory settings,\n        uint256 initialReserveImbalance_,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        $._blockchainID =\n            IWarpMessenger(0x0200000000000000000000000000000000000005).getBlockchainID();\n        require(\n            settings.tokenHomeBlockchainID != bytes32(0),\n            \"TokenRemote: zero token home blockchain ID\"\n        );\n        require(\n            settings.tokenHomeBlockchainID != $._blockchainID,\n            \"TokenRemote: cannot deploy to same blockchain as token home\"\n        );\n        require(settings.tokenHomeAddress != address(0), \"TokenRemote: zero token home address\");\n        require(\n            settings.tokenHomeDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenRemote: token home decimals too high\"\n        );\n        require(\n            tokenDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenRemote: token decimals too high\"\n        );\n        $._tokenHomeBlockchainID = settings.tokenHomeBlockchainID;\n        $._tokenHomeAddress = settings.tokenHomeAddress;\n        $._initialReserveImbalance = initialReserveImbalance_;\n        $._isCollateralized = initialReserveImbalance_ == 0;\n        $._homeTokenDecimals = settings.tokenHomeDecimals;\n        $._tokenDecimals = tokenDecimals;\n        ($._tokenMultiplier, $._multiplyOnRemote) =\n            TokenScalingUtils.deriveTokenMultiplierValues(settings.tokenHomeDecimals, tokenDecimals);\n    }",
            "startLine": 165,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_send",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSendTokensInput",
                "type": "internal"
              },
              {
                "target": "_processSend",
                "type": "internal"
              },
              {
                "target": "_processSendMultiHop",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _send(SendTokensInput calldata input, uint256 amount) internal sendNonReentrant {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSendTokensInput(input);\n        if (input.destinationBlockchainID == $._tokenHomeBlockchainID) {\n            _processSend(input, amount);\n        } else {\n            _processSendMultiHop(input, amount);\n        }\n    }",
            "startLine": 290,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_sendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSendAndCallInput",
                "type": "internal"
              },
              {
                "target": "_processSendAndCall",
                "type": "internal"
              },
              {
                "target": "_processSendAndCallMultiHop",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _sendAndCall(\n        SendAndCallInput calldata input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSendAndCallInput(input);\n\n        if (input.destinationBlockchainID == $._tokenHomeBlockchainID) {\n            return _processSendAndCall(input, amount);\n        } else {\n            return _processSendAndCallMultiHop(input, amount);\n        }\n    }",
            "startLine": 308,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_receiveTeleporterMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "message",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_handleSendAndCall",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _receiveTeleporterMessage(\n        bytes32 sourceBlockchainID,\n        address originSenderAddress,\n        bytes memory message\n    ) internal override {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        require(\n            sourceBlockchainID == $._tokenHomeBlockchainID,\n            \"TokenRemote: invalid source blockchain ID\"\n        );\n        require(\n            originSenderAddress == $._tokenHomeAddress, \"TokenRemote: invalid origin sender address\"\n        );\n        TransferrerMessage memory transferrerMessage = abi.decode(message, (TransferrerMessage));\n\n        // If the contract was not previously known to be registered or collateralized, it is now given that\n        // the home has sent a message to mint funds.\n        if (!$._isRegistered || !$._isCollateralized) {\n            $._isRegistered = true;\n            $._isCollateralized = true;\n        }\n\n        // Remote contracts should only ever receive single-hop messages because\n        // multi-hop messages are always routed through the home contract.\n        if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_SEND) {\n            SingleHopSendMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopSendMessage));\n            _withdraw(payload.recipient, payload.amount);\n        } else if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_CALL) {\n            // The {sourceBlockchainID}, and {originSenderAddress} specified in the message\n            // payload will not match the sender of this Teleporter message in the case of a\n            // multi-hop message. Since Teleporter messages are only received from the specified\n            // token TokenHome instance, no additional authentication is needed on the payload values.\n            SingleHopCallMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopCallMessage));\n            _handleSendAndCall(payload, payload.amount);\n        } else {\n            revert(\"TokenRemote: invalid message type\");\n        }\n    }",
            "startLine": 328,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_prepareSend",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "primaryFeeTokenAddress",
                "type": "address"
              },
              {
                "name": "primaryFee",
                "type": "uint256"
              },
              {
                "name": "secondaryFee",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_burn",
                "type": "internal"
              },
              {
                "target": "_handleFees",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _prepareSend(\n        uint256 amount,\n        address primaryFeeTokenAddress,\n        uint256 primaryFee,\n        uint256 secondaryFee\n    ) private returns (uint256, uint256) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n\n        // Burn the amount of tokens that will be transferred.\n        amount = _burn(amount);\n\n        // Transfer the primary fee to pay for fees on the first hop.\n        // The user can specify this contract as {primaryFeeTokenAddress},\n        // in which case the fee will be paid on top of the transferred amount.\n        primaryFee = _handleFees(primaryFeeTokenAddress, primaryFee);\n\n        // The transferred amount must cover the secondary fee, because the secondary fee\n        // is directly subtracted from the transferred amount on the intermediate (home) chain\n        // performing the multi-hop, before forwarding to the final destination TokenRemote instance.\n        require(\n            TokenScalingUtils.removeTokenScale($._tokenMultiplier, $._multiplyOnRemote, amount)\n                > TokenScalingUtils.removeTokenScale(\n                    $._tokenMultiplier, $._multiplyOnRemote, secondaryFee\n                ),\n            \"TokenRemote: insufficient tokens to transfer\"\n        );\n\n        // Return the amount in this contract's local denomination and the primary fee.\n        return (amount, primaryFee);\n    }",
            "startLine": 414,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_processSend",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSingleHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSend(SendTokensInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSingleHopInput(\n            input.destinationTokenTransferrerAddress, input.secondaryFee, input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_SEND,\n            payload: abi.encode(SingleHopSendMessage({recipient: input.recipient, amount: amount}))\n        });\n\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 448,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_processSendMultiHop",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateMultiHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSendMultiHop(SendTokensInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateMultiHopInput(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.MULTI_HOP_SEND,\n            payload: abi.encode(\n                MultiHopSendMessage({\n                    destinationBlockchainID: input.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n                    recipient: input.recipient,\n                    amount: amount,\n                    secondaryFee: input.secondaryFee,\n                    secondaryGasLimit: input.requiredGasLimit,\n                    multiHopFallback: input.multiHopFallback\n                })\n            )\n        });\n\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: MULTI_HOP_SEND_REQUIRED_GAS,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 487,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_processSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSingleHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSendAndCall(SendAndCallInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSingleHopInput(\n            input.destinationTokenTransferrerAddress, input.secondaryFee, input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_CALL,\n            payload: abi.encode(\n                SingleHopCallMessage({\n                    sourceBlockchainID: $._blockchainID,\n                    originTokenTransferrerAddress: address(this),\n                    originSenderAddress: _msgSender(),\n                    recipientContract: input.recipientContract,\n                    amount: amount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient\n                })\n            )\n        });\n\n        // Send message to the token TokenHome instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 539,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_processSendAndCallMultiHop",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateMultiHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "calculateNumWords",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSendAndCallMultiHop(SendAndCallInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateMultiHopInput(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.MULTI_HOP_CALL,\n            payload: abi.encode(\n                MultiHopCallMessage({\n                    originSenderAddress: _msgSender(),\n                    destinationBlockchainID: input.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n                    recipientContract: input.recipientContract,\n                    amount: amount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient,\n                    multiHopFallback: input.multiHopFallback,\n                    secondaryRequiredGasLimit: input.requiredGasLimit,\n                    secondaryFee: input.secondaryFee\n                })\n            )\n        });\n\n        // The required gas limit for the first message sent back to the TokenHome instance\n        // needs to account for the number of words in the payload. Each word uses additional\n        // gas to include in the message to the final destination chain.\n        uint256 messageRequiredGasLimit = MULTI_HOP_CALL_REQUIRED_GAS\n            + (calculateNumWords(input.recipientPayload.length) * MULTI_HOP_CALL_GAS_PER_WORD);\n\n        // Send message to the token TokenHome instance\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: messageRequiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 591,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_validateSingleHopInput",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "destinationTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "secondaryFee",
                "type": "uint256"
              },
              {
                "name": "multiHopFallback",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSingleHopInput(\n        address destinationTokenTransferrerAddress,\n        uint256 secondaryFee,\n        address multiHopFallback\n    ) private view {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        require(\n            destinationTokenTransferrerAddress == $._tokenHomeAddress,\n            \"TokenRemote: invalid destination token transferrer address\"\n        );\n        require(secondaryFee == 0, \"TokenRemote: non-zero secondary fee\");\n        require(multiHopFallback == address(0), \"TokenRemote: non-zero multi-hop fallback\");\n    }",
            "startLine": 650,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_validateMultiHopInput",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "destinationBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "destinationTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "multiHopFallback",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateMultiHopInput(\n        bytes32 destinationBlockchainID,\n        address destinationTokenTransferrerAddress,\n        address multiHopFallback\n    ) private view {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        // If the destination blockchain ID is this blockchain, the destination\n        // token transferrer address must be a different contract. This is a multi-hop case to\n        // a different token transfer contract on this chain.\n        if (destinationBlockchainID == $._blockchainID) {\n            require(\n                destinationTokenTransferrerAddress != address(this),\n                \"TokenRemote: invalid destination token transferrer address\"\n            );\n        }\n        require(multiHopFallback != address(0), \"TokenRemote: zero multi-hop fallback\");\n    }",
            "startLine": 664,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_validateSendTokensInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendTokensInput(\n        SendTokensInput calldata input\n    ) private pure {\n        require(input.recipient != address(0), \"TokenRemote: zero recipient address\");\n        require(input.requiredGasLimit > 0, \"TokenRemote: zero required gas limit\");\n        require(\n            input.destinationBlockchainID != bytes32(0),\n            \"TokenRemote: zero destination blockchain ID\"\n        );\n        require(\n            input.destinationTokenTransferrerAddress != address(0),\n            \"TokenRemote: zero destination token transferrer address\"\n        );\n    }",
            "startLine": 682,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_validateSendAndCallInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendAndCallInput(\n        SendAndCallInput calldata input\n    ) private pure {\n        require(\n            input.destinationBlockchainID != bytes32(0),\n            \"TokenRemote: zero destination blockchain ID\"\n        );\n        require(\n            input.destinationTokenTransferrerAddress != address(0),\n            \"TokenRemote: zero destination token transferrer address\"\n        );\n        require(\n            input.recipientContract != address(0), \"TokenRemote: zero recipient contract address\"\n        );\n        require(input.requiredGasLimit > 0, \"TokenRemote: zero required gas limit\");\n        require(input.recipientGasLimit > 0, \"TokenRemote: zero recipient gas limit\");\n        require(\n            input.recipientGasLimit < input.requiredGasLimit,\n            \"TokenRemote: invalid recipient gas limit\"\n        );\n        require(\n            input.fallbackRecipient != address(0), \"TokenRemote: zero fallback recipient address\"\n        );\n    }",
            "startLine": 697,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "__TeleporterRegistryOwnableApp_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "initialOwner",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryApp_init",
                "type": "internal"
              },
              {
                "target": "__Ownable_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TeleporterRegistryOwnableApp_init(\n        address teleporterRegistryAddress,\n        address initialOwner,\n        uint256 minTeleporterVersion\n    ) internal onlyInitializing {\n        __TeleporterRegistryApp_init(teleporterRegistryAddress, minTeleporterVersion);\n        __Ownable_init(initialOwner);\n    }",
            "startLine": 24,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_TeleporterRegistryOwnableApp_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _TeleporterRegistryOwnableApp_init_unchained() internal onlyInitializing {}",
            "startLine": 34,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_checkTeleporterRegistryAppAccess",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_checkOwner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkTeleporterRegistryAppAccess() internal view virtual override {\n        _checkOwner();\n    }",
            "startLine": 42,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_getOwnableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "OwnableStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }",
            "startLine": 30,
            "visibility": "private",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__Ownable_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }",
            "startLine": 51,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }",
            "startLine": 55,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }",
            "startLine": 81,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "OwnershipTransferred"
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }",
            "startLine": 113,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_getSendReentrancyGuardStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "SendReentrancyGuardStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getSendReentrancyGuardStorage()\n        private\n        pure\n        returns (SendReentrancyGuardStorage storage $)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := _SEND_REENTRANCY_GUARD_STORAGE_LOCATION\n        }\n    }",
            "startLine": 35,
            "visibility": "private",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrancyGuard_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "__SendReentrnacyGuard_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrancyGuard_init() internal onlyInitializing {\n        __SendReentrnacyGuard_init_unchained();\n    }",
            "startLine": 59,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrnacyGuard_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getSendReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrnacyGuard_init_unchained() internal {\n        SendReentrancyGuardStorage storage $ = _getSendReentrancyGuardStorage();\n        $._sendEntered = _NOT_ENTERED;\n    }",
            "startLine": 64,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "ERC20TokenRemoteUpgradeable",
        "kind": "contract",
        "category": "ictt",
        "filePath": "@ictt/TokenRemote/ERC20TokenRemoteUpgradeable.sol",
        "inherits": [
          "ERC20Upgradeable",
          "TokenRemote"
        ],
        "implements": [
          "IERC20TokenTransferrer"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "TokenRemote",
            "path": "./TokenRemote.sol",
            "isExternal": false
          },
          {
            "name": "TokenRemoteSettings",
            "path": "./interfaces/ITokenRemote.sol",
            "isExternal": false
          },
          {
            "name": "IERC20TokenTransferrer",
            "path": "../interfaces/IERC20TokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "IERC20SendAndCallReceiver",
            "path": "../interfaces/IERC20SendAndCallReceiver.sol",
            "isExternal": false
          },
          {
            "name": "SendTokensInput",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SendAndCallInput",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SingleHopCallMessage",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "IERC20",
            "path": "@openzeppelin/contracts@5.0.2/token/ERC20/ERC20.sol",
            "isExternal": true
          },
          {
            "name": "ERC20Upgradeable",
            "path": "@openzeppelin/contracts-upgradeable@5.0.2/token/ERC20/ERC20Upgradeable.sol",
            "isExternal": true
          },
          {
            "name": "SafeERC20TransferFrom",
            "path": "@utilities/SafeERC20TransferFrom.sol",
            "isExternal": true
          },
          {
            "name": "CallUtils",
            "path": "@utilities/CallUtils.sol",
            "isExternal": true
          },
          {
            "name": "ICMInitializable",
            "path": "@utilities/ICMInitializable.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "initialize",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "TokenRemoteSettings"
              },
              {
                "name": "tokenName",
                "type": "string"
              },
              {
                "name": "tokenSymbol",
                "type": "string"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ERC20TokenRemote_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initialize(\n        TokenRemoteSettings memory settings,\n        string memory tokenName,\n        string memory tokenSymbol,\n        uint8 tokenDecimals\n    ) public initializer {\n        __ERC20TokenRemote_init(settings, tokenName, tokenSymbol, tokenDecimals);\n    }",
            "startLine": 78,
            "signature": "initialize(TokenRemoteSettings,string,string,uint8)",
            "selector": "0x558cb4ad",
            "visibility": "public",
            "modifiers": [
              "initializer"
            ]
          },
          {
            "name": "send",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_send",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function send(SendTokensInput calldata input, uint256 amount) external {\n        _send(input, amount);\n    }",
            "startLine": 114,
            "signature": "send(SendTokensInput,uint256)",
            "selector": "0x247bc3d4",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "sendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_sendAndCall",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function sendAndCall(SendAndCallInput calldata input, uint256 amount) external {\n        _sendAndCall(input, amount);\n    }",
            "startLine": 121,
            "signature": "sendAndCall(SendAndCallInput,uint256)",
            "selector": "0x6f1f7d9c",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "decimals",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [
              {
                "target": "_getERC20TokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function decimals() public view override returns (uint8) {\n        ERC20TokenRemoteStorage storage $ = _getERC20TokenRemoteStorage();\n        return $._decimals;\n    }",
            "startLine": 128,
            "signature": "decimals()",
            "selector": "0x76436c3d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "name",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }",
            "startLine": 70,
            "signature": "name()",
            "selector": "0x3ec0f734",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "symbol",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }",
            "startLine": 79,
            "signature": "symbol()",
            "selector": "0x6a927499",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "totalSupply",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }",
            "startLine": 102,
            "signature": "totalSupply()",
            "selector": "0x6190166c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "balanceOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }",
            "startLine": 108,
            "signature": "balanceOf(address)",
            "selector": "0x7d2b9996",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }",
            "startLine": 121,
            "signature": "transfer(address,uint256)",
            "selector": "0x59d228e5",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "allowance",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }",
            "startLine": 128,
            "signature": "allowance(address,address)",
            "selector": "0x596dd87d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }",
            "startLine": 143,
            "signature": "approve(address,uint256)",
            "selector": "0x1d38323d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "transferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_spendAllowance",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }",
            "startLine": 165,
            "signature": "transferFrom(address,address,uint256)",
            "selector": "0x447f286d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "registerWithHome",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "feeInfo",
                "type": "TeleporterFeeInfo"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_handleFees",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function registerWithHome(\n        TeleporterFeeInfo calldata feeInfo\n    ) external virtual {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        require(!$._isRegistered, \"TokenRemote: already registered\");\n\n        // Send a message to the token TokenHome instance to register this TokenRemote instance.\n        RegisterRemoteMessage memory registerMessage = RegisterRemoteMessage({\n            initialReserveImbalance: $._initialReserveImbalance,\n            homeTokenDecimals: $._homeTokenDecimals,\n            remoteTokenDecimals: $._tokenDecimals\n        });\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.REGISTER_REMOTE,\n            payload: abi.encode(registerMessage)\n        });\n\n        uint256 feeAmount = _handleFees(feeInfo.feeTokenAddress, feeInfo.amount);\n        _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({feeTokenAddress: feeInfo.feeTokenAddress, amount: feeAmount}),\n                requiredGasLimit: REGISTER_REMOTE_REQUIRED_GAS,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n    }",
            "startLine": 206,
            "signature": "registerWithHome(TeleporterFeeInfo)",
            "selector": "0x5535b6b3",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "calculateNumWords",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "payloadSize",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function calculateNumWords(\n        uint256 payloadSize\n    ) public pure returns (uint256) {\n        // Add 31 to effectively round up to the nearest multiple of 32.\n        // Right-shift by 5 bits to divide by 32.\n        return (payloadSize + 31) >> 5;\n    }",
            "startLine": 240,
            "signature": "calculateNumWords(uint256)",
            "selector": "0x5a673771",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getIsCollateralized",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getIsCollateralized() public view returns (bool) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._isCollateralized;\n    }",
            "startLine": 248,
            "signature": "getIsCollateralized()",
            "selector": "0x0892f6c8",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getTokenMultiplier",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenMultiplier() public view returns (uint256) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._tokenMultiplier;\n    }",
            "startLine": 253,
            "signature": "getTokenMultiplier()",
            "selector": "0x10c6819b",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getMultiplyOnRemote",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getMultiplyOnRemote() public view returns (bool) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._multiplyOnRemote;\n    }",
            "startLine": 258,
            "signature": "getMultiplyOnRemote()",
            "selector": "0x1dc0ae00",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getTokenHomeBlockchainID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenHomeBlockchainID() public view returns (bytes32) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._tokenHomeBlockchainID;\n    }",
            "startLine": 263,
            "signature": "getTokenHomeBlockchainID()",
            "selector": "0x480733ee",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getTokenHomeAddress",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenHomeAddress() public view returns (address) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._tokenHomeAddress;\n    }",
            "startLine": 268,
            "signature": "getTokenHomeAddress()",
            "selector": "0x3b3fc1ad",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getInitialReserveImbalance",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getInitialReserveImbalance() public view returns (uint256) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._initialReserveImbalance;\n    }",
            "startLine": 273,
            "signature": "getInitialReserveImbalance()",
            "selector": "0x1bdb1d8b",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getBlockchainID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getBlockchainID() public view returns (bytes32) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._blockchainID;\n    }",
            "startLine": 278,
            "signature": "getBlockchainID()",
            "selector": "0x587a98a6",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }",
            "startLine": 73,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "renounceOwnership",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
            "startLine": 94,
            "signature": "renounceOwnership()",
            "selector": "0x765becbf",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }",
            "startLine": 102,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC20TokenRemoteStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC20TokenRemoteStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getERC20TokenRemoteStorage()\n        private\n        pure\n        returns (ERC20TokenRemoteStorage storage $)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := ERC20_TOKEN_REMOTE_STORAGE_LOCATION\n        }\n    }",
            "startLine": 51,
            "visibility": "private"
          },
          {
            "name": "__ERC20TokenRemote_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "TokenRemoteSettings"
              },
              {
                "name": "tokenName",
                "type": "string"
              },
              {
                "name": "tokenSymbol",
                "type": "string"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ERC20_init",
                "type": "internal"
              },
              {
                "target": "__TokenRemote_init",
                "type": "internal"
              },
              {
                "target": "__ERC20TokenRemote_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20TokenRemote_init(\n        TokenRemoteSettings memory settings,\n        string memory tokenName,\n        string memory tokenSymbol,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        __ERC20_init(tokenName, tokenSymbol);\n        __TokenRemote_init(settings, 0, tokenDecimals);\n        __ERC20TokenRemote_init_unchained(tokenDecimals);\n    }",
            "startLine": 88,
            "visibility": "internal"
          },
          {
            "name": "__ERC20TokenRemote_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20TokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20TokenRemote_init_unchained(\n        uint8 tokenDecimals\n    ) internal {\n        _getERC20TokenRemoteStorage()._decimals = tokenDecimals;\n    }",
            "startLine": 100,
            "visibility": "internal"
          },
          {
            "name": "_withdraw",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "recipient",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_mint",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensWithdrawn"
            ],
            "isVirtual": true,
            "sourceCode": "function _withdraw(address recipient, uint256 amount) internal virtual override {\n        emit TokensWithdrawn(recipient, amount);\n        _mint(recipient, amount);\n    }",
            "startLine": 136,
            "visibility": "internal"
          },
          {
            "name": "_burn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_spendAllowance",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_burn",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _burn(\n        uint256 amount\n    ) internal virtual override returns (uint256) {\n        _spendAllowance(_msgSender(), address(this), amount);\n        _burn(_msgSender(), amount);\n        return amount;\n    }",
            "startLine": 152,
            "visibility": "internal"
          },
          {
            "name": "_handleSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "message",
                "type": "SingleHopCallMessage"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_mint",
                "type": "internal"
              },
              {
                "target": "_approve",
                "type": "internal"
              },
              {
                "target": "CallUtils._callWithExactGas",
                "type": "library"
              },
              {
                "target": "allowance",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              }
            ],
            "emits": [
              "CallSucceeded",
              "CallFailed"
            ],
            "isVirtual": true,
            "sourceCode": "function _handleSendAndCall(\n        SingleHopCallMessage memory message,\n        uint256 amount\n    ) internal virtual override {\n        // Mint the tokens to this contract address.\n        _mint(address(this), amount);\n\n        // Approve the recipient contract to spend the amount.\n        _approve(address(this), message.recipientContract, amount);\n\n        // Encode the call to {IERC20SendAndCallReceiver-receiveTokens}\n        bytes memory payload = abi.encodeCall(\n            IERC20SendAndCallReceiver.receiveTokens,\n            (\n                message.sourceBlockchainID,\n                message.originTokenTransferrerAddress,\n                message.originSenderAddress,\n                address(this),\n                amount,\n                message.recipientPayload\n            )\n        );\n\n        // Call the recipient contract with the given payload and gas amount.\n        bool success = CallUtils._callWithExactGas(\n            message.recipientGasLimit, message.recipientContract, payload\n        );\n\n        // Check what the remaining allowance is to transfer to the fallback recipient.\n        uint256 remainingAllowance = allowance(address(this), message.recipientContract);\n\n        // Reset the recipient contract allowance to 0.\n        _approve(address(this), message.recipientContract, 0);\n\n        if (success) {\n            emit CallSucceeded(message.recipientContract, amount);\n        } else {\n            emit CallFailed(message.recipientContract, amount);\n        }\n\n        // Transfer any remaining allowance to the fallback recipient. This will be the\n        // full amount if the call failed.\n        if (remainingAllowance > 0) {\n            _transfer(address(this), message.fallbackRecipient, remainingAllowance);\n        }\n    }",
            "startLine": 168,
            "visibility": "internal"
          },
          {
            "name": "_handleFees",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "feeTokenAddress",
                "type": "address"
              },
              {
                "name": "feeAmount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_spendAllowance",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              },
              {
                "target": "SafeERC20TransferFrom.safeTransferFrom",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _handleFees(\n        address feeTokenAddress,\n        uint256 feeAmount\n    ) internal virtual override returns (uint256) {\n        if (feeAmount == 0) {\n            return 0;\n        }\n        // If the {feeTokenAddress} is this contract, then just deposit the tokens directly.\n        if (feeTokenAddress == address(this)) {\n            _spendAllowance(_msgSender(), address(this), feeAmount);\n            _transfer(_msgSender(), address(this), feeAmount);\n            return feeAmount;\n        }\n        return\n            SafeERC20TransferFrom.safeTransferFrom(IERC20(feeTokenAddress), _msgSender(), feeAmount);\n    }",
            "startLine": 222,
            "visibility": "internal"
          },
          {
            "name": "_getERC20Storage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC20Storage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }",
            "startLine": 46,
            "visibility": "private",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "__ERC20_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name_",
                "type": "string"
              },
              {
                "name": "symbol_",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ERC20_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }",
            "startLine": 57,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "__ERC20_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name_",
                "type": "string"
              },
              {
                "name": "symbol_",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }",
            "startLine": 61,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }",
            "startLine": 182,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_update",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [
              "Transfer"
            ],
            "isVirtual": true,
            "sourceCode": "function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
            "startLine": 199,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_mint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }",
            "startLine": 238,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }",
            "startLine": 275,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_spendAllowance",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "allowance",
                "type": "internal"
              },
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }",
            "startLine": 319,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getTokenRemoteStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "TokenRemoteStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getTokenRemoteStorage() private pure returns (TokenRemoteStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := TOKEN_REMOTE_STORAGE_LOCATION\n        }\n    }",
            "startLine": 108,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "__TokenRemote_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "TokenRemoteSettings"
              },
              {
                "name": "initialReserveImbalance_",
                "type": "uint256"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryOwnableApp_init",
                "type": "internal"
              },
              {
                "target": "__SendReentrancyGuard_init",
                "type": "internal"
              },
              {
                "target": "__TokenRemote_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TokenRemote_init(\n        TokenRemoteSettings memory settings,\n        uint256 initialReserveImbalance_,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        __TeleporterRegistryOwnableApp_init(\n            settings.teleporterRegistryAddress,\n            settings.teleporterManager,\n            settings.minTeleporterVersion\n        );\n        __SendReentrancyGuard_init();\n        __TokenRemote_init_unchained(settings, initialReserveImbalance_, tokenDecimals);\n    }",
            "startLine": 150,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "__TokenRemote_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "TokenRemoteSettings"
              },
              {
                "name": "initialReserveImbalance_",
                "type": "uint256"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.deriveTokenMultiplierValues",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TokenRemote_init_unchained(\n        TokenRemoteSettings memory settings,\n        uint256 initialReserveImbalance_,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        $._blockchainID =\n            IWarpMessenger(0x0200000000000000000000000000000000000005).getBlockchainID();\n        require(\n            settings.tokenHomeBlockchainID != bytes32(0),\n            \"TokenRemote: zero token home blockchain ID\"\n        );\n        require(\n            settings.tokenHomeBlockchainID != $._blockchainID,\n            \"TokenRemote: cannot deploy to same blockchain as token home\"\n        );\n        require(settings.tokenHomeAddress != address(0), \"TokenRemote: zero token home address\");\n        require(\n            settings.tokenHomeDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenRemote: token home decimals too high\"\n        );\n        require(\n            tokenDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenRemote: token decimals too high\"\n        );\n        $._tokenHomeBlockchainID = settings.tokenHomeBlockchainID;\n        $._tokenHomeAddress = settings.tokenHomeAddress;\n        $._initialReserveImbalance = initialReserveImbalance_;\n        $._isCollateralized = initialReserveImbalance_ == 0;\n        $._homeTokenDecimals = settings.tokenHomeDecimals;\n        $._tokenDecimals = tokenDecimals;\n        ($._tokenMultiplier, $._multiplyOnRemote) =\n            TokenScalingUtils.deriveTokenMultiplierValues(settings.tokenHomeDecimals, tokenDecimals);\n    }",
            "startLine": 165,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_send",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSendTokensInput",
                "type": "internal"
              },
              {
                "target": "_processSend",
                "type": "internal"
              },
              {
                "target": "_processSendMultiHop",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _send(SendTokensInput calldata input, uint256 amount) internal sendNonReentrant {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSendTokensInput(input);\n        if (input.destinationBlockchainID == $._tokenHomeBlockchainID) {\n            _processSend(input, amount);\n        } else {\n            _processSendMultiHop(input, amount);\n        }\n    }",
            "startLine": 290,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_sendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSendAndCallInput",
                "type": "internal"
              },
              {
                "target": "_processSendAndCall",
                "type": "internal"
              },
              {
                "target": "_processSendAndCallMultiHop",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _sendAndCall(\n        SendAndCallInput calldata input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSendAndCallInput(input);\n\n        if (input.destinationBlockchainID == $._tokenHomeBlockchainID) {\n            return _processSendAndCall(input, amount);\n        } else {\n            return _processSendAndCallMultiHop(input, amount);\n        }\n    }",
            "startLine": 308,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_receiveTeleporterMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "message",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_handleSendAndCall",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _receiveTeleporterMessage(\n        bytes32 sourceBlockchainID,\n        address originSenderAddress,\n        bytes memory message\n    ) internal override {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        require(\n            sourceBlockchainID == $._tokenHomeBlockchainID,\n            \"TokenRemote: invalid source blockchain ID\"\n        );\n        require(\n            originSenderAddress == $._tokenHomeAddress, \"TokenRemote: invalid origin sender address\"\n        );\n        TransferrerMessage memory transferrerMessage = abi.decode(message, (TransferrerMessage));\n\n        // If the contract was not previously known to be registered or collateralized, it is now given that\n        // the home has sent a message to mint funds.\n        if (!$._isRegistered || !$._isCollateralized) {\n            $._isRegistered = true;\n            $._isCollateralized = true;\n        }\n\n        // Remote contracts should only ever receive single-hop messages because\n        // multi-hop messages are always routed through the home contract.\n        if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_SEND) {\n            SingleHopSendMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopSendMessage));\n            _withdraw(payload.recipient, payload.amount);\n        } else if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_CALL) {\n            // The {sourceBlockchainID}, and {originSenderAddress} specified in the message\n            // payload will not match the sender of this Teleporter message in the case of a\n            // multi-hop message. Since Teleporter messages are only received from the specified\n            // token TokenHome instance, no additional authentication is needed on the payload values.\n            SingleHopCallMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopCallMessage));\n            _handleSendAndCall(payload, payload.amount);\n        } else {\n            revert(\"TokenRemote: invalid message type\");\n        }\n    }",
            "startLine": 328,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_prepareSend",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "primaryFeeTokenAddress",
                "type": "address"
              },
              {
                "name": "primaryFee",
                "type": "uint256"
              },
              {
                "name": "secondaryFee",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_burn",
                "type": "internal"
              },
              {
                "target": "_handleFees",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _prepareSend(\n        uint256 amount,\n        address primaryFeeTokenAddress,\n        uint256 primaryFee,\n        uint256 secondaryFee\n    ) private returns (uint256, uint256) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n\n        // Burn the amount of tokens that will be transferred.\n        amount = _burn(amount);\n\n        // Transfer the primary fee to pay for fees on the first hop.\n        // The user can specify this contract as {primaryFeeTokenAddress},\n        // in which case the fee will be paid on top of the transferred amount.\n        primaryFee = _handleFees(primaryFeeTokenAddress, primaryFee);\n\n        // The transferred amount must cover the secondary fee, because the secondary fee\n        // is directly subtracted from the transferred amount on the intermediate (home) chain\n        // performing the multi-hop, before forwarding to the final destination TokenRemote instance.\n        require(\n            TokenScalingUtils.removeTokenScale($._tokenMultiplier, $._multiplyOnRemote, amount)\n                > TokenScalingUtils.removeTokenScale(\n                    $._tokenMultiplier, $._multiplyOnRemote, secondaryFee\n                ),\n            \"TokenRemote: insufficient tokens to transfer\"\n        );\n\n        // Return the amount in this contract's local denomination and the primary fee.\n        return (amount, primaryFee);\n    }",
            "startLine": 414,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_processSend",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSingleHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSend(SendTokensInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSingleHopInput(\n            input.destinationTokenTransferrerAddress, input.secondaryFee, input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_SEND,\n            payload: abi.encode(SingleHopSendMessage({recipient: input.recipient, amount: amount}))\n        });\n\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 448,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_processSendMultiHop",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateMultiHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSendMultiHop(SendTokensInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateMultiHopInput(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.MULTI_HOP_SEND,\n            payload: abi.encode(\n                MultiHopSendMessage({\n                    destinationBlockchainID: input.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n                    recipient: input.recipient,\n                    amount: amount,\n                    secondaryFee: input.secondaryFee,\n                    secondaryGasLimit: input.requiredGasLimit,\n                    multiHopFallback: input.multiHopFallback\n                })\n            )\n        });\n\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: MULTI_HOP_SEND_REQUIRED_GAS,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 487,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_processSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSingleHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSendAndCall(SendAndCallInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSingleHopInput(\n            input.destinationTokenTransferrerAddress, input.secondaryFee, input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_CALL,\n            payload: abi.encode(\n                SingleHopCallMessage({\n                    sourceBlockchainID: $._blockchainID,\n                    originTokenTransferrerAddress: address(this),\n                    originSenderAddress: _msgSender(),\n                    recipientContract: input.recipientContract,\n                    amount: amount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient\n                })\n            )\n        });\n\n        // Send message to the token TokenHome instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 539,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_processSendAndCallMultiHop",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateMultiHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "calculateNumWords",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSendAndCallMultiHop(SendAndCallInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateMultiHopInput(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.MULTI_HOP_CALL,\n            payload: abi.encode(\n                MultiHopCallMessage({\n                    originSenderAddress: _msgSender(),\n                    destinationBlockchainID: input.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n                    recipientContract: input.recipientContract,\n                    amount: amount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient,\n                    multiHopFallback: input.multiHopFallback,\n                    secondaryRequiredGasLimit: input.requiredGasLimit,\n                    secondaryFee: input.secondaryFee\n                })\n            )\n        });\n\n        // The required gas limit for the first message sent back to the TokenHome instance\n        // needs to account for the number of words in the payload. Each word uses additional\n        // gas to include in the message to the final destination chain.\n        uint256 messageRequiredGasLimit = MULTI_HOP_CALL_REQUIRED_GAS\n            + (calculateNumWords(input.recipientPayload.length) * MULTI_HOP_CALL_GAS_PER_WORD);\n\n        // Send message to the token TokenHome instance\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: messageRequiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 591,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_validateSingleHopInput",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "destinationTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "secondaryFee",
                "type": "uint256"
              },
              {
                "name": "multiHopFallback",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSingleHopInput(\n        address destinationTokenTransferrerAddress,\n        uint256 secondaryFee,\n        address multiHopFallback\n    ) private view {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        require(\n            destinationTokenTransferrerAddress == $._tokenHomeAddress,\n            \"TokenRemote: invalid destination token transferrer address\"\n        );\n        require(secondaryFee == 0, \"TokenRemote: non-zero secondary fee\");\n        require(multiHopFallback == address(0), \"TokenRemote: non-zero multi-hop fallback\");\n    }",
            "startLine": 650,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_validateMultiHopInput",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "destinationBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "destinationTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "multiHopFallback",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateMultiHopInput(\n        bytes32 destinationBlockchainID,\n        address destinationTokenTransferrerAddress,\n        address multiHopFallback\n    ) private view {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        // If the destination blockchain ID is this blockchain, the destination\n        // token transferrer address must be a different contract. This is a multi-hop case to\n        // a different token transfer contract on this chain.\n        if (destinationBlockchainID == $._blockchainID) {\n            require(\n                destinationTokenTransferrerAddress != address(this),\n                \"TokenRemote: invalid destination token transferrer address\"\n            );\n        }\n        require(multiHopFallback != address(0), \"TokenRemote: zero multi-hop fallback\");\n    }",
            "startLine": 664,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_validateSendTokensInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendTokensInput(\n        SendTokensInput calldata input\n    ) private pure {\n        require(input.recipient != address(0), \"TokenRemote: zero recipient address\");\n        require(input.requiredGasLimit > 0, \"TokenRemote: zero required gas limit\");\n        require(\n            input.destinationBlockchainID != bytes32(0),\n            \"TokenRemote: zero destination blockchain ID\"\n        );\n        require(\n            input.destinationTokenTransferrerAddress != address(0),\n            \"TokenRemote: zero destination token transferrer address\"\n        );\n    }",
            "startLine": 682,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_validateSendAndCallInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendAndCallInput(\n        SendAndCallInput calldata input\n    ) private pure {\n        require(\n            input.destinationBlockchainID != bytes32(0),\n            \"TokenRemote: zero destination blockchain ID\"\n        );\n        require(\n            input.destinationTokenTransferrerAddress != address(0),\n            \"TokenRemote: zero destination token transferrer address\"\n        );\n        require(\n            input.recipientContract != address(0), \"TokenRemote: zero recipient contract address\"\n        );\n        require(input.requiredGasLimit > 0, \"TokenRemote: zero required gas limit\");\n        require(input.recipientGasLimit > 0, \"TokenRemote: zero recipient gas limit\");\n        require(\n            input.recipientGasLimit < input.requiredGasLimit,\n            \"TokenRemote: invalid recipient gas limit\"\n        );\n        require(\n            input.fallbackRecipient != address(0), \"TokenRemote: zero fallback recipient address\"\n        );\n    }",
            "startLine": 697,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "__TeleporterRegistryOwnableApp_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "initialOwner",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryApp_init",
                "type": "internal"
              },
              {
                "target": "__Ownable_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TeleporterRegistryOwnableApp_init(\n        address teleporterRegistryAddress,\n        address initialOwner,\n        uint256 minTeleporterVersion\n    ) internal onlyInitializing {\n        __TeleporterRegistryApp_init(teleporterRegistryAddress, minTeleporterVersion);\n        __Ownable_init(initialOwner);\n    }",
            "startLine": 24,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_TeleporterRegistryOwnableApp_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _TeleporterRegistryOwnableApp_init_unchained() internal onlyInitializing {}",
            "startLine": 34,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_checkTeleporterRegistryAppAccess",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_checkOwner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkTeleporterRegistryAppAccess() internal view virtual override {\n        _checkOwner();\n    }",
            "startLine": 42,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_getOwnableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "OwnableStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }",
            "startLine": 30,
            "visibility": "private",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__Ownable_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }",
            "startLine": 51,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }",
            "startLine": 55,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }",
            "startLine": 81,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "OwnershipTransferred"
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }",
            "startLine": 113,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_getSendReentrancyGuardStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "SendReentrancyGuardStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getSendReentrancyGuardStorage()\n        private\n        pure\n        returns (SendReentrancyGuardStorage storage $)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := _SEND_REENTRANCY_GUARD_STORAGE_LOCATION\n        }\n    }",
            "startLine": 35,
            "visibility": "private",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrancyGuard_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "__SendReentrnacyGuard_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrancyGuard_init() internal onlyInitializing {\n        __SendReentrnacyGuard_init_unchained();\n    }",
            "startLine": 59,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrnacyGuard_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getSendReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrnacyGuard_init_unchained() internal {\n        SendReentrancyGuardStorage storage $ = _getSendReentrancyGuardStorage();\n        $._sendEntered = _NOT_ENTERED;\n    }",
            "startLine": 64,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "NativeTokenRemote",
        "kind": "contract",
        "category": "ictt",
        "filePath": "@ictt/TokenRemote/NativeTokenRemote.sol",
        "inherits": [
          "NativeTokenRemoteUpgradeable"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "NativeTokenRemoteUpgradeable",
            "path": "./NativeTokenRemoteUpgradeable.sol",
            "isExternal": false
          },
          {
            "name": "TokenRemoteSettings",
            "path": "./interfaces/ITokenRemote.sol",
            "isExternal": false
          },
          {
            "name": "ICMInitializable",
            "path": "@utilities/ICMInitializable.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "initialize",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "TokenRemoteSettings"
              },
              {
                "name": "nativeAssetSymbol",
                "type": "string"
              },
              {
                "name": "initialReserveImbalance",
                "type": "uint256"
              },
              {
                "name": "burnedFeesReportingRewardPercentage",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__NativeTokenRemote_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initialize(\n        TokenRemoteSettings memory settings,\n        string memory nativeAssetSymbol,\n        uint256 initialReserveImbalance,\n        uint256 burnedFeesReportingRewardPercentage\n    ) public initializer {\n        __NativeTokenRemote_init(\n            settings,\n            nativeAssetSymbol,\n            initialReserveImbalance,\n            burnedFeesReportingRewardPercentage\n        );\n    }",
            "startLine": 149,
            "signature": "initialize(TokenRemoteSettings,string,uint256,uint256)",
            "selector": "0x502719dc",
            "visibility": "public",
            "modifiers": [
              "initializer"
            ],
            "inheritedFrom": "NativeTokenRemoteUpgradeable"
          },
          {
            "name": "send",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_send",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function send(\n        SendTokensInput calldata input\n    ) external payable onlyWhenCollateralized {\n        _send(input, msg.value);\n    }",
            "startLine": 205,
            "signature": "send(SendTokensInput)",
            "selector": "0x34cc3541",
            "visibility": "external",
            "modifiers": [
              "onlyWhenCollateralized"
            ],
            "inheritedFrom": "NativeTokenRemoteUpgradeable"
          },
          {
            "name": "sendAndCall",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_sendAndCall",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function sendAndCall(\n        SendAndCallInput calldata input\n    ) external payable onlyWhenCollateralized {\n        _sendAndCall(input, msg.value);\n    }",
            "startLine": 214,
            "signature": "sendAndCall(SendAndCallInput)",
            "selector": "0x4b1f7c2f",
            "visibility": "external",
            "modifiers": [
              "onlyWhenCollateralized"
            ],
            "inheritedFrom": "NativeTokenRemoteUpgradeable"
          },
          {
            "name": "reportBurnedTxFees",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "requiredGasLimit",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getNativeTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_mintNativeCoin",
                "type": "internal"
              },
              {
                "target": "_mint",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              },
              {
                "target": "getTokenMultiplier",
                "type": "internal"
              },
              {
                "target": "getMultiplyOnRemote",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              },
              {
                "target": "getTokenHomeBlockchainID",
                "type": "internal"
              },
              {
                "target": "getTokenHomeAddress",
                "type": "internal"
              }
            ],
            "emits": [
              "ReportBurnedTxFees"
            ],
            "isVirtual": false,
            "sourceCode": "function reportBurnedTxFees(\n        uint256 requiredGasLimit\n    ) external sendNonReentrant {\n        NativeTokenRemoteStorage storage $ = _getNativeTokenRemoteStorage();\n        uint256 burnAddressBalance = BURNED_TX_FEES_ADDRESS.balance;\n        require(\n            burnAddressBalance > $._lastestBurnedFeesReported,\n            \"NativeTokenRemote: burn address balance not greater than last report\"\n        );\n\n        uint256 burnedDifference = burnAddressBalance - $._lastestBurnedFeesReported;\n        uint256 reward = (burnedDifference * $._burnedFeesReportingRewardPercentage) / 100;\n        uint256 burnedTxFees = burnedDifference - reward;\n        $._lastestBurnedFeesReported = burnAddressBalance;\n\n        if (reward > 0) {\n            // Re-mint the native tokens to this contract, and then deposit them to be the wrapped\n            // native token (ERC20) representation, such that they can be used as a Teleporter\n            // message fee.\n            _mintNativeCoin(address(this), reward);\n            _mint(address(this), reward);\n        }\n\n        // Check that the scaled amount on the TokenHome instance will be non-zero.\n        require(\n            TokenScalingUtils.removeTokenScale(\n                getTokenMultiplier(), getMultiplyOnRemote(), burnedTxFees\n            ) > 0,\n            \"NativeTokenRemote: zero scaled amount to report burn\"\n        );\n\n        // Report the burned amount to the TokenHome instance.\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_SEND,\n            payload: abi.encode(\n                SingleHopSendMessage({recipient: HOME_CHAIN_BURN_ADDRESS, amount: burnedTxFees})\n            )\n        });\n\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: getTokenHomeBlockchainID(),\n                destinationAddress: getTokenHomeAddress(),\n                feeInfo: TeleporterFeeInfo({feeTokenAddress: address(this), amount: reward}),\n                requiredGasLimit: requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit ReportBurnedTxFees({teleporterMessageID: messageID, feesBurned: burnedTxFees});\n    }",
            "startLine": 223,
            "signature": "reportBurnedTxFees(uint256)",
            "selector": "0x5c66eddb",
            "visibility": "external",
            "modifiers": [
              "sendNonReentrant"
            ],
            "inheritedFrom": "NativeTokenRemoteUpgradeable"
          },
          {
            "name": "withdraw",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_burn",
                "type": "internal"
              }
            ],
            "emits": [
              "Withdrawal"
            ],
            "isVirtual": false,
            "sourceCode": "function withdraw(\n        uint256 amount\n    ) external {\n        emit Withdrawal(_msgSender(), amount);\n        _burn(_msgSender(), amount);\n        payable(_msgSender()).sendValue(amount);\n    }",
            "startLine": 284,
            "signature": "withdraw(uint256)",
            "selector": "0x279e2aee",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "NativeTokenRemoteUpgradeable"
          },
          {
            "name": "deposit",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_mint",
                "type": "internal"
              }
            ],
            "emits": [
              "Deposit"
            ],
            "isVirtual": false,
            "sourceCode": "function deposit() public payable {\n        emit Deposit(_msgSender(), msg.value);\n        _mint(_msgSender(), msg.value);\n    }",
            "startLine": 295,
            "signature": "deposit()",
            "selector": "0x30c413e1",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "NativeTokenRemoteUpgradeable"
          },
          {
            "name": "totalNativeAssetSupply",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getNativeTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "getInitialReserveImbalance",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function totalNativeAssetSupply() public view returns (uint256) {\n        NativeTokenRemoteStorage storage $ = _getNativeTokenRemoteStorage();\n        uint256 burned = BURNED_TX_FEES_ADDRESS.balance + BURNED_FOR_TRANSFER_ADDRESS.balance;\n        uint256 created = $._totalMinted + getInitialReserveImbalance();\n        return created - burned;\n    }",
            "startLine": 311,
            "signature": "totalNativeAssetSupply()",
            "selector": "0x5ad4777b",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "NativeTokenRemoteUpgradeable"
          },
          {
            "name": "getTotalMinted",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getNativeTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTotalMinted() external view returns (uint256) {\n        return _getNativeTokenRemoteStorage()._totalMinted;\n    }",
            "startLine": 318,
            "signature": "getTotalMinted()",
            "selector": "0x6e8900f0",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "NativeTokenRemoteUpgradeable"
          },
          {
            "name": "name",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }",
            "startLine": 70,
            "signature": "name()",
            "selector": "0x3ec0f734",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "symbol",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }",
            "startLine": 79,
            "signature": "symbol()",
            "selector": "0x6a927499",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "decimals",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function decimals() public view virtual returns (uint8) {\n        return 18;\n    }",
            "startLine": 97,
            "signature": "decimals()",
            "selector": "0x76436c3d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "totalSupply",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }",
            "startLine": 102,
            "signature": "totalSupply()",
            "selector": "0x6190166c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "balanceOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }",
            "startLine": 108,
            "signature": "balanceOf(address)",
            "selector": "0x7d2b9996",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }",
            "startLine": 121,
            "signature": "transfer(address,uint256)",
            "selector": "0x59d228e5",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "allowance",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }",
            "startLine": 128,
            "signature": "allowance(address,address)",
            "selector": "0x596dd87d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }",
            "startLine": 143,
            "signature": "approve(address,uint256)",
            "selector": "0x1d38323d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "transferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_spendAllowance",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }",
            "startLine": 165,
            "signature": "transferFrom(address,address,uint256)",
            "selector": "0x447f286d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "registerWithHome",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "feeInfo",
                "type": "TeleporterFeeInfo"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_handleFees",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function registerWithHome(\n        TeleporterFeeInfo calldata feeInfo\n    ) external virtual {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        require(!$._isRegistered, \"TokenRemote: already registered\");\n\n        // Send a message to the token TokenHome instance to register this TokenRemote instance.\n        RegisterRemoteMessage memory registerMessage = RegisterRemoteMessage({\n            initialReserveImbalance: $._initialReserveImbalance,\n            homeTokenDecimals: $._homeTokenDecimals,\n            remoteTokenDecimals: $._tokenDecimals\n        });\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.REGISTER_REMOTE,\n            payload: abi.encode(registerMessage)\n        });\n\n        uint256 feeAmount = _handleFees(feeInfo.feeTokenAddress, feeInfo.amount);\n        _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({feeTokenAddress: feeInfo.feeTokenAddress, amount: feeAmount}),\n                requiredGasLimit: REGISTER_REMOTE_REQUIRED_GAS,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n    }",
            "startLine": 206,
            "signature": "registerWithHome(TeleporterFeeInfo)",
            "selector": "0x5535b6b3",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "calculateNumWords",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "payloadSize",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function calculateNumWords(\n        uint256 payloadSize\n    ) public pure returns (uint256) {\n        // Add 31 to effectively round up to the nearest multiple of 32.\n        // Right-shift by 5 bits to divide by 32.\n        return (payloadSize + 31) >> 5;\n    }",
            "startLine": 240,
            "signature": "calculateNumWords(uint256)",
            "selector": "0x5a673771",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getIsCollateralized",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getIsCollateralized() public view returns (bool) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._isCollateralized;\n    }",
            "startLine": 248,
            "signature": "getIsCollateralized()",
            "selector": "0x0892f6c8",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getTokenMultiplier",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenMultiplier() public view returns (uint256) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._tokenMultiplier;\n    }",
            "startLine": 253,
            "signature": "getTokenMultiplier()",
            "selector": "0x10c6819b",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getMultiplyOnRemote",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getMultiplyOnRemote() public view returns (bool) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._multiplyOnRemote;\n    }",
            "startLine": 258,
            "signature": "getMultiplyOnRemote()",
            "selector": "0x1dc0ae00",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getTokenHomeBlockchainID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenHomeBlockchainID() public view returns (bytes32) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._tokenHomeBlockchainID;\n    }",
            "startLine": 263,
            "signature": "getTokenHomeBlockchainID()",
            "selector": "0x480733ee",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getTokenHomeAddress",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenHomeAddress() public view returns (address) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._tokenHomeAddress;\n    }",
            "startLine": 268,
            "signature": "getTokenHomeAddress()",
            "selector": "0x3b3fc1ad",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getInitialReserveImbalance",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getInitialReserveImbalance() public view returns (uint256) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._initialReserveImbalance;\n    }",
            "startLine": 273,
            "signature": "getInitialReserveImbalance()",
            "selector": "0x1bdb1d8b",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getBlockchainID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getBlockchainID() public view returns (bytes32) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._blockchainID;\n    }",
            "startLine": 278,
            "signature": "getBlockchainID()",
            "selector": "0x587a98a6",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }",
            "startLine": 73,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "renounceOwnership",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
            "startLine": 94,
            "signature": "renounceOwnership()",
            "selector": "0x765becbf",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }",
            "startLine": 102,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          }
        ],
        "internalFunctions": [
          {
            "name": "_getNativeTokenRemoteStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "NativeTokenRemoteStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getNativeTokenRemoteStorage()\n        private\n        pure\n        returns (NativeTokenRemoteStorage storage $)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := NATIVE_TOKEN_REMOTE_STORAGE_LOCATION\n        }\n    }",
            "startLine": 78,
            "visibility": "private",
            "inheritedFrom": "NativeTokenRemoteUpgradeable"
          },
          {
            "name": "__NativeTokenRemote_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "TokenRemoteSettings"
              },
              {
                "name": "nativeAssetSymbol",
                "type": "string"
              },
              {
                "name": "initialReserveImbalance",
                "type": "uint256"
              },
              {
                "name": "burnedFeesReportingRewardPercentage",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ERC20_init",
                "type": "internal"
              },
              {
                "target": "__TokenRemote_init",
                "type": "internal"
              },
              {
                "target": "__NativeTokenRemote_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __NativeTokenRemote_init(\n        TokenRemoteSettings memory settings,\n        string memory nativeAssetSymbol,\n        uint256 initialReserveImbalance,\n        uint256 burnedFeesReportingRewardPercentage\n    ) internal onlyInitializing {\n        require(initialReserveImbalance != 0, \"NativeTokenRemote: zero initial reserve imbalance\");\n        __ERC20_init(nativeAssetSymbol, nativeAssetSymbol);\n        __TokenRemote_init(settings, initialReserveImbalance, 18);\n        __NativeTokenRemote_init_unchained(burnedFeesReportingRewardPercentage);\n    }",
            "startLine": 164,
            "visibility": "internal",
            "inheritedFrom": "NativeTokenRemoteUpgradeable"
          },
          {
            "name": "__NativeTokenRemote_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "burnedFeesReportingRewardPercentage",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getNativeTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __NativeTokenRemote_init_unchained(\n        uint256 burnedFeesReportingRewardPercentage\n    ) internal onlyInitializing {\n        require(burnedFeesReportingRewardPercentage < 100, \"NativeTokenRemote: invalid percentage\");\n        _getNativeTokenRemoteStorage()._burnedFeesReportingRewardPercentage =\n            burnedFeesReportingRewardPercentage;\n    }",
            "startLine": 177,
            "visibility": "internal",
            "inheritedFrom": "NativeTokenRemoteUpgradeable"
          },
          {
            "name": "_withdraw",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "recipient",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_mintNativeCoin",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensWithdrawn"
            ],
            "isVirtual": true,
            "sourceCode": "function _withdraw(address recipient, uint256 amount) internal virtual override {\n        emit TokensWithdrawn(recipient, amount);\n        _mintNativeCoin(recipient, amount);\n    }",
            "startLine": 325,
            "visibility": "internal",
            "inheritedFrom": "NativeTokenRemoteUpgradeable"
          },
          {
            "name": "_burn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _burn(\n        uint256 amount\n    ) internal virtual override returns (uint256) {\n        payable(BURNED_FOR_TRANSFER_ADDRESS).sendValue(amount);\n        return amount;\n    }",
            "startLine": 337,
            "visibility": "internal",
            "inheritedFrom": "NativeTokenRemoteUpgradeable"
          },
          {
            "name": "_handleSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "message",
                "type": "SingleHopCallMessage"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_mintNativeCoin",
                "type": "internal"
              },
              {
                "target": "CallUtils._callWithExactGasAndValue",
                "type": "library"
              }
            ],
            "emits": [
              "CallSucceeded",
              "CallFailed"
            ],
            "isVirtual": true,
            "sourceCode": "function _handleSendAndCall(\n        SingleHopCallMessage memory message,\n        uint256 amount\n    ) internal virtual override {\n        // Mint the tokens to this contract address.\n        _mintNativeCoin(address(this), amount);\n\n        // Encode the call to {INativeSendAndCallReceiver-receiveTokens}\n        bytes memory payload = abi.encodeCall(\n            INativeSendAndCallReceiver.receiveTokens,\n            (\n                message.sourceBlockchainID,\n                message.originTokenTransferrerAddress,\n                message.originSenderAddress,\n                message.recipientPayload\n            )\n        );\n\n        // Call the recipient contract with the given payload, gas amount, and value.\n        bool success = CallUtils._callWithExactGasAndValue(\n            message.recipientGasLimit, amount, message.recipientContract, payload\n        );\n\n        // If the call failed, send the funds to the fallback recipient.\n        if (success) {\n            emit CallSucceeded(message.recipientContract, amount);\n        } else {\n            emit CallFailed(message.recipientContract, amount);\n            payable(message.fallbackRecipient).sendValue(amount);\n        }\n    }",
            "startLine": 355,
            "visibility": "internal",
            "inheritedFrom": "NativeTokenRemoteUpgradeable"
          },
          {
            "name": "_handleFees",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "feeTokenAddress",
                "type": "address"
              },
              {
                "name": "feeAmount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_spendAllowance",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              },
              {
                "target": "SafeERC20TransferFrom.safeTransferFrom",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _handleFees(\n        address feeTokenAddress,\n        uint256 feeAmount\n    ) internal virtual override returns (uint256) {\n        if (feeAmount == 0) {\n            return 0;\n        }\n        // If the {feeTokenAddress} is this contract, then just deposit the tokens directly.\n        if (feeTokenAddress == address(this)) {\n            _spendAllowance(_msgSender(), address(this), feeAmount);\n            _transfer(_msgSender(), address(this), feeAmount);\n            return feeAmount;\n        }\n        return\n            SafeERC20TransferFrom.safeTransferFrom(IERC20(feeTokenAddress), _msgSender(), feeAmount);\n    }",
            "startLine": 394,
            "visibility": "internal",
            "inheritedFrom": "NativeTokenRemoteUpgradeable"
          },
          {
            "name": "_mintNativeCoin",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "recipient",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getNativeTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "NATIVE_MINTER.mintNativeCoin",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _mintNativeCoin(address recipient, uint256 amount) private {\n        NativeTokenRemoteStorage storage $ = _getNativeTokenRemoteStorage();\n        $._totalMinted += amount;\n        // Calls NativeMinter precompile through INativeMinter interface.\n        NATIVE_MINTER.mintNativeCoin(recipient, amount);\n    }",
            "startLine": 414,
            "visibility": "private",
            "inheritedFrom": "NativeTokenRemoteUpgradeable"
          },
          {
            "name": "_getERC20Storage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC20Storage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }",
            "startLine": 46,
            "visibility": "private",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "__ERC20_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name_",
                "type": "string"
              },
              {
                "name": "symbol_",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ERC20_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }",
            "startLine": 57,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "__ERC20_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name_",
                "type": "string"
              },
              {
                "name": "symbol_",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }",
            "startLine": 61,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }",
            "startLine": 182,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_update",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [
              "Transfer"
            ],
            "isVirtual": true,
            "sourceCode": "function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
            "startLine": 199,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_mint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }",
            "startLine": 238,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }",
            "startLine": 275,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_spendAllowance",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "allowance",
                "type": "internal"
              },
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }",
            "startLine": 319,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getTokenRemoteStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "TokenRemoteStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getTokenRemoteStorage() private pure returns (TokenRemoteStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := TOKEN_REMOTE_STORAGE_LOCATION\n        }\n    }",
            "startLine": 108,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "__TokenRemote_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "TokenRemoteSettings"
              },
              {
                "name": "initialReserveImbalance_",
                "type": "uint256"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryOwnableApp_init",
                "type": "internal"
              },
              {
                "target": "__SendReentrancyGuard_init",
                "type": "internal"
              },
              {
                "target": "__TokenRemote_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TokenRemote_init(\n        TokenRemoteSettings memory settings,\n        uint256 initialReserveImbalance_,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        __TeleporterRegistryOwnableApp_init(\n            settings.teleporterRegistryAddress,\n            settings.teleporterManager,\n            settings.minTeleporterVersion\n        );\n        __SendReentrancyGuard_init();\n        __TokenRemote_init_unchained(settings, initialReserveImbalance_, tokenDecimals);\n    }",
            "startLine": 150,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "__TokenRemote_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "TokenRemoteSettings"
              },
              {
                "name": "initialReserveImbalance_",
                "type": "uint256"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.deriveTokenMultiplierValues",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TokenRemote_init_unchained(\n        TokenRemoteSettings memory settings,\n        uint256 initialReserveImbalance_,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        $._blockchainID =\n            IWarpMessenger(0x0200000000000000000000000000000000000005).getBlockchainID();\n        require(\n            settings.tokenHomeBlockchainID != bytes32(0),\n            \"TokenRemote: zero token home blockchain ID\"\n        );\n        require(\n            settings.tokenHomeBlockchainID != $._blockchainID,\n            \"TokenRemote: cannot deploy to same blockchain as token home\"\n        );\n        require(settings.tokenHomeAddress != address(0), \"TokenRemote: zero token home address\");\n        require(\n            settings.tokenHomeDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenRemote: token home decimals too high\"\n        );\n        require(\n            tokenDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenRemote: token decimals too high\"\n        );\n        $._tokenHomeBlockchainID = settings.tokenHomeBlockchainID;\n        $._tokenHomeAddress = settings.tokenHomeAddress;\n        $._initialReserveImbalance = initialReserveImbalance_;\n        $._isCollateralized = initialReserveImbalance_ == 0;\n        $._homeTokenDecimals = settings.tokenHomeDecimals;\n        $._tokenDecimals = tokenDecimals;\n        ($._tokenMultiplier, $._multiplyOnRemote) =\n            TokenScalingUtils.deriveTokenMultiplierValues(settings.tokenHomeDecimals, tokenDecimals);\n    }",
            "startLine": 165,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_send",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSendTokensInput",
                "type": "internal"
              },
              {
                "target": "_processSend",
                "type": "internal"
              },
              {
                "target": "_processSendMultiHop",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _send(SendTokensInput calldata input, uint256 amount) internal sendNonReentrant {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSendTokensInput(input);\n        if (input.destinationBlockchainID == $._tokenHomeBlockchainID) {\n            _processSend(input, amount);\n        } else {\n            _processSendMultiHop(input, amount);\n        }\n    }",
            "startLine": 290,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_sendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSendAndCallInput",
                "type": "internal"
              },
              {
                "target": "_processSendAndCall",
                "type": "internal"
              },
              {
                "target": "_processSendAndCallMultiHop",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _sendAndCall(\n        SendAndCallInput calldata input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSendAndCallInput(input);\n\n        if (input.destinationBlockchainID == $._tokenHomeBlockchainID) {\n            return _processSendAndCall(input, amount);\n        } else {\n            return _processSendAndCallMultiHop(input, amount);\n        }\n    }",
            "startLine": 308,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_receiveTeleporterMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "message",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_handleSendAndCall",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _receiveTeleporterMessage(\n        bytes32 sourceBlockchainID,\n        address originSenderAddress,\n        bytes memory message\n    ) internal override {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        require(\n            sourceBlockchainID == $._tokenHomeBlockchainID,\n            \"TokenRemote: invalid source blockchain ID\"\n        );\n        require(\n            originSenderAddress == $._tokenHomeAddress, \"TokenRemote: invalid origin sender address\"\n        );\n        TransferrerMessage memory transferrerMessage = abi.decode(message, (TransferrerMessage));\n\n        // If the contract was not previously known to be registered or collateralized, it is now given that\n        // the home has sent a message to mint funds.\n        if (!$._isRegistered || !$._isCollateralized) {\n            $._isRegistered = true;\n            $._isCollateralized = true;\n        }\n\n        // Remote contracts should only ever receive single-hop messages because\n        // multi-hop messages are always routed through the home contract.\n        if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_SEND) {\n            SingleHopSendMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopSendMessage));\n            _withdraw(payload.recipient, payload.amount);\n        } else if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_CALL) {\n            // The {sourceBlockchainID}, and {originSenderAddress} specified in the message\n            // payload will not match the sender of this Teleporter message in the case of a\n            // multi-hop message. Since Teleporter messages are only received from the specified\n            // token TokenHome instance, no additional authentication is needed on the payload values.\n            SingleHopCallMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopCallMessage));\n            _handleSendAndCall(payload, payload.amount);\n        } else {\n            revert(\"TokenRemote: invalid message type\");\n        }\n    }",
            "startLine": 328,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_prepareSend",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "primaryFeeTokenAddress",
                "type": "address"
              },
              {
                "name": "primaryFee",
                "type": "uint256"
              },
              {
                "name": "secondaryFee",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_burn",
                "type": "internal"
              },
              {
                "target": "_handleFees",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _prepareSend(\n        uint256 amount,\n        address primaryFeeTokenAddress,\n        uint256 primaryFee,\n        uint256 secondaryFee\n    ) private returns (uint256, uint256) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n\n        // Burn the amount of tokens that will be transferred.\n        amount = _burn(amount);\n\n        // Transfer the primary fee to pay for fees on the first hop.\n        // The user can specify this contract as {primaryFeeTokenAddress},\n        // in which case the fee will be paid on top of the transferred amount.\n        primaryFee = _handleFees(primaryFeeTokenAddress, primaryFee);\n\n        // The transferred amount must cover the secondary fee, because the secondary fee\n        // is directly subtracted from the transferred amount on the intermediate (home) chain\n        // performing the multi-hop, before forwarding to the final destination TokenRemote instance.\n        require(\n            TokenScalingUtils.removeTokenScale($._tokenMultiplier, $._multiplyOnRemote, amount)\n                > TokenScalingUtils.removeTokenScale(\n                    $._tokenMultiplier, $._multiplyOnRemote, secondaryFee\n                ),\n            \"TokenRemote: insufficient tokens to transfer\"\n        );\n\n        // Return the amount in this contract's local denomination and the primary fee.\n        return (amount, primaryFee);\n    }",
            "startLine": 414,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_processSend",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSingleHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSend(SendTokensInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSingleHopInput(\n            input.destinationTokenTransferrerAddress, input.secondaryFee, input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_SEND,\n            payload: abi.encode(SingleHopSendMessage({recipient: input.recipient, amount: amount}))\n        });\n\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 448,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_processSendMultiHop",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateMultiHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSendMultiHop(SendTokensInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateMultiHopInput(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.MULTI_HOP_SEND,\n            payload: abi.encode(\n                MultiHopSendMessage({\n                    destinationBlockchainID: input.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n                    recipient: input.recipient,\n                    amount: amount,\n                    secondaryFee: input.secondaryFee,\n                    secondaryGasLimit: input.requiredGasLimit,\n                    multiHopFallback: input.multiHopFallback\n                })\n            )\n        });\n\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: MULTI_HOP_SEND_REQUIRED_GAS,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 487,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_processSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSingleHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSendAndCall(SendAndCallInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSingleHopInput(\n            input.destinationTokenTransferrerAddress, input.secondaryFee, input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_CALL,\n            payload: abi.encode(\n                SingleHopCallMessage({\n                    sourceBlockchainID: $._blockchainID,\n                    originTokenTransferrerAddress: address(this),\n                    originSenderAddress: _msgSender(),\n                    recipientContract: input.recipientContract,\n                    amount: amount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient\n                })\n            )\n        });\n\n        // Send message to the token TokenHome instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 539,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_processSendAndCallMultiHop",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateMultiHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "calculateNumWords",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSendAndCallMultiHop(SendAndCallInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateMultiHopInput(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.MULTI_HOP_CALL,\n            payload: abi.encode(\n                MultiHopCallMessage({\n                    originSenderAddress: _msgSender(),\n                    destinationBlockchainID: input.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n                    recipientContract: input.recipientContract,\n                    amount: amount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient,\n                    multiHopFallback: input.multiHopFallback,\n                    secondaryRequiredGasLimit: input.requiredGasLimit,\n                    secondaryFee: input.secondaryFee\n                })\n            )\n        });\n\n        // The required gas limit for the first message sent back to the TokenHome instance\n        // needs to account for the number of words in the payload. Each word uses additional\n        // gas to include in the message to the final destination chain.\n        uint256 messageRequiredGasLimit = MULTI_HOP_CALL_REQUIRED_GAS\n            + (calculateNumWords(input.recipientPayload.length) * MULTI_HOP_CALL_GAS_PER_WORD);\n\n        // Send message to the token TokenHome instance\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: messageRequiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 591,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_validateSingleHopInput",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "destinationTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "secondaryFee",
                "type": "uint256"
              },
              {
                "name": "multiHopFallback",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSingleHopInput(\n        address destinationTokenTransferrerAddress,\n        uint256 secondaryFee,\n        address multiHopFallback\n    ) private view {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        require(\n            destinationTokenTransferrerAddress == $._tokenHomeAddress,\n            \"TokenRemote: invalid destination token transferrer address\"\n        );\n        require(secondaryFee == 0, \"TokenRemote: non-zero secondary fee\");\n        require(multiHopFallback == address(0), \"TokenRemote: non-zero multi-hop fallback\");\n    }",
            "startLine": 650,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_validateMultiHopInput",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "destinationBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "destinationTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "multiHopFallback",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateMultiHopInput(\n        bytes32 destinationBlockchainID,\n        address destinationTokenTransferrerAddress,\n        address multiHopFallback\n    ) private view {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        // If the destination blockchain ID is this blockchain, the destination\n        // token transferrer address must be a different contract. This is a multi-hop case to\n        // a different token transfer contract on this chain.\n        if (destinationBlockchainID == $._blockchainID) {\n            require(\n                destinationTokenTransferrerAddress != address(this),\n                \"TokenRemote: invalid destination token transferrer address\"\n            );\n        }\n        require(multiHopFallback != address(0), \"TokenRemote: zero multi-hop fallback\");\n    }",
            "startLine": 664,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_validateSendTokensInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendTokensInput(\n        SendTokensInput calldata input\n    ) private pure {\n        require(input.recipient != address(0), \"TokenRemote: zero recipient address\");\n        require(input.requiredGasLimit > 0, \"TokenRemote: zero required gas limit\");\n        require(\n            input.destinationBlockchainID != bytes32(0),\n            \"TokenRemote: zero destination blockchain ID\"\n        );\n        require(\n            input.destinationTokenTransferrerAddress != address(0),\n            \"TokenRemote: zero destination token transferrer address\"\n        );\n    }",
            "startLine": 682,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_validateSendAndCallInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendAndCallInput(\n        SendAndCallInput calldata input\n    ) private pure {\n        require(\n            input.destinationBlockchainID != bytes32(0),\n            \"TokenRemote: zero destination blockchain ID\"\n        );\n        require(\n            input.destinationTokenTransferrerAddress != address(0),\n            \"TokenRemote: zero destination token transferrer address\"\n        );\n        require(\n            input.recipientContract != address(0), \"TokenRemote: zero recipient contract address\"\n        );\n        require(input.requiredGasLimit > 0, \"TokenRemote: zero required gas limit\");\n        require(input.recipientGasLimit > 0, \"TokenRemote: zero recipient gas limit\");\n        require(\n            input.recipientGasLimit < input.requiredGasLimit,\n            \"TokenRemote: invalid recipient gas limit\"\n        );\n        require(\n            input.fallbackRecipient != address(0), \"TokenRemote: zero fallback recipient address\"\n        );\n    }",
            "startLine": 697,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "__TeleporterRegistryOwnableApp_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "initialOwner",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryApp_init",
                "type": "internal"
              },
              {
                "target": "__Ownable_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TeleporterRegistryOwnableApp_init(\n        address teleporterRegistryAddress,\n        address initialOwner,\n        uint256 minTeleporterVersion\n    ) internal onlyInitializing {\n        __TeleporterRegistryApp_init(teleporterRegistryAddress, minTeleporterVersion);\n        __Ownable_init(initialOwner);\n    }",
            "startLine": 24,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_TeleporterRegistryOwnableApp_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _TeleporterRegistryOwnableApp_init_unchained() internal onlyInitializing {}",
            "startLine": 34,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_checkTeleporterRegistryAppAccess",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_checkOwner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkTeleporterRegistryAppAccess() internal view virtual override {\n        _checkOwner();\n    }",
            "startLine": 42,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_getOwnableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "OwnableStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }",
            "startLine": 30,
            "visibility": "private",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__Ownable_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }",
            "startLine": 51,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }",
            "startLine": 55,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }",
            "startLine": 81,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "OwnershipTransferred"
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }",
            "startLine": 113,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_getSendReentrancyGuardStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "SendReentrancyGuardStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getSendReentrancyGuardStorage()\n        private\n        pure\n        returns (SendReentrancyGuardStorage storage $)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := _SEND_REENTRANCY_GUARD_STORAGE_LOCATION\n        }\n    }",
            "startLine": 35,
            "visibility": "private",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrancyGuard_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "__SendReentrnacyGuard_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrancyGuard_init() internal onlyInitializing {\n        __SendReentrnacyGuard_init_unchained();\n    }",
            "startLine": 59,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrnacyGuard_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getSendReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrnacyGuard_init_unchained() internal {\n        SendReentrancyGuardStorage storage $ = _getSendReentrancyGuardStorage();\n        $._sendEntered = _NOT_ENTERED;\n    }",
            "startLine": 64,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "NativeTokenRemoteUpgradeable",
        "kind": "contract",
        "category": "ictt",
        "filePath": "@ictt/TokenRemote/NativeTokenRemoteUpgradeable.sol",
        "inherits": [
          "ERC20Upgradeable",
          "TokenRemote"
        ],
        "implements": [
          "INativeTokenRemote",
          "IWrappedNativeToken"
        ],
        "usesLibraries": [
          "Address"
        ],
        "imports": [
          {
            "name": "TokenRemote",
            "path": "./TokenRemote.sol",
            "isExternal": false
          },
          {
            "name": "TokenRemoteSettings",
            "path": "./interfaces/ITokenRemote.sol",
            "isExternal": false
          },
          {
            "name": "INativeTokenRemote",
            "path": "./interfaces/INativeTokenRemote.sol",
            "isExternal": false
          },
          {
            "name": "INativeSendAndCallReceiver",
            "path": "../interfaces/INativeSendAndCallReceiver.sol",
            "isExternal": false
          },
          {
            "name": "IWrappedNativeToken",
            "path": "../interfaces/IWrappedNativeToken.sol",
            "isExternal": false
          },
          {
            "name": "SendTokensInput",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SendAndCallInput",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "TransferrerMessageType",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "TransferrerMessage",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SingleHopSendMessage",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SingleHopCallMessage",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "TeleporterFeeInfo",
            "path": "@teleporter/ITeleporterMessenger.sol",
            "isExternal": true
          },
          {
            "name": "TeleporterMessageInput",
            "path": "@teleporter/ITeleporterMessenger.sol",
            "isExternal": true
          },
          {
            "name": "INativeMinter",
            "path": "@subnet-evm/INativeMinter.sol",
            "isExternal": true
          },
          {
            "name": "IERC20",
            "path": "@openzeppelin/contracts@5.0.2/token/ERC20/ERC20.sol",
            "isExternal": true
          },
          {
            "name": "ERC20Upgradeable",
            "path": "@openzeppelin/contracts-upgradeable@5.0.2/token/ERC20/ERC20Upgradeable.sol",
            "isExternal": true
          },
          {
            "name": "Address",
            "path": "@openzeppelin/contracts@5.0.2/utils/Address.sol",
            "isExternal": true
          },
          {
            "name": "CallUtils",
            "path": "@utilities/CallUtils.sol",
            "isExternal": true
          },
          {
            "name": "TokenScalingUtils",
            "path": "@utilities/TokenScalingUtils.sol",
            "isExternal": true
          },
          {
            "name": "SafeERC20TransferFrom",
            "path": "@utilities/SafeERC20TransferFrom.sol",
            "isExternal": true
          },
          {
            "name": "ICMInitializable",
            "path": "@utilities/ICMInitializable.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "initialize",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "TokenRemoteSettings"
              },
              {
                "name": "nativeAssetSymbol",
                "type": "string"
              },
              {
                "name": "initialReserveImbalance",
                "type": "uint256"
              },
              {
                "name": "burnedFeesReportingRewardPercentage",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__NativeTokenRemote_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function initialize(\n        TokenRemoteSettings memory settings,\n        string memory nativeAssetSymbol,\n        uint256 initialReserveImbalance,\n        uint256 burnedFeesReportingRewardPercentage\n    ) public initializer {\n        __NativeTokenRemote_init(\n            settings,\n            nativeAssetSymbol,\n            initialReserveImbalance,\n            burnedFeesReportingRewardPercentage\n        );\n    }",
            "startLine": 149,
            "signature": "initialize(TokenRemoteSettings,string,uint256,uint256)",
            "selector": "0x502719dc",
            "visibility": "public",
            "modifiers": [
              "initializer"
            ]
          },
          {
            "name": "send",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_send",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function send(\n        SendTokensInput calldata input\n    ) external payable onlyWhenCollateralized {\n        _send(input, msg.value);\n    }",
            "startLine": 205,
            "signature": "send(SendTokensInput)",
            "selector": "0x34cc3541",
            "visibility": "external",
            "modifiers": [
              "onlyWhenCollateralized"
            ]
          },
          {
            "name": "sendAndCall",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_sendAndCall",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function sendAndCall(\n        SendAndCallInput calldata input\n    ) external payable onlyWhenCollateralized {\n        _sendAndCall(input, msg.value);\n    }",
            "startLine": 214,
            "signature": "sendAndCall(SendAndCallInput)",
            "selector": "0x4b1f7c2f",
            "visibility": "external",
            "modifiers": [
              "onlyWhenCollateralized"
            ]
          },
          {
            "name": "reportBurnedTxFees",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "requiredGasLimit",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getNativeTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_mintNativeCoin",
                "type": "internal"
              },
              {
                "target": "_mint",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              },
              {
                "target": "getTokenMultiplier",
                "type": "internal"
              },
              {
                "target": "getMultiplyOnRemote",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              },
              {
                "target": "getTokenHomeBlockchainID",
                "type": "internal"
              },
              {
                "target": "getTokenHomeAddress",
                "type": "internal"
              }
            ],
            "emits": [
              "ReportBurnedTxFees"
            ],
            "isVirtual": false,
            "sourceCode": "function reportBurnedTxFees(\n        uint256 requiredGasLimit\n    ) external sendNonReentrant {\n        NativeTokenRemoteStorage storage $ = _getNativeTokenRemoteStorage();\n        uint256 burnAddressBalance = BURNED_TX_FEES_ADDRESS.balance;\n        require(\n            burnAddressBalance > $._lastestBurnedFeesReported,\n            \"NativeTokenRemote: burn address balance not greater than last report\"\n        );\n\n        uint256 burnedDifference = burnAddressBalance - $._lastestBurnedFeesReported;\n        uint256 reward = (burnedDifference * $._burnedFeesReportingRewardPercentage) / 100;\n        uint256 burnedTxFees = burnedDifference - reward;\n        $._lastestBurnedFeesReported = burnAddressBalance;\n\n        if (reward > 0) {\n            // Re-mint the native tokens to this contract, and then deposit them to be the wrapped\n            // native token (ERC20) representation, such that they can be used as a Teleporter\n            // message fee.\n            _mintNativeCoin(address(this), reward);\n            _mint(address(this), reward);\n        }\n\n        // Check that the scaled amount on the TokenHome instance will be non-zero.\n        require(\n            TokenScalingUtils.removeTokenScale(\n                getTokenMultiplier(), getMultiplyOnRemote(), burnedTxFees\n            ) > 0,\n            \"NativeTokenRemote: zero scaled amount to report burn\"\n        );\n\n        // Report the burned amount to the TokenHome instance.\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_SEND,\n            payload: abi.encode(\n                SingleHopSendMessage({recipient: HOME_CHAIN_BURN_ADDRESS, amount: burnedTxFees})\n            )\n        });\n\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: getTokenHomeBlockchainID(),\n                destinationAddress: getTokenHomeAddress(),\n                feeInfo: TeleporterFeeInfo({feeTokenAddress: address(this), amount: reward}),\n                requiredGasLimit: requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit ReportBurnedTxFees({teleporterMessageID: messageID, feesBurned: burnedTxFees});\n    }",
            "startLine": 223,
            "signature": "reportBurnedTxFees(uint256)",
            "selector": "0x5c66eddb",
            "visibility": "external",
            "modifiers": [
              "sendNonReentrant"
            ]
          },
          {
            "name": "withdraw",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_burn",
                "type": "internal"
              }
            ],
            "emits": [
              "Withdrawal"
            ],
            "isVirtual": false,
            "sourceCode": "function withdraw(\n        uint256 amount\n    ) external {\n        emit Withdrawal(_msgSender(), amount);\n        _burn(_msgSender(), amount);\n        payable(_msgSender()).sendValue(amount);\n    }",
            "startLine": 284,
            "signature": "withdraw(uint256)",
            "selector": "0x279e2aee",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "deposit",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_mint",
                "type": "internal"
              }
            ],
            "emits": [
              "Deposit"
            ],
            "isVirtual": false,
            "sourceCode": "function deposit() public payable {\n        emit Deposit(_msgSender(), msg.value);\n        _mint(_msgSender(), msg.value);\n    }",
            "startLine": 295,
            "signature": "deposit()",
            "selector": "0x30c413e1",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "totalNativeAssetSupply",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getNativeTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "getInitialReserveImbalance",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function totalNativeAssetSupply() public view returns (uint256) {\n        NativeTokenRemoteStorage storage $ = _getNativeTokenRemoteStorage();\n        uint256 burned = BURNED_TX_FEES_ADDRESS.balance + BURNED_FOR_TRANSFER_ADDRESS.balance;\n        uint256 created = $._totalMinted + getInitialReserveImbalance();\n        return created - burned;\n    }",
            "startLine": 311,
            "signature": "totalNativeAssetSupply()",
            "selector": "0x5ad4777b",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getTotalMinted",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getNativeTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTotalMinted() external view returns (uint256) {\n        return _getNativeTokenRemoteStorage()._totalMinted;\n    }",
            "startLine": 318,
            "signature": "getTotalMinted()",
            "selector": "0x6e8900f0",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "name",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }",
            "startLine": 70,
            "signature": "name()",
            "selector": "0x3ec0f734",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "symbol",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }",
            "startLine": 79,
            "signature": "symbol()",
            "selector": "0x6a927499",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "decimals",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function decimals() public view virtual returns (uint8) {\n        return 18;\n    }",
            "startLine": 97,
            "signature": "decimals()",
            "selector": "0x76436c3d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "totalSupply",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }",
            "startLine": 102,
            "signature": "totalSupply()",
            "selector": "0x6190166c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "balanceOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }",
            "startLine": 108,
            "signature": "balanceOf(address)",
            "selector": "0x7d2b9996",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }",
            "startLine": 121,
            "signature": "transfer(address,uint256)",
            "selector": "0x59d228e5",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "allowance",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }",
            "startLine": 128,
            "signature": "allowance(address,address)",
            "selector": "0x596dd87d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }",
            "startLine": 143,
            "signature": "approve(address,uint256)",
            "selector": "0x1d38323d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "transferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_spendAllowance",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }",
            "startLine": 165,
            "signature": "transferFrom(address,address,uint256)",
            "selector": "0x447f286d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "registerWithHome",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "feeInfo",
                "type": "TeleporterFeeInfo"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_handleFees",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function registerWithHome(\n        TeleporterFeeInfo calldata feeInfo\n    ) external virtual {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        require(!$._isRegistered, \"TokenRemote: already registered\");\n\n        // Send a message to the token TokenHome instance to register this TokenRemote instance.\n        RegisterRemoteMessage memory registerMessage = RegisterRemoteMessage({\n            initialReserveImbalance: $._initialReserveImbalance,\n            homeTokenDecimals: $._homeTokenDecimals,\n            remoteTokenDecimals: $._tokenDecimals\n        });\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.REGISTER_REMOTE,\n            payload: abi.encode(registerMessage)\n        });\n\n        uint256 feeAmount = _handleFees(feeInfo.feeTokenAddress, feeInfo.amount);\n        _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({feeTokenAddress: feeInfo.feeTokenAddress, amount: feeAmount}),\n                requiredGasLimit: REGISTER_REMOTE_REQUIRED_GAS,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n    }",
            "startLine": 206,
            "signature": "registerWithHome(TeleporterFeeInfo)",
            "selector": "0x5535b6b3",
            "visibility": "external",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "calculateNumWords",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "payloadSize",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function calculateNumWords(\n        uint256 payloadSize\n    ) public pure returns (uint256) {\n        // Add 31 to effectively round up to the nearest multiple of 32.\n        // Right-shift by 5 bits to divide by 32.\n        return (payloadSize + 31) >> 5;\n    }",
            "startLine": 240,
            "signature": "calculateNumWords(uint256)",
            "selector": "0x5a673771",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getIsCollateralized",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getIsCollateralized() public view returns (bool) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._isCollateralized;\n    }",
            "startLine": 248,
            "signature": "getIsCollateralized()",
            "selector": "0x0892f6c8",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getTokenMultiplier",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenMultiplier() public view returns (uint256) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._tokenMultiplier;\n    }",
            "startLine": 253,
            "signature": "getTokenMultiplier()",
            "selector": "0x10c6819b",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getMultiplyOnRemote",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getMultiplyOnRemote() public view returns (bool) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._multiplyOnRemote;\n    }",
            "startLine": 258,
            "signature": "getMultiplyOnRemote()",
            "selector": "0x1dc0ae00",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getTokenHomeBlockchainID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenHomeBlockchainID() public view returns (bytes32) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._tokenHomeBlockchainID;\n    }",
            "startLine": 263,
            "signature": "getTokenHomeBlockchainID()",
            "selector": "0x480733ee",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getTokenHomeAddress",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenHomeAddress() public view returns (address) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._tokenHomeAddress;\n    }",
            "startLine": 268,
            "signature": "getTokenHomeAddress()",
            "selector": "0x3b3fc1ad",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getInitialReserveImbalance",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getInitialReserveImbalance() public view returns (uint256) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._initialReserveImbalance;\n    }",
            "startLine": 273,
            "signature": "getInitialReserveImbalance()",
            "selector": "0x1bdb1d8b",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "getBlockchainID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getBlockchainID() public view returns (bytes32) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._blockchainID;\n    }",
            "startLine": 278,
            "signature": "getBlockchainID()",
            "selector": "0x587a98a6",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }",
            "startLine": 73,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "renounceOwnership",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
            "startLine": 94,
            "signature": "renounceOwnership()",
            "selector": "0x765becbf",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }",
            "startLine": 102,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          }
        ],
        "internalFunctions": [
          {
            "name": "_getNativeTokenRemoteStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "NativeTokenRemoteStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getNativeTokenRemoteStorage()\n        private\n        pure\n        returns (NativeTokenRemoteStorage storage $)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := NATIVE_TOKEN_REMOTE_STORAGE_LOCATION\n        }\n    }",
            "startLine": 78,
            "visibility": "private"
          },
          {
            "name": "__NativeTokenRemote_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "TokenRemoteSettings"
              },
              {
                "name": "nativeAssetSymbol",
                "type": "string"
              },
              {
                "name": "initialReserveImbalance",
                "type": "uint256"
              },
              {
                "name": "burnedFeesReportingRewardPercentage",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ERC20_init",
                "type": "internal"
              },
              {
                "target": "__TokenRemote_init",
                "type": "internal"
              },
              {
                "target": "__NativeTokenRemote_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __NativeTokenRemote_init(\n        TokenRemoteSettings memory settings,\n        string memory nativeAssetSymbol,\n        uint256 initialReserveImbalance,\n        uint256 burnedFeesReportingRewardPercentage\n    ) internal onlyInitializing {\n        require(initialReserveImbalance != 0, \"NativeTokenRemote: zero initial reserve imbalance\");\n        __ERC20_init(nativeAssetSymbol, nativeAssetSymbol);\n        __TokenRemote_init(settings, initialReserveImbalance, 18);\n        __NativeTokenRemote_init_unchained(burnedFeesReportingRewardPercentage);\n    }",
            "startLine": 164,
            "visibility": "internal"
          },
          {
            "name": "__NativeTokenRemote_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "burnedFeesReportingRewardPercentage",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getNativeTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __NativeTokenRemote_init_unchained(\n        uint256 burnedFeesReportingRewardPercentage\n    ) internal onlyInitializing {\n        require(burnedFeesReportingRewardPercentage < 100, \"NativeTokenRemote: invalid percentage\");\n        _getNativeTokenRemoteStorage()._burnedFeesReportingRewardPercentage =\n            burnedFeesReportingRewardPercentage;\n    }",
            "startLine": 177,
            "visibility": "internal"
          },
          {
            "name": "_withdraw",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "recipient",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_mintNativeCoin",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensWithdrawn"
            ],
            "isVirtual": true,
            "sourceCode": "function _withdraw(address recipient, uint256 amount) internal virtual override {\n        emit TokensWithdrawn(recipient, amount);\n        _mintNativeCoin(recipient, amount);\n    }",
            "startLine": 325,
            "visibility": "internal"
          },
          {
            "name": "_burn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _burn(\n        uint256 amount\n    ) internal virtual override returns (uint256) {\n        payable(BURNED_FOR_TRANSFER_ADDRESS).sendValue(amount);\n        return amount;\n    }",
            "startLine": 337,
            "visibility": "internal"
          },
          {
            "name": "_handleSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "message",
                "type": "SingleHopCallMessage"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_mintNativeCoin",
                "type": "internal"
              },
              {
                "target": "CallUtils._callWithExactGasAndValue",
                "type": "library"
              }
            ],
            "emits": [
              "CallSucceeded",
              "CallFailed"
            ],
            "isVirtual": true,
            "sourceCode": "function _handleSendAndCall(\n        SingleHopCallMessage memory message,\n        uint256 amount\n    ) internal virtual override {\n        // Mint the tokens to this contract address.\n        _mintNativeCoin(address(this), amount);\n\n        // Encode the call to {INativeSendAndCallReceiver-receiveTokens}\n        bytes memory payload = abi.encodeCall(\n            INativeSendAndCallReceiver.receiveTokens,\n            (\n                message.sourceBlockchainID,\n                message.originTokenTransferrerAddress,\n                message.originSenderAddress,\n                message.recipientPayload\n            )\n        );\n\n        // Call the recipient contract with the given payload, gas amount, and value.\n        bool success = CallUtils._callWithExactGasAndValue(\n            message.recipientGasLimit, amount, message.recipientContract, payload\n        );\n\n        // If the call failed, send the funds to the fallback recipient.\n        if (success) {\n            emit CallSucceeded(message.recipientContract, amount);\n        } else {\n            emit CallFailed(message.recipientContract, amount);\n            payable(message.fallbackRecipient).sendValue(amount);\n        }\n    }",
            "startLine": 355,
            "visibility": "internal"
          },
          {
            "name": "_handleFees",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "feeTokenAddress",
                "type": "address"
              },
              {
                "name": "feeAmount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_spendAllowance",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              },
              {
                "target": "SafeERC20TransferFrom.safeTransferFrom",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _handleFees(\n        address feeTokenAddress,\n        uint256 feeAmount\n    ) internal virtual override returns (uint256) {\n        if (feeAmount == 0) {\n            return 0;\n        }\n        // If the {feeTokenAddress} is this contract, then just deposit the tokens directly.\n        if (feeTokenAddress == address(this)) {\n            _spendAllowance(_msgSender(), address(this), feeAmount);\n            _transfer(_msgSender(), address(this), feeAmount);\n            return feeAmount;\n        }\n        return\n            SafeERC20TransferFrom.safeTransferFrom(IERC20(feeTokenAddress), _msgSender(), feeAmount);\n    }",
            "startLine": 394,
            "visibility": "internal"
          },
          {
            "name": "_mintNativeCoin",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "recipient",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getNativeTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "NATIVE_MINTER.mintNativeCoin",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _mintNativeCoin(address recipient, uint256 amount) private {\n        NativeTokenRemoteStorage storage $ = _getNativeTokenRemoteStorage();\n        $._totalMinted += amount;\n        // Calls NativeMinter precompile through INativeMinter interface.\n        NATIVE_MINTER.mintNativeCoin(recipient, amount);\n    }",
            "startLine": 414,
            "visibility": "private"
          },
          {
            "name": "_getERC20Storage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC20Storage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }",
            "startLine": 46,
            "visibility": "private",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "__ERC20_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name_",
                "type": "string"
              },
              {
                "name": "symbol_",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ERC20_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }",
            "startLine": 57,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "__ERC20_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name_",
                "type": "string"
              },
              {
                "name": "symbol_",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }",
            "startLine": 61,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }",
            "startLine": 182,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_update",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [
              "Transfer"
            ],
            "isVirtual": true,
            "sourceCode": "function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
            "startLine": 199,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_mint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }",
            "startLine": 238,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }",
            "startLine": 275,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_spendAllowance",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "allowance",
                "type": "internal"
              },
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }",
            "startLine": 319,
            "visibility": "internal",
            "inheritedFrom": "ERC20Upgradeable"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getTokenRemoteStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "TokenRemoteStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getTokenRemoteStorage() private pure returns (TokenRemoteStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := TOKEN_REMOTE_STORAGE_LOCATION\n        }\n    }",
            "startLine": 108,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "__TokenRemote_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "TokenRemoteSettings"
              },
              {
                "name": "initialReserveImbalance_",
                "type": "uint256"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryOwnableApp_init",
                "type": "internal"
              },
              {
                "target": "__SendReentrancyGuard_init",
                "type": "internal"
              },
              {
                "target": "__TokenRemote_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TokenRemote_init(\n        TokenRemoteSettings memory settings,\n        uint256 initialReserveImbalance_,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        __TeleporterRegistryOwnableApp_init(\n            settings.teleporterRegistryAddress,\n            settings.teleporterManager,\n            settings.minTeleporterVersion\n        );\n        __SendReentrancyGuard_init();\n        __TokenRemote_init_unchained(settings, initialReserveImbalance_, tokenDecimals);\n    }",
            "startLine": 150,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "__TokenRemote_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "TokenRemoteSettings"
              },
              {
                "name": "initialReserveImbalance_",
                "type": "uint256"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.deriveTokenMultiplierValues",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TokenRemote_init_unchained(\n        TokenRemoteSettings memory settings,\n        uint256 initialReserveImbalance_,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        $._blockchainID =\n            IWarpMessenger(0x0200000000000000000000000000000000000005).getBlockchainID();\n        require(\n            settings.tokenHomeBlockchainID != bytes32(0),\n            \"TokenRemote: zero token home blockchain ID\"\n        );\n        require(\n            settings.tokenHomeBlockchainID != $._blockchainID,\n            \"TokenRemote: cannot deploy to same blockchain as token home\"\n        );\n        require(settings.tokenHomeAddress != address(0), \"TokenRemote: zero token home address\");\n        require(\n            settings.tokenHomeDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenRemote: token home decimals too high\"\n        );\n        require(\n            tokenDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenRemote: token decimals too high\"\n        );\n        $._tokenHomeBlockchainID = settings.tokenHomeBlockchainID;\n        $._tokenHomeAddress = settings.tokenHomeAddress;\n        $._initialReserveImbalance = initialReserveImbalance_;\n        $._isCollateralized = initialReserveImbalance_ == 0;\n        $._homeTokenDecimals = settings.tokenHomeDecimals;\n        $._tokenDecimals = tokenDecimals;\n        ($._tokenMultiplier, $._multiplyOnRemote) =\n            TokenScalingUtils.deriveTokenMultiplierValues(settings.tokenHomeDecimals, tokenDecimals);\n    }",
            "startLine": 165,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_send",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSendTokensInput",
                "type": "internal"
              },
              {
                "target": "_processSend",
                "type": "internal"
              },
              {
                "target": "_processSendMultiHop",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _send(SendTokensInput calldata input, uint256 amount) internal sendNonReentrant {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSendTokensInput(input);\n        if (input.destinationBlockchainID == $._tokenHomeBlockchainID) {\n            _processSend(input, amount);\n        } else {\n            _processSendMultiHop(input, amount);\n        }\n    }",
            "startLine": 290,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_sendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSendAndCallInput",
                "type": "internal"
              },
              {
                "target": "_processSendAndCall",
                "type": "internal"
              },
              {
                "target": "_processSendAndCallMultiHop",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _sendAndCall(\n        SendAndCallInput calldata input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSendAndCallInput(input);\n\n        if (input.destinationBlockchainID == $._tokenHomeBlockchainID) {\n            return _processSendAndCall(input, amount);\n        } else {\n            return _processSendAndCallMultiHop(input, amount);\n        }\n    }",
            "startLine": 308,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_receiveTeleporterMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "message",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_handleSendAndCall",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _receiveTeleporterMessage(\n        bytes32 sourceBlockchainID,\n        address originSenderAddress,\n        bytes memory message\n    ) internal override {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        require(\n            sourceBlockchainID == $._tokenHomeBlockchainID,\n            \"TokenRemote: invalid source blockchain ID\"\n        );\n        require(\n            originSenderAddress == $._tokenHomeAddress, \"TokenRemote: invalid origin sender address\"\n        );\n        TransferrerMessage memory transferrerMessage = abi.decode(message, (TransferrerMessage));\n\n        // If the contract was not previously known to be registered or collateralized, it is now given that\n        // the home has sent a message to mint funds.\n        if (!$._isRegistered || !$._isCollateralized) {\n            $._isRegistered = true;\n            $._isCollateralized = true;\n        }\n\n        // Remote contracts should only ever receive single-hop messages because\n        // multi-hop messages are always routed through the home contract.\n        if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_SEND) {\n            SingleHopSendMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopSendMessage));\n            _withdraw(payload.recipient, payload.amount);\n        } else if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_CALL) {\n            // The {sourceBlockchainID}, and {originSenderAddress} specified in the message\n            // payload will not match the sender of this Teleporter message in the case of a\n            // multi-hop message. Since Teleporter messages are only received from the specified\n            // token TokenHome instance, no additional authentication is needed on the payload values.\n            SingleHopCallMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopCallMessage));\n            _handleSendAndCall(payload, payload.amount);\n        } else {\n            revert(\"TokenRemote: invalid message type\");\n        }\n    }",
            "startLine": 328,
            "visibility": "internal",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_prepareSend",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "primaryFeeTokenAddress",
                "type": "address"
              },
              {
                "name": "primaryFee",
                "type": "uint256"
              },
              {
                "name": "secondaryFee",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_burn",
                "type": "internal"
              },
              {
                "target": "_handleFees",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _prepareSend(\n        uint256 amount,\n        address primaryFeeTokenAddress,\n        uint256 primaryFee,\n        uint256 secondaryFee\n    ) private returns (uint256, uint256) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n\n        // Burn the amount of tokens that will be transferred.\n        amount = _burn(amount);\n\n        // Transfer the primary fee to pay for fees on the first hop.\n        // The user can specify this contract as {primaryFeeTokenAddress},\n        // in which case the fee will be paid on top of the transferred amount.\n        primaryFee = _handleFees(primaryFeeTokenAddress, primaryFee);\n\n        // The transferred amount must cover the secondary fee, because the secondary fee\n        // is directly subtracted from the transferred amount on the intermediate (home) chain\n        // performing the multi-hop, before forwarding to the final destination TokenRemote instance.\n        require(\n            TokenScalingUtils.removeTokenScale($._tokenMultiplier, $._multiplyOnRemote, amount)\n                > TokenScalingUtils.removeTokenScale(\n                    $._tokenMultiplier, $._multiplyOnRemote, secondaryFee\n                ),\n            \"TokenRemote: insufficient tokens to transfer\"\n        );\n\n        // Return the amount in this contract's local denomination and the primary fee.\n        return (amount, primaryFee);\n    }",
            "startLine": 414,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_processSend",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSingleHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSend(SendTokensInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSingleHopInput(\n            input.destinationTokenTransferrerAddress, input.secondaryFee, input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_SEND,\n            payload: abi.encode(SingleHopSendMessage({recipient: input.recipient, amount: amount}))\n        });\n\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 448,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_processSendMultiHop",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateMultiHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSendMultiHop(SendTokensInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateMultiHopInput(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.MULTI_HOP_SEND,\n            payload: abi.encode(\n                MultiHopSendMessage({\n                    destinationBlockchainID: input.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n                    recipient: input.recipient,\n                    amount: amount,\n                    secondaryFee: input.secondaryFee,\n                    secondaryGasLimit: input.requiredGasLimit,\n                    multiHopFallback: input.multiHopFallback\n                })\n            )\n        });\n\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: MULTI_HOP_SEND_REQUIRED_GAS,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 487,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_processSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSingleHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSendAndCall(SendAndCallInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSingleHopInput(\n            input.destinationTokenTransferrerAddress, input.secondaryFee, input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_CALL,\n            payload: abi.encode(\n                SingleHopCallMessage({\n                    sourceBlockchainID: $._blockchainID,\n                    originTokenTransferrerAddress: address(this),\n                    originSenderAddress: _msgSender(),\n                    recipientContract: input.recipientContract,\n                    amount: amount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient\n                })\n            )\n        });\n\n        // Send message to the token TokenHome instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 539,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_processSendAndCallMultiHop",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateMultiHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "calculateNumWords",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSendAndCallMultiHop(SendAndCallInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateMultiHopInput(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.MULTI_HOP_CALL,\n            payload: abi.encode(\n                MultiHopCallMessage({\n                    originSenderAddress: _msgSender(),\n                    destinationBlockchainID: input.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n                    recipientContract: input.recipientContract,\n                    amount: amount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient,\n                    multiHopFallback: input.multiHopFallback,\n                    secondaryRequiredGasLimit: input.requiredGasLimit,\n                    secondaryFee: input.secondaryFee\n                })\n            )\n        });\n\n        // The required gas limit for the first message sent back to the TokenHome instance\n        // needs to account for the number of words in the payload. Each word uses additional\n        // gas to include in the message to the final destination chain.\n        uint256 messageRequiredGasLimit = MULTI_HOP_CALL_REQUIRED_GAS\n            + (calculateNumWords(input.recipientPayload.length) * MULTI_HOP_CALL_GAS_PER_WORD);\n\n        // Send message to the token TokenHome instance\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: messageRequiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 591,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_validateSingleHopInput",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "destinationTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "secondaryFee",
                "type": "uint256"
              },
              {
                "name": "multiHopFallback",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSingleHopInput(\n        address destinationTokenTransferrerAddress,\n        uint256 secondaryFee,\n        address multiHopFallback\n    ) private view {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        require(\n            destinationTokenTransferrerAddress == $._tokenHomeAddress,\n            \"TokenRemote: invalid destination token transferrer address\"\n        );\n        require(secondaryFee == 0, \"TokenRemote: non-zero secondary fee\");\n        require(multiHopFallback == address(0), \"TokenRemote: non-zero multi-hop fallback\");\n    }",
            "startLine": 650,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_validateMultiHopInput",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "destinationBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "destinationTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "multiHopFallback",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateMultiHopInput(\n        bytes32 destinationBlockchainID,\n        address destinationTokenTransferrerAddress,\n        address multiHopFallback\n    ) private view {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        // If the destination blockchain ID is this blockchain, the destination\n        // token transferrer address must be a different contract. This is a multi-hop case to\n        // a different token transfer contract on this chain.\n        if (destinationBlockchainID == $._blockchainID) {\n            require(\n                destinationTokenTransferrerAddress != address(this),\n                \"TokenRemote: invalid destination token transferrer address\"\n            );\n        }\n        require(multiHopFallback != address(0), \"TokenRemote: zero multi-hop fallback\");\n    }",
            "startLine": 664,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_validateSendTokensInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendTokensInput(\n        SendTokensInput calldata input\n    ) private pure {\n        require(input.recipient != address(0), \"TokenRemote: zero recipient address\");\n        require(input.requiredGasLimit > 0, \"TokenRemote: zero required gas limit\");\n        require(\n            input.destinationBlockchainID != bytes32(0),\n            \"TokenRemote: zero destination blockchain ID\"\n        );\n        require(\n            input.destinationTokenTransferrerAddress != address(0),\n            \"TokenRemote: zero destination token transferrer address\"\n        );\n    }",
            "startLine": 682,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "_validateSendAndCallInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendAndCallInput(\n        SendAndCallInput calldata input\n    ) private pure {\n        require(\n            input.destinationBlockchainID != bytes32(0),\n            \"TokenRemote: zero destination blockchain ID\"\n        );\n        require(\n            input.destinationTokenTransferrerAddress != address(0),\n            \"TokenRemote: zero destination token transferrer address\"\n        );\n        require(\n            input.recipientContract != address(0), \"TokenRemote: zero recipient contract address\"\n        );\n        require(input.requiredGasLimit > 0, \"TokenRemote: zero required gas limit\");\n        require(input.recipientGasLimit > 0, \"TokenRemote: zero recipient gas limit\");\n        require(\n            input.recipientGasLimit < input.requiredGasLimit,\n            \"TokenRemote: invalid recipient gas limit\"\n        );\n        require(\n            input.fallbackRecipient != address(0), \"TokenRemote: zero fallback recipient address\"\n        );\n    }",
            "startLine": 697,
            "visibility": "private",
            "inheritedFrom": "TokenRemote"
          },
          {
            "name": "__TeleporterRegistryOwnableApp_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "initialOwner",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryApp_init",
                "type": "internal"
              },
              {
                "target": "__Ownable_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TeleporterRegistryOwnableApp_init(\n        address teleporterRegistryAddress,\n        address initialOwner,\n        uint256 minTeleporterVersion\n    ) internal onlyInitializing {\n        __TeleporterRegistryApp_init(teleporterRegistryAddress, minTeleporterVersion);\n        __Ownable_init(initialOwner);\n    }",
            "startLine": 24,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_TeleporterRegistryOwnableApp_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _TeleporterRegistryOwnableApp_init_unchained() internal onlyInitializing {}",
            "startLine": 34,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_checkTeleporterRegistryAppAccess",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_checkOwner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkTeleporterRegistryAppAccess() internal view virtual override {\n        _checkOwner();\n    }",
            "startLine": 42,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_getOwnableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "OwnableStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }",
            "startLine": 30,
            "visibility": "private",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__Ownable_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }",
            "startLine": 51,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }",
            "startLine": 55,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }",
            "startLine": 81,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "OwnershipTransferred"
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }",
            "startLine": 113,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_getSendReentrancyGuardStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "SendReentrancyGuardStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getSendReentrancyGuardStorage()\n        private\n        pure\n        returns (SendReentrancyGuardStorage storage $)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := _SEND_REENTRANCY_GUARD_STORAGE_LOCATION\n        }\n    }",
            "startLine": 35,
            "visibility": "private",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrancyGuard_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "__SendReentrnacyGuard_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrancyGuard_init() internal onlyInitializing {\n        __SendReentrnacyGuard_init_unchained();\n    }",
            "startLine": 59,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrnacyGuard_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getSendReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrnacyGuard_init_unchained() internal {\n        SendReentrancyGuardStorage storage $ = _getSendReentrancyGuardStorage();\n        $._sendEntered = _NOT_ENTERED;\n    }",
            "startLine": 64,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "TokenRemote",
        "kind": "abstract",
        "category": "ictt",
        "filePath": "@ictt/TokenRemote/TokenRemote.sol",
        "inherits": [
          "TeleporterRegistryOwnableAppUpgradeable",
          "SendReentrancyGuardUpgradeable"
        ],
        "implements": [
          "ITokenRemote"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "ITokenRemote",
            "path": "./interfaces/ITokenRemote.sol",
            "isExternal": false
          },
          {
            "name": "TokenRemoteSettings",
            "path": "./interfaces/ITokenRemote.sol",
            "isExternal": false
          },
          {
            "name": "SendTokensInput",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SendAndCallInput",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "TransferrerMessageType",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "TransferrerMessage",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SingleHopSendMessage",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SingleHopCallMessage",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "MultiHopSendMessage",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "MultiHopCallMessage",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "RegisterRemoteMessage",
            "path": "../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "TeleporterMessageInput",
            "path": "@teleporter/ITeleporterMessenger.sol",
            "isExternal": true
          },
          {
            "name": "TeleporterFeeInfo",
            "path": "@teleporter/ITeleporterMessenger.sol",
            "isExternal": true
          },
          {
            "name": "TeleporterRegistryOwnableAppUpgradeable",
            "path": "@teleporter/registry/TeleporterRegistryOwnableAppUpgradeable.sol",
            "isExternal": true
          },
          {
            "name": "IWarpMessenger",
            "path": "@subnet-evm/IWarpMessenger.sol",
            "isExternal": true
          },
          {
            "name": "SendReentrancyGuardUpgradeable",
            "path": "@utilities/SendReentrancyGuardUpgradeable.sol",
            "isExternal": true
          },
          {
            "name": "TokenScalingUtils",
            "path": "@utilities/TokenScalingUtils.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "registerWithHome",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "feeInfo",
                "type": "TeleporterFeeInfo"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_handleFees",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function registerWithHome(\n        TeleporterFeeInfo calldata feeInfo\n    ) external virtual {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        require(!$._isRegistered, \"TokenRemote: already registered\");\n\n        // Send a message to the token TokenHome instance to register this TokenRemote instance.\n        RegisterRemoteMessage memory registerMessage = RegisterRemoteMessage({\n            initialReserveImbalance: $._initialReserveImbalance,\n            homeTokenDecimals: $._homeTokenDecimals,\n            remoteTokenDecimals: $._tokenDecimals\n        });\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.REGISTER_REMOTE,\n            payload: abi.encode(registerMessage)\n        });\n\n        uint256 feeAmount = _handleFees(feeInfo.feeTokenAddress, feeInfo.amount);\n        _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({feeTokenAddress: feeInfo.feeTokenAddress, amount: feeAmount}),\n                requiredGasLimit: REGISTER_REMOTE_REQUIRED_GAS,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n    }",
            "startLine": 206,
            "signature": "registerWithHome(TeleporterFeeInfo)",
            "selector": "0x5535b6b3",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "calculateNumWords",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "payloadSize",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function calculateNumWords(\n        uint256 payloadSize\n    ) public pure returns (uint256) {\n        // Add 31 to effectively round up to the nearest multiple of 32.\n        // Right-shift by 5 bits to divide by 32.\n        return (payloadSize + 31) >> 5;\n    }",
            "startLine": 240,
            "signature": "calculateNumWords(uint256)",
            "selector": "0x5a673771",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getIsCollateralized",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getIsCollateralized() public view returns (bool) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._isCollateralized;\n    }",
            "startLine": 248,
            "signature": "getIsCollateralized()",
            "selector": "0x0892f6c8",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getTokenMultiplier",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenMultiplier() public view returns (uint256) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._tokenMultiplier;\n    }",
            "startLine": 253,
            "signature": "getTokenMultiplier()",
            "selector": "0x10c6819b",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getMultiplyOnRemote",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getMultiplyOnRemote() public view returns (bool) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._multiplyOnRemote;\n    }",
            "startLine": 258,
            "signature": "getMultiplyOnRemote()",
            "selector": "0x1dc0ae00",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getTokenHomeBlockchainID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenHomeBlockchainID() public view returns (bytes32) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._tokenHomeBlockchainID;\n    }",
            "startLine": 263,
            "signature": "getTokenHomeBlockchainID()",
            "selector": "0x480733ee",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getTokenHomeAddress",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getTokenHomeAddress() public view returns (address) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._tokenHomeAddress;\n    }",
            "startLine": 268,
            "signature": "getTokenHomeAddress()",
            "selector": "0x3b3fc1ad",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getInitialReserveImbalance",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getInitialReserveImbalance() public view returns (uint256) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._initialReserveImbalance;\n    }",
            "startLine": 273,
            "signature": "getInitialReserveImbalance()",
            "selector": "0x1bdb1d8b",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "getBlockchainID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getBlockchainID() public view returns (bytes32) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        return $._blockchainID;\n    }",
            "startLine": 278,
            "signature": "getBlockchainID()",
            "selector": "0x587a98a6",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }",
            "startLine": 73,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "renounceOwnership",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
            "startLine": 94,
            "signature": "renounceOwnership()",
            "selector": "0x765becbf",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }",
            "startLine": 102,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          }
        ],
        "internalFunctions": [
          {
            "name": "_getTokenRemoteStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "TokenRemoteStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getTokenRemoteStorage() private pure returns (TokenRemoteStorage storage $) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := TOKEN_REMOTE_STORAGE_LOCATION\n        }\n    }",
            "startLine": 108,
            "visibility": "private"
          },
          {
            "name": "__TokenRemote_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "TokenRemoteSettings"
              },
              {
                "name": "initialReserveImbalance_",
                "type": "uint256"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryOwnableApp_init",
                "type": "internal"
              },
              {
                "target": "__SendReentrancyGuard_init",
                "type": "internal"
              },
              {
                "target": "__TokenRemote_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TokenRemote_init(\n        TokenRemoteSettings memory settings,\n        uint256 initialReserveImbalance_,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        __TeleporterRegistryOwnableApp_init(\n            settings.teleporterRegistryAddress,\n            settings.teleporterManager,\n            settings.minTeleporterVersion\n        );\n        __SendReentrancyGuard_init();\n        __TokenRemote_init_unchained(settings, initialReserveImbalance_, tokenDecimals);\n    }",
            "startLine": 150,
            "visibility": "internal"
          },
          {
            "name": "__TokenRemote_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "settings",
                "type": "TokenRemoteSettings"
              },
              {
                "name": "initialReserveImbalance_",
                "type": "uint256"
              },
              {
                "name": "tokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.deriveTokenMultiplierValues",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TokenRemote_init_unchained(\n        TokenRemoteSettings memory settings,\n        uint256 initialReserveImbalance_,\n        uint8 tokenDecimals\n    ) internal onlyInitializing {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        $._blockchainID =\n            IWarpMessenger(0x0200000000000000000000000000000000000005).getBlockchainID();\n        require(\n            settings.tokenHomeBlockchainID != bytes32(0),\n            \"TokenRemote: zero token home blockchain ID\"\n        );\n        require(\n            settings.tokenHomeBlockchainID != $._blockchainID,\n            \"TokenRemote: cannot deploy to same blockchain as token home\"\n        );\n        require(settings.tokenHomeAddress != address(0), \"TokenRemote: zero token home address\");\n        require(\n            settings.tokenHomeDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenRemote: token home decimals too high\"\n        );\n        require(\n            tokenDecimals <= TokenScalingUtils.MAX_TOKEN_DECIMALS,\n            \"TokenRemote: token decimals too high\"\n        );\n        $._tokenHomeBlockchainID = settings.tokenHomeBlockchainID;\n        $._tokenHomeAddress = settings.tokenHomeAddress;\n        $._initialReserveImbalance = initialReserveImbalance_;\n        $._isCollateralized = initialReserveImbalance_ == 0;\n        $._homeTokenDecimals = settings.tokenHomeDecimals;\n        $._tokenDecimals = tokenDecimals;\n        ($._tokenMultiplier, $._multiplyOnRemote) =\n            TokenScalingUtils.deriveTokenMultiplierValues(settings.tokenHomeDecimals, tokenDecimals);\n    }",
            "startLine": 165,
            "visibility": "internal"
          },
          {
            "name": "_send",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSendTokensInput",
                "type": "internal"
              },
              {
                "target": "_processSend",
                "type": "internal"
              },
              {
                "target": "_processSendMultiHop",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _send(SendTokensInput calldata input, uint256 amount) internal sendNonReentrant {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSendTokensInput(input);\n        if (input.destinationBlockchainID == $._tokenHomeBlockchainID) {\n            _processSend(input, amount);\n        } else {\n            _processSendMultiHop(input, amount);\n        }\n    }",
            "startLine": 290,
            "visibility": "internal"
          },
          {
            "name": "_sendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSendAndCallInput",
                "type": "internal"
              },
              {
                "target": "_processSendAndCall",
                "type": "internal"
              },
              {
                "target": "_processSendAndCallMultiHop",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _sendAndCall(\n        SendAndCallInput calldata input,\n        uint256 amount\n    ) internal sendNonReentrant {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSendAndCallInput(input);\n\n        if (input.destinationBlockchainID == $._tokenHomeBlockchainID) {\n            return _processSendAndCall(input, amount);\n        } else {\n            return _processSendAndCallMultiHop(input, amount);\n        }\n    }",
            "startLine": 308,
            "visibility": "internal"
          },
          {
            "name": "_receiveTeleporterMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "message",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_withdraw",
                "type": "internal"
              },
              {
                "target": "_handleSendAndCall",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _receiveTeleporterMessage(\n        bytes32 sourceBlockchainID,\n        address originSenderAddress,\n        bytes memory message\n    ) internal override {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        require(\n            sourceBlockchainID == $._tokenHomeBlockchainID,\n            \"TokenRemote: invalid source blockchain ID\"\n        );\n        require(\n            originSenderAddress == $._tokenHomeAddress, \"TokenRemote: invalid origin sender address\"\n        );\n        TransferrerMessage memory transferrerMessage = abi.decode(message, (TransferrerMessage));\n\n        // If the contract was not previously known to be registered or collateralized, it is now given that\n        // the home has sent a message to mint funds.\n        if (!$._isRegistered || !$._isCollateralized) {\n            $._isRegistered = true;\n            $._isCollateralized = true;\n        }\n\n        // Remote contracts should only ever receive single-hop messages because\n        // multi-hop messages are always routed through the home contract.\n        if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_SEND) {\n            SingleHopSendMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopSendMessage));\n            _withdraw(payload.recipient, payload.amount);\n        } else if (transferrerMessage.messageType == TransferrerMessageType.SINGLE_HOP_CALL) {\n            // The {sourceBlockchainID}, and {originSenderAddress} specified in the message\n            // payload will not match the sender of this Teleporter message in the case of a\n            // multi-hop message. Since Teleporter messages are only received from the specified\n            // token TokenHome instance, no additional authentication is needed on the payload values.\n            SingleHopCallMessage memory payload =\n                abi.decode(transferrerMessage.payload, (SingleHopCallMessage));\n            _handleSendAndCall(payload, payload.amount);\n        } else {\n            revert(\"TokenRemote: invalid message type\");\n        }\n    }",
            "startLine": 328,
            "visibility": "internal"
          },
          {
            "name": "_withdraw",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "recipient",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _withdraw(address recipient, uint256 amount) internal virtual;",
            "startLine": 374,
            "visibility": "internal"
          },
          {
            "name": "_burn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _burn(\n        uint256 amount\n    ) internal virtual returns (uint256);",
            "startLine": 382,
            "visibility": "internal"
          },
          {
            "name": "_handleSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "message",
                "type": "SingleHopCallMessage"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _handleSendAndCall(\n        SingleHopCallMessage memory message,\n        uint256 amount\n    ) internal virtual;",
            "startLine": 392,
            "visibility": "internal"
          },
          {
            "name": "_handleFees",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "feeTokenAddress",
                "type": "address"
              },
              {
                "name": "feeAmount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _handleFees(\n        address feeTokenAddress,\n        uint256 feeAmount\n    ) internal virtual returns (uint256);",
            "startLine": 404,
            "visibility": "internal"
          },
          {
            "name": "_prepareSend",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "primaryFeeTokenAddress",
                "type": "address"
              },
              {
                "name": "primaryFee",
                "type": "uint256"
              },
              {
                "name": "secondaryFee",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_burn",
                "type": "internal"
              },
              {
                "target": "_handleFees",
                "type": "internal"
              },
              {
                "target": "TokenScalingUtils.removeTokenScale",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _prepareSend(\n        uint256 amount,\n        address primaryFeeTokenAddress,\n        uint256 primaryFee,\n        uint256 secondaryFee\n    ) private returns (uint256, uint256) {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n\n        // Burn the amount of tokens that will be transferred.\n        amount = _burn(amount);\n\n        // Transfer the primary fee to pay for fees on the first hop.\n        // The user can specify this contract as {primaryFeeTokenAddress},\n        // in which case the fee will be paid on top of the transferred amount.\n        primaryFee = _handleFees(primaryFeeTokenAddress, primaryFee);\n\n        // The transferred amount must cover the secondary fee, because the secondary fee\n        // is directly subtracted from the transferred amount on the intermediate (home) chain\n        // performing the multi-hop, before forwarding to the final destination TokenRemote instance.\n        require(\n            TokenScalingUtils.removeTokenScale($._tokenMultiplier, $._multiplyOnRemote, amount)\n                > TokenScalingUtils.removeTokenScale(\n                    $._tokenMultiplier, $._multiplyOnRemote, secondaryFee\n                ),\n            \"TokenRemote: insufficient tokens to transfer\"\n        );\n\n        // Return the amount in this contract's local denomination and the primary fee.\n        return (amount, primaryFee);\n    }",
            "startLine": 414,
            "visibility": "private"
          },
          {
            "name": "_processSend",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSingleHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSend(SendTokensInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSingleHopInput(\n            input.destinationTokenTransferrerAddress, input.secondaryFee, input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_SEND,\n            payload: abi.encode(SingleHopSendMessage({recipient: input.recipient, amount: amount}))\n        });\n\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 448,
            "visibility": "private"
          },
          {
            "name": "_processSendMultiHop",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateMultiHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSendMultiHop(SendTokensInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateMultiHopInput(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.MULTI_HOP_SEND,\n            payload: abi.encode(\n                MultiHopSendMessage({\n                    destinationBlockchainID: input.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n                    recipient: input.recipient,\n                    amount: amount,\n                    secondaryFee: input.secondaryFee,\n                    secondaryGasLimit: input.requiredGasLimit,\n                    multiHopFallback: input.multiHopFallback\n                })\n            )\n        });\n\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: MULTI_HOP_SEND_REQUIRED_GAS,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 487,
            "visibility": "private"
          },
          {
            "name": "_processSendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateSingleHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSendAndCall(SendAndCallInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateSingleHopInput(\n            input.destinationTokenTransferrerAddress, input.secondaryFee, input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.SINGLE_HOP_CALL,\n            payload: abi.encode(\n                SingleHopCallMessage({\n                    sourceBlockchainID: $._blockchainID,\n                    originTokenTransferrerAddress: address(this),\n                    originSenderAddress: _msgSender(),\n                    recipientContract: input.recipientContract,\n                    amount: amount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient\n                })\n            )\n        });\n\n        // Send message to the token TokenHome instance.\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: input.requiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 539,
            "visibility": "private"
          },
          {
            "name": "_processSendAndCallMultiHop",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              },
              {
                "target": "_validateMultiHopInput",
                "type": "internal"
              },
              {
                "target": "_prepareSend",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "calculateNumWords",
                "type": "internal"
              },
              {
                "target": "_sendTeleporterMessage",
                "type": "internal"
              }
            ],
            "emits": [
              "TokensAndCallSent"
            ],
            "isVirtual": false,
            "sourceCode": "function _processSendAndCallMultiHop(SendAndCallInput calldata input, uint256 amount) private {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        _validateMultiHopInput(\n            input.destinationBlockchainID,\n            input.destinationTokenTransferrerAddress,\n            input.multiHopFallback\n        );\n\n        uint256 primaryFee;\n        (amount, primaryFee) = _prepareSend({\n            amount: amount,\n            primaryFeeTokenAddress: input.primaryFeeTokenAddress,\n            primaryFee: input.primaryFee,\n            secondaryFee: input.secondaryFee\n        });\n\n        TransferrerMessage memory message = TransferrerMessage({\n            messageType: TransferrerMessageType.MULTI_HOP_CALL,\n            payload: abi.encode(\n                MultiHopCallMessage({\n                    originSenderAddress: _msgSender(),\n                    destinationBlockchainID: input.destinationBlockchainID,\n                    destinationTokenTransferrerAddress: input.destinationTokenTransferrerAddress,\n                    recipientContract: input.recipientContract,\n                    amount: amount,\n                    recipientPayload: input.recipientPayload,\n                    recipientGasLimit: input.recipientGasLimit,\n                    fallbackRecipient: input.fallbackRecipient,\n                    multiHopFallback: input.multiHopFallback,\n                    secondaryRequiredGasLimit: input.requiredGasLimit,\n                    secondaryFee: input.secondaryFee\n                })\n            )\n        });\n\n        // The required gas limit for the first message sent back to the TokenHome instance\n        // needs to account for the number of words in the payload. Each word uses additional\n        // gas to include in the message to the final destination chain.\n        uint256 messageRequiredGasLimit = MULTI_HOP_CALL_REQUIRED_GAS\n            + (calculateNumWords(input.recipientPayload.length) * MULTI_HOP_CALL_GAS_PER_WORD);\n\n        // Send message to the token TokenHome instance\n        bytes32 messageID = _sendTeleporterMessage(\n            TeleporterMessageInput({\n                destinationBlockchainID: $._tokenHomeBlockchainID,\n                destinationAddress: $._tokenHomeAddress,\n                feeInfo: TeleporterFeeInfo({\n                    feeTokenAddress: input.primaryFeeTokenAddress,\n                    amount: primaryFee\n                }),\n                requiredGasLimit: messageRequiredGasLimit,\n                allowedRelayerAddresses: new address[](0),\n                message: abi.encode(message)\n            })\n        );\n\n        emit TokensAndCallSent(messageID, _msgSender(), input, amount);\n    }",
            "startLine": 591,
            "visibility": "private"
          },
          {
            "name": "_validateSingleHopInput",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "destinationTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "secondaryFee",
                "type": "uint256"
              },
              {
                "name": "multiHopFallback",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSingleHopInput(\n        address destinationTokenTransferrerAddress,\n        uint256 secondaryFee,\n        address multiHopFallback\n    ) private view {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        require(\n            destinationTokenTransferrerAddress == $._tokenHomeAddress,\n            \"TokenRemote: invalid destination token transferrer address\"\n        );\n        require(secondaryFee == 0, \"TokenRemote: non-zero secondary fee\");\n        require(multiHopFallback == address(0), \"TokenRemote: non-zero multi-hop fallback\");\n    }",
            "startLine": 650,
            "visibility": "private"
          },
          {
            "name": "_validateMultiHopInput",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "destinationBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "destinationTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "multiHopFallback",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getTokenRemoteStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateMultiHopInput(\n        bytes32 destinationBlockchainID,\n        address destinationTokenTransferrerAddress,\n        address multiHopFallback\n    ) private view {\n        TokenRemoteStorage storage $ = _getTokenRemoteStorage();\n        // If the destination blockchain ID is this blockchain, the destination\n        // token transferrer address must be a different contract. This is a multi-hop case to\n        // a different token transfer contract on this chain.\n        if (destinationBlockchainID == $._blockchainID) {\n            require(\n                destinationTokenTransferrerAddress != address(this),\n                \"TokenRemote: invalid destination token transferrer address\"\n            );\n        }\n        require(multiHopFallback != address(0), \"TokenRemote: zero multi-hop fallback\");\n    }",
            "startLine": 664,
            "visibility": "private"
          },
          {
            "name": "_validateSendTokensInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendTokensInput(\n        SendTokensInput calldata input\n    ) private pure {\n        require(input.recipient != address(0), \"TokenRemote: zero recipient address\");\n        require(input.requiredGasLimit > 0, \"TokenRemote: zero required gas limit\");\n        require(\n            input.destinationBlockchainID != bytes32(0),\n            \"TokenRemote: zero destination blockchain ID\"\n        );\n        require(\n            input.destinationTokenTransferrerAddress != address(0),\n            \"TokenRemote: zero destination token transferrer address\"\n        );\n    }",
            "startLine": 682,
            "visibility": "private"
          },
          {
            "name": "_validateSendAndCallInput",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _validateSendAndCallInput(\n        SendAndCallInput calldata input\n    ) private pure {\n        require(\n            input.destinationBlockchainID != bytes32(0),\n            \"TokenRemote: zero destination blockchain ID\"\n        );\n        require(\n            input.destinationTokenTransferrerAddress != address(0),\n            \"TokenRemote: zero destination token transferrer address\"\n        );\n        require(\n            input.recipientContract != address(0), \"TokenRemote: zero recipient contract address\"\n        );\n        require(input.requiredGasLimit > 0, \"TokenRemote: zero required gas limit\");\n        require(input.recipientGasLimit > 0, \"TokenRemote: zero recipient gas limit\");\n        require(\n            input.recipientGasLimit < input.requiredGasLimit,\n            \"TokenRemote: invalid recipient gas limit\"\n        );\n        require(\n            input.fallbackRecipient != address(0), \"TokenRemote: zero fallback recipient address\"\n        );\n    }",
            "startLine": 697,
            "visibility": "private"
          },
          {
            "name": "__TeleporterRegistryOwnableApp_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "initialOwner",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryApp_init",
                "type": "internal"
              },
              {
                "target": "__Ownable_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TeleporterRegistryOwnableApp_init(\n        address teleporterRegistryAddress,\n        address initialOwner,\n        uint256 minTeleporterVersion\n    ) internal onlyInitializing {\n        __TeleporterRegistryApp_init(teleporterRegistryAddress, minTeleporterVersion);\n        __Ownable_init(initialOwner);\n    }",
            "startLine": 24,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_TeleporterRegistryOwnableApp_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _TeleporterRegistryOwnableApp_init_unchained() internal onlyInitializing {}",
            "startLine": 34,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_checkTeleporterRegistryAppAccess",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_checkOwner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkTeleporterRegistryAppAccess() internal view virtual override {\n        _checkOwner();\n    }",
            "startLine": 42,
            "visibility": "internal",
            "inheritedFrom": "TeleporterRegistryOwnableAppUpgradeable"
          },
          {
            "name": "_getOwnableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "OwnableStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }",
            "startLine": 30,
            "visibility": "private",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__Ownable_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }",
            "startLine": 51,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }",
            "startLine": 55,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }",
            "startLine": 81,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "OwnershipTransferred"
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }",
            "startLine": 113,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getSendReentrancyGuardStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "SendReentrancyGuardStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getSendReentrancyGuardStorage()\n        private\n        pure\n        returns (SendReentrancyGuardStorage storage $)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := _SEND_REENTRANCY_GUARD_STORAGE_LOCATION\n        }\n    }",
            "startLine": 35,
            "visibility": "private",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrancyGuard_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "__SendReentrnacyGuard_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrancyGuard_init() internal onlyInitializing {\n        __SendReentrnacyGuard_init_unchained();\n    }",
            "startLine": 59,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          },
          {
            "name": "__SendReentrnacyGuard_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getSendReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrnacyGuard_init_unchained() internal {\n        SendReentrancyGuardStorage storage $ = _getSendReentrancyGuardStorage();\n        $._sendEntered = _NOT_ENTERED;\n    }",
            "startLine": 64,
            "visibility": "internal",
            "inheritedFrom": "SendReentrancyGuardUpgradeable"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "INativeTokenRemote",
        "kind": "interface",
        "category": "interface",
        "filePath": "@ictt/TokenRemote/interfaces/INativeTokenRemote.sol",
        "inherits": [],
        "implements": [
          "ITokenRemote",
          "INativeTokenTransferrer"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "INativeTokenTransferrer",
            "path": "../../interfaces/INativeTokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "ITokenRemote",
            "path": "./ITokenRemote.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "reportBurnedTxFees",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "requiredGasLimit",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function reportBurnedTxFees(\n        uint256 requiredGasLimit\n    ) external;",
            "startLine": 25,
            "signature": "reportBurnedTxFees(uint256)",
            "selector": "0x5c66eddb",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "totalNativeAssetSupply",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function totalNativeAssetSupply() external view returns (uint256);",
            "startLine": 34,
            "signature": "totalNativeAssetSupply()",
            "selector": "0x5ad4777b",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [
          {
            "name": "ReportBurnedTxFees",
            "parameters": [
              {
                "name": "teleporterMessageID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "feesBurned",
                "type": "uint256",
                "indexed": false
              }
            ]
          }
        ],
        "errors": []
      },
      {
        "name": "ITokenRemote",
        "kind": "interface",
        "category": "interface",
        "filePath": "@ictt/TokenRemote/interfaces/ITokenRemote.sol",
        "inherits": [],
        "implements": [
          "ITokenTransferrer"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "ITokenTransferrer",
            "path": "../../interfaces/ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "TeleporterFeeInfo",
            "path": "@teleporter/ITeleporterMessenger.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "registerWithHome",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "feeInfo",
                "type": "TeleporterFeeInfo"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function registerWithHome(\n        TeleporterFeeInfo calldata feeInfo\n    ) external;",
            "startLine": 40,
            "signature": "registerWithHome(TeleporterFeeInfo)",
            "selector": "0x5535b6b3",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": []
      },
      {
        "name": "WrappedNativeToken",
        "kind": "contract",
        "category": "ictt",
        "filePath": "@ictt/WrappedNativeToken.sol",
        "inherits": [
          "ERC20"
        ],
        "implements": [
          "IWrappedNativeToken"
        ],
        "usesLibraries": [
          "Address"
        ],
        "imports": [
          {
            "name": "IWrappedNativeToken",
            "path": "./interfaces/IWrappedNativeToken.sol",
            "isExternal": false
          },
          {
            "name": "ERC20",
            "path": "@openzeppelin/contracts@5.0.2/token/ERC20/ERC20.sol",
            "isExternal": true
          },
          {
            "name": "Address",
            "path": "@openzeppelin/contracts@5.0.2/utils/Address.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "withdraw",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_burn",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "Withdrawal"
            ],
            "isVirtual": false,
            "sourceCode": "function withdraw(\n        uint256 amount\n    ) external {\n        _burn(_msgSender(), amount);\n        emit Withdrawal(_msgSender(), amount);\n        payable(_msgSender()).sendValue(amount);\n    }",
            "startLine": 27,
            "signature": "withdraw(uint256)",
            "selector": "0x279e2aee",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "deposit",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_mint",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [
              "Deposit"
            ],
            "isVirtual": false,
            "sourceCode": "function deposit() public payable {\n        _mint(_msgSender(), msg.value);\n        emit Deposit(_msgSender(), msg.value);\n    }",
            "startLine": 35,
            "signature": "deposit()",
            "selector": "0x30c413e1",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "name",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function name() public view virtual returns (string memory) {\n        return _name;\n    }",
            "startLine": 52,
            "signature": "name()",
            "selector": "0x3ec0f734",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20"
          },
          {
            "name": "symbol",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }",
            "startLine": 60,
            "signature": "symbol()",
            "selector": "0x6a927499",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20"
          },
          {
            "name": "decimals",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function decimals() public view virtual returns (uint8) {\n        return 18;\n    }",
            "startLine": 77,
            "signature": "decimals()",
            "selector": "0x76436c3d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20"
          },
          {
            "name": "totalSupply",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }",
            "startLine": 82,
            "signature": "totalSupply()",
            "selector": "0x6190166c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20"
          },
          {
            "name": "balanceOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }",
            "startLine": 87,
            "signature": "balanceOf(address)",
            "selector": "0x7d2b9996",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20"
          },
          {
            "name": "transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }",
            "startLine": 99,
            "signature": "transfer(address,uint256)",
            "selector": "0x59d228e5",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20"
          },
          {
            "name": "allowance",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }",
            "startLine": 106,
            "signature": "allowance(address,address)",
            "selector": "0x596dd87d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20"
          },
          {
            "name": "approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }",
            "startLine": 120,
            "signature": "approve(address,uint256)",
            "selector": "0x1d38323d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20"
          },
          {
            "name": "transferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_spendAllowance",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }",
            "startLine": 142,
            "signature": "transferFrom(address,address,uint256)",
            "selector": "0x447f286d",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "ERC20"
          }
        ],
        "internalFunctions": [
          {
            "name": "_transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }",
            "startLine": 159,
            "visibility": "internal",
            "inheritedFrom": "ERC20"
          },
          {
            "name": "_update",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [
              "Transfer"
            ],
            "isVirtual": true,
            "sourceCode": "function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
            "startLine": 176,
            "visibility": "internal",
            "inheritedFrom": "ERC20"
          },
          {
            "name": "_mint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }",
            "startLine": 214,
            "visibility": "internal",
            "inheritedFrom": "ERC20"
          },
          {
            "name": "_burn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }",
            "startLine": 229,
            "visibility": "internal",
            "inheritedFrom": "ERC20"
          },
          {
            "name": "_approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }",
            "startLine": 251,
            "visibility": "internal",
            "inheritedFrom": "ERC20"
          },
          {
            "name": "_spendAllowance",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "allowance",
                "type": "internal"
              },
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }",
            "startLine": 294,
            "visibility": "internal",
            "inheritedFrom": "ERC20"
          }
        ],
        "events": [],
        "errors": []
      },
      {
        "name": "IERC20SendAndCallReceiver",
        "kind": "interface",
        "category": "interface",
        "filePath": "@ictt/interfaces/IERC20SendAndCallReceiver.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "receiveTokens",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "token",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "payload",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function receiveTokens(\n        bytes32 sourceBlockchainID,\n        address originTokenTransferrerAddress,\n        address originSenderAddress,\n        address token,\n        uint256 amount,\n        bytes calldata payload\n    ) external;",
            "startLine": 22,
            "signature": "receiveTokens(bytes32,address,address,address,uint256,bytes)",
            "selector": "0x354ed65a",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": []
      },
      {
        "name": "IERC20TokenTransferrer",
        "kind": "interface",
        "category": "interface",
        "filePath": "@ictt/interfaces/IERC20TokenTransferrer.sol",
        "inherits": [],
        "implements": [
          "ITokenTransferrer"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "ITokenTransferrer",
            "path": "./ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SendTokensInput",
            "path": "./ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SendAndCallInput",
            "path": "./ITokenTransferrer.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "send",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function send(SendTokensInput calldata input, uint256 amount) external;",
            "startLine": 21,
            "signature": "send(SendTokensInput,uint256)",
            "selector": "0x247bc3d4",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "sendAndCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function sendAndCall(SendAndCallInput calldata input, uint256 amount) external;",
            "startLine": 28,
            "signature": "sendAndCall(SendAndCallInput,uint256)",
            "selector": "0x6f1f7d9c",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": []
      },
      {
        "name": "INativeSendAndCallReceiver",
        "kind": "interface",
        "category": "interface",
        "filePath": "@ictt/interfaces/INativeSendAndCallReceiver.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "receiveTokens",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originTokenTransferrerAddress",
                "type": "address"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "payload",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function receiveTokens(\n        bytes32 sourceBlockchainID,\n        address originTokenTransferrerAddress,\n        address originSenderAddress,\n        bytes calldata payload\n    ) external payable;",
            "startLine": 22,
            "signature": "receiveTokens(bytes32,address,address,bytes)",
            "selector": "0x7fa89565",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": []
      },
      {
        "name": "INativeTokenTransferrer",
        "kind": "interface",
        "category": "interface",
        "filePath": "@ictt/interfaces/INativeTokenTransferrer.sol",
        "inherits": [],
        "implements": [
          "ITokenTransferrer"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "ITokenTransferrer",
            "path": "./ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SendTokensInput",
            "path": "./ITokenTransferrer.sol",
            "isExternal": false
          },
          {
            "name": "SendAndCallInput",
            "path": "./ITokenTransferrer.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "send",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "input",
                "type": "SendTokensInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function send(\n        SendTokensInput calldata input\n    ) external payable;",
            "startLine": 20,
            "signature": "send(SendTokensInput)",
            "selector": "0x34cc3541",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "sendAndCall",
            "stateMutability": "payable",
            "parameters": [
              {
                "name": "input",
                "type": "SendAndCallInput"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function sendAndCall(\n        SendAndCallInput calldata input\n    ) external payable;",
            "startLine": 29,
            "signature": "sendAndCall(SendAndCallInput)",
            "selector": "0x4b1f7c2f",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": []
      },
      {
        "name": "ITokenTransferrer",
        "kind": "interface",
        "category": "interface",
        "filePath": "@ictt/interfaces/ITokenTransferrer.sol",
        "inherits": [],
        "implements": [
          "ITeleporterReceiver"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "ITeleporterReceiver",
            "path": "@teleporter/ITeleporterReceiver.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [],
        "internalFunctions": [],
        "events": [
          {
            "name": "TokensSent",
            "parameters": [
              {
                "name": "teleporterMessageID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "sender",
                "type": "address",
                "indexed": true
              },
              {
                "name": "input",
                "type": "SendTokensInput",
                "indexed": false
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "TokensAndCallSent",
            "parameters": [
              {
                "name": "teleporterMessageID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "sender",
                "type": "address",
                "indexed": true
              },
              {
                "name": "input",
                "type": "SendAndCallInput",
                "indexed": false
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "TokensWithdrawn",
            "parameters": [
              {
                "name": "recipient",
                "type": "address",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "CallSucceeded",
            "parameters": [
              {
                "name": "recipientContract",
                "type": "address",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "CallFailed",
            "parameters": [
              {
                "name": "recipientContract",
                "type": "address",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          }
        ],
        "errors": []
      },
      {
        "name": "IWrappedNativeToken",
        "kind": "interface",
        "category": "interface",
        "filePath": "@ictt/interfaces/IWrappedNativeToken.sol",
        "inherits": [],
        "implements": [
          "IERC20"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IERC20",
            "path": "@openzeppelin/contracts@5.0.2/token/ERC20/IERC20.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "deposit",
            "stateMutability": "payable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function deposit() external payable;",
            "startLine": 35,
            "signature": "deposit()",
            "selector": "0x30c413e1",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "withdraw",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function withdraw(\n        uint256 amount\n    ) external;",
            "startLine": 41,
            "signature": "withdraw(uint256)",
            "selector": "0x279e2aee",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [
          {
            "name": "Deposit",
            "parameters": [
              {
                "name": "sender",
                "type": "address",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "Withdrawal",
            "parameters": [
              {
                "name": "sender",
                "type": "address",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          }
        ],
        "errors": []
      },
      {
        "name": "ERC20",
        "kind": "abstract",
        "category": "OpenZeppelin/token",
        "filePath": "@openzeppelin/contracts@5.0.2/token/ERC20/ERC20.sol",
        "inherits": [
          "Context"
        ],
        "implements": [
          "IERC20",
          "IERC20Metadata",
          "IERC20Errors"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IERC20",
            "path": "./IERC20.sol",
            "isExternal": false
          },
          {
            "name": "IERC20Metadata",
            "path": "./extensions/IERC20Metadata.sol",
            "isExternal": false
          },
          {
            "name": "Context",
            "path": "../../utils/Context.sol",
            "isExternal": false
          },
          {
            "name": "IERC20Errors",
            "path": "../../interfaces/draft-IERC6093.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "name",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function name() public view virtual returns (string memory) {\n        return _name;\n    }",
            "startLine": 52,
            "signature": "name()",
            "selector": "0x3ec0f734",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "symbol",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }",
            "startLine": 60,
            "signature": "symbol()",
            "selector": "0x6a927499",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "decimals",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function decimals() public view virtual returns (uint8) {\n        return 18;\n    }",
            "startLine": 77,
            "signature": "decimals()",
            "selector": "0x76436c3d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "totalSupply",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }",
            "startLine": 82,
            "signature": "totalSupply()",
            "selector": "0x6190166c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "balanceOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }",
            "startLine": 87,
            "signature": "balanceOf(address)",
            "selector": "0x7d2b9996",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }",
            "startLine": 99,
            "signature": "transfer(address,uint256)",
            "selector": "0x59d228e5",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "allowance",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }",
            "startLine": 106,
            "signature": "allowance(address,address)",
            "selector": "0x596dd87d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }",
            "startLine": 120,
            "signature": "approve(address,uint256)",
            "selector": "0x1d38323d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "transferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_spendAllowance",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }",
            "startLine": 142,
            "signature": "transferFrom(address,address,uint256)",
            "selector": "0x447f286d",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }",
            "startLine": 159,
            "visibility": "internal"
          },
          {
            "name": "_update",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [
              "Transfer"
            ],
            "isVirtual": true,
            "sourceCode": "function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
            "startLine": 176,
            "visibility": "internal"
          },
          {
            "name": "_mint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }",
            "startLine": 214,
            "visibility": "internal"
          },
          {
            "name": "_burn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }",
            "startLine": 229,
            "visibility": "internal"
          },
          {
            "name": "_approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }",
            "startLine": 251,
            "visibility": "internal"
          },
          {
            "name": "_approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "emitEvent",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [
              "Approval"
            ],
            "isVirtual": true,
            "sourceCode": "function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }",
            "startLine": 273,
            "visibility": "internal"
          },
          {
            "name": "_spendAllowance",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "allowance",
                "type": "internal"
              },
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }",
            "startLine": 294,
            "visibility": "internal"
          }
        ],
        "events": [],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin"
      },
      {
        "name": "SafeERC20",
        "kind": "library",
        "category": "library",
        "filePath": "@openzeppelin/contracts@5.0.2/token/ERC20/utils/SafeERC20.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IERC20",
            "path": "../IERC20.sol",
            "isExternal": false
          },
          {
            "name": "IERC1363",
            "path": "../../../interfaces/IERC1363.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "safeTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_callOptionalReturn",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }",
            "startLine": 33,
            "visibility": "internal"
          },
          {
            "name": "safeTransferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_callOptionalReturn",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }",
            "startLine": 41,
            "visibility": "internal"
          },
          {
            "name": "trySafeTransfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_callOptionalReturnBool",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }",
            "startLine": 48,
            "visibility": "internal"
          },
          {
            "name": "trySafeTransferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_callOptionalReturnBool",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }",
            "startLine": 55,
            "visibility": "internal"
          },
          {
            "name": "safeIncreaseAllowance",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "token.allowance",
                "type": "external"
              },
              {
                "target": "forceApprove",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }",
            "startLine": 68,
            "visibility": "internal"
          },
          {
            "name": "safeDecreaseAllowance",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "requestedDecrease",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "token.allowance",
                "type": "external"
              },
              {
                "target": "forceApprove",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }",
            "startLine": 82,
            "visibility": "internal"
          },
          {
            "name": "forceApprove",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_callOptionalReturnBool",
                "type": "internal"
              },
              {
                "target": "_callOptionalReturn",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }",
            "startLine": 101,
            "visibility": "internal"
          },
          {
            "name": "transferAndCallRelaxed",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC1363"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "safeTransfer",
                "type": "internal"
              },
              {
                "target": "token.transferAndCall",
                "type": "external"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }",
            "startLine": 117,
            "visibility": "internal"
          },
          {
            "name": "transferFromAndCallRelaxed",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC1363"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "safeTransferFrom",
                "type": "internal"
              },
              {
                "target": "token.transferFromAndCall",
                "type": "external"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }",
            "startLine": 132,
            "visibility": "internal"
          },
          {
            "name": "approveAndCallRelaxed",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC1363"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "forceApprove",
                "type": "internal"
              },
              {
                "target": "token.approveAndCall",
                "type": "external"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }",
            "startLine": 157,
            "visibility": "internal"
          },
          {
            "name": "_callOptionalReturn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }",
            "startLine": 173,
            "visibility": "private"
          },
          {
            "name": "_callOptionalReturnBool",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IERC20"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }",
            "startLine": 201,
            "visibility": "private"
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "SafeERC20FailedOperation",
            "parameters": [
              {
                "name": "token",
                "type": "address"
              }
            ]
          },
          {
            "name": "SafeERC20FailedDecreaseAllowance",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "currentAllowance",
                "type": "uint256"
              },
              {
                "name": "requestedDecrease",
                "type": "uint256"
              }
            ]
          }
        ],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin"
      },
      {
        "name": "SafeERC20TransferFrom",
        "kind": "library",
        "category": "library",
        "filePath": "@utilities/SafeERC20TransferFrom.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [
          "SafeERC20"
        ],
        "imports": [
          {
            "name": "IERC20",
            "path": "@openzeppelin/contracts@5.0.2/token/ERC20/IERC20.sol",
            "isExternal": true
          },
          {
            "name": "SafeERC20",
            "path": "@openzeppelin/contracts@5.0.2/token/ERC20/utils/SafeERC20.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "safeTransferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "erc20",
                "type": "IERC20"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "safeTransferFrom",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function safeTransferFrom(IERC20 erc20, uint256 amount) internal returns (uint256) {\n        return safeTransferFrom(erc20, msg.sender, amount);\n    }",
            "startLine": 31,
            "visibility": "internal"
          },
          {
            "name": "safeTransferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "erc20",
                "type": "IERC20"
              },
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "erc20.balanceOf",
                "type": "external"
              },
              {
                "target": "erc20.safeTransferFrom",
                "type": "external"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function safeTransferFrom(\n        IERC20 erc20,\n        address from,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 balanceBefore = erc20.balanceOf(address(this));\n        erc20.safeTransferFrom(from, address(this), amount);\n        uint256 balanceAfter = erc20.balanceOf(address(this));\n\n        require(balanceAfter > balanceBefore, \"SafeERC20TransferFrom: balance not increased\");\n\n        return balanceAfter - balanceBefore;\n    }",
            "startLine": 46,
            "visibility": "internal"
          }
        ],
        "events": [],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "avalanche-icm"
      },
      {
        "name": "CallUtils",
        "kind": "library",
        "category": "library",
        "filePath": "@utilities/CallUtils.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "_callWithExactGas",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "gasAmount",
                "type": "uint256"
              },
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_callWithExactGasAndValue",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _callWithExactGas(\n        uint256 gasAmount,\n        address target,\n        bytes memory data\n    ) internal returns (bool) {\n        return _callWithExactGasAndValue(gasAmount, 0, target, data);\n    }",
            "startLine": 12,
            "visibility": "internal"
          },
          {
            "name": "_callWithExactGasAndValue",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "gasAmount",
                "type": "uint256"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _callWithExactGasAndValue(\n        uint256 gasAmount,\n        uint256 value,\n        address target,\n        bytes memory data\n    ) internal returns (bool) {\n        require(gasleft() >= gasAmount, \"CallUtils: insufficient gas\");\n        require(address(this).balance >= value, \"CallUtils: insufficient value\");\n\n        // If there is no code at the target, automatically consider the call to have failed since it\n        // doesn't have any effect on state.\n        if (target.code.length == 0) {\n            return false;\n        }\n\n        // Call the target address of the message with the provided data and amount of gas.\n        //\n        // Assembly is used for the low-level call to avoid unnecessary expansion of the return data in memory.\n        // This prevents possible \"return bomb\" vectors where the external contract could force the caller\n        // to use an arbitrary amount of gas. See Solidity issue here: https://github.com/ethereum/solidity/issues/12306\n        bool success;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            success :=\n                call(\n                    gasAmount, // gas provided to the call\n                    target, // call target\n                    value, // value transferred\n                    add(data, 0x20), // input data - 0x20 needs to be added to an array because the first 32-byte slot contains the array length (0x20 in hex is 32 in decimal).\n                    mload(data), // input data size - mload returns mem[p..(p+32)], which is the first 32-byte slot of the array. In this case, the array length.\n                    0, // output\n                    0 // output size\n                )\n        }\n        return success;\n    }",
            "startLine": 24,
            "visibility": "internal"
          }
        ],
        "events": [],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "avalanche-icm"
      },
      {
        "name": "SafeWrappedNativeTokenDeposit",
        "kind": "library",
        "category": "library",
        "filePath": "@utilities/SafeWrappedNativeTokenDeposit.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IWrappedNativeToken",
            "path": "../ictt/interfaces/IWrappedNativeToken.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "safeDeposit",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "token",
                "type": "IWrappedNativeToken"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "token.balanceOf",
                "type": "external"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function safeDeposit(IWrappedNativeToken token, uint256 amount) internal returns (uint256) {\n        uint256 balanceBefore = token.balanceOf(address(this));\n        token.deposit{value: amount}();\n        uint256 balanceAfter = token.balanceOf(address(this));\n\n        require(\n            balanceAfter > balanceBefore, \"SafeWrappedNativeTokenDeposit: balance not increased\"\n        );\n\n        return balanceAfter - balanceBefore;\n    }",
            "startLine": 28,
            "visibility": "internal"
          }
        ],
        "events": [],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "avalanche-icm"
      },
      {
        "name": "Address",
        "kind": "library",
        "category": "library",
        "filePath": "@openzeppelin/contracts@5.0.2/utils/Address.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "Errors",
            "path": "./Errors.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "sendValue",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "recipient",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "Errors.InsufficientBalance",
                "type": "library"
              },
              {
                "target": "_revert",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }",
            "startLine": 33,
            "visibility": "internal"
          },
          {
            "name": "functionCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "functionCallWithValue",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }",
            "startLine": 62,
            "visibility": "internal"
          },
          {
            "name": "functionCallWithValue",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "Errors.InsufficientBalance",
                "type": "library"
              },
              {
                "target": "verifyCallResultFromTarget",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }",
            "startLine": 75,
            "visibility": "internal"
          },
          {
            "name": "functionStaticCall",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "target.staticcall",
                "type": "external"
              },
              {
                "target": "verifyCallResultFromTarget",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }",
            "startLine": 87,
            "visibility": "internal"
          },
          {
            "name": "functionDelegateCall",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "data",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "unknown",
                "type": "delegatecall"
              },
              {
                "target": "verifyCallResultFromTarget",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }",
            "startLine": 96,
            "visibility": "internal"
          },
          {
            "name": "verifyCallResultFromTarget",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              },
              {
                "name": "success",
                "type": "bool"
              },
              {
                "name": "returndata",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "_revert",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }",
            "startLine": 106,
            "visibility": "internal"
          },
          {
            "name": "verifyCallResult",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "success",
                "type": "bool"
              },
              {
                "name": "returndata",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes"
              }
            ],
            "calls": [
              {
                "target": "_revert",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }",
            "startLine": 127,
            "visibility": "internal"
          },
          {
            "name": "_revert",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "returndata",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "Errors.FailedCall",
                "type": "library"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }",
            "startLine": 138,
            "visibility": "private"
          }
        ],
        "events": [],
        "errors": [
          {
            "name": "AddressEmptyCode",
            "parameters": [
              {
                "name": "target",
                "type": "address"
              }
            ]
          }
        ],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin"
      },
      {
        "name": "ITeleporterMessenger",
        "kind": "interface",
        "category": "interface",
        "filePath": "@teleporter/ITeleporterMessenger.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "sendCrossChainMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageInput",
                "type": "TeleporterMessageInput"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function sendCrossChainMessage(\n        TeleporterMessageInput calldata messageInput\n    ) external returns (bytes32);",
            "startLine": 124,
            "signature": "sendCrossChainMessage(TeleporterMessageInput)",
            "selector": "0x183ea2c4",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "retrySendCrossChainMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "message",
                "type": "TeleporterMessage"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function retrySendCrossChainMessage(\n        TeleporterMessage calldata message\n    ) external;",
            "startLine": 137,
            "signature": "retrySendCrossChainMessage(TeleporterMessage)",
            "selector": "0x22d1a534",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "addFeeAmount",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageID",
                "type": "bytes32"
              },
              {
                "name": "feeTokenAddress",
                "type": "address"
              },
              {
                "name": "additionalFeeAmount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function addFeeAmount(\n        bytes32 messageID,\n        address feeTokenAddress,\n        uint256 additionalFeeAmount\n    ) external;",
            "startLine": 149,
            "signature": "addFeeAmount(bytes32,address,uint256)",
            "selector": "0x5a2d4a6b",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "receiveCrossChainMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "messageIndex",
                "type": "uint32"
              },
              {
                "name": "relayerRewardAddress",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function receiveCrossChainMessage(uint32 messageIndex, address relayerRewardAddress) external;",
            "startLine": 161,
            "signature": "receiveCrossChainMessage(uint32,address)",
            "selector": "0x27455e63",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "retryMessageExecution",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "message",
                "type": "TeleporterMessage"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function retryMessageExecution(\n        bytes32 sourceBlockchainID,\n        TeleporterMessage calldata message\n    ) external;",
            "startLine": 172,
            "signature": "retryMessageExecution(bytes32,TeleporterMessage)",
            "selector": "0x6b18afd5",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "sendSpecifiedReceipts",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "messageIDs",
                "type": "bytes32[]"
              },
              {
                "name": "feeInfo",
                "type": "TeleporterFeeInfo"
              },
              {
                "name": "allowedRelayerAddresses",
                "type": "address[]"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function sendSpecifiedReceipts(\n        bytes32 sourceBlockchainID,\n        bytes32[] calldata messageIDs,\n        TeleporterFeeInfo calldata feeInfo,\n        address[] calldata allowedRelayerAddresses\n    ) external returns (bytes32);",
            "startLine": 185,
            "signature": "sendSpecifiedReceipts(bytes32,bytes32[],TeleporterFeeInfo,address[])",
            "selector": "0x5a1d84b6",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "redeemRelayerRewards",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "feeTokenAddress",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function redeemRelayerRewards(\n        address feeTokenAddress\n    ) external;",
            "startLine": 195,
            "signature": "redeemRelayerRewards(address)",
            "selector": "0x24144de5",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "getMessageHash",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "messageID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getMessageHash(\n        bytes32 messageID\n    ) external view returns (bytes32);",
            "startLine": 203,
            "signature": "getMessageHash(bytes32)",
            "selector": "0x6d060018",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "messageReceived",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "messageID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function messageReceived(\n        bytes32 messageID\n    ) external view returns (bool);",
            "startLine": 211,
            "signature": "messageReceived(bytes32)",
            "selector": "0x4e45ec81",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "getRelayerRewardAddress",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "messageID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getRelayerRewardAddress(\n        bytes32 messageID\n    ) external view returns (address);",
            "startLine": 220,
            "signature": "getRelayerRewardAddress(bytes32)",
            "selector": "0x53e2be4a",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "checkRelayerRewardAmount",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "relayer",
                "type": "address"
              },
              {
                "name": "feeTokenAddress",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function checkRelayerRewardAmount(\n        address relayer,\n        address feeTokenAddress\n    ) external view returns (uint256);",
            "startLine": 228,
            "signature": "checkRelayerRewardAmount(address,address)",
            "selector": "0x60cd4ad8",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "getFeeInfo",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "messageID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              },
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getFeeInfo(\n        bytes32 messageID\n    ) external view returns (address, uint256);",
            "startLine": 238,
            "signature": "getFeeInfo(bytes32)",
            "selector": "0x641e7629",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "getNextMessageID",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "destinationBlockchainID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getNextMessageID(\n        bytes32 destinationBlockchainID\n    ) external view returns (bytes32);",
            "startLine": 251,
            "signature": "getNextMessageID(bytes32)",
            "selector": "0x42a893ae",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "getReceiptQueueSize",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getReceiptQueueSize(\n        bytes32 sourceBlockchainID\n    ) external view returns (uint256);",
            "startLine": 259,
            "signature": "getReceiptQueueSize(bytes32)",
            "selector": "0x5c305ab7",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "getReceiptAtIndex",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "index",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "TeleporterMessageReceipt"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getReceiptAtIndex(\n        bytes32 sourceBlockchainID,\n        uint256 index\n    ) external view returns (TeleporterMessageReceipt memory);",
            "startLine": 267,
            "signature": "getReceiptAtIndex(bytes32,uint256)",
            "selector": "0x60d9ebbd",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [
          {
            "name": "BlockchainIDInitialized",
            "parameters": [
              {
                "name": "blockchainID",
                "type": "bytes32",
                "indexed": true
              }
            ]
          },
          {
            "name": "SendCrossChainMessage",
            "parameters": [
              {
                "name": "messageID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "destinationBlockchainID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "message",
                "type": "TeleporterMessage",
                "indexed": false
              },
              {
                "name": "feeInfo",
                "type": "TeleporterFeeInfo",
                "indexed": false
              }
            ]
          },
          {
            "name": "AddFeeAmount",
            "parameters": [
              {
                "name": "messageID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "updatedFeeInfo",
                "type": "TeleporterFeeInfo",
                "indexed": false
              }
            ]
          },
          {
            "name": "MessageExecutionFailed",
            "parameters": [
              {
                "name": "messageID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "sourceBlockchainID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "message",
                "type": "TeleporterMessage",
                "indexed": false
              }
            ]
          },
          {
            "name": "MessageExecuted",
            "parameters": [
              {
                "name": "messageID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "sourceBlockchainID",
                "type": "bytes32",
                "indexed": true
              }
            ]
          },
          {
            "name": "ReceiveCrossChainMessage",
            "parameters": [
              {
                "name": "messageID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "sourceBlockchainID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "deliverer",
                "type": "address",
                "indexed": true
              },
              {
                "name": "rewardRedeemer",
                "type": "address",
                "indexed": false
              },
              {
                "name": "message",
                "type": "TeleporterMessage",
                "indexed": false
              }
            ]
          },
          {
            "name": "ReceiptReceived",
            "parameters": [
              {
                "name": "messageID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "destinationBlockchainID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "relayerRewardAddress",
                "type": "address",
                "indexed": true
              },
              {
                "name": "feeInfo",
                "type": "TeleporterFeeInfo",
                "indexed": false
              }
            ]
          },
          {
            "name": "RelayerRewardsRedeemed",
            "parameters": [
              {
                "name": "redeemer",
                "type": "address",
                "indexed": true
              },
              {
                "name": "asset",
                "type": "address",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "avalanche-icm"
      },
      {
        "name": "TeleporterRegistryOwnableAppUpgradeable",
        "kind": "abstract",
        "category": "teleporter",
        "filePath": "@teleporter/registry/TeleporterRegistryOwnableAppUpgradeable.sol",
        "inherits": [
          "TeleporterRegistryAppUpgradeable",
          "OwnableUpgradeable"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "TeleporterRegistryAppUpgradeable",
            "path": "./TeleporterRegistryAppUpgradeable.sol",
            "isExternal": false
          },
          {
            "name": "OwnableUpgradeable",
            "path": "@openzeppelin/contracts-upgradeable@5.0.2/access/OwnableUpgradeable.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }",
            "startLine": 73,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": [],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "renounceOwnership",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
            "startLine": 94,
            "signature": "renounceOwnership()",
            "selector": "0x765becbf",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }",
            "startLine": 102,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ],
            "inheritedFrom": "OwnableUpgradeable"
          }
        ],
        "internalFunctions": [
          {
            "name": "__TeleporterRegistryOwnableApp_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "teleporterRegistryAddress",
                "type": "address"
              },
              {
                "name": "initialOwner",
                "type": "address"
              },
              {
                "name": "minTeleporterVersion",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__TeleporterRegistryApp_init",
                "type": "internal"
              },
              {
                "target": "__Ownable_init",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __TeleporterRegistryOwnableApp_init(\n        address teleporterRegistryAddress,\n        address initialOwner,\n        uint256 minTeleporterVersion\n    ) internal onlyInitializing {\n        __TeleporterRegistryApp_init(teleporterRegistryAddress, minTeleporterVersion);\n        __Ownable_init(initialOwner);\n    }",
            "startLine": 24,
            "visibility": "internal"
          },
          {
            "name": "_TeleporterRegistryOwnableApp_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _TeleporterRegistryOwnableApp_init_unchained() internal onlyInitializing {}",
            "startLine": 34,
            "visibility": "internal"
          },
          {
            "name": "_checkTeleporterRegistryAppAccess",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_checkOwner",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkTeleporterRegistryAppAccess() internal view virtual override {\n        _checkOwner();\n    }",
            "startLine": 42,
            "visibility": "internal"
          },
          {
            "name": "_getOwnableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "OwnableStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }",
            "startLine": 30,
            "visibility": "private",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__Ownable_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }",
            "startLine": 51,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "__Ownable_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }",
            "startLine": 55,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }",
            "startLine": 81,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "OwnershipTransferred"
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }",
            "startLine": 113,
            "visibility": "internal",
            "inheritedFrom": "OwnableUpgradeable"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          }
        ],
        "events": [],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "avalanche-icm"
      },
      {
        "name": "SendReentrancyGuardUpgradeable",
        "kind": "abstract",
        "category": "utilities",
        "filePath": "@utilities/SendReentrancyGuardUpgradeable.sol",
        "inherits": [
          "Initializable"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "Initializable",
            "path": "@openzeppelin/contracts-upgradeable@5.0.2/proxy/utils/Initializable.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "_getSendReentrancyGuardStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "SendReentrancyGuardStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getSendReentrancyGuardStorage()\n        private\n        pure\n        returns (SendReentrancyGuardStorage storage $)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            $.slot := _SEND_REENTRANCY_GUARD_STORAGE_LOCATION\n        }\n    }",
            "startLine": 35,
            "visibility": "private"
          },
          {
            "name": "__SendReentrancyGuard_init",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "__SendReentrnacyGuard_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrancyGuard_init() internal onlyInitializing {\n        __SendReentrnacyGuard_init_unchained();\n    }",
            "startLine": 59,
            "visibility": "internal"
          },
          {
            "name": "__SendReentrnacyGuard_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getSendReentrancyGuardStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __SendReentrnacyGuard_init_unchained() internal {\n        SendReentrancyGuardStorage storage $ = _getSendReentrancyGuardStorage();\n        $._sendEntered = _NOT_ENTERED;\n    }",
            "startLine": 64,
            "visibility": "internal"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          }
        ],
        "events": [],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "avalanche-icm"
      },
      {
        "name": "TokenScalingUtils",
        "kind": "library",
        "category": "library",
        "filePath": "@utilities/TokenScalingUtils.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "applyTokenScale",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tokenMultiplier",
                "type": "uint256"
              },
              {
                "name": "multiplyOnRemote",
                "type": "bool"
              },
              {
                "name": "homeTokenAmount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_scaleTokens",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function applyTokenScale(\n        uint256 tokenMultiplier,\n        bool multiplyOnRemote,\n        uint256 homeTokenAmount\n    ) internal pure returns (uint256) {\n        return _scaleTokens(tokenMultiplier, multiplyOnRemote, homeTokenAmount, true);\n    }",
            "startLine": 16,
            "visibility": "internal"
          },
          {
            "name": "removeTokenScale",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tokenMultiplier",
                "type": "uint256"
              },
              {
                "name": "multiplyOnRemote",
                "type": "bool"
              },
              {
                "name": "remoteTokenAmount",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_scaleTokens",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function removeTokenScale(\n        uint256 tokenMultiplier,\n        bool multiplyOnRemote,\n        uint256 remoteTokenAmount\n    ) internal pure returns (uint256) {\n        return _scaleTokens(tokenMultiplier, multiplyOnRemote, remoteTokenAmount, false);\n    }",
            "startLine": 31,
            "visibility": "internal"
          },
          {
            "name": "deriveTokenMultiplierValues",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "homeTokenDecimals",
                "type": "uint8"
              },
              {
                "name": "remoteTokenDecimals",
                "type": "uint8"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              },
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function deriveTokenMultiplierValues(\n        uint8 homeTokenDecimals,\n        uint8 remoteTokenDecimals\n    ) internal pure returns (uint256, bool) {\n        bool multiplyOnRemote = remoteTokenDecimals > homeTokenDecimals;\n        uint256 tokenMultiplier = 10\n            ** (\n                multiplyOnRemote\n                    ? uint256(remoteTokenDecimals - homeTokenDecimals)\n                    : uint256(homeTokenDecimals - remoteTokenDecimals)\n            );\n        return (tokenMultiplier, multiplyOnRemote);\n    }",
            "startLine": 45,
            "visibility": "internal"
          },
          {
            "name": "_scaleTokens",
            "stateMutability": "pure",
            "parameters": [
              {
                "name": "tokenMultiplier",
                "type": "uint256"
              },
              {
                "name": "multiplyOnRemote",
                "type": "bool"
              },
              {
                "name": "amount",
                "type": "uint256"
              },
              {
                "name": "isSendToRemote",
                "type": "bool"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _scaleTokens(\n        uint256 tokenMultiplier,\n        bool multiplyOnRemote,\n        uint256 amount,\n        bool isSendToRemote\n    ) private pure returns (uint256) {\n        // Multiply when multiplyOnRemote and isSendToRemote are\n        // both true or both false.\n        if (multiplyOnRemote == isSendToRemote) {\n            return amount * tokenMultiplier;\n        }\n        // Otherwise divide.\n        return amount / tokenMultiplier;\n    }",
            "startLine": 70,
            "visibility": "private"
          }
        ],
        "events": [],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "avalanche-icm"
      },
      {
        "name": "IWarpMessenger",
        "kind": "interface",
        "category": "interface",
        "filePath": "@subnet-evm/IWarpMessenger.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "sendWarpMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "payload",
                "type": "bytes"
              }
            ],
            "returnValues": [
              {
                "name": "messageID",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function sendWarpMessage(\n        bytes calldata payload\n    ) external returns (bytes32 messageID);",
            "startLine": 26,
            "signature": "sendWarpMessage(bytes)",
            "selector": "0x14602c51",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "getVerifiedWarpMessage",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "index",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "message",
                "type": "WarpMessage"
              },
              {
                "name": "valid",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getVerifiedWarpMessage(\n        uint32 index\n    ) external view returns (WarpMessage calldata message, bool valid);",
            "startLine": 35,
            "signature": "getVerifiedWarpMessage(uint32)",
            "selector": "0x24db2f29",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "getVerifiedWarpBlockHash",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "index",
                "type": "uint32"
              }
            ],
            "returnValues": [
              {
                "name": "warpBlockHash",
                "type": "WarpBlockHash"
              },
              {
                "name": "valid",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getVerifiedWarpBlockHash(\n        uint32 index\n    ) external view returns (WarpBlockHash calldata warpBlockHash, bool valid);",
            "startLine": 44,
            "signature": "getVerifiedWarpBlockHash(uint32)",
            "selector": "0x5b034023",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "getBlockchainID",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "blockchainID",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function getBlockchainID() external view returns (bytes32 blockchainID);",
            "startLine": 51,
            "signature": "getBlockchainID()",
            "selector": "0x587a98a6",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [
          {
            "name": "SendWarpMessage",
            "parameters": [
              {
                "name": "sender",
                "type": "address",
                "indexed": true
              },
              {
                "name": "messageID",
                "type": "bytes32",
                "indexed": true
              },
              {
                "name": "message",
                "type": "bytes",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "avalanche-icm"
      },
      {
        "name": "ERC20Upgradeable",
        "kind": "abstract",
        "category": "OZ-Upgradeable/token",
        "filePath": "@openzeppelin/contracts-upgradeable@5.0.2/token/ERC20/ERC20Upgradeable.sol",
        "inherits": [
          "Initializable",
          "ContextUpgradeable"
        ],
        "implements": [
          "IERC20",
          "IERC20Metadata",
          "IERC20Errors"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IERC20",
            "path": "@openzeppelin/contracts/token/ERC20/IERC20.sol",
            "isExternal": true
          },
          {
            "name": "IERC20Metadata",
            "path": "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol",
            "isExternal": true
          },
          {
            "name": "ContextUpgradeable",
            "path": "../../utils/ContextUpgradeable.sol",
            "isExternal": false
          },
          {
            "name": "IERC20Errors",
            "path": "@openzeppelin/contracts/interfaces/draft-IERC6093.sol",
            "isExternal": true
          },
          {
            "name": "Initializable",
            "path": "../../proxy/utils/Initializable.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "name",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }",
            "startLine": 70,
            "signature": "name()",
            "selector": "0x3ec0f734",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "symbol",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }",
            "startLine": 79,
            "signature": "symbol()",
            "selector": "0x6a927499",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "decimals",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function decimals() public view virtual returns (uint8) {\n        return 18;\n    }",
            "startLine": 97,
            "signature": "decimals()",
            "selector": "0x76436c3d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "totalSupply",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }",
            "startLine": 102,
            "signature": "totalSupply()",
            "selector": "0x6190166c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "balanceOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }",
            "startLine": 108,
            "signature": "balanceOf(address)",
            "selector": "0x7d2b9996",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }",
            "startLine": 121,
            "signature": "transfer(address,uint256)",
            "selector": "0x59d228e5",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "allowance",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }",
            "startLine": 128,
            "signature": "allowance(address,address)",
            "selector": "0x596dd87d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }",
            "startLine": 143,
            "signature": "approve(address,uint256)",
            "selector": "0x1d38323d",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "transferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_msgSender",
                "type": "internal"
              },
              {
                "target": "_spendAllowance",
                "type": "internal"
              },
              {
                "target": "_transfer",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }",
            "startLine": 165,
            "signature": "transferFrom(address,address,uint256)",
            "selector": "0x447f286d",
            "visibility": "public",
            "modifiers": []
          }
        ],
        "internalFunctions": [
          {
            "name": "_getERC20Storage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "ERC20Storage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }",
            "startLine": 46,
            "visibility": "private"
          },
          {
            "name": "__ERC20_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name_",
                "type": "string"
              },
              {
                "name": "symbol_",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__ERC20_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }",
            "startLine": 57,
            "visibility": "internal"
          },
          {
            "name": "__ERC20_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "name_",
                "type": "string"
              },
              {
                "name": "symbol_",
                "type": "string"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }",
            "startLine": 61,
            "visibility": "internal"
          },
          {
            "name": "_transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }",
            "startLine": 182,
            "visibility": "internal"
          },
          {
            "name": "_update",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [
              "Transfer"
            ],
            "isVirtual": true,
            "sourceCode": "function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
            "startLine": 199,
            "visibility": "internal"
          },
          {
            "name": "_mint",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }",
            "startLine": 238,
            "visibility": "internal"
          },
          {
            "name": "_burn",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_update",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }",
            "startLine": 253,
            "visibility": "internal"
          },
          {
            "name": "_approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }",
            "startLine": 275,
            "visibility": "internal"
          },
          {
            "name": "_approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              },
              {
                "name": "emitEvent",
                "type": "bool"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getERC20Storage",
                "type": "internal"
              }
            ],
            "emits": [
              "Approval"
            ],
            "isVirtual": true,
            "sourceCode": "function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        $._allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }",
            "startLine": 297,
            "visibility": "internal"
          },
          {
            "name": "_spendAllowance",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "allowance",
                "type": "internal"
              },
              {
                "target": "_approve",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }",
            "startLine": 319,
            "visibility": "internal"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          }
        ],
        "events": [],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin-upgradeable"
      },
      {
        "name": "INativeMinter",
        "kind": "interface",
        "category": "interface",
        "filePath": "@subnet-evm/INativeMinter.sol",
        "inherits": [],
        "implements": [
          "IAllowList"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IAllowList",
            "path": "@subnet-evm/IAllowList.sol",
            "isExternal": true
          }
        ],
        "externalFunctions": [
          {
            "name": "mintNativeCoin",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "addr",
                "type": "address"
              },
              {
                "name": "amount",
                "type": "uint256"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function mintNativeCoin(address addr, uint256 amount) external;",
            "startLine": 10,
            "signature": "mintNativeCoin(address,uint256)",
            "selector": "0x0372929a",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [
          {
            "name": "NativeCoinMinted",
            "parameters": [
              {
                "name": "sender",
                "type": "address",
                "indexed": true
              },
              {
                "name": "recipient",
                "type": "address",
                "indexed": true
              },
              {
                "name": "amount",
                "type": "uint256",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "avalanche-icm"
      },
      {
        "name": "ITeleporterReceiver",
        "kind": "interface",
        "category": "interface",
        "filePath": "@teleporter/ITeleporterReceiver.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "receiveTeleporterMessage",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "sourceBlockchainID",
                "type": "bytes32"
              },
              {
                "name": "originSenderAddress",
                "type": "address"
              },
              {
                "name": "message",
                "type": "bytes"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function receiveTeleporterMessage(\n        bytes32 sourceBlockchainID,\n        address originSenderAddress,\n        bytes calldata message\n    ) external;",
            "startLine": 21,
            "signature": "receiveTeleporterMessage(bytes32,address,bytes)",
            "selector": "0x38475acc",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "avalanche-icm"
      },
      {
        "name": "IERC20",
        "kind": "interface",
        "category": "interface",
        "filePath": "@openzeppelin/contracts@5.0.2/token/ERC20/IERC20.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "totalSupply",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function totalSupply() external view returns (uint256);",
            "startLine": 27,
            "signature": "totalSupply()",
            "selector": "0x6190166c",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "balanceOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function balanceOf(address account) external view returns (uint256);",
            "startLine": 32,
            "signature": "balanceOf(address)",
            "selector": "0x7d2b9996",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function transfer(address to, uint256 value) external returns (bool);",
            "startLine": 41,
            "signature": "transfer(address,uint256)",
            "selector": "0x59d228e5",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "allowance",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function allowance(address owner, address spender) external view returns (uint256);",
            "startLine": 50,
            "signature": "allowance(address,address)",
            "selector": "0x596dd87d",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function approve(address spender, uint256 value) external returns (bool);",
            "startLine": 67,
            "signature": "approve(address,uint256)",
            "selector": "0x1d38323d",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "transferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function transferFrom(address from, address to, uint256 value) external returns (bool);",
            "startLine": 78,
            "signature": "transferFrom(address,address,uint256)",
            "selector": "0x447f286d",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [
          {
            "name": "Transfer",
            "parameters": [
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "value",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "Approval",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "spender",
                "type": "address",
                "indexed": true
              },
              {
                "name": "value",
                "type": "uint256",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin"
      },
      {
        "name": "OwnableUpgradeable",
        "kind": "abstract",
        "category": "OZ-Upgradeable/access",
        "filePath": "@openzeppelin/contracts-upgradeable@5.0.2/access/OwnableUpgradeable.sol",
        "inherits": [
          "Initializable",
          "ContextUpgradeable"
        ],
        "implements": [],
        "usesLibraries": [],
        "imports": [
          {
            "name": "ContextUpgradeable",
            "path": "../utils/ContextUpgradeable.sol",
            "isExternal": false
          },
          {
            "name": "Initializable",
            "path": "../proxy/utils/Initializable.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "owner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "address"
              }
            ],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }",
            "startLine": 73,
            "signature": "owner()",
            "selector": "0x3edde90c",
            "visibility": "public",
            "modifiers": []
          },
          {
            "name": "renounceOwnership",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
            "startLine": 94,
            "signature": "renounceOwnership()",
            "selector": "0x765becbf",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          },
          {
            "name": "transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }",
            "startLine": 102,
            "signature": "transferOwnership(address)",
            "selector": "0x4c5f2467",
            "visibility": "public",
            "modifiers": [
              "onlyOwner"
            ]
          }
        ],
        "internalFunctions": [
          {
            "name": "_getOwnableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "OwnableStorage"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }",
            "startLine": 30,
            "visibility": "private"
          },
          {
            "name": "__Ownable_init",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "__Ownable_init_unchained",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }",
            "startLine": 51,
            "visibility": "internal"
          },
          {
            "name": "__Ownable_init_unchained",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "initialOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_transferOwnership",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }",
            "startLine": 55,
            "visibility": "internal"
          },
          {
            "name": "_checkOwner",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "owner",
                "type": "internal"
              },
              {
                "target": "_msgSender",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }",
            "startLine": 81,
            "visibility": "internal"
          },
          {
            "name": "_transferOwnership",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "newOwner",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [
              {
                "target": "_getOwnableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "OwnershipTransferred"
            ],
            "isVirtual": true,
            "sourceCode": "function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }",
            "startLine": 113,
            "visibility": "internal"
          },
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal",
            "inheritedFrom": "Initializable"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private",
            "inheritedFrom": "Initializable"
          }
        ],
        "events": [
          {
            "name": "OwnershipTransferred",
            "parameters": [
              {
                "name": "previousOwner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "newOwner",
                "type": "address",
                "indexed": true
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "OwnableUnauthorizedAccount",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ]
          },
          {
            "name": "OwnableInvalidOwner",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ]
          }
        ],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin-upgradeable"
      },
      {
        "name": "Initializable",
        "kind": "abstract",
        "category": "OZ-Upgradeable/proxy",
        "filePath": "@openzeppelin/contracts-upgradeable@5.0.2/proxy/utils/Initializable.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [
          {
            "name": "_checkInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_isInitializing",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }",
            "startLine": 178,
            "visibility": "internal"
          },
          {
            "name": "_disableInitializers",
            "stateMutability": "nonpayable",
            "parameters": [],
            "returnValues": [],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [
              "Initialized"
            ],
            "isVirtual": true,
            "sourceCode": "function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }",
            "startLine": 192,
            "visibility": "internal"
          },
          {
            "name": "_getInitializedVersion",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint64"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }",
            "startLine": 208,
            "visibility": "internal"
          },
          {
            "name": "_isInitializing",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [
              {
                "target": "_getInitializableStorage",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }",
            "startLine": 215,
            "visibility": "internal"
          },
          {
            "name": "_initializableStorageSlot",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "bytes32"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": true,
            "sourceCode": "function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }",
            "startLine": 224,
            "visibility": "internal"
          },
          {
            "name": "_getInitializableStorage",
            "stateMutability": "pure",
            "parameters": [],
            "returnValues": [
              {
                "name": "$",
                "type": "InitializableStorage"
              }
            ],
            "calls": [
              {
                "target": "_initializableStorageSlot",
                "type": "internal"
              }
            ],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }",
            "startLine": 232,
            "visibility": "private"
          }
        ],
        "events": [
          {
            "name": "Initialized",
            "parameters": [
              {
                "name": "version",
                "type": "uint64",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [
          {
            "name": "InvalidInitialization",
            "parameters": []
          },
          {
            "name": "NotInitializing",
            "parameters": []
          }
        ],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin-upgradeable"
      },
      {
        "name": "IERC20",
        "kind": "interface",
        "category": "interface",
        "filePath": "@openzeppelin/contracts/token/ERC20/IERC20.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "totalSupply",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function totalSupply() external view returns (uint256);",
            "startLine": 27,
            "signature": "totalSupply()",
            "selector": "0x6190166c",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "balanceOf",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "account",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function balanceOf(address account) external view returns (uint256);",
            "startLine": 32,
            "signature": "balanceOf(address)",
            "selector": "0x7d2b9996",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "transfer",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function transfer(address to, uint256 value) external returns (bool);",
            "startLine": 41,
            "signature": "transfer(address,uint256)",
            "selector": "0x59d228e5",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "allowance",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "spender",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function allowance(address owner, address spender) external view returns (uint256);",
            "startLine": 50,
            "signature": "allowance(address,address)",
            "selector": "0x596dd87d",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "approve",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function approve(address spender, uint256 value) external returns (bool);",
            "startLine": 67,
            "signature": "approve(address,uint256)",
            "selector": "0x1d38323d",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "transferFrom",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "from",
                "type": "address"
              },
              {
                "name": "to",
                "type": "address"
              },
              {
                "name": "value",
                "type": "uint256"
              }
            ],
            "returnValues": [
              {
                "name": "",
                "type": "bool"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function transferFrom(address from, address to, uint256 value) external returns (bool);",
            "startLine": 78,
            "signature": "transferFrom(address,address,uint256)",
            "selector": "0x447f286d",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [
          {
            "name": "Transfer",
            "parameters": [
              {
                "name": "from",
                "type": "address",
                "indexed": true
              },
              {
                "name": "to",
                "type": "address",
                "indexed": true
              },
              {
                "name": "value",
                "type": "uint256",
                "indexed": false
              }
            ]
          },
          {
            "name": "Approval",
            "parameters": [
              {
                "name": "owner",
                "type": "address",
                "indexed": true
              },
              {
                "name": "spender",
                "type": "address",
                "indexed": true
              },
              {
                "name": "value",
                "type": "uint256",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin"
      },
      {
        "name": "IERC20Metadata",
        "kind": "interface",
        "category": "interface",
        "filePath": "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol",
        "inherits": [],
        "implements": [
          "IERC20"
        ],
        "usesLibraries": [],
        "imports": [
          {
            "name": "IERC20",
            "path": "../IERC20.sol",
            "isExternal": false
          }
        ],
        "externalFunctions": [
          {
            "name": "name",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function name() external view returns (string memory);",
            "startLine": 15,
            "signature": "name()",
            "selector": "0x3ec0f734",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "symbol",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "string"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function symbol() external view returns (string memory);",
            "startLine": 20,
            "signature": "symbol()",
            "selector": "0x6a927499",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "decimals",
            "stateMutability": "view",
            "parameters": [],
            "returnValues": [
              {
                "name": "",
                "type": "uint8"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function decimals() external view returns (uint8);",
            "startLine": 25,
            "signature": "decimals()",
            "selector": "0x76436c3d",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin"
      },
      {
        "name": "IERC20Errors",
        "kind": "interface",
        "category": "interface",
        "filePath": "@openzeppelin/contracts/interfaces/draft-IERC6093.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [],
        "events": [],
        "errors": [
          {
            "name": "ERC20InsufficientBalance",
            "parameters": [
              {
                "name": "sender",
                "type": "address"
              },
              {
                "name": "balance",
                "type": "uint256"
              },
              {
                "name": "needed",
                "type": "uint256"
              }
            ]
          },
          {
            "name": "ERC20InvalidSender",
            "parameters": [
              {
                "name": "sender",
                "type": "address"
              }
            ]
          },
          {
            "name": "ERC20InvalidReceiver",
            "parameters": [
              {
                "name": "receiver",
                "type": "address"
              }
            ]
          },
          {
            "name": "ERC20InsufficientAllowance",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              },
              {
                "name": "allowance",
                "type": "uint256"
              },
              {
                "name": "needed",
                "type": "uint256"
              }
            ]
          },
          {
            "name": "ERC20InvalidApprover",
            "parameters": [
              {
                "name": "approver",
                "type": "address"
              }
            ]
          },
          {
            "name": "ERC20InvalidSpender",
            "parameters": [
              {
                "name": "spender",
                "type": "address"
              }
            ]
          }
        ],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin"
      },
      {
        "name": "IERC721Errors",
        "kind": "interface",
        "category": "interface",
        "filePath": "@openzeppelin/contracts/interfaces/draft-IERC6093.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [],
        "events": [],
        "errors": [
          {
            "name": "ERC721InvalidOwner",
            "parameters": [
              {
                "name": "owner",
                "type": "address"
              }
            ]
          },
          {
            "name": "ERC721NonexistentToken",
            "parameters": [
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ]
          },
          {
            "name": "ERC721IncorrectOwner",
            "parameters": [
              {
                "name": "sender",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              },
              {
                "name": "owner",
                "type": "address"
              }
            ]
          },
          {
            "name": "ERC721InvalidSender",
            "parameters": [
              {
                "name": "sender",
                "type": "address"
              }
            ]
          },
          {
            "name": "ERC721InvalidReceiver",
            "parameters": [
              {
                "name": "receiver",
                "type": "address"
              }
            ]
          },
          {
            "name": "ERC721InsufficientApproval",
            "parameters": [
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ]
          },
          {
            "name": "ERC721InvalidApprover",
            "parameters": [
              {
                "name": "approver",
                "type": "address"
              }
            ]
          },
          {
            "name": "ERC721InvalidOperator",
            "parameters": [
              {
                "name": "operator",
                "type": "address"
              }
            ]
          }
        ],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin"
      },
      {
        "name": "IERC1155Errors",
        "kind": "interface",
        "category": "interface",
        "filePath": "@openzeppelin/contracts/interfaces/draft-IERC6093.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [],
        "internalFunctions": [],
        "events": [],
        "errors": [
          {
            "name": "ERC1155InsufficientBalance",
            "parameters": [
              {
                "name": "sender",
                "type": "address"
              },
              {
                "name": "balance",
                "type": "uint256"
              },
              {
                "name": "needed",
                "type": "uint256"
              },
              {
                "name": "tokenId",
                "type": "uint256"
              }
            ]
          },
          {
            "name": "ERC1155InvalidSender",
            "parameters": [
              {
                "name": "sender",
                "type": "address"
              }
            ]
          },
          {
            "name": "ERC1155InvalidReceiver",
            "parameters": [
              {
                "name": "receiver",
                "type": "address"
              }
            ]
          },
          {
            "name": "ERC1155MissingApprovalForAll",
            "parameters": [
              {
                "name": "operator",
                "type": "address"
              },
              {
                "name": "owner",
                "type": "address"
              }
            ]
          },
          {
            "name": "ERC1155InvalidApprover",
            "parameters": [
              {
                "name": "approver",
                "type": "address"
              }
            ]
          },
          {
            "name": "ERC1155InvalidOperator",
            "parameters": [
              {
                "name": "operator",
                "type": "address"
              }
            ]
          },
          {
            "name": "ERC1155InvalidArrayLength",
            "parameters": [
              {
                "name": "idsLength",
                "type": "uint256"
              },
              {
                "name": "valuesLength",
                "type": "uint256"
              }
            ]
          }
        ],
        "isExternalLibrary": true,
        "librarySource": "openzeppelin"
      },
      {
        "name": "IAllowList",
        "kind": "interface",
        "category": "interface",
        "filePath": "@subnet-evm/IAllowList.sol",
        "inherits": [],
        "implements": [],
        "usesLibraries": [],
        "imports": [],
        "externalFunctions": [
          {
            "name": "setAdmin",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "addr",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function setAdmin(\n        address addr\n    ) external;",
            "startLine": 10,
            "signature": "setAdmin(address)",
            "selector": "0x572d4a90",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "setEnabled",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "addr",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function setEnabled(\n        address addr\n    ) external;",
            "startLine": 15,
            "signature": "setEnabled(address)",
            "selector": "0x15c4c53e",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "setManager",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "addr",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function setManager(\n        address addr\n    ) external;",
            "startLine": 20,
            "signature": "setManager(address)",
            "selector": "0x517b7a52",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "setNone",
            "stateMutability": "nonpayable",
            "parameters": [
              {
                "name": "addr",
                "type": "address"
              }
            ],
            "returnValues": [],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function setNone(\n        address addr\n    ) external;",
            "startLine": 25,
            "signature": "setNone(address)",
            "selector": "0x5fd54d63",
            "visibility": "external",
            "modifiers": []
          },
          {
            "name": "readAllowList",
            "stateMutability": "view",
            "parameters": [
              {
                "name": "addr",
                "type": "address"
              }
            ],
            "returnValues": [
              {
                "name": "role",
                "type": "uint256"
              }
            ],
            "calls": [],
            "emits": [],
            "isVirtual": false,
            "sourceCode": "function readAllowList(\n        address addr\n    ) external view returns (uint256 role);",
            "startLine": 30,
            "signature": "readAllowList(address)",
            "selector": "0x7613636c",
            "visibility": "external",
            "modifiers": []
          }
        ],
        "internalFunctions": [],
        "events": [
          {
            "name": "RoleSet",
            "parameters": [
              {
                "name": "role",
                "type": "uint256",
                "indexed": true
              },
              {
                "name": "account",
                "type": "address",
                "indexed": true
              },
              {
                "name": "sender",
                "type": "address",
                "indexed": true
              },
              {
                "name": "oldRole",
                "type": "uint256",
                "indexed": false
              }
            ]
          }
        ],
        "errors": [],
        "isExternalLibrary": true,
        "librarySource": "avalanche-icm"
      }
    ],
    "dependencies": [
      {
        "from": "ERC20TokenHome",
        "to": "ERC20TokenHomeUpgradeable",
        "type": "inherits"
      },
      {
        "from": "ERC20TokenHomeUpgradeable",
        "to": "TokenHome",
        "type": "inherits"
      },
      {
        "from": "ERC20TokenHomeUpgradeable",
        "to": "IERC20TokenHome",
        "type": "implements"
      },
      {
        "from": "ERC20TokenHomeUpgradeable",
        "to": "SafeERC20",
        "type": "uses",
        "functions": [
          "safeIncreaseAllowance",
          "forceApprove"
        ]
      },
      {
        "from": "NativeTokenHome",
        "to": "NativeTokenHomeUpgradeable",
        "type": "inherits"
      },
      {
        "from": "NativeTokenHomeUpgradeable",
        "to": "TokenHome",
        "type": "inherits"
      },
      {
        "from": "NativeTokenHomeUpgradeable",
        "to": "INativeTokenHome",
        "type": "implements"
      },
      {
        "from": "NativeTokenHomeUpgradeable",
        "to": "Address",
        "type": "uses"
      },
      {
        "from": "TokenHome",
        "to": "TeleporterRegistryOwnableAppUpgradeable",
        "type": "inherits"
      },
      {
        "from": "TokenHome",
        "to": "SendReentrancyGuardUpgradeable",
        "type": "inherits"
      },
      {
        "from": "TokenHome",
        "to": "ITokenHome",
        "type": "implements"
      },
      {
        "from": "IERC20TokenHome",
        "to": "IERC20TokenTransferrer",
        "type": "implements"
      },
      {
        "from": "IERC20TokenHome",
        "to": "ITokenHome",
        "type": "implements"
      },
      {
        "from": "INativeTokenHome",
        "to": "INativeTokenTransferrer",
        "type": "implements"
      },
      {
        "from": "INativeTokenHome",
        "to": "ITokenHome",
        "type": "implements"
      },
      {
        "from": "ITokenHome",
        "to": "ITokenTransferrer",
        "type": "implements"
      },
      {
        "from": "ERC20TokenRemote",
        "to": "ERC20TokenRemoteUpgradeable",
        "type": "inherits"
      },
      {
        "from": "ERC20TokenRemoteUpgradeable",
        "to": "ERC20Upgradeable",
        "type": "inherits"
      },
      {
        "from": "ERC20TokenRemoteUpgradeable",
        "to": "TokenRemote",
        "type": "inherits"
      },
      {
        "from": "ERC20TokenRemoteUpgradeable",
        "to": "IERC20TokenTransferrer",
        "type": "implements"
      },
      {
        "from": "NativeTokenRemote",
        "to": "NativeTokenRemoteUpgradeable",
        "type": "inherits"
      },
      {
        "from": "NativeTokenRemoteUpgradeable",
        "to": "ERC20Upgradeable",
        "type": "inherits"
      },
      {
        "from": "NativeTokenRemoteUpgradeable",
        "to": "TokenRemote",
        "type": "inherits"
      },
      {
        "from": "NativeTokenRemoteUpgradeable",
        "to": "INativeTokenRemote",
        "type": "implements"
      },
      {
        "from": "NativeTokenRemoteUpgradeable",
        "to": "IWrappedNativeToken",
        "type": "implements"
      },
      {
        "from": "NativeTokenRemoteUpgradeable",
        "to": "Address",
        "type": "uses"
      },
      {
        "from": "TokenRemote",
        "to": "TeleporterRegistryOwnableAppUpgradeable",
        "type": "inherits"
      },
      {
        "from": "TokenRemote",
        "to": "SendReentrancyGuardUpgradeable",
        "type": "inherits"
      },
      {
        "from": "TokenRemote",
        "to": "ITokenRemote",
        "type": "implements"
      },
      {
        "from": "INativeTokenRemote",
        "to": "ITokenRemote",
        "type": "implements"
      },
      {
        "from": "INativeTokenRemote",
        "to": "INativeTokenTransferrer",
        "type": "implements"
      },
      {
        "from": "ITokenRemote",
        "to": "ITokenTransferrer",
        "type": "implements"
      },
      {
        "from": "WrappedNativeToken",
        "to": "ERC20",
        "type": "inherits"
      },
      {
        "from": "WrappedNativeToken",
        "to": "IWrappedNativeToken",
        "type": "implements"
      },
      {
        "from": "WrappedNativeToken",
        "to": "Address",
        "type": "uses"
      },
      {
        "from": "IERC20TokenTransferrer",
        "to": "ITokenTransferrer",
        "type": "implements"
      },
      {
        "from": "INativeTokenTransferrer",
        "to": "ITokenTransferrer",
        "type": "implements"
      },
      {
        "from": "ITokenTransferrer",
        "to": "ITeleporterReceiver",
        "type": "implements"
      },
      {
        "from": "IWrappedNativeToken",
        "to": "IERC20",
        "type": "implements"
      },
      {
        "from": "ERC20",
        "to": "IERC20",
        "type": "implements"
      },
      {
        "from": "ERC20",
        "to": "IERC20Metadata",
        "type": "implements"
      },
      {
        "from": "ERC20",
        "to": "IERC20Errors",
        "type": "implements"
      },
      {
        "from": "SafeERC20TransferFrom",
        "to": "SafeERC20",
        "type": "uses"
      },
      {
        "from": "TeleporterRegistryOwnableAppUpgradeable",
        "to": "OwnableUpgradeable",
        "type": "inherits"
      },
      {
        "from": "SendReentrancyGuardUpgradeable",
        "to": "Initializable",
        "type": "inherits"
      },
      {
        "from": "ERC20Upgradeable",
        "to": "Initializable",
        "type": "inherits"
      },
      {
        "from": "ERC20Upgradeable",
        "to": "IERC20",
        "type": "implements"
      },
      {
        "from": "ERC20Upgradeable",
        "to": "IERC20Metadata",
        "type": "implements"
      },
      {
        "from": "ERC20Upgradeable",
        "to": "IERC20Errors",
        "type": "implements"
      },
      {
        "from": "INativeMinter",
        "to": "IAllowList",
        "type": "implements"
      },
      {
        "from": "OwnableUpgradeable",
        "to": "Initializable",
        "type": "inherits"
      },
      {
        "from": "IERC20Metadata",
        "to": "IERC20",
        "type": "implements"
      }
    ],
    "proxyGroups": [],
    "stats": {
      "totalContracts": 17,
      "totalLibraries": 6,
      "totalInterfaces": 22,
      "totalFunctions": 784
    }
  }
}